{"version":3,"sources":["assets\\scripts\\common\\cmpt\\ui\\multiTexture\\assembler\\MultiAssembler.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["const gfx = cc[\"gfx\"];\r\nconst vfmtPosUvColorIndex = new gfx.VertexFormat([\r\n    { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },\r\n    { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },\r\n    { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_UINT8, num: 4, normalize: true },\r\n    { name: \"a_texture_idx\", type: gfx.ATTR_TYPE_FLOAT32, num: 1 },\r\n]);\r\n\r\nexport default class MultiAssembler extends cc.Assembler {\r\n    /** 每个顶点的数据长度 */\r\n    protected floatsPerVert: number = 6;\r\n    protected verticesCount: number = 4;\r\n    protected indicesCount: number = 6;\r\n    protected uvOffset: number = 2;\r\n    protected colorOffset: number = 4;\r\n    protected textureIdxOffset: number = 5;\r\n\r\n    protected _renderData = null;\r\n    protected _local = [];\r\n\r\n    protected get verticesFloats() {\r\n        return this.verticesCount * this.floatsPerVert;\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this._renderData = new cc[\"RenderData\"]();\r\n        this._renderData.init(this);\r\n\r\n        this.initData();\r\n        this.initLocal();\r\n    }\r\n\r\n    public initData() {\r\n        let data = this._renderData;\r\n        // createFlexData支持创建指定格式的renderData\r\n        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());\r\n\r\n        // createFlexData不会填充顶点索引信息，手动补充一下\r\n        let indices = data.iDatas[0];\r\n        let count = indices.length / 6;\r\n        for (let i = 0, idx = 0; i < count; i++) {\r\n            let vertextID = i * 4;\r\n            indices[idx++] = vertextID;\r\n            indices[idx++] = vertextID + 1;\r\n            indices[idx++] = vertextID + 2;\r\n            indices[idx++] = vertextID + 1;\r\n            indices[idx++] = vertextID + 3;\r\n            indices[idx++] = vertextID + 2;\r\n        }\r\n    }\r\n\r\n    public initLocal() {\r\n        this._local = [];\r\n        this._local.length = 4;\r\n    }\r\n\r\n    public getBuffer(v) {\r\n        return cc.renderer[\"_handle\"].getBuffer(\"mesh\", this.getVfmt());\r\n    }\r\n\r\n    public getVfmt() {\r\n        return vfmtPosUvColorIndex;\r\n    }\r\n\r\n    public updateColor(comp, color?) {\r\n        if (CC_NATIVERENDERER) {\r\n            this[\"_dirtyPtr\"][0] |= cc.Assembler[\"FLAG_VERTICES_OPACITY_CHANGED\"];\r\n        }\r\n        let uintVerts = this._renderData.uintVDatas[0];\r\n        if (!uintVerts) return;\r\n        color = color != null ? color : comp.node.color._val;\r\n        let floatsPerVert = this.floatsPerVert;\r\n        let colorOffset = this.colorOffset;\r\n        for (let i = colorOffset, l = uintVerts.length; i < l; i += floatsPerVert) {\r\n            uintVerts[i] = color;\r\n        }\r\n    }\r\n\r\n    public updateTextureIdx(sprite) {\r\n        let verts = this._renderData.vDatas[0];\r\n\r\n        for (let i = 0; i < this.verticesCount; i++) {\r\n            let dstOffset = this.floatsPerVert * i + this.textureIdxOffset;\r\n            verts[dstOffset] = sprite.textureIdx;\r\n        }\r\n    }\r\n\r\n    public updateWorldVerts(comp) {\r\n        let local = this._local;\r\n        let verts = this._renderData.vDatas[0];\r\n\r\n        let matrix = comp.node._worldMatrix;\r\n        let matrixm = matrix.m,\r\n            a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5],\r\n            tx = matrixm[12], ty = matrixm[13];\r\n\r\n        let vl = local[0], vr = local[2],\r\n            vb = local[1], vt = local[3];\r\n\r\n        let floatsPerVert = this.floatsPerVert;\r\n        let vertexOffset = 0;\r\n        let justTranslate = a === 1 && b === 0 && c === 0 && d === 1;\r\n\r\n        if (CC_NATIVERENDERER) {\r\n            // left bottom\r\n            verts[vertexOffset] = vl;\r\n            verts[vertexOffset + 1] = vb;\r\n            vertexOffset += floatsPerVert;\r\n            // right bottom\r\n            verts[vertexOffset] = vr;\r\n            verts[vertexOffset + 1] = vb;\r\n            vertexOffset += floatsPerVert;\r\n            // left top\r\n            verts[vertexOffset] = vl;\r\n            verts[vertexOffset + 1] = vt;\r\n            vertexOffset += floatsPerVert;\r\n            // right top\r\n            verts[vertexOffset] = vr;\r\n            verts[vertexOffset + 1] = vt;\r\n        } else {\r\n            if (justTranslate) {\r\n                // left bottom\r\n                verts[vertexOffset] = vl + tx;\r\n                verts[vertexOffset + 1] = vb + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // right bottom\r\n                verts[vertexOffset] = vr + tx;\r\n                verts[vertexOffset + 1] = vb + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // left top\r\n                verts[vertexOffset] = vl + tx;\r\n                verts[vertexOffset + 1] = vt + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // right top\r\n                verts[vertexOffset] = vr + tx;\r\n                verts[vertexOffset + 1] = vt + ty;\r\n            } else {\r\n                let al = a * vl, ar = a * vr,\r\n                    bl = b * vl, br = b * vr,\r\n                    cb = c * vb, ct = c * vt,\r\n                    db = d * vb, dt = d * vt;\r\n\r\n                // left bottom\r\n                verts[vertexOffset] = al + cb + tx;\r\n                verts[vertexOffset + 1] = bl + db + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // right bottom\r\n                verts[vertexOffset] = ar + cb + tx;\r\n                verts[vertexOffset + 1] = br + db + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // left top\r\n                verts[vertexOffset] = al + ct + tx;\r\n                verts[vertexOffset + 1] = bl + dt + ty;\r\n                vertexOffset += floatsPerVert;\r\n                // right top\r\n                verts[vertexOffset] = ar + ct + tx;\r\n                verts[vertexOffset + 1] = br + dt + ty;\r\n            }\r\n        }\r\n    }\r\n\r\n    public fillBuffers(comp, renderer) {\r\n        if (renderer.worldMatDirty) {\r\n            this.updateWorldVerts(comp);\r\n        }\r\n\r\n        let renderData = this._renderData;\r\n        let vData = renderData.vDatas[0];\r\n        let iData = renderData.iDatas[0];\r\n\r\n        let buffer = this.getBuffer(renderer);\r\n        let offsetInfo = buffer.request(this.verticesCount, this.indicesCount);\r\n\r\n        // buffer data may be realloc, need get reference after request.\r\n\r\n        // fill vertices\r\n        let vertexOffset = offsetInfo.byteOffset >> 2,\r\n            vbuf = buffer._vData;\r\n\r\n        if (vData.length + vertexOffset > vbuf.length) {\r\n            vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset);\r\n        } else {\r\n            vbuf.set(vData, vertexOffset);\r\n        }\r\n\r\n        // fill indices\r\n        let ibuf = buffer._iData,\r\n            indiceOffset = offsetInfo.indiceOffset,\r\n            vertexId = offsetInfo.vertexOffset;\r\n        for (let i = 0, l = iData.length; i < l; i++) {\r\n            ibuf[indiceOffset++] = vertexId + iData[i];\r\n        }\r\n    }\r\n\r\n    public packToDynamicAtlas(comp, frame) {\r\n        if (CC_TEST) return;\r\n\r\n        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {\r\n            let packedFrame: any = cc.dynamicAtlasManager.insertSpriteFrame(frame);\r\n            if (packedFrame) {\r\n                frame._setDynamicAtlasFrame(packedFrame);\r\n            }\r\n        }\r\n        let material = comp._materials[0];\r\n        if (!material) return;\r\n\r\n        if (material.getProperty(\"texture\") !== frame._texture._texture) {\r\n            // texture was packed to dynamic atlas, should update uvs\r\n            comp._vertsDirty = true;\r\n            comp._updateMaterial();\r\n        }\r\n    }\r\n}"]}