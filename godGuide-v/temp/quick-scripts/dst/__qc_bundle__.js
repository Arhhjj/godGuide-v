
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__qc_index__.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}
require('./assets/scripts/animator/AnimatorAnimation');
require('./assets/scripts/animator/AnimatorCustomization');
require('./assets/scripts/animator/AnimatorDragonBones');
require('./assets/scripts/animator/AnimatorSpine');
require('./assets/scripts/animator/AnimatorSpineSecondary');
require('./assets/scripts/animator/core/AnimatorBase');
require('./assets/scripts/animator/core/AnimatorCondition');
require('./assets/scripts/animator/core/AnimatorController');
require('./assets/scripts/animator/core/AnimatorParams');
require('./assets/scripts/animator/core/AnimatorState');
require('./assets/scripts/animator/core/AnimatorStateLogic');
require('./assets/scripts/animator/core/AnimatorTransition');
require('./assets/scripts/common/cmpt/base/DialogBase');
require('./assets/scripts/common/cmpt/base/Layer');
require('./assets/scripts/common/cmpt/base/Singleton');
require('./assets/scripts/common/cmpt/base/Timer');
require('./assets/scripts/common/cmpt/base/Tip');
require('./assets/scripts/common/cmpt/shader/ShaderFill');
require('./assets/scripts/common/cmpt/shader/ShaderOutline');
require('./assets/scripts/common/cmpt/shader/ShaderShining');
require('./assets/scripts/common/cmpt/shader/ShaderTile');
require('./assets/scripts/common/cmpt/ui/CountdownLabel');
require('./assets/scripts/common/cmpt/ui/ShakeNode');
require('./assets/scripts/common/cmpt/ui/adapt/AdaptCanvas');
require('./assets/scripts/common/cmpt/ui/adapt/AdaptSize');
require('./assets/scripts/common/cmpt/ui/animValue/AnimValue');
require('./assets/scripts/common/cmpt/ui/animValue/AnimValueLabel');
require('./assets/scripts/common/cmpt/ui/animValue/AnimValueProgress');
require('./assets/scripts/common/cmpt/ui/animValue/AnimValueProgressHP');
require('./assets/scripts/common/cmpt/ui/button/ButtonChildGray');
require('./assets/scripts/common/cmpt/ui/button/ButtonChildPos');
require('./assets/scripts/common/cmpt/ui/button/ButtonSingle');
require('./assets/scripts/common/cmpt/ui/i18n/I18nLabel');
require('./assets/scripts/common/cmpt/ui/i18n/I18nSprite');
require('./assets/scripts/common/cmpt/ui/multiTexture/MultiSprite');
require('./assets/scripts/common/cmpt/ui/multiTexture/MultiTextureManager');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssembler');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerBarFilled');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerRadialFilled');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSimple');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSliced');
require('./assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerTiled');
require('./assets/scripts/common/cmpt/ui/res/ResSpine');
require('./assets/scripts/common/cmpt/ui/res/ResSprite');
require('./assets/scripts/common/cmpt/ui/scrollList/CircleList');
require('./assets/scripts/common/cmpt/ui/scrollList/LoopList');
require('./assets/scripts/common/cmpt/ui/scrollList/VirtualItem');
require('./assets/scripts/common/cmpt/ui/scrollList/VirtualLayout');
require('./assets/scripts/common/cmpt/ui/scrollList/VirtualList');
require('./assets/scripts/common/config/En');
require('./assets/scripts/common/config/Zh');
require('./assets/scripts/common/const/EventName');
require('./assets/scripts/common/const/Url');
require('./assets/scripts/common/hack/ButtonHack');
require('./assets/scripts/common/hack/EditorBoxHack');
require('./assets/scripts/common/runtime/EnumIndex');
require('./assets/scripts/common/runtime/GlobalInfo');
require('./assets/scripts/common/runtime/UserInfo');
require('./assets/scripts/common/util/AudioManager');
require('./assets/scripts/common/util/Behavior3');
require('./assets/scripts/common/util/Decorator');
require('./assets/scripts/common/util/EditorTool');
require('./assets/scripts/common/util/Events');
require('./assets/scripts/common/util/I18n');
require('./assets/scripts/common/util/PhysicsController');
require('./assets/scripts/common/util/Random');
require('./assets/scripts/common/util/RecyclePool');
require('./assets/scripts/common/util/Res');
require('./assets/scripts/common/util/Tool');
require('./assets/scripts/common/util/Tween');
require('./assets/scripts/showcase/dialog/DlgLevel');
require('./assets/scripts/showcase/dialog/DlgRole');
require('./assets/scripts/showcase/dialog/DlgSign');
require('./assets/scripts/showcase/dialog/DlgStore');
require('./assets/scripts/showcase/game/Game');
require('./assets/scripts/showcase/home/Home');
require('./assets/scripts/showcase/home/guide/GodGuide');
require('./assets/scripts/showcase/home/guide/GuideFinger');
require('./assets/scripts/showcase/home/guide/task/GuideTask1');
require('./assets/scripts/showcase/home/guide/task/GuideTask2');
require('./assets/scripts/showcase/home/guide/task/GuideTaskIndex');
require('./assets/scripts/showcase/home/main/Barrier');
require('./assets/scripts/showcase/home/main/BarrierManager');
require('./assets/scripts/showcase/home/main/GameController');
require('./assets/scripts/showcase/home/main/MoveCtr');
require('./assets/scripts/showcase/scenes/Loading');
require('./assets/scripts/showcase/scenes/Main');

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorCondition.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'dee7b/HNztHyqFZucFEjW8S', 'AnimatorCondition');
// scripts/animator/core/AnimatorCondition.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogicType = exports.ParamType = void 0;
/** 参数类型 */
var ParamType;
(function (ParamType) {
    ParamType[ParamType["COMPLETE"] = 0] = "COMPLETE";
    ParamType[ParamType["BOOLEAN"] = 1] = "BOOLEAN";
    ParamType[ParamType["NUMBER"] = 2] = "NUMBER";
    ParamType[ParamType["TRIGGER"] = 3] = "TRIGGER";
    ParamType[ParamType["AUTO_TRIGGER"] = 4] = "AUTO_TRIGGER";
})(ParamType = exports.ParamType || (exports.ParamType = {}));
/** 逻辑类型 */
var LogicType;
(function (LogicType) {
    LogicType[LogicType["EQUAL"] = 0] = "EQUAL";
    LogicType[LogicType["NOTEQUAL"] = 1] = "NOTEQUAL";
    LogicType[LogicType["GREATER"] = 2] = "GREATER";
    LogicType[LogicType["LESS"] = 3] = "LESS";
    LogicType[LogicType["GREATER_EQUAL"] = 4] = "GREATER_EQUAL";
    LogicType[LogicType["LESS_EQUAL"] = 5] = "LESS_EQUAL";
})(LogicType = exports.LogicType || (exports.LogicType = {}));
/**
 * 单项条件
 */
var AnimatorCondition = /** @class */ (function () {
    function AnimatorCondition(data, ac) {
        this._ac = null;
        /** 此条件对应的参数名 */
        this._param = "";
        /** 此条件对应的值 */
        this._value = 0;
        /** 此条件与值比较的逻辑 */
        this._logic = LogicType.EQUAL;
        this._ac = ac;
        this._param = data.param;
        this._value = data.value;
        this._logic = data.logic;
    }
    AnimatorCondition.prototype.getParamName = function () {
        return this._param;
    };
    AnimatorCondition.prototype.getParamType = function () {
        return this._ac.params.getParamType(this._param);
    };
    /** 判断此条件是否满足 */
    AnimatorCondition.prototype.check = function () {
        var type = this.getParamType();
        if (type === ParamType.BOOLEAN) {
            return this._ac.params.getBool(this._param) === this._value;
        }
        else if (type === ParamType.NUMBER) {
            var value = this._ac.params.getNumber(this._param);
            switch (this._logic) {
                case LogicType.EQUAL:
                    return value === this._value;
                case LogicType.NOTEQUAL:
                    return value !== this._value;
                case LogicType.GREATER:
                    return value > this._value;
                case LogicType.LESS:
                    return value < this._value;
                case LogicType.GREATER_EQUAL:
                    return value >= this._value;
                case LogicType.LESS_EQUAL:
                    return value <= this._value;
                default:
                    return false;
            }
        }
        else if (type === ParamType.AUTO_TRIGGER) {
            return this._ac.params.getAutoTrigger(this._param) !== 0;
        }
        else if (type === ParamType.TRIGGER) {
            return this._ac.params.getTrigger(this._param) !== 0;
        }
        else {
            cc.error("[AnimatorCondition.check] \u9519\u8BEF\u7684type: " + type);
            return false;
        }
    };
    return AnimatorCondition;
}());
exports.default = AnimatorCondition;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yQ29uZGl0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLFdBQVc7QUFDWCxJQUFZLFNBTVg7QUFORCxXQUFZLFNBQVM7SUFDakIsaURBQVksQ0FBQTtJQUNaLCtDQUFXLENBQUE7SUFDWCw2Q0FBVSxDQUFBO0lBQ1YsK0NBQVcsQ0FBQTtJQUNYLHlEQUFnQixDQUFBO0FBQ3BCLENBQUMsRUFOVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQU1wQjtBQUVELFdBQVc7QUFDWCxJQUFZLFNBT1g7QUFQRCxXQUFZLFNBQVM7SUFDakIsMkNBQVMsQ0FBQTtJQUNULGlEQUFZLENBQUE7SUFDWiwrQ0FBVyxDQUFBO0lBQ1gseUNBQVEsQ0FBQTtJQUNSLDJEQUFpQixDQUFBO0lBQ2pCLHFEQUFjLENBQUE7QUFDbEIsQ0FBQyxFQVBXLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBT3BCO0FBRUQ7O0dBRUc7QUFDSDtJQVNJLDJCQUFZLElBQVMsRUFBRSxFQUFzQjtRQVJyQyxRQUFHLEdBQXVCLElBQUksQ0FBQztRQUN2QyxnQkFBZ0I7UUFDUixXQUFNLEdBQVcsRUFBRSxDQUFDO1FBQzVCLGNBQWM7UUFDTixXQUFNLEdBQVcsQ0FBQyxDQUFDO1FBQzNCLGlCQUFpQjtRQUNULFdBQU0sR0FBYyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBR3hDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDN0IsQ0FBQztJQUVNLHdDQUFZLEdBQW5CO1FBQ0ksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFTSx3Q0FBWSxHQUFuQjtRQUNJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQsZ0JBQWdCO0lBQ1QsaUNBQUssR0FBWjtRQUNJLElBQUksSUFBSSxHQUFjLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMxQyxJQUFJLElBQUksS0FBSyxTQUFTLENBQUMsT0FBTyxFQUFFO1lBQzVCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQy9EO2FBQU0sSUFBSSxJQUFJLEtBQUssU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNsQyxJQUFJLEtBQUssR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNELFFBQVEsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDakIsS0FBSyxTQUFTLENBQUMsS0FBSztvQkFDaEIsT0FBTyxLQUFLLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDakMsS0FBSyxTQUFTLENBQUMsUUFBUTtvQkFDbkIsT0FBTyxLQUFLLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDakMsS0FBSyxTQUFTLENBQUMsT0FBTztvQkFDbEIsT0FBTyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDL0IsS0FBSyxTQUFTLENBQUMsSUFBSTtvQkFDZixPQUFPLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUMvQixLQUFLLFNBQVMsQ0FBQyxhQUFhO29CQUN4QixPQUFPLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUNoQyxLQUFLLFNBQVMsQ0FBQyxVQUFVO29CQUNyQixPQUFPLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUNoQztvQkFDSSxPQUFPLEtBQUssQ0FBQzthQUNwQjtTQUNKO2FBQU0sSUFBSSxJQUFJLEtBQUssU0FBUyxDQUFDLFlBQVksRUFBRTtZQUN4QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzVEO2FBQU0sSUFBSSxJQUFJLEtBQUssU0FBUyxDQUFDLE9BQU8sRUFBRTtZQUNuQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3hEO2FBQU07WUFDSCxFQUFFLENBQUMsS0FBSyxDQUFDLHVEQUFzQyxJQUFNLENBQUMsQ0FBQztZQUN2RCxPQUFPLEtBQUssQ0FBQztTQUNoQjtJQUNMLENBQUM7SUFDTCx3QkFBQztBQUFELENBeERBLEFBd0RDLElBQUEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW5pbWF0b3JDb250cm9sbGVyIGZyb20gXCIuL0FuaW1hdG9yQ29udHJvbGxlclwiO1xyXG5cclxuLyoqIOWPguaVsOexu+WeiyAqL1xyXG5leHBvcnQgZW51bSBQYXJhbVR5cGUge1xyXG4gICAgQ09NUExFVEUgPSAwLFxyXG4gICAgQk9PTEVBTiA9IDEsXHJcbiAgICBOVU1CRVIgPSAyLFxyXG4gICAgVFJJR0dFUiA9IDMsXHJcbiAgICBBVVRPX1RSSUdHRVIgPSA0XHJcbn1cclxuXHJcbi8qKiDpgLvovpHnsbvlnosgKi9cclxuZXhwb3J0IGVudW0gTG9naWNUeXBlIHtcclxuICAgIEVRVUFMID0gMCxcclxuICAgIE5PVEVRVUFMID0gMSxcclxuICAgIEdSRUFURVIgPSAyLFxyXG4gICAgTEVTUyA9IDMsXHJcbiAgICBHUkVBVEVSX0VRVUFMID0gNCxcclxuICAgIExFU1NfRVFVQUwgPSA1XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDljZXpobnmnaHku7ZcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yQ29uZGl0aW9uIHtcclxuICAgIHByaXZhdGUgX2FjOiBBbmltYXRvckNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgLyoqIOatpOadoeS7tuWvueW6lOeahOWPguaVsOWQjSAqL1xyXG4gICAgcHJpdmF0ZSBfcGFyYW06IHN0cmluZyA9IFwiXCI7XHJcbiAgICAvKiog5q2k5p2h5Lu25a+55bqU55qE5YC8ICovXHJcbiAgICBwcml2YXRlIF92YWx1ZTogbnVtYmVyID0gMDtcclxuICAgIC8qKiDmraTmnaHku7bkuI7lgLzmr5TovoPnmoTpgLvovpEgKi9cclxuICAgIHByaXZhdGUgX2xvZ2ljOiBMb2dpY1R5cGUgPSBMb2dpY1R5cGUuRVFVQUw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGF0YTogYW55LCBhYzogQW5pbWF0b3JDb250cm9sbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYWMgPSBhYztcclxuICAgICAgICB0aGlzLl9wYXJhbSA9IGRhdGEucGFyYW07XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2xvZ2ljID0gZGF0YS5sb2dpYztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1OYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1UeXBlKCk6IFBhcmFtVHlwZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjLnBhcmFtcy5nZXRQYXJhbVR5cGUodGhpcy5fcGFyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiDliKTmlq3mraTmnaHku7bmmK/lkKbmu6HotrMgKi9cclxuICAgIHB1YmxpYyBjaGVjaygpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgdHlwZTogUGFyYW1UeXBlID0gdGhpcy5nZXRQYXJhbVR5cGUoKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gUGFyYW1UeXBlLkJPT0xFQU4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjLnBhcmFtcy5nZXRCb29sKHRoaXMuX3BhcmFtKSA9PT0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBQYXJhbVR5cGUuTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZTogbnVtYmVyID0gdGhpcy5fYWMucGFyYW1zLmdldE51bWJlcih0aGlzLl9wYXJhbSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fbG9naWMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9naWNUeXBlLkVRVUFMOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2ljVHlwZS5OT1RFUVVBTDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMb2dpY1R5cGUuR1JFQVRFUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9naWNUeXBlLkxFU1M6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2ljVHlwZS5HUkVBVEVSX0VRVUFMOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgTG9naWNUeXBlLkxFU1NfRVFVQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFBhcmFtVHlwZS5BVVRPX1RSSUdHRVIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjLnBhcmFtcy5nZXRBdXRvVHJpZ2dlcih0aGlzLl9wYXJhbSkgIT09IDA7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBQYXJhbVR5cGUuVFJJR0dFUikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWMucGFyYW1zLmdldFRyaWdnZXIodGhpcy5fcGFyYW0pICE9PSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbQW5pbWF0b3JDb25kaXRpb24uY2hlY2tdIOmUmeivr+eahHR5cGU6ICR7dHlwZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerBarFilled.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0d306+qdllOJo+T76peVXVI', 'MultiAssemblerBarFilled');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerBarFilled.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MultiAssembler_1 = require("./MultiAssembler");
var MultiAssemblerBarFilled = /** @class */ (function (_super) {
    __extends(MultiAssemblerBarFilled, _super);
    function MultiAssemblerBarFilled() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiAssemblerBarFilled.prototype.updateRenderData = function (sprite) {
        var frame = sprite._spriteFrame;
        this.packToDynamicAtlas(sprite, frame);
        if (!sprite._vertsDirty) {
            return;
        }
        var fillStart = sprite._fillStart;
        var fillRange = sprite._fillRange;
        if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
        }
        fillRange = fillStart + fillRange;
        fillStart = fillStart > 1.0 ? 1.0 : fillStart;
        fillStart = fillStart < 0.0 ? 0.0 : fillStart;
        fillRange = fillRange > 1.0 ? 1.0 : fillRange;
        fillRange = fillRange < 0.0 ? 0.0 : fillRange;
        fillRange = fillRange - fillStart;
        fillRange = fillRange < 0 ? 0 : fillRange;
        var fillEnd = fillStart + fillRange;
        fillEnd = fillEnd > 1 ? 1 : fillEnd;
        this.updateUVs(sprite, fillStart, fillEnd);
        this.updateVerts(sprite, fillStart, fillEnd);
        this.updateTextureIdx(sprite);
        sprite._vertsDirty = false;
    };
    MultiAssemblerBarFilled.prototype.updateUVs = function (sprite, fillStart, fillEnd) {
        var spriteFrame = sprite._spriteFrame;
        //build uvs
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        //uv computation should take spritesheet into account.
        var ul, vb, ur, vt;
        var quadUV0, quadUV1, quadUV2, quadUV3, quadUV4, quadUV5, quadUV6, quadUV7;
        if (spriteFrame._rotated) {
            ul = (textureRect.x) / atlasWidth;
            vb = (textureRect.y + textureRect.width) / atlasHeight;
            ur = (textureRect.x + textureRect.height) / atlasWidth;
            vt = (textureRect.y) / atlasHeight;
            quadUV0 = quadUV2 = ul;
            quadUV4 = quadUV6 = ur;
            quadUV3 = quadUV7 = vb;
            quadUV1 = quadUV5 = vt;
        }
        else {
            ul = (textureRect.x) / atlasWidth;
            vb = (textureRect.y + textureRect.height) / atlasHeight;
            ur = (textureRect.x + textureRect.width) / atlasWidth;
            vt = (textureRect.y) / atlasHeight;
            quadUV0 = quadUV4 = ul;
            quadUV2 = quadUV6 = ur;
            quadUV1 = quadUV3 = vb;
            quadUV5 = quadUV7 = vt;
        }
        var verts = this._renderData.vDatas[0];
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        switch (sprite._fillType) {
            case cc.Sprite.FillType.HORIZONTAL:
                verts[uvOffset] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
                verts[uvOffset + 1] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
                verts[uvOffset + floatsPerVert] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
                verts[uvOffset + floatsPerVert + 1] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
                verts[uvOffset + floatsPerVert * 2] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
                verts[uvOffset + floatsPerVert * 2 + 1] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
                verts[uvOffset + floatsPerVert * 3] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
                verts[uvOffset + floatsPerVert * 3 + 1] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                break;
            case cc.Sprite.FillType.VERTICAL:
                verts[uvOffset] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
                verts[uvOffset + 1] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
                verts[uvOffset + floatsPerVert] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
                verts[uvOffset + floatsPerVert + 1] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
                verts[uvOffset + floatsPerVert * 2] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
                verts[uvOffset + floatsPerVert * 2 + 1] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
                verts[uvOffset + floatsPerVert * 3] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
                verts[uvOffset + floatsPerVert * 3 + 1] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                break;
            default:
                cc["errorID"](2626);
                break;
        }
    };
    MultiAssemblerBarFilled.prototype.updateVerts = function (sprite, fillStart, fillEnd) {
        var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var l = -appx, b = -appy, r = width - appx, t = height - appy;
        var progressStart, progressEnd;
        switch (sprite._fillType) {
            case cc.Sprite.FillType.HORIZONTAL:
                progressStart = l + (r - l) * fillStart;
                progressEnd = l + (r - l) * fillEnd;
                l = progressStart;
                r = progressEnd;
                break;
            case cc.Sprite.FillType.VERTICAL:
                progressStart = b + (t - b) * fillStart;
                progressEnd = b + (t - b) * fillEnd;
                b = progressStart;
                t = progressEnd;
                break;
            default:
                cc["errorID"](2626);
                break;
        }
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(sprite);
    };
    return MultiAssemblerBarFilled;
}(MultiAssembler_1.default));
exports.default = MultiAssemblerBarFilled;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyQmFyRmlsbGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUE4QztBQUU5QztJQUFxRCwyQ0FBYztJQUFuRTs7SUF5SUEsQ0FBQztJQXhJVSxrREFBZ0IsR0FBdkIsVUFBd0IsTUFBTTtRQUMxQixJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUU7WUFDckIsT0FBTztTQUNWO1FBRUQsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUNsQyxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1FBRWxDLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRTtZQUNmLFNBQVMsSUFBSSxTQUFTLENBQUM7WUFDdkIsU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDO1NBQzFCO1FBRUQsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFFbEMsU0FBUyxHQUFHLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQzlDLFNBQVMsR0FBRyxTQUFTLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUU5QyxTQUFTLEdBQUcsU0FBUyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDOUMsU0FBUyxHQUFHLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxD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QU8sQ0FBQztnQkFFcEMsQ0FBQyxHQUFHLGFBQWEsQ0FBQztnQkFDbEIsQ0FBQyxHQUFHLFdBQVcsQ0FBQztnQkFDaEIsTUFBTTtZQUNWO2dCQUNJLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDcEIsTUFBTTtTQUNiO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN4QixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNiLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDYixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFDTCw4QkFBQztBQUFELENBeklBLEFBeUlDLENBeklvRCx3QkFBYyxHQXlJbEUiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTXVsdGlBc3NlbWJsZXIgZnJvbSBcIi4vTXVsdGlBc3NlbWJsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpQXNzZW1ibGVyQmFyRmlsbGVkIGV4dGVuZHMgTXVsdGlBc3NlbWJsZXIge1xyXG4gICAgcHVibGljIHVwZGF0ZVJlbmRlckRhdGEoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IGZyYW1lID0gc3ByaXRlLl9zcHJpdGVGcmFtZTtcclxuICAgICAgICB0aGlzLnBhY2tUb0R5bmFtaWNBdGxhcyhzcHJpdGUsIGZyYW1lKTtcclxuXHJcbiAgICAgICAgaWYgKCFzcHJpdGUuX3ZlcnRzRGlydHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGZpbGxTdGFydCA9IHNwcml0ZS5fZmlsbFN0YXJ0O1xyXG4gICAgICAgIGxldCBmaWxsUmFuZ2UgPSBzcHJpdGUuX2ZpbGxSYW5nZTtcclxuXHJcbiAgICAgICAgaWYgKGZpbGxSYW5nZSA8IDApIHtcclxuICAgICAgICAgICAgZmlsbFN0YXJ0ICs9IGZpbGxSYW5nZTtcclxuICAgICAgICAgICAgZmlsbFJhbmdlID0gLWZpbGxSYW5nZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZpbGxSYW5nZSA9IGZpbGxTdGFydCArIGZpbGxSYW5nZTtcclxuXHJcbiAgICAgICAgZmlsbFN0YXJ0ID0gZmlsbFN0YXJ0ID4gMS4wID8gMS4wIDogZmlsbFN0YXJ0O1xyXG4gICAgICAgIGZpbGxTdGFydCA9IGZpbGxTdGFydCA8IDAuMCA/IDAuMCA6IGZpbGxTdGFydDtcclxuXHJcbiAgICAgICAgZmlsbFJhbmdlID0gZmlsbFJhbmdlID4gMS4wID8gMS4wIDogZmlsbFJhbmdlO1xyXG4gICAgICAgIGZpbGxSYW5nZSA9IGZpbGxSYW5nZSA8IDAuMCA/IDAuMCA6IGZpbGxSYW5nZTtcclxuICAgICAgICBmaWxsUmFuZ2UgPSBmaWxsUmFuZ2UgLSBmaWxsU3RhcnQ7XHJcbiAgICAgICAgZmlsbFJhbmdlID0gZmlsbFJhbmdlIDwgMCA/IDAgOiBmaWxsUmFuZ2U7XHJcblxyXG4gICAgICAgIGxldCBmaWxsRW5kID0gZmlsbFN0YXJ0ICsgZmlsbFJhbmdlO1xyXG4gICAgICAgIGZpbGxFbmQgPSBmaWxsRW5kID4gMSA/IDEgOiBmaWxsRW5kO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVVWcyhzcHJpdGUsIGZpbGxTdGFydCwgZmlsbEVuZCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWZXJ0cyhzcHJpdGUsIGZpbGxTdGFydCwgZmlsbEVuZCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlSWR4KHNwcml0ZSk7XHJcblxyXG4gICAgICAgIHNwcml0ZS5fdmVydHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVVVnMoc3ByaXRlLCBmaWxsU3RhcnQsIGZpbGxFbmQpIHtcclxuICAgICAgICBsZXQgc3ByaXRlRnJhbWUgPSBzcHJpdGUuX3Nwcml0ZUZyYW1lO1xyXG5cclxuICAgICAgICAvL2J1aWxkIHV2c1xyXG4gICAgICAgIGxldCBhdGxhc1dpZHRoID0gc3ByaXRlRnJhbWUuX3RleHR1cmUud2lkdGg7XHJcbiAgICAgICAgbGV0IGF0bGFzSGVpZ2h0ID0gc3ByaXRlRnJhbWUuX3RleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgIGxldCB0ZXh0dXJlUmVjdCA9IHNwcml0ZUZyYW1lLl9yZWN0O1xyXG4gICAgICAgIC8vdXYgY29tcHV0YXRpb24gc2hvdWxkIHRha2Ugc3ByaXRlc2hlZXQgaW50byBhY2NvdW50LlxyXG4gICAgICAgIGxldCB1bCwgdmIsIHVyLCB2dDtcclxuICAgICAgICBsZXQgcXVhZFVWMCwgcXVhZFVWMSwgcXVhZFVWMiwgcXVhZFVWMywgcXVhZFVWNCwgcXVhZFVWNSwgcXVhZFVWNiwgcXVhZFVWNztcclxuICAgICAgICBpZiAoc3ByaXRlRnJhbWUuX3JvdGF0ZWQpIHtcclxuICAgICAgICAgICAgdWwgPSAodGV4dHVyZVJlY3QueCkgLyBhdGxhc1dpZHRoO1xyXG4gICAgICAgICAgICB2YiA9ICh0ZXh0dXJlUmVjdC55ICsgdGV4dHVyZVJlY3Qud2lkdGgpIC8gYXRsYXNIZWlnaHQ7XHJcbiAgICAgICAgICAgIHVyID0gKHRleHR1cmVSZWN0LnggKyB0ZXh0dXJlUmVjdC5oZWlnaHQpIC8gYXRsYXNXaWR0aDtcclxuICAgICAgICAgICAgdnQgPSAodGV4dHVyZVJlY3QueSkgLyBhdGxhc0hlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHF1YWRVVjAgPSBxdWFkVVYyID0gdWw7XHJcbiAgICAgICAgICAgIHF1YWRVVjQgPSBxdWFkVVY2ID0gdXI7XHJcbiAgICAgICAgICAgIHF1YWRVVjMgPSBxdWFkVVY3ID0gdmI7XHJcbiAgICAgICAgICAgIHF1YWRVVjEgPSBxdWFkVVY1ID0gdnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bCA9ICh0ZXh0dXJlUmVjdC54KSAvIGF0bGFzV2lkdGg7XHJcbiAgICAgICAgICAgIHZiID0gKHRleHR1cmVSZWN0LnkgKyB0ZXh0dXJlUmVjdC5oZWlnaHQpIC8gYXRsYXNIZWlnaHQ7XHJcbiAgICAgICAgICAgIHVyID0gKHRleHR1cmVSZWN0LnggKyB0ZXh0dXJlUmVjdC53aWR0aCkgLyBhdGxhc1dpZHRoO1xyXG4gICAgICAgICAgICB2dCA9ICh0ZXh0dXJlUmVjdC55KSAvIGF0bGFzSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgcXVhZFVWMCA9IHF1YWRVVjQgPSB1bDtcclxuICAgICAgICAgICAgcXVhZFVWMiA9IHF1YWRVVjYgPSB1cjtcclxuICAgICAgICAgICAgcXVhZFVWMSA9IHF1YWRVVjMgPSB2YjtcclxuICAgICAgICAgICAgcXVhZFVWNSA9IHF1YWRVVjcgPSB2dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG4gICAgICAgIGxldCB1dk9mZnNldCA9IHRoaXMudXZPZmZzZXQ7XHJcbiAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgc3dpdGNoIChzcHJpdGUuX2ZpbGxUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuU3ByaXRlLkZpbGxUeXBlLkhPUklaT05UQUw6XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldF0gPSBxdWFkVVYwICsgKHF1YWRVVjIgLSBxdWFkVVYwKSAqIGZpbGxTdGFydDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgMV0gPSBxdWFkVVYxICsgKHF1YWRVVjMgLSBxdWFkVVYxKSAqIGZpbGxTdGFydDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgZmxvYXRzUGVyVmVydF0gPSBxdWFkVVYwICsgKHF1YWRVVjIgLSBxdWFkVVYwKSAqIGZpbGxFbmQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnQgKyAxXSA9IHF1YWRVVjEgKyAocXVhZFVWMyAtIHF1YWRVVjEpICogZmlsbEVuZDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgZmxvYXRzUGVyVmVydCAqIDJdID0gcXVhZFVWNCArIChxdWFkVVY2IC0gcXVhZFVWNCkgKiBmaWxsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnQgKiAyICsgMV0gPSBxdWFkVVY1ICsgKHF1YWRVVjcgLSBxdWFkVVY1KSAqIGZpbGxTdGFydDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgZmxvYXRzUGVyVmVydCAqIDNdID0gcXVhZFVWNCArIChxdWFkVVY2IC0gcXVhZFVWNCkgKiBmaWxsRW5kO1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXQgKyBmbG9hdHNQZXJWZXJ0ICogMyArIDFdID0gcXVhZFVWNSArIChxdWFkVVY3IC0gcXVhZFVWNSkgKiBmaWxsRW5kO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuU3ByaXRlLkZpbGxUeXBlLlZFUlRJQ0FMOlxyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXRdID0gcXVhZFVWMCArIChxdWFkVVY0IC0gcXVhZFVWMCkgKiBmaWxsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIDFdID0gcXVhZFVWMSArIChxdWFkVVY1IC0gcXVhZFVWMSkgKiBmaWxsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnRdID0gcXVhZFVWMiArIChxdWFkVVY2IC0gcXVhZFVWMikgKiBmaWxsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnQgKyAxXSA9IHF1YWRVVjMgKyAocXVhZFVWNyAtIHF1YWRVVjMpICogZmlsbFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXQgKyBmbG9hdHNQZXJWZXJ0ICogMl0gPSBxdWFkVVYwICsgKHF1YWRVVjQgLSBxdWFkVVYwKSAqIGZpbGxFbmQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnQgKiAyICsgMV0gPSBxdWFkVVYxICsgKHF1YWRVVjUgLSBxdWFkVVYxKSAqIGZpbGxFbmQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIGZsb2F0c1BlclZlcnQgKiAzXSA9IHF1YWRVVjIgKyAocXVhZFVWNiAtIHF1YWRVVjIpICogZmlsbEVuZDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgZmxvYXRzUGVyVmVydCAqIDMgKyAxXSA9IHF1YWRVVjMgKyAocXVhZFVWNyAtIHF1YWRVVjMpICogZmlsbEVuZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2NbXCJlcnJvcklEXCJdKDI2MjYpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVWZXJ0cyhzcHJpdGUsIGZpbGxTdGFydCwgZmlsbEVuZCkge1xyXG4gICAgICAgIGxldCBub2RlID0gc3ByaXRlLm5vZGUsXHJcbiAgICAgICAgICAgIHdpZHRoID0gbm9kZS53aWR0aCwgaGVpZ2h0ID0gbm9kZS5oZWlnaHQsXHJcbiAgICAgICAgICAgIGFwcHggPSBub2RlLmFuY2hvclggKiB3aWR0aCwgYXBweSA9IG5vZGUuYW5jaG9yWSAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgbGV0IGwgPSAtYXBweCwgYiA9IC1hcHB5LFxyXG4gICAgICAgICAgICByID0gd2lkdGggLSBhcHB4LCB0ID0gaGVpZ2h0IC0gYXBweTtcclxuXHJcbiAgICAgICAgbGV0IHByb2dyZXNzU3RhcnQsIHByb2dyZXNzRW5kO1xyXG4gICAgICAgIHN3aXRjaCAoc3ByaXRlLl9maWxsVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIGNjLlNwcml0ZS5GaWxsVHlwZS5IT1JJWk9OVEFMOlxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdGFydCA9IGwgKyAociAtIGwpICogZmlsbFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NFbmQgPSBsICsgKHIgLSBsKSAqIGZpbGxFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgbCA9IHByb2dyZXNzU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICByID0gcHJvZ3Jlc3NFbmQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjYy5TcHJpdGUuRmlsbFR5cGUuVkVSVElDQUw6XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc1N0YXJ0ID0gYiArICh0IC0gYikgKiBmaWxsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0VuZCA9IGIgKyAodCAtIGIpICogZmlsbEVuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBiID0gcHJvZ3Jlc3NTdGFydDtcclxuICAgICAgICAgICAgICAgIHQgPSBwcm9ncmVzc0VuZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2NbXCJlcnJvcklEXCJdKDI2MjYpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICBsb2NhbFswXSA9IGw7XHJcbiAgICAgICAgbG9jYWxbMV0gPSBiO1xyXG4gICAgICAgIGxvY2FsWzJdID0gcjtcclxuICAgICAgICBsb2NhbFszXSA9IHQ7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRWZXJ0cyhzcHJpdGUpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/base/Tip.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '86d61wcIsZPSrb29FvmFJRL', 'Tip');
// scripts/common/cmpt/base/Tip.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
var Tip = /** @class */ (function (_super) {
    __extends(Tip, _super);
    function Tip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.layout = null;
        _this.textLab = null;
        return _this;
    }
    Tip.prototype.init = function (text) {
        this.textLab.string = text;
        this.textLab["_forceUpdateRenderData"]();
        this.layout.updateLayout();
    };
    __decorate([
        property(cc.Layout)
    ], Tip.prototype, "layout", void 0);
    __decorate([
        property(cc.Label)
    ], Tip.prototype, "textLab", void 0);
    Tip = __decorate([
        ccclass,
        disallowMultiple,
        menu("Framework/基础组件/Tip")
    ], Tip);
    return Tip;
}(cc.Component));
exports.default = Tip;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxiYXNlXFxUaXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU0sSUFBQSxLQUFnRCxFQUFFLENBQUMsVUFBVSxFQUEzRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFLcEU7SUFBaUMsdUJBQVk7SUFBN0M7UUFBQSxxRUFVQztRQVJnQyxZQUFNLEdBQWMsSUFBSSxDQUFDO1FBQzFCLGFBQU8sR0FBYSxJQUFJLENBQUM7O0lBT3pELENBQUM7SUFMVSxrQkFBSSxHQUFYLFVBQVksSUFBWTtRQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBUG9CO1FBQXBCLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDO3VDQUFrQztJQUNsQztRQUFuQixRQUFRLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQzt3Q0FBa0M7SUFIcEMsR0FBRztRQUh2QixPQUFPO1FBQ1AsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztPQUNOLEdBQUcsQ0FVdkI7SUFBRCxVQUFDO0NBVkQsQUFVQyxDQVZnQyxFQUFFLENBQUMsU0FBUyxHQVU1QztrQkFWb0IsR0FBRyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIGRpc2FsbG93TXVsdGlwbGUsIG1lbnUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG5AY2NjbGFzc1xyXG5AZGlzYWxsb3dNdWx0aXBsZVxyXG5AbWVudShcIkZyYW1ld29yay/ln7rnoYDnu4Tku7YvVGlwXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpcCBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcblxyXG4gICAgQHByb3BlcnR5KGNjLkxheW91dCkgcHJpdmF0ZSBsYXlvdXQ6IGNjLkxheW91dCA9IG51bGw7XHJcbiAgICBAcHJvcGVydHkoY2MuTGFiZWwpIHByaXZhdGUgdGV4dExhYjogY2MuTGFiZWwgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBpbml0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGV4dExhYi5zdHJpbmcgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMudGV4dExhYltcIl9mb3JjZVVwZGF0ZVJlbmRlckRhdGFcIl0oKTtcclxuICAgICAgICB0aGlzLmxheW91dC51cGRhdGVMYXlvdXQoKTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/animValue/AnimValueLabel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '93188RmKh1GHJhJYMxNsu+u', 'AnimValueLabel');
// scripts/common/cmpt/ui/animValue/AnimValueLabel.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimValue_1 = require("./AnimValue");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent, executeInEditMode = _a.executeInEditMode;
/**
 * 数值渐变的数字
 */
var AnimValueLabel = /** @class */ (function (_super) {
    __extends(AnimValueLabel, _super);
    function AnimValueLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._label = null;
        return _this;
    }
    Object.defineProperty(AnimValueLabel.prototype, "label", {
        get: function () {
            if (!this._label)
                this._label = this.getComponent(cc.Label);
            return this._label;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @override
     */
    AnimValueLabel.prototype.onAnimUpdate = function () {
        this.label.string = "" + Math.round(this.curValue);
    };
    AnimValueLabel = __decorate([
        ccclass,
        executeInEditMode,
        requireComponent(cc.Label),
        menu("Framework/UI组件/AnimValueLabel")
    ], AnimValueLabel);
    return AnimValueLabel;
}(AnimValue_1.default));
exports.default = AnimValueLabel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYW5pbVZhbHVlXFxBbmltVmFsdWVMYWJlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBb0M7QUFFOUIsSUFBQSxLQUFtRSxFQUFFLENBQUMsVUFBVSxFQUE5RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxpQkFBaUIsdUJBQWtCLENBQUM7QUFFdkY7O0dBRUc7QUFLSDtJQUE0QyxrQ0FBUztJQUFyRDtRQUFBLHFFQWNDO1FBWlcsWUFBTSxHQUFhLElBQUksQ0FBQzs7SUFZcEMsQ0FBQztJQVhHLHNCQUFXLGlDQUFLO2FBQWhCO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNO2dCQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRUQ7O09BRUc7SUFDTyxxQ0FBWSxHQUF0QjtRQUNJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFHLENBQUM7SUFDdkQsQ0FBQztJQWJnQixjQUFjO1FBSmxDLE9BQU87UUFDUCxpQkFBaUI7UUFDakIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztRQUMxQixJQUFJLENBQUMsK0JBQStCLENBQUM7T0FDakIsY0FBYyxDQWNsQztJQUFELHFCQUFDO0NBZEQsQUFjQyxDQWQyQyxtQkFBUyxHQWNwRDtrQkFkb0IsY0FBYyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBbmltVmFsdWUgZnJvbSBcIi4vQW5pbVZhbHVlXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCByZXF1aXJlQ29tcG9uZW50LCBleGVjdXRlSW5FZGl0TW9kZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiDmlbDlgLzmuJDlj5jnmoTmlbDlrZdcclxuICovXHJcbkBjY2NsYXNzXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AcmVxdWlyZUNvbXBvbmVudChjYy5MYWJlbClcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvQW5pbVZhbHVlTGFiZWxcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbVZhbHVlTGFiZWwgZXh0ZW5kcyBBbmltVmFsdWUge1xyXG5cclxuICAgIHByaXZhdGUgX2xhYmVsOiBjYy5MYWJlbCA9IG51bGw7XHJcbiAgICBwdWJsaWMgZ2V0IGxhYmVsKCk6IGNjLkxhYmVsIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsKSB0aGlzLl9sYWJlbCA9IHRoaXMuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uQW5pbVVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxhYmVsLnN0cmluZyA9IGAke01hdGgucm91bmQodGhpcy5jdXJWYWx1ZSl9YDtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/AnimatorSpine.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '8f224eiAodM8YIcjrZ0B9zN', 'AnimatorSpine');
// scripts/animator/AnimatorSpine.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorBase_1 = require("./core/AnimatorBase");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * Spine状态机组件（主状态机），trackIndex为0
 */
var AnimatorSpine = /** @class */ (function (_super) {
    __extends(AnimatorSpine, _super);
    function AnimatorSpine() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** spine组件 */
        _this._spine = null;
        /** 动画完成的回调 */
        _this._completeListenerMap = new Map();
        /** 次状态机注册的回调 */
        _this._secondaryListenerMap = new Map();
        return _this;
    }
    AnimatorSpine.prototype.start = function () {
        if (!this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this._spine = this.getComponent(sp.Skeleton);
        this._spine.setCompleteListener(this.onSpineComplete.bind(this));
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @override
     */
    AnimatorSpine.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this.initArgs.apply(this, args);
        this._spine = this.getComponent(sp.Skeleton);
        this._spine.setCompleteListener(this.onSpineComplete.bind(this));
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    AnimatorSpine.prototype.onSpineComplete = function (entry) {
        entry.trackIndex === 0 && this.onAnimFinished();
        this._completeListenerMap.forEach(function (target, cb) { target ? cb.call(target, entry) : cb(entry); });
        this._secondaryListenerMap.forEach(function (target, cb) { entry.trackIndex === target.trackIndex && cb.call(target, entry); });
    };
    /**
     * 播放动画
     * @override
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorSpine.prototype.playAnimation = function (animName, loop) {
        if (animName) {
            this._spine.setAnimation(0, animName, loop);
        }
        else {
            this._spine.clearTrack(0);
        }
    };
    /**
     * 缩放动画播放速率
     * @override
     * @param scale 缩放倍率
     */
    AnimatorSpine.prototype.scaleTime = function (scale) {
        this._spine.timeScale = scale;
    };
    /**
     * 注册次状态机动画结束的回调（状态机内部方法，不能由外部直接调用）
     */
    AnimatorSpine.prototype.addSecondaryListener = function (cb, target) {
        this._secondaryListenerMap.set(cb, target);
    };
    /**
     * 注册动画完成时的监听
     * @param cb 回调
     * @param target 调用回调的this对象
     */
    AnimatorSpine.prototype.addCompleteListener = function (cb, target) {
        if (target === void 0) { target = null; }
        if (this._completeListenerMap.has(cb)) {
            return;
        }
        this._completeListenerMap.set(cb, target);
    };
    /**
     * 注销动画完成的监听
     * @param cb 回调
     */
    AnimatorSpine.prototype.removeCompleteListener = function (cb) {
        this._completeListenerMap.delete(cb);
    };
    /**
     * 清空动画完成的监听
     */
    AnimatorSpine.prototype.clearCompleteListener = function () {
        this._completeListenerMap.clear;
    };
    AnimatorSpine = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(sp.Skeleton),
        menu('Framework/Animator/AnimatorSpine')
    ], AnimatorSpine);
    return AnimatorSpine;
}(AnimatorBase_1.default));
exports.default = AnimatorSpine;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXEFuaW1hdG9yU3BpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0Esb0RBQW9FO0FBRzlELElBQUEsS0FBa0UsRUFBRSxDQUFDLFVBQVUsRUFBN0UsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsSUFBSSxVQUFrQixDQUFDO0FBRXRGOztHQUVHO0FBS0g7SUFBMkMsaUNBQVk7SUFBdkQ7UUFBQSxxRUEyR0M7UUExR0csY0FBYztRQUNOLFlBQU0sR0FBZ0IsSUFBSSxDQUFDO1FBQ25DLGNBQWM7UUFDTiwwQkFBb0IsR0FBb0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUMxRSxnQkFBZ0I7UUFDUiwyQkFBcUIsR0FBdUQsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7SUFxR2xHLENBQUM7SUFuR2EsNkJBQUssR0FBZjtRQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDcEMsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFakUsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUksRUFBRTtZQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEM7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksOEJBQU0sR0FBYjtRQUFjLGNBQWtI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QU87UUFDUCxnQkFBZ0I7UUFDaEIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztRQUM3QixJQUFJLENBQUMsa0NBQWtDLENBQUM7T0FDcEIsYUFBYSxDQTJHakM7SUFBRCxvQkFBQztDQTNHRCxBQTJHQyxDQTNHMEMsc0JBQVksR0EyR3REO2tCQTNHb0IsYUFBYSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBbmltYXRvclNwaW5lU2Vjb25kYXJ5IGZyb20gXCIuL0FuaW1hdG9yU3BpbmVTZWNvbmRhcnlcIjtcclxuaW1wb3J0IEFuaW1hdG9yQmFzZSwgeyBBbmltYXRpb25QbGF5ZXIgfSBmcm9tIFwiLi9jb3JlL0FuaW1hdG9yQmFzZVwiO1xyXG5pbXBvcnQgQW5pbWF0b3JTdGF0ZUxvZ2ljIGZyb20gXCIuL2NvcmUvQW5pbWF0b3JTdGF0ZUxvZ2ljXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCByZXF1aXJlQ29tcG9uZW50LCBkaXNhbGxvd011bHRpcGxlLCBtZW51IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqIFxyXG4gKiBTcGluZeeKtuaAgeacuue7hOS7tu+8iOS4u+eKtuaAgeacuu+8ie+8jHRyYWNrSW5kZXjkuLowXHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AZGlzYWxsb3dNdWx0aXBsZVxyXG5AcmVxdWlyZUNvbXBvbmVudChzcC5Ta2VsZXRvbilcclxuQG1lbnUoJ0ZyYW1ld29yay9BbmltYXRvci9BbmltYXRvclNwaW5lJylcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JTcGluZSBleHRlbmRzIEFuaW1hdG9yQmFzZSB7XHJcbiAgICAvKiogc3BpbmXnu4Tku7YgKi9cclxuICAgIHByaXZhdGUgX3NwaW5lOiBzcC5Ta2VsZXRvbiA9IG51bGw7XHJcbiAgICAvKiog5Yqo55S75a6M5oiQ55qE5Zue6LCDICovXHJcbiAgICBwcml2YXRlIF9jb21wbGV0ZUxpc3RlbmVyTWFwOiBNYXA8KGVudHJ5PzogYW55KSA9PiB2b2lkLCBhbnk+ID0gbmV3IE1hcCgpO1xyXG4gICAgLyoqIOasoeeKtuaAgeacuuazqOWGjOeahOWbnuiwgyAqL1xyXG4gICAgcHJpdmF0ZSBfc2Vjb25kYXJ5TGlzdGVuZXJNYXA6IE1hcDwoZW50cnk/OiBhbnkpID0+IHZvaWQsIEFuaW1hdG9yU3BpbmVTZWNvbmRhcnk+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGxheU9uU3RhcnQgfHwgdGhpcy5faGFzSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc0luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9zcGluZSA9IHRoaXMuZ2V0Q29tcG9uZW50KHNwLlNrZWxldG9uKTtcclxuICAgICAgICB0aGlzLl9zcGluZS5zZXRDb21wbGV0ZUxpc3RlbmVyKHRoaXMub25TcGluZUNvbXBsZXRlLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hc3NldFJhd1VybCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRKc29uKHRoaXMuYXNzZXRSYXdVcmwuanNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omL5Yqo5Yid5aeL5YyW54q25oCB5py677yM5Y+v5Lyg5YWlMC0z5Liq5Y+C5pWw77yM57G75Z6L5aaC5LiLXHJcbiAgICAgKiAtIG9uU3RhdGVDaGFuZ2VDYWxsIOeKtuaAgeWIh+aNouaXtueahOWbnuiwg1xyXG4gICAgICogLSBzdGF0ZUxvZ2ljTWFwIOWQhOS4queKtuaAgemAu+i+keaOp+WItlxyXG4gICAgICogLSBhbmltYXRpb25QbGF5ZXIg6Ieq5a6a5LmJ5Yqo55S75o6n5Yi2XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uSW5pdCguLi5hcmdzOiBBcnJheTxNYXA8c3RyaW5nLCBBbmltYXRvclN0YXRlTG9naWM+IHwgKChmcm9tU3RhdGU6IHN0cmluZywgdG9TdGF0ZTogc3RyaW5nKSA9PiB2b2lkKSB8IEFuaW1hdGlvblBsYXllcj4pIHtcclxuICAgICAgICBpZiAodGhpcy5wbGF5T25TdGFydCB8fCB0aGlzLl9oYXNJbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFzSW5pdCA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdEFyZ3MoLi4uYXJncyk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NwaW5lID0gdGhpcy5nZXRDb21wb25lbnQoc3AuU2tlbGV0b24pO1xyXG4gICAgICAgIHRoaXMuX3NwaW5lLnNldENvbXBsZXRlTGlzdGVuZXIodGhpcy5vblNwaW5lQ29tcGxldGUuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFzc2V0UmF3VXJsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEpzb24odGhpcy5hc3NldFJhd1VybC5qc29uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvblNwaW5lQ29tcGxldGUoZW50cnk6IGFueSkge1xyXG4gICAgICAgIGVudHJ5LnRyYWNrSW5kZXggPT09IDAgJiYgdGhpcy5vbkFuaW1GaW5pc2hlZCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlTGlzdGVuZXJNYXAuZm9yRWFjaCgodGFyZ2V0LCBjYikgPT4geyB0YXJnZXQgPyBjYi5jYWxsKHRhcmdldCwgZW50cnkpIDogY2IoZW50cnkpOyB9KTtcclxuICAgICAgICB0aGlzLl9zZWNvbmRhcnlMaXN0ZW5lck1hcC5mb3JFYWNoKCh0YXJnZXQsIGNiKSA9PiB7IGVudHJ5LnRyYWNrSW5kZXggPT09IHRhcmdldC50cmFja0luZGV4ICYmIGNiLmNhbGwodGFyZ2V0LCBlbnRyeSk7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pKt5pS+5Yqo55S7XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSBhbmltTmFtZSDliqjnlLvlkI1cclxuICAgICAqIEBwYXJhbSBsb29wIOaYr+WQpuW+queOr+aSreaUvlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGxheUFuaW1hdGlvbihhbmltTmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKGFuaW1OYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwaW5lLnNldEFuaW1hdGlvbigwLCBhbmltTmFtZSwgbG9vcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BpbmUuY2xlYXJUcmFjaygwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnvKnmlL7liqjnlLvmkq3mlL7pgJ/njodcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIHNjYWxlIOe8qeaUvuWAjeeOh1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2NhbGVUaW1lKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9zcGluZS50aW1lU2NhbGUgPSBzY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOasoeeKtuaAgeacuuWKqOeUu+e7k+adn+eahOWbnuiwg++8iOeKtuaAgeacuuWGhemDqOaWueazle+8jOS4jeiDveeUseWklumDqOebtOaOpeiwg+eUqO+8iVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkU2Vjb25kYXJ5TGlzdGVuZXIoY2I6IChlbnRyeT86IGFueSkgPT4gdm9pZCwgdGFyZ2V0OiBBbmltYXRvclNwaW5lU2Vjb25kYXJ5KSB7XHJcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5TGlzdGVuZXJNYXAuc2V0KGNiLCB0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaM5Yqo55S75a6M5oiQ5pe255qE55uR5ZCsXHJcbiAgICAgKiBAcGFyYW0gY2Ig5Zue6LCDXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IOiwg+eUqOWbnuiwg+eahHRoaXPlr7nosaFcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENvbXBsZXRlTGlzdGVuZXIoY2I6IChlbnRyeT86IGFueSkgPT4gdm9pZCwgdGFyZ2V0OiBhbnkgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBsZXRlTGlzdGVuZXJNYXAuaGFzKGNiKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlTGlzdGVuZXJNYXAuc2V0KGNiLCB0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rOo6ZSA5Yqo55S75a6M5oiQ55qE55uR5ZCsXHJcbiAgICAgKiBAcGFyYW0gY2Ig5Zue6LCDXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb21wbGV0ZUxpc3RlbmVyKGNiOiAoZW50cnk/OiBhbnkpID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLl9jb21wbGV0ZUxpc3RlbmVyTWFwLmRlbGV0ZShjYik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmuIXnqbrliqjnlLvlrozmiJDnmoTnm5HlkKxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyQ29tcGxldGVMaXN0ZW5lcigpIHtcclxuICAgICAgICB0aGlzLl9jb21wbGV0ZUxpc3RlbmVyTWFwLmNsZWFyO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/shader/ShaderShining.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '10bd9Ws1BRG/ZPICDgLNLvK', 'ShaderShining');
// scripts/common/cmpt/shader/ShaderShining.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Timer_1 = require("../base/Timer");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple, executeInEditMode = _a.executeInEditMode;
var ShaderShining = /** @class */ (function (_super) {
    __extends(ShaderShining, _super);
    function ShaderShining() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.speed = 1;
        _this.slope = 1;
        _this.len = 0.25;
        _this.strength = 2;
        _this.interval = 1;
        _this.timeScale = false;
        _this._mat = null;
        return _this;
    }
    Object.defineProperty(ShaderShining.prototype, "mat", {
        get: function () {
            if (!this._mat) {
                this._mat = this.getComponent(cc.RenderComponent).getMaterial(0);
            }
            return this._mat;
        },
        enumerable: false,
        configurable: true
    });
    ShaderShining.prototype.start = function () {
        this.updateShader();
    };
    ShaderShining.prototype.update = function () {
        this.updateShader();
    };
    ShaderShining.prototype.updateShader = function () {
        this.mat.setProperty("shiningData", new cc.Vec4(this.speed, this.slope, this.len, this.interval));
        this.mat.setProperty("extra", new cc.Vec4(this.timeScale ? Timer_1.default.scaleGameSec : Timer_1.default.gameSec, this.strength));
    };
    __decorate([
        property({ tooltip: CC_DEV && "流光速度" })
    ], ShaderShining.prototype, "speed", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "流光斜率" })
    ], ShaderShining.prototype, "slope", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "流光宽度", range: [0, Number.MAX_SAFE_INTEGER] })
    ], ShaderShining.prototype, "len", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "流光强度", range: [0, Number.MAX_SAFE_INTEGER] })
    ], ShaderShining.prototype, "strength", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "两次流光动画之间的间隔时间", range: [0, Number.MAX_SAFE_INTEGER] })
    ], ShaderShining.prototype, "interval", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "流光速度是否受到timeScale的影响" })
    ], ShaderShining.prototype, "timeScale", void 0);
    ShaderShining = __decorate([
        ccclass,
        disallowMultiple,
        executeInEditMode,
        menu("Framework/Shader/ShaderShining")
    ], ShaderShining);
    return ShaderShining;
}(cc.Component));
exports.default = ShaderShining;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxzaGFkZXJcXFNoYWRlclNoaW5pbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUNBQWtDO0FBRTVCLElBQUEsS0FBbUUsRUFBRSxDQUFDLFVBQVUsRUFBOUUsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsSUFBSSxVQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsaUJBQWlCLHVCQUFrQixDQUFDO0FBTXZGO0lBQTJDLGlDQUFZO0lBQXZEO1FBQUEscUVBa0NDO1FBaENVLFdBQUssR0FBVyxDQUFDLENBQUM7UUFFbEIsV0FBSyxHQUFXLENBQUMsQ0FBQztRQUVsQixTQUFHLEdBQVcsSUFBSSxDQUFDO1FBRW5CLGNBQVEsR0FBVyxDQUFDLENBQUM7UUFFckIsY0FBUSxHQUFXLENBQUMsQ0FBQztRQUVyQixlQUFTLEdBQVksS0FBSyxDQUFDO1FBRTFCLFVBQUksR0FBZ0IsSUFBSSxDQUFDOztJQW9CckMsQ0FBQztJQW5CRyxzQkFBVyw4QkFBRzthQUFkO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEU7WUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDckIsQ0FBQzs7O09BQUE7SUFFUyw2QkFBSyxHQUFmO1FBQ0ksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFUyw4QkFBTSxHQUFoQjtRQUNJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRU0sb0NBQVksR0FBbkI7UUFDSSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2xHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsZUFBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsZUFBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNuSCxDQUFDO0lBL0JEO1FBREMsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxNQUFNLEVBQUUsQ0FBQztnREFDZjtJQUV6QjtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7Z0RBQ2Y7SUFFekI7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQzs4Q0FDbkQ7SUFFMUI7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQzttREFDakQ7SUFFNUI7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLGVBQWUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQzttREFDMUQ7SUFFNUI7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLHNCQUFzQixFQUFFLENBQUM7b0RBQ3RCO0lBWmpCLGFBQWE7UUFKakMsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixpQkFBaUI7UUFDakIsSUFBSSxDQUFDLGdDQUFnQyxDQUFDO09BQ2xCLGFBQWEsQ0FrQ2pDO0lBQUQsb0JBQUM7Q0FsQ0QsQUFrQ0MsQ0FsQzBDLEVBQUUsQ0FBQyxTQUFTLEdBa0N0RDtrQkFsQ29CLGFBQWEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGltZXIgZnJvbSBcIi4uL2Jhc2UvVGltZXJcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUsIGRpc2FsbG93TXVsdGlwbGUsIGV4ZWN1dGVJbkVkaXRNb2RlIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuQGRpc2FsbG93TXVsdGlwbGVcclxuQGV4ZWN1dGVJbkVkaXRNb2RlXHJcbkBtZW51KFwiRnJhbWV3b3JrL1NoYWRlci9TaGFkZXJTaGluaW5nXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclNoaW5pbmcgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5rWB5YWJ6YCf5bqmXCIgfSlcclxuICAgIHB1YmxpYyBzcGVlZDogbnVtYmVyID0gMTtcclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiBcIua1geWFieaWnOeOh1wiIH0pXHJcbiAgICBwdWJsaWMgc2xvcGU6IG51bWJlciA9IDE7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmtYHlhYnlrr3luqZcIiwgcmFuZ2U6IFswLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0gfSlcclxuICAgIHB1YmxpYyBsZW46IG51bWJlciA9IDAuMjU7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmtYHlhYnlvLrluqZcIiwgcmFuZ2U6IFswLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0gfSlcclxuICAgIHB1YmxpYyBzdHJlbmd0aDogbnVtYmVyID0gMjtcclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiBcIuS4pOasoea1geWFieWKqOeUu+S5i+mXtOeahOmXtOmalOaXtumXtFwiLCByYW5nZTogWzAsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSB9KVxyXG4gICAgcHVibGljIGludGVydmFsOiBudW1iZXIgPSAxO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5rWB5YWJ6YCf5bqm5piv5ZCm5Y+X5YiwdGltZVNjYWxl55qE5b2x5ZONXCIgfSlcclxuICAgIHB1YmxpYyB0aW1lU2NhbGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIF9tYXQ6IGNjLk1hdGVyaWFsID0gbnVsbDtcclxuICAgIHB1YmxpYyBnZXQgbWF0KCk6IGNjLk1hdGVyaWFsIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21hdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXQgPSB0aGlzLmdldENvbXBvbmVudChjYy5SZW5kZXJDb21wb25lbnQpLmdldE1hdGVyaWFsKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB1cGRhdGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTaGFkZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlU2hhZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWF0LnNldFByb3BlcnR5KFwic2hpbmluZ0RhdGFcIiwgbmV3IGNjLlZlYzQodGhpcy5zcGVlZCwgdGhpcy5zbG9wZSwgdGhpcy5sZW4sIHRoaXMuaW50ZXJ2YWwpKTtcclxuICAgICAgICB0aGlzLm1hdC5zZXRQcm9wZXJ0eShcImV4dHJhXCIsIG5ldyBjYy5WZWM0KHRoaXMudGltZVNjYWxlID8gVGltZXIuc2NhbGVHYW1lU2VjIDogVGltZXIuZ2FtZVNlYywgdGhpcy5zdHJlbmd0aCkpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/adapt/AdaptSize.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '6c391dfrNBD95q+Uj9I1ejA', 'AdaptSize');
// scripts/common/cmpt/ui/adapt/AdaptSize.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EventName_1 = require("../../../const/EventName");
var Events_1 = require("../../../util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, executeInEditMode = _a.executeInEditMode;
/**
 * - 适配组件，使节点与设计分辨率size保持一致，不影响节点位置
 * - 不使用cc.Widget是因为某些需要改变节点position的情况下会产生冲突
 */
var AdaptSize = /** @class */ (function (_super) {
    __extends(AdaptSize, _super);
    function AdaptSize() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AdaptSize.prototype.onLoad = function () {
        this.adapt();
    };
    AdaptSize.prototype.adapt = function () {
        if (CC_EDITOR) {
            this.node.width = cc["engine"].getDesignResolutionSize().width;
            this.node.height = cc["engine"].getDesignResolutionSize().height;
        }
        else {
            this.node.width = cc.winSize.width;
            this.node.height = cc.winSize.height;
        }
    };
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.RESIZE)
    ], AdaptSize.prototype, "adapt", null);
    AdaptSize = __decorate([
        ccclass,
        Events_1.eventsOnLoad(),
        executeInEditMode,
        menu("Framework/UI组件/AdaptSize")
    ], AdaptSize);
    return AdaptSize;
}(cc.Component));
exports.default = AdaptSize;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYWRhcHRcXEFkYXB0U2l6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBcUQ7QUFDckQsK0NBQWtFO0FBRTVELElBQUEsS0FBaUQsRUFBRSxDQUFDLFVBQVUsRUFBNUQsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsSUFBSSxVQUFBLEVBQUUsaUJBQWlCLHVCQUFrQixDQUFDO0FBRXJFOzs7R0FHRztBQUtIO0lBQXVDLDZCQUFZO0lBQW5EOztJQWVBLENBQUM7SUFkYSwwQkFBTSxHQUFoQjtRQUNJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBR08seUJBQUssR0FBYjtRQUNJLElBQUksU0FBUyxFQUFFO1lBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLHVCQUF1QixFQUFFLENBQUMsS0FBSyxDQUFDO1lBQy9ELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLE1BQU0sQ0FBQztTQUNwRTthQUFNO1lBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7U0FDeEM7SUFDTCxDQUFDO0lBUkQ7UUFEQyxxQkFBWSxDQUFDLHFCQUFTLENBQUMsTUFBTSxDQUFDOzBDQVM5QjtJQWRnQixTQUFTO1FBSjdCLE9BQU87UUFDUCxxQkFBWSxFQUFFO1FBQ2QsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQywwQkFBMEIsQ0FBQztPQUNaLFNBQVMsQ0FlN0I7SUFBRCxnQkFBQztDQWZELEFBZUMsQ0Fmc0MsRUFBRSxDQUFDLFNBQVMsR0FlbEQ7a0JBZm9CLFNBQVMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudE5hbWUgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCB7IGV2ZW50c09uTG9hZCwgcHJlbG9hZEV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvRXZlbnRzXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCBleGVjdXRlSW5FZGl0TW9kZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiAtIOmAgumFjee7hOS7tu+8jOS9v+iKgueCueS4juiuvuiuoeWIhui+qOeOh3NpemXkv53mjIHkuIDoh7TvvIzkuI3lvbHlk43oioLngrnkvY3nva5cclxuICogLSDkuI3kvb/nlKhjYy5XaWRnZXTmmK/lm6DkuLrmn5DkupvpnIDopoHmlLnlj5joioLngrlwb3NpdGlvbueahOaDheWGteS4i+S8muS6p+eUn+WGsueqgVxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGV2ZW50c09uTG9hZCgpXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9BZGFwdFNpemVcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRhcHRTaXplIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIHByb3RlY3RlZCBvbkxvYWQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hZGFwdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBwcmVsb2FkRXZlbnQoRXZlbnROYW1lLlJFU0laRSlcclxuICAgIHByaXZhdGUgYWRhcHQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKENDX0VESVRPUikge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUud2lkdGggPSBjY1tcImVuZ2luZVwiXS5nZXREZXNpZ25SZXNvbHV0aW9uU2l6ZSgpLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuaGVpZ2h0ID0gY2NbXCJlbmdpbmVcIl0uZ2V0RGVzaWduUmVzb2x1dGlvblNpemUoKS5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLndpZHRoID0gY2Mud2luU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmhlaWdodCA9IGNjLndpblNpemUuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/button/ButtonSingle.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0dd4fIEsu5H8YHrLixEwxNu', 'ButtonSingle');
// scripts/common/cmpt/ui/button/ButtonSingle.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent;
/**
 * 按钮分组
 */
var ButtonGroup;
(function (ButtonGroup) {
    ButtonGroup[ButtonGroup["DEFAULT"] = 0] = "DEFAULT";
    ButtonGroup[ButtonGroup["GROUP1"] = 1] = "GROUP1";
    ButtonGroup[ButtonGroup["GROUP2"] = 2] = "GROUP2";
})(ButtonGroup || (ButtonGroup = {}));
/**
 * 防多点触摸的按钮，同组按钮同一时刻只会有一个生效
 */
var ButtonSingle = /** @class */ (function (_super) {
    __extends(ButtonSingle, _super);
    function ButtonSingle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buttonGroup = ButtonGroup.DEFAULT;
        _this._button = null;
        return _this;
    }
    ButtonSingle_1 = ButtonSingle;
    Object.defineProperty(ButtonSingle, "groupMap", {
        get: function () {
            if (this._groupMap === null) {
                this._groupMap = new Map();
            }
            return this._groupMap;
        },
        enumerable: false,
        configurable: true
    });
    ButtonSingle.prototype.onLoad = function () {
        this._button = this.getComponent(cc.Button);
        var groupData = ButtonSingle_1.groupMap.get(this.buttonGroup);
        if (groupData === undefined) {
            groupData = {
                lock: false,
                buttonSet: new Set()
            };
            ButtonSingle_1.groupMap.set(this.buttonGroup, groupData);
        }
        groupData.buttonSet.add(this._button);
        // 监听触摸事件
        this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchEnd, this);
    };
    ButtonSingle.prototype.onDestroy = function () {
        var groupData = ButtonSingle_1.groupMap.get(this.buttonGroup);
        if (groupData === undefined) {
            cc.error("[ButtonSingle.onDestroy] \u6570\u636E\u5F02\u5E38 ButtonGroup: " + this.buttonGroup);
            return;
        }
        groupData.buttonSet.delete(this._button);
        this.unlock(groupData);
    };
    ButtonSingle.prototype.onTouchStart = function (event) {
        var _this = this;
        var groupData = ButtonSingle_1.groupMap.get(this.buttonGroup);
        if (groupData === undefined) {
            cc.error("[ButtonSingle.onTouchStart] \u6570\u636E\u5F02\u5E38 ButtonGroup: " + this.buttonGroup);
            return;
        }
        if (groupData.lock) {
            return;
        }
        groupData.lock = true;
        groupData.buttonSet.forEach(function (e) {
            e.enabled = (e === _this._button);
        });
    };
    ButtonSingle.prototype.onTouchEnd = function (event) {
        var groupData = ButtonSingle_1.groupMap.get(this.buttonGroup);
        if (groupData === undefined) {
            cc.error("[ButtonSingle.onTouchEnd] \u6570\u636E\u5F02\u5E38 ButtonGroup: " + this.buttonGroup);
            return;
        }
        this.unlock(groupData);
    };
    /**
     * 当前按钮松开或销毁时解除同组按钮锁定状态
     */
    ButtonSingle.prototype.unlock = function (groupData) {
        if (groupData.lock && this._button.enabled) {
            groupData.lock = false;
            groupData.buttonSet.forEach(function (e) {
                e.enabled = true;
            });
        }
    };
    var ButtonSingle_1;
    /** 记录所有绑定该组件的按钮数据 */
    ButtonSingle._groupMap = null;
    __decorate([
        property({ type: cc.Enum(ButtonGroup), tooltip: CC_DEV && "按钮分组，同组按钮同一时刻只会有一个生效" })
    ], ButtonSingle.prototype, "buttonGroup", void 0);
    ButtonSingle = ButtonSingle_1 = __decorate([
        ccclass,
        requireComponent(cc.Button),
        menu("Framework/UI组件/ButtonSingle")
    ], ButtonSingle);
    return ButtonSingle;
}(cc.Component));
exports.default = ButtonSingle;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYnV0dG9uXFxCdXR0b25TaW5nbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU0sSUFBQSxLQUFnRCxFQUFFLENBQUMsVUFBVSxFQUEzRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFZcEU7O0dBRUc7QUFDSCxJQUFLLFdBSUo7QUFKRCxXQUFLLFdBQVc7SUFDWixtREFBTyxDQUFBO0lBQ1AsaURBQU0sQ0FBQTtJQUNOLGlEQUFNLENBQUE7QUFDVixDQUFDLEVBSkksV0FBVyxLQUFYLFdBQVcsUUFJZjtBQUVEOztHQUVHO0FBSUg7SUFBMEMsZ0NBQVk7SUFBdEQ7UUFBQSxxRUFnRkM7UUE5RVUsaUJBQVcsR0FBZ0IsV0FBVyxDQUFDLE9BQU8sQ0FBQztRQVc5QyxhQUFPLEdBQWMsSUFBSSxDQUFDOztJQW1FdEMsQ0FBQztxQkFoRm9CLFlBQVk7SUFNN0Isc0JBQW1CLHdCQUFRO2FBQTNCO1lBQ0ksSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLElBQUksRUFBRTtnQkFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO2FBQzlCO1lBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQzFCLENBQUM7OztPQUFBO0lBSVMsNkJBQU0sR0FBaEI7UUFDSSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLElBQUksU0FBUyxHQUFjLGNBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2RSxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDekIsU0FBUyxHQUFHO2dCQUNSLElBQUksRUFBRSxL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Q0FBQzs7SUEzRUQscUJBQXFCO0lBQ04sc0JBQVMsR0FBZ0MsSUFBSSxDQUFDO0lBSDdEO1FBREMsUUFBUSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxzQkFBc0IsRUFBRSxDQUFDO3FEQUM5QjtJQUZyQyxZQUFZO1FBSGhDLE9BQU87UUFDUCxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyw2QkFBNkIsQ0FBQztPQUNmLFlBQVksQ0FnRmhDO0lBQUQsbUJBQUM7Q0FoRkQsQUFnRkMsQ0FoRnlDLEVBQUUsQ0FBQyxTQUFTLEdBZ0ZyRDtrQkFoRm9CLFlBQVkiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCByZXF1aXJlQ29tcG9uZW50IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOaMiemSrue7hOaVsOaNrlxyXG4gKi9cclxuaW50ZXJmYWNlIEdyb3VwRGF0YSB7XHJcbiAgICAvKiog6K+l57uE5piv5ZCm6ZSB5a6a77yM5ZCM57uE5oyJ6ZKu6KKr6Kem5pG45pe26L+b5YWl6ZSB5a6a54q25oCBICovXHJcbiAgICBsb2NrOiBib29sZWFuO1xyXG4gICAgLyoqIOWQjOe7hOaMiemSriAqL1xyXG4gICAgYnV0dG9uU2V0OiBTZXQ8Y2MuQnV0dG9uPjtcclxufVxyXG5cclxuLyoqXHJcbiAqIOaMiemSruWIhue7hFxyXG4gKi9cclxuZW51bSBCdXR0b25Hcm91cCB7XHJcbiAgICBERUZBVUxULFxyXG4gICAgR1JPVVAxLFxyXG4gICAgR1JPVVAyLFxyXG59XHJcblxyXG4vKipcclxuICog6Ziy5aSa54K56Kem5pG455qE5oyJ6ZKu77yM5ZCM57uE5oyJ6ZKu5ZCM5LiA5pe25Yi75Y+q5Lya5pyJ5LiA5Liq55Sf5pWIXHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AcmVxdWlyZUNvbXBvbmVudChjYy5CdXR0b24pXHJcbkBtZW51KFwiRnJhbWV3b3JrL1VJ57uE5Lu2L0J1dHRvblNpbmdsZVwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25TaW5nbGUgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogY2MuRW51bShCdXR0b25Hcm91cCksIHRvb2x0aXA6IENDX0RFViAmJiBcIuaMiemSruWIhue7hO+8jOWQjOe7hOaMiemSruWQjOS4gOaXtuWIu+WPquS8muacieS4gOS4queUn+aViFwiIH0pXHJcbiAgICBwdWJsaWMgYnV0dG9uR3JvdXA6IEJ1dHRvbkdyb3VwID0gQnV0dG9uR3JvdXAuREVGQVVMVDtcclxuXHJcbiAgICAvKiog6K6w5b2V5omA5pyJ57uR5a6a6K+l57uE5Lu255qE5oyJ6ZKu5pWw5o2uICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfZ3JvdXBNYXA6IE1hcDxCdXR0b25Hcm91cCwgR3JvdXBEYXRhPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgZ3JvdXBNYXAoKTogTWFwPEJ1dHRvbkdyb3VwLCBHcm91cERhdGE+IHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JvdXBNYXAgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cE1hcDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9idXR0b246IGNjLkJ1dHRvbiA9IG51bGw7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9idXR0b24gPSB0aGlzLmdldENvbXBvbmVudChjYy5CdXR0b24pO1xyXG4gICAgICAgIGxldCBncm91cERhdGE6IEdyb3VwRGF0YSA9IEJ1dHRvblNpbmdsZS5ncm91cE1hcC5nZXQodGhpcy5idXR0b25Hcm91cCk7XHJcbiAgICAgICAgaWYgKGdyb3VwRGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGdyb3VwRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGxvY2s6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uU2V0OiBuZXcgU2V0KClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQnV0dG9uU2luZ2xlLmdyb3VwTWFwLnNldCh0aGlzLmJ1dHRvbkdyb3VwLCBncm91cERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncm91cERhdGEuYnV0dG9uU2V0LmFkZCh0aGlzLl9idXR0b24pO1xyXG5cclxuICAgICAgICAvLyDnm5HlkKzop6bmkbjkuovku7ZcclxuICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsIHRoaXMub25Ub3VjaFN0YXJ0LCB0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGUub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfRU5ELCB0aGlzLm9uVG91Y2hFbmQsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMubm9kZS5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9DQU5DRUwsIHRoaXMub25Ub3VjaEVuZCwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZ3JvdXBEYXRhOiBHcm91cERhdGEgPSBCdXR0b25TaW5nbGUuZ3JvdXBNYXAuZ2V0KHRoaXMuYnV0dG9uR3JvdXApO1xyXG4gICAgICAgIGlmIChncm91cERhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW0J1dHRvblNpbmdsZS5vbkRlc3Ryb3ldIOaVsOaNruW8guW4uCBCdXR0b25Hcm91cDogJHt0aGlzLmJ1dHRvbkdyb3VwfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3VwRGF0YS5idXR0b25TZXQuZGVsZXRlKHRoaXMuX2J1dHRvbik7XHJcbiAgICAgICAgdGhpcy51bmxvY2soZ3JvdXBEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uVG91Y2hTdGFydChldmVudDogY2MuRXZlbnQuRXZlbnRUb3VjaCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBncm91cERhdGE6IEdyb3VwRGF0YSA9IEJ1dHRvblNpbmdsZS5ncm91cE1hcC5nZXQodGhpcy5idXR0b25Hcm91cCk7XHJcbiAgICAgICAgaWYgKGdyb3VwRGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbQnV0dG9uU2luZ2xlLm9uVG91Y2hTdGFydF0g5pWw5o2u5byC5bi4IEJ1dHRvbkdyb3VwOiAke3RoaXMuYnV0dG9uR3JvdXB9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChncm91cERhdGEubG9jaykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3VwRGF0YS5sb2NrID0gdHJ1ZTtcclxuICAgICAgICBncm91cERhdGEuYnV0dG9uU2V0LmZvckVhY2goKGUpID0+IHtcclxuICAgICAgICAgICAgZS5lbmFibGVkID0gKGUgPT09IHRoaXMuX2J1dHRvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvblRvdWNoRW5kKGV2ZW50OiBjYy5FdmVudC5FdmVudFRvdWNoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGdyb3VwRGF0YTogR3JvdXBEYXRhID0gQnV0dG9uU2luZ2xlLmdyb3VwTWFwLmdldCh0aGlzLmJ1dHRvbkdyb3VwKTtcclxuICAgICAgICBpZiAoZ3JvdXBEYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoYFtCdXR0b25TaW5nbGUub25Ub3VjaEVuZF0g5pWw5o2u5byC5bi4IEJ1dHRvbkdyb3VwOiAke3RoaXMuYnV0dG9uR3JvdXB9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudW5sb2NrKGdyb3VwRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvZPliY3mjInpkq7mnb7lvIDmiJbplIDmr4Hml7bop6PpmaTlkIznu4TmjInpkq7plIHlrprnirbmgIFcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1bmxvY2soZ3JvdXBEYXRhOiBHcm91cERhdGEpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZ3JvdXBEYXRhLmxvY2sgJiYgdGhpcy5fYnV0dG9uLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgZ3JvdXBEYXRhLmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ3JvdXBEYXRhLmJ1dHRvblNldC5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/i18n/I18nLabel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '102e7zRjoBIIaR3Sun9XFVJ', 'I18nLabel');
// scripts/common/cmpt/ui/i18n/I18nLabel.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EventName_1 = require("../../../const/EventName");
var Events_1 = require("../../../util/Events");
var I18n_1 = require("../../../util/I18n");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executeInEditMode = _a.executeInEditMode, menu = _a.menu;
var I18nLabel = /** @class */ (function (_super) {
    __extends(I18nLabel, _super);
    function I18nLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._textKey = "";
        /**
         * 用于正则替换的配置
         */
        _this._option = [];
        _this._label = null;
        return _this;
    }
    Object.defineProperty(I18nLabel.prototype, "textKey", {
        get: function () { return this._textKey; },
        set: function (key) {
            this._textKey = key;
            this.updateLabel();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(I18nLabel.prototype, "label", {
        get: function () {
            if (!this._label) {
                this._label = this.node.getComponent(cc.Label) || this.node.getComponent(cc.RichText);
                if (!this._label) {
                    cc.error("Failed to update localized label, label component is invalid!");
                    return null;
                }
            }
            return this._label;
        },
        enumerable: false,
        configurable: true
    });
    I18nLabel.prototype.onLoad = function () {
        try {
            I18n_1.default.init();
            this.updateLabel();
        }
        catch (err) {
            cc.error(err);
        }
    };
    I18nLabel.prototype.update = function () {
        if (CC_EDITOR) {
            if (this.label.string) {
                var key = I18n_1.default.getKeyByValue(this.label.string);
                if (key) {
                    this.textKey = key;
                }
            }
        }
    };
    /**
     * 更新语言
     */
    I18nLabel.prototype.updateLabel = function () {
        var localizedString = this._option instanceof Array ? I18n_1.default.getText.apply(I18n_1.default, __spreadArrays([this._textKey], this._option)) : I18n_1.default.getText(this._textKey, this._option);
        if (localizedString) {
            this.label.string = localizedString;
        }
    };
    /**
     * 设置语言与配置
     * @param key
     * @param option
     */
    I18nLabel.prototype.setTextKeyAndOption = function (key) {
        var option = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            option[_i - 1] = arguments[_i];
        }
        this._textKey = key;
        this.setOption.apply(this, option);
    };
    /**
     * 仅设置配置
     * @param option
     */
    I18nLabel.prototype.setOption = function () {
        var option = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            option[_i] = arguments[_i];
        }
        if (option.length === 1 && Object.prototype.toString.call(option[0]) === "[object Object]") {
            this._option = option[0];
        }
        else {
            this._option = option;
        }
        this.updateLabel();
    };
    /**
     * 清除key
     */
    I18nLabel.prototype.clear = function () {
        this.label.string = "";
        this.textKey = "";
    };
    __decorate([
        property(cc.String)
    ], I18nLabel.prototype, "_textKey", void 0);
    __decorate([
        property({ type: cc.String, tooltip: "i18n key" })
    ], I18nLabel.prototype, "textKey", null);
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.UPDATE_LOCALIZED_CMPT)
    ], I18nLabel.prototype, "updateLabel", null);
    I18nLabel = __decorate([
        ccclass,
        Events_1.eventsOnLoad(),
        executeInEditMode,
        menu("Framework/I18N/I18nLabel")
    ], I18nLabel);
    return I18nLabel;
}(cc.Component));
exports.default = I18nLabel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcaTE4blxcSTE4bkxhYmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBcUQ7QUFDckQsK0NBQWtFO0FBQ2xFLDJDQUFzQztBQUVoQyxJQUFBLEtBQWlELEVBQUUsQ0FBQyxVQUFVLEVBQTVELE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLGlCQUFpQix1QkFBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQU1yRTtJQUF1Qyw2QkFBWTtJQUFuRDtRQUFBLHFFQXdGQztRQXZGZ0MsY0FBUSxHQUFXLEVBQUUsQ0FBQztRQVNuRDs7V0FFRztRQUNLLGFBQU8sR0FBOEQsRUFBRSxDQUFDO1FBRXhFLFlBQU0sR0FBMkIsSUFBSSxDQUFDOztJQXlFbEQsQ0FBQztJQXBGRyxzQkFBVyw4QkFBTzthQUFsQixjQUErQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2FBQ3RELFVBQW1CLEdBQVc7WUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUM7WUFDcEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3ZCLENBQUM7OztPQUpxRDtJQVl0RCxzQkFBVyw0QkFBSzthQUFoQjtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNkLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDdEYsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ2QsRUFBRSxDQUFDLEtBQUssQ0FBQywrREFBK0QsQ0FBQyxDQUFDO29CQUMxRSxPQUFPLElBQUksQ0FBQztpQkFDZjth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QixTQUFTIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnROYW1lIH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0L0V2ZW50TmFtZVwiO1xyXG5pbXBvcnQgeyBldmVudHNPbkxvYWQsIHByZWxvYWRFdmVudCB9IGZyb20gXCIuLi8uLi8uLi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgSTE4biBmcm9tIFwiLi4vLi4vLi4vdXRpbC9JMThuXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBleGVjdXRlSW5FZGl0TW9kZSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbkBldmVudHNPbkxvYWQoKVxyXG5AZXhlY3V0ZUluRWRpdE1vZGVcclxuQG1lbnUoXCJGcmFtZXdvcmsvSTE4Ti9JMThuTGFiZWxcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSTE4bkxhYmVsIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eShjYy5TdHJpbmcpIHByaXZhdGUgX3RleHRLZXk6IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogY2MuU3RyaW5nLCB0b29sdGlwOiBcImkxOG4ga2V5XCIgfSlcclxuICAgIHB1YmxpYyBnZXQgdGV4dEtleSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGV4dEtleTsgfVxyXG4gICAgcHVibGljIHNldCB0ZXh0S2V5KGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dEtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlKjkuo7mraPliJnmm7/mjaLnmoTphY3nva5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfb3B0aW9uOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfSB8IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTtcclxuXHJcbiAgICBwcml2YXRlIF9sYWJlbDogY2MuTGFiZWwgfCBjYy5SaWNoVGV4dCA9IG51bGw7XHJcbiAgICBwdWJsaWMgZ2V0IGxhYmVsKCk6IGNjLkxhYmVsIHwgY2MuUmljaFRleHQge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKSB8fCB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLlJpY2hUZXh0KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2MuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIGxvY2FsaXplZCBsYWJlbCwgbGFiZWwgY29tcG9uZW50IGlzIGludmFsaWQhXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkxvYWQoKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgSTE4bi5pbml0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoQ0NfRURJVE9SKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsLnN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IEkxOG4uZ2V0S2V5QnlWYWx1ZSh0aGlzLmxhYmVsLnN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0S2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pu05paw6K+t6KiAXHJcbiAgICAgKi9cclxuICAgIEBwcmVsb2FkRXZlbnQoRXZlbnROYW1lLlVQREFURV9MT0NBTElaRURfQ01QVClcclxuICAgIHB1YmxpYyB1cGRhdGVMYWJlbCgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbG9jYWxpemVkU3RyaW5nID0gdGhpcy5fb3B0aW9uIGluc3RhbmNlb2YgQXJyYXkgPyBJMThuLmdldFRleHQodGhpcy5fdGV4dEtleSwgLi4udGhpcy5fb3B0aW9uKSA6IEkxOG4uZ2V0VGV4dCh0aGlzLl90ZXh0S2V5LCB0aGlzLl9vcHRpb24pO1xyXG4gICAgICAgIGlmIChsb2NhbGl6ZWRTdHJpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbC5zdHJpbmcgPSBsb2NhbGl6ZWRTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u6K+t6KiA5LiO6YWN572uXHJcbiAgICAgKiBAcGFyYW0ga2V5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUZXh0S2V5QW5kT3B0aW9uKGtleTogc3RyaW5nLCAuLi5vcHRpb246IFt7IFtrOiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfV0gfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fdGV4dEtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnNldE9wdGlvbiguLi5vcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5LuF6K6+572u6YWN572uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRPcHRpb24oLi4ub3B0aW9uOiBbeyBbazogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH1dIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChvcHRpb24ubGVuZ3RoID09PSAxICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRpb25bMF0pID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbiA9IG9wdGlvblswXSBhcyB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb24gPSBvcHRpb24gYXMgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF6Zmka2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxhYmVsLnN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy50ZXh0S2V5ID0gXCJcIjtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/res/ResSpine.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '14fadlt4gBHJ47mZbSl1iSm', 'ResSpine');
// scripts/common/cmpt/ui/res/ResSpine.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Res_1 = require("../../../util/Res");
var _a = cc._decorator, ccclass = _a.ccclass, menu = _a.menu, disallowMultiple = _a.disallowMultiple, requireComponent = _a.requireComponent;
/**
 * spine组件，自动管理资源的引用计数
 */
var ResSpine = /** @class */ (function (_super) {
    __extends(ResSpine, _super);
    function ResSpine() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // 动态加载的资源
        _this._asset = null;
        _this._url = "";
        _this._spine = null;
        return _this;
    }
    Object.defineProperty(ResSpine.prototype, "spine", {
        get: function () {
            if (!this._spine) {
                this._spine = this.getComponent(sp.Skeleton);
            }
            return this._spine;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResSpine.prototype, "skeletonData", {
        get: function () {
            return this.spine.skeletonData;
        },
        set: function (v) {
            var _a;
            if (!this.isValid || this.spine.skeletonData === v) {
                return;
            }
            v === null || v === void 0 ? void 0 : v.addRef();
            (_a = this._asset) === null || _a === void 0 ? void 0 : _a.decRef();
            this._asset = v;
            this.spine.skeletonData = v;
        },
        enumerable: false,
        configurable: true
    });
    ResSpine.prototype.onDestroy = function () {
        var _a;
        (_a = this._asset) === null || _a === void 0 ? void 0 : _a.decRef();
    };
    /**
     * 设置skeletonData
     * @param url 骨骼资源路径，规则同Res加载路径
     */
    ResSpine.prototype.setSkeletonData = function (url) {
        return __awaiter(this, void 0, Promise, function () {
            var result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this._url = url;
                        _a = Res_1.default.get(url, sp.SkeletonData);
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, Res_1.default.load(url, sp.SkeletonData)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        result = _a;
                        // 如短时间内多次调用，需保证显示最新一次加载的资源
                        if (result instanceof sp.SkeletonData && this._url === url) {
                            this.skeletonData = result;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ResSpine = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(sp.Skeleton),
        menu("Framework/UI组件/ResSpine")
    ], ResSpine);
    return ResSpine;
}(cc.Component));
exports.default = ResSpine;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxccmVzXFxSZXNTcGluZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBb0M7QUFFOUIsSUFBQSxLQUF3RCxFQUFFLENBQUMsVUFBVSxFQUFuRSxPQUFPLGFBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFNUU7O0dBRUc7QUFLSDtJQUFzQyw0QkFBWTtJQUFsRDtRQUFBLHFFQTJDQztRQTFDRyxVQUFVO1FBQ0YsWUFBTSxHQUFvQixJQUFJLENBQUM7UUFFL0IsVUFBSSxHQUFXLEVBQUUsQ0FBQztRQUVsQixZQUFNLEdBQWdCLElBQUksQ0FBQzs7SUFxQ3ZDLENBQUM7SUFwQ0csc0JBQVksMkJBQUs7YUFBakI7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDZCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ2hEO1lBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRUQsc0JBQVcsa0NBQVk7YUFBdkI7WUFDSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDO1FBQ25DLENBQUM7YUFDRCxVQUF3QixDQUFrQjs7WUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEtBQUssQ0FBQyxFQUFFO2dCQUNoRCxPQUFPO2FBQ1Y7WUFDRCxDQUFDLGFBQUQsQ0FBQyx1QkFBRCxDQUFDLENBQUUsTUFBTSxHQUFHO1lBQ1osTUFBQSxJQUFJLENBQUMsTUFBTSwwQ0FBRSxNQUFNLEdBQUc7WUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7OztPQVRBO0lBV1MsNEJBQVMsR0FBbkI7O1FBQ0ksTUFBQSxJQUFJLENBQUMsTUFBTSwwQ0FBRSxNQUFNLEdBQUc7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNVLGtDQUFlLEdBQTVCLFVBQTZCLEdBQVc7dUNBQUcsT0FBTzs7Ozs7d0JBQzlDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO3dCQUNILEtBQUEsYUFBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFBO2dDQUE3Qix3QkFBNkI7d0JBQUkscUJBQU0sYUFBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFBOzs4QkFBcEMsU0FBb0M7Ozt3QkFBOUUsTUFBTSxLQUF3RTt3QkFDbEYsMkJBQTJCO3dCQUMzQixJQUFJLE1BQU0sWUFBWSxFQUFFLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxFQUFFOzRCQUN4RCxJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQzt5QkFDOUI7Ozs7O0tBQ0o7SUExQ2dCLFFBQVE7UUFKNUIsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1FBQzdCLElBQUksQ0FBQyx5QkFBeUIsQ0FBQztPQUNYLFFBQVEsQ0EyQzVCO0lBQUQsZUFBQztDQTNDRCxBQTJDQyxDQTNDcUMsRUFBRSxDQUFDLFNBQVMsR0EyQ2pEO2tCQTNDb0IsUUFBUSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZXMgZnJvbSBcIi4uLy4uLy4uL3V0aWwvUmVzXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIG1lbnUsIGRpc2FsbG93TXVsdGlwbGUsIHJlcXVpcmVDb21wb25lbnQgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKipcclxuICogc3BpbmXnu4Tku7bvvIzoh6rliqjnrqHnkIbotYTmupDnmoTlvJXnlKjorqHmlbBcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkByZXF1aXJlQ29tcG9uZW50KHNwLlNrZWxldG9uKVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9SZXNTcGluZVwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNTcGluZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICAvLyDliqjmgIHliqDovb3nmoTotYTmupBcclxuICAgIHByaXZhdGUgX2Fzc2V0OiBzcC5Ta2VsZXRvbkRhdGEgPSBudWxsO1xyXG5cclxuICAgIHByaXZhdGUgX3VybDogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICBwcml2YXRlIF9zcGluZTogc3AuU2tlbGV0b24gPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBnZXQgc3BpbmUoKTogc3AuU2tlbGV0b24ge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3BpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BpbmUgPSB0aGlzLmdldENvbXBvbmVudChzcC5Ta2VsZXRvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcGluZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNrZWxldG9uRGF0YSgpOiBzcC5Ta2VsZXRvbkRhdGEge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwaW5lLnNrZWxldG9uRGF0YTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2tlbGV0b25EYXRhKHY6IHNwLlNrZWxldG9uRGF0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8IHRoaXMuc3BpbmUuc2tlbGV0b25EYXRhID09PSB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdj8uYWRkUmVmKCk7XHJcbiAgICAgICAgdGhpcy5fYXNzZXQ/LmRlY1JlZigpO1xyXG4gICAgICAgIHRoaXMuX2Fzc2V0ID0gdjtcclxuICAgICAgICB0aGlzLnNwaW5lLnNrZWxldG9uRGF0YSA9IHY7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9hc3NldD8uZGVjUmVmKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5za2VsZXRvbkRhdGFcclxuICAgICAqIEBwYXJhbSB1cmwg6aqo6aq86LWE5rqQ6Lev5b6E77yM6KeE5YiZ5ZCMUmVz5Yqg6L296Lev5b6EXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzZXRTa2VsZXRvbkRhdGEodXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJlcy5nZXQodXJsLCBzcC5Ta2VsZXRvbkRhdGEpIHx8IGF3YWl0IFJlcy5sb2FkKHVybCwgc3AuU2tlbGV0b25EYXRhKTtcclxuICAgICAgICAvLyDlpoLnn63ml7bpl7TlhoXlpJrmrKHosIPnlKjvvIzpnIDkv53or4HmmL7npLrmnIDmlrDkuIDmrKHliqDovb3nmoTotYTmupBcclxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2Ygc3AuU2tlbGV0b25EYXRhICYmIHRoaXMuX3VybCA9PT0gdXJsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2tlbGV0b25EYXRhID0gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/scrollList/CircleList.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b16a3Aay4tOsrajlZkk+6I1', 'CircleList');
// scripts/common/cmpt/ui/scrollList/CircleList.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tool_1 = require("../../../util/Tool");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executeInEditMode = _a.executeInEditMode, menu = _a.menu;
/** 初始角度 */
var INIT_DEGREE = 270;
/**
 * 环形列表，将节点以椭圆排列
 */
var CircleList = /** @class */ (function (_super) {
    __extends(CircleList, _super);
    function CircleList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.content = null;
        _this.ellipseAxes = cc.v2(0, 0);
        _this.scrollSpeed = 200;
        _this._init = false;
        _this._curDegree = INIT_DEGREE;
        _this._targetDegree = INIT_DEGREE;
        _this._scrolling = false;
        _this._itemDegreeMap = new Map();
        _this._maxDelta = 0;
        /** 子节点被选中时的回调 */
        _this._selectCall = null;
        return _this;
    }
    Object.defineProperty(CircleList.prototype, "curDegree", {
        /** 虚拟角度，子节点会根据角度计算坐标 */
        get: function () { return this._curDegree; },
        set: function (v) {
            this._curDegree = Tool_1.default.normalizeDegree(v);
            this.refreshItems();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化列表，按角度均匀排列content所有子节点
     * @param selectCall
     */
    CircleList.prototype.init = function (selectCall) {
        var _this = this;
        if (selectCall === void 0) { selectCall = null; }
        this._init = true;
        this._scrolling = false;
        this._maxDelta = 0;
        this._itemDegreeMap.clear();
        this._selectCall = selectCall;
        if (this.content.childrenCount <= 0) {
            return;
        }
        var average = 360 / this.content.childrenCount;
        this.content.children.forEach(function (v, i) {
            _this._itemDegreeMap.set(v, i * average);
            v.on(cc.Node.EventType.TOUCH_MOVE, _this.itemTouchMove, _this);
            v.on(cc.Node.EventType.TOUCH_END, _this.itemTouchEnd, _this);
            v.on(cc.Node.EventType.TOUCH_CANCEL, _this.itemTouchEnd, _this);
        });
        this.refreshItems();
    };
    /**
     * 滚动到指定子节点处
     * @param item 子节点
     */
    CircleList.prototype.scrollToItem = function (item) {
        var _a;
        if (!this._itemDegreeMap.has(item)) {
            return;
        }
        var itemDegree = this._itemDegreeMap.get(item);
        var delta = INIT_DEGREE - itemDegree;
        this._targetDegree = Tool_1.default.normalizeDegree(delta);
        this._scrolling = true;
        (_a = this._selectCall) === null || _a === void 0 ? void 0 : _a.call(this, item);
    };
    CircleList.prototype.refreshItems = function () {
        var _this = this;
        this.content.children.forEach(function (v, i) {
            var degree = Tool_1.default.normalizeDegree(_this._itemDegreeMap.get(v) + _this.curDegree);
            var pos = Tool_1.default.getEllipsePoint(_this.ellipseAxes.x, _this.ellipseAxes.y, degree);
            v.setPosition(pos);
            v.zIndex = -v.y;
        });
    };
    CircleList.prototype.update = function (dt) {
        if (!this._init || !this._scrolling || this.curDegree === this._targetDegree) {
            return;
        }
        var delta = Math.abs(this._targetDegree - this.curDegree);
        var degree = this.curDegree;
        var sign = (delta < 180 ? 1 : -1) * Math.sign(this._targetDegree - this.curDegree);
        degree += dt * this.scrollSpeed * sign;
        if ((this.curDegree > this._targetDegree && degree < this._targetDegree) || (this.curDegree < this._targetDegree && degree > this._targetDegree)) {
            degree = this._targetDegree;
            this._scrolling = false;
        }
        this.curDegree = degree;
    };
    CircleList.prototype.itemTouchMove = function (event) {
        var delta = event.getDeltaX();
        if (Math.abs(delta) < 1) {
            return;
        }
        if (this._maxDelta < Math.abs(delta)) {
            this._maxDelta = Math.abs(delta);
        }
        this.curDegree = this.curDegree + delta / 5;
    };
    CircleList.prototype.itemTouchEnd = function (event) {
        var node = event.target;
        if (this._maxDelta < 5) {
            this._maxDelta = 0;
            this.scrollToItem(node);
            return;
        }
        var minDelta = 360;
        var minNode = this.content.children[0];
        for (var i = 0; i < this.content.children.length; i++) {
            var item = this.content.children[i];
            var itemDegree = Tool_1.default.normalizeDegree(this._itemDegreeMap.get(item) + this.curDegree);
            var delta = Math.abs(INIT_DEGREE - itemDegree);
            if (delta > 180) {
                delta = itemDegree + 360 - INIT_DEGREE;
            }
            if (delta < minDelta) {
                minDelta = delta;
                minNode = item;
            }
        }
        this._maxDelta = 0;
        this.scrollToItem(minNode);
    };
    __decorate([
        property(cc.Node)
    ], CircleList.prototype, "content", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "椭圆长短轴" })
    ], CircleList.prototype, "ellipseAxes", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "列表自动滚动的速度" })
    ], CircleList.prototype, "scrollSpeed", void 0);
    CircleList = __decorate([
        ccclass,
        executeInEditMode,
        menu("Framework/UI组件/CircleList")
    ], CircleList);
    return CircleList;
}(cc.Component));
exports.default = CircleList;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcc2Nyb2xsTGlzdFxcQ2lyY2xlTGlzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBc0M7QUFFaEMsSUFBQSxLQUFpRCxFQUFFLENBQUMsVUFBVSxFQUE1RCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxpQkFBaUIsdUJBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFFckUsV0FBVztBQUNYLElBQU0sV0FBVyxHQUFXLEdBQUcsQ0FBQztBQUVoQzs7R0FFRztBQUlIO0lBQXdDLDhCQUFZO0lBQXBEO1FBQUEscUVBK0hDO1FBN0hXLGFBQU8sR0FBWSxJQUFJLENBQUM7UUFFeEIsaUJBQVcsR0FBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVuQyxpQkFBVyxHQUFXLEdBQUcsQ0FBQztRQUUxQixXQUFLLEdBQVksS0FBSyxDQUFDO1FBQ3ZCLGdCQUFVLEdBQVcsV0FBVyxDQUFDO1FBQ2pDLG1CQUFhLEdBQVcsV0FBVyxDQUFDO1FBQ3BDLGdCQUFVLEdBQVksS0FBSyxDQUFDO1FBQzVCLG9CQUFjLEdBQXlCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDakQsZUFBUyxHQUFXLENBQUMsQ0FBQztRQUM5QixpQkFBaUI7UUFDVCxpQkFBVyxHQUE0QixJQUFJLENBQUM7O0lBZ0h4RCxDQUFDO0lBN0dHLHNCQUFXLGlDQUFTO1FBRHBCLHdCQUF3QjthQUN4QixjQUFpQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQzFELFVBQXFCLENBQVM7WUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxjQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixDQUFDOzs7T0FKeUQ7SUFNMUQ7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QVEsRUFBRTtnQkFDbEIsUUFBUSxHQUFHLEtBQUssQ0FBQztnQkFDakIsT0FBTyxHQUFHLElBQUksQ0FBQzthQUNsQjtTQUNKO1FBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBNUhEO1FBREMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7K0NBQ2M7SUFFaEM7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE9BQU8sRUFBRSxDQUFDO21EQUNFO0lBRTNDO1FBREMsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxXQUFXLEVBQUUsQ0FBQzttREFDWDtJQU5qQixVQUFVO1FBSDlCLE9BQU87UUFDUCxpQkFBaUI7UUFDakIsSUFBSSxDQUFDLDJCQUEyQixDQUFDO09BQ2IsVUFBVSxDQStIOUI7SUFBRCxpQkFBQztDQS9IRCxBQStIQyxDQS9IdUMsRUFBRSxDQUFDLFNBQVMsR0ErSG5EO2tCQS9Ib0IsVUFBVSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUb29sIGZyb20gXCIuLi8uLi8uLi91dGlsL1Rvb2xcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIGV4ZWN1dGVJbkVkaXRNb2RlLCBtZW51IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqIOWIneWni+inkuW6piAqL1xyXG5jb25zdCBJTklUX0RFR1JFRTogbnVtYmVyID0gMjcwO1xyXG5cclxuLyoqXHJcbiAqIOeOr+W9ouWIl+ihqO+8jOWwhuiKgueCueS7peakreWchuaOkuWIl1xyXG4gKi9cclxuQGNjY2xhc3NcclxuQGV4ZWN1dGVJbkVkaXRNb2RlXHJcbkBtZW51KFwiRnJhbWV3b3JrL1VJ57uE5Lu2L0NpcmNsZUxpc3RcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlTGlzdCBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBAcHJvcGVydHkoY2MuTm9kZSlcclxuICAgIHByaXZhdGUgY29udGVudDogY2MuTm9kZSA9IG51bGw7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmpK3lnIbplb/nn63ovbRcIiB9KVxyXG4gICAgcHJpdmF0ZSBlbGxpcHNlQXhlczogY2MuVmVjMiA9IGNjLnYyKDAsIDApO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5YiX6KGo6Ieq5Yqo5rua5Yqo55qE6YCf5bqmXCIgfSlcclxuICAgIHByaXZhdGUgc2Nyb2xsU3BlZWQ6IG51bWJlciA9IDIwMDtcclxuXHJcbiAgICBwcml2YXRlIF9pbml0OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9jdXJEZWdyZWU6IG51bWJlciA9IElOSVRfREVHUkVFO1xyXG4gICAgcHJpdmF0ZSBfdGFyZ2V0RGVncmVlOiBudW1iZXIgPSBJTklUX0RFR1JFRTtcclxuICAgIHByaXZhdGUgX3Njcm9sbGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfaXRlbURlZ3JlZU1hcDogTWFwPGNjLk5vZGUsIG51bWJlcj4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIF9tYXhEZWx0YTogbnVtYmVyID0gMDtcclxuICAgIC8qKiDlrZDoioLngrnooqvpgInkuK3ml7bnmoTlm57osIMgKi9cclxuICAgIHByaXZhdGUgX3NlbGVjdENhbGw6IChpdGVtOiBjYy5Ob2RlKSA9PiB2b2lkID0gbnVsbDtcclxuXHJcbiAgICAvKiog6Jma5ouf6KeS5bqm77yM5a2Q6IqC54K55Lya5qC55o2u6KeS5bqm6K6h566X5Z2Q5qCHICovXHJcbiAgICBwdWJsaWMgZ2V0IGN1ckRlZ3JlZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fY3VyRGVncmVlOyB9XHJcbiAgICBwdWJsaWMgc2V0IGN1ckRlZ3JlZSh2OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9jdXJEZWdyZWUgPSBUb29sLm5vcm1hbGl6ZURlZ3JlZSh2KTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hJdGVtcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW5YiX6KGo77yM5oyJ6KeS5bqm5Z2H5YyA5o6S5YiXY29udGVudOaJgOacieWtkOiKgueCuVxyXG4gICAgICogQHBhcmFtIHNlbGVjdENhbGwgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0KHNlbGVjdENhbGw6IChpdGVtOiBjYy5Ob2RlKSA9PiB2b2lkID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX21heERlbHRhID0gMDtcclxuICAgICAgICB0aGlzLl9pdGVtRGVncmVlTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0Q2FsbCA9IHNlbGVjdENhbGw7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5jaGlsZHJlbkNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYXZlcmFnZTogbnVtYmVyID0gMzYwIC8gdGhpcy5jb250ZW50LmNoaWxkcmVuQ291bnQ7XHJcbiAgICAgICAgdGhpcy5jb250ZW50LmNoaWxkcmVuLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faXRlbURlZ3JlZU1hcC5zZXQodiwgaSAqIGF2ZXJhZ2UpO1xyXG5cclxuICAgICAgICAgICAgdi5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9NT1ZFLCB0aGlzLml0ZW1Ub3VjaE1vdmUsIHRoaXMpO1xyXG4gICAgICAgICAgICB2Lm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0VORCwgdGhpcy5pdGVtVG91Y2hFbmQsIHRoaXMpO1xyXG4gICAgICAgICAgICB2Lm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0NBTkNFTCwgdGhpcy5pdGVtVG91Y2hFbmQsIHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEl0ZW1zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmu5rliqjliLDmjIflrprlrZDoioLngrnlpIRcclxuICAgICAqIEBwYXJhbSBpdGVtIOWtkOiKgueCuVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2Nyb2xsVG9JdGVtKGl0ZW06IGNjLk5vZGUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2l0ZW1EZWdyZWVNYXAuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpdGVtRGVncmVlID0gdGhpcy5faXRlbURlZ3JlZU1hcC5nZXQoaXRlbSk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gSU5JVF9ERUdSRUUgLSBpdGVtRGVncmVlO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldERlZ3JlZSA9IFRvb2wubm9ybWFsaXplRGVncmVlKGRlbHRhKTtcclxuICAgICAgICB0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdENhbGw/LihpdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlZnJlc2hJdGVtcygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnQuY2hpbGRyZW4uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGVncmVlID0gVG9vbC5ub3JtYWxpemVEZWdyZWUodGhpcy5faXRlbURlZ3JlZU1hcC5nZXQodikgKyB0aGlzLmN1ckRlZ3JlZSk7XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSBUb29sLmdldEVsbGlwc2VQb2ludCh0aGlzLmVsbGlwc2VBeGVzLngsIHRoaXMuZWxsaXBzZUF4ZXMueSwgZGVncmVlKTtcclxuICAgICAgICAgICAgdi5zZXRQb3NpdGlvbihwb3MpO1xyXG4gICAgICAgICAgICB2LnpJbmRleCA9IC12Lnk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZShkdDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0IHx8ICF0aGlzLl9zY3JvbGxpbmcgfHwgdGhpcy5jdXJEZWdyZWUgPT09IHRoaXMuX3RhcmdldERlZ3JlZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyh0aGlzLl90YXJnZXREZWdyZWUgLSB0aGlzLmN1ckRlZ3JlZSk7XHJcbiAgICAgICAgbGV0IGRlZ3JlZSA9IHRoaXMuY3VyRGVncmVlO1xyXG4gICAgICAgIGxldCBzaWduID0gKGRlbHRhIDwgMTgwID8gMSA6IC0xKSAqIE1hdGguc2lnbih0aGlzLl90YXJnZXREZWdyZWUgLSB0aGlzLmN1ckRlZ3JlZSk7XHJcbiAgICAgICAgZGVncmVlICs9IGR0ICogdGhpcy5zY3JvbGxTcGVlZCAqIHNpZ247XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5jdXJEZWdyZWUgPiB0aGlzLl90YXJnZXREZWdyZWUgJiYgZGVncmVlIDwgdGhpcy5fdGFyZ2V0RGVncmVlKSB8fCAodGhpcy5jdXJEZWdyZWUgPCB0aGlzLl90YXJnZXREZWdyZWUgJiYgZGVncmVlID4gdGhpcy5fdGFyZ2V0RGVncmVlKSkge1xyXG4gICAgICAgICAgICBkZWdyZWUgPSB0aGlzLl90YXJnZXREZWdyZWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1ckRlZ3JlZSA9IGRlZ3JlZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGl0ZW1Ub3VjaE1vdmUoZXZlbnQ6IGNjLkV2ZW50LkV2ZW50VG91Y2gpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVsdGEgPSBldmVudC5nZXREZWx0YVgoKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fbWF4RGVsdGEgPCBNYXRoLmFicyhkZWx0YSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF4RGVsdGEgPSBNYXRoLmFicyhkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VyRGVncmVlID0gdGhpcy5jdXJEZWdyZWUgKyBkZWx0YSAvIDU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpdGVtVG91Y2hFbmQoZXZlbnQ6IGNjLkV2ZW50LkV2ZW50VG91Y2gpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICBpZiAodGhpcy5fbWF4RGVsdGEgPCA1KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21heERlbHRhID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0l0ZW0obm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtaW5EZWx0YSA9IDM2MDtcclxuICAgICAgICBsZXQgbWluTm9kZSA9IHRoaXMuY29udGVudC5jaGlsZHJlblswXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jb250ZW50LmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBsZXQgaXRlbURlZ3JlZSA9IFRvb2wubm9ybWFsaXplRGVncmVlKHRoaXMuX2l0ZW1EZWdyZWVNYXAuZ2V0KGl0ZW0pICsgdGhpcy5jdXJEZWdyZWUpO1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLmFicyhJTklUX0RFR1JFRSAtIGl0ZW1EZWdyZWUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxODApIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gaXRlbURlZ3JlZSArIDM2MCAtIElOSVRfREVHUkVFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IG1pbkRlbHRhKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5EZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgbWluTm9kZSA9IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWF4RGVsdGEgPSAwO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JdGVtKG1pbk5vZGUpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/const/EventName.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '52bf65jN2xMY6Ig2aroKkQw', 'EventName');
// scripts/common/const/EventName.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventName = void 0;
/**
 * 事件名
 */
var EventName;
(function (EventName) {
    /** cc.view 调整视窗尺寸的事件，仅在 Web 平台下有效 */
    EventName[EventName["RESIZE"] = 0] = "RESIZE";
    /** 更新多语言组件 */
    EventName[EventName["UPDATE_LOCALIZED_CMPT"] = 1] = "UPDATE_LOCALIZED_CMPT";
    /** 游戏暂停 */
    EventName[EventName["GAME_PAUSE"] = 2] = "GAME_PAUSE";
    /** 游戏恢复 */
    EventName[EventName["GAME_RESUME"] = 3] = "GAME_RESUME";
    /** 游戏时间缩放值修改 */
    EventName[EventName["TIME_SCALE"] = 4] = "TIME_SCALE";
    /** 相机移动 */
    EventName[EventName["CAMERA_MOVE"] = 5] = "CAMERA_MOVE";
    EventName[EventName["EVENT_TEST1"] = 6] = "EVENT_TEST1";
    EventName[EventName["EVENT_TEST2"] = 7] = "EVENT_TEST2";
    /************************************ */
    EventName[EventName["UPDATE_COIN"] = 8] = "UPDATE_COIN";
    EventName[EventName["ADD_COIN"] = 9] = "ADD_COIN";
    EventName[EventName["REDUCE_COIN"] = 10] = "REDUCE_COIN";
    EventName[EventName["JUDG_RESULT"] = 11] = "JUDG_RESULT";
    EventName[EventName["EXCUTE_GUIDE_TASK"] = 12] = "EXCUTE_GUIDE_TASK";
})(EventName = exports.EventName || (exports.EventName = {}));
;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjb25zdFxcRXZlbnROYW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsSUFBWSxTQTZCWDtBQTdCRCxXQUFZLFNBQVM7SUFDcEIscUNBQXFDO0lBQ3JDLDZDQUFNLENBQUE7SUFDTixjQUFjO0lBQ2QsMkVBQXFCLENBQUE7SUFFckIsV0FBVztJQUNYLHFEQUFVLENBQUE7SUFDVixXQUFXO0lBQ1gsdURBQVcsQ0FBQTtJQUNYLGdCQUFnQjtJQUNoQixxREFBVSxDQUFBO0lBRVYsV0FBVztJQUNYLHVEQUFXLENBQUE7SUFFWCx1REFBVyxDQUFBO0lBQ1gsdURBQVcsQ0FBQTtJQUVYLHdDQUF3QztJQUV4Qyx1REFBVyxDQUFBO0lBQ1gsaURBQVEsQ0FBQTtJQUNSLHdEQUFXLENBQUE7SUFFWCx3REFBVyxDQUFBO0lBRVgsb0VBQWlCLENBQUE7QUFFbEIsQ0FBQyxFQTdCVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQTZCcEI7QUFBQSxDQUFDIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIOS6i+S7tuWQjVxyXG4gKi9cclxuZXhwb3J0IGVudW0gRXZlbnROYW1lIHtcclxuXHQvKiogY2MudmlldyDosIPmlbTop4bnqpflsLrlr7jnmoTkuovku7bvvIzku4XlnKggV2ViIOW5s+WPsOS4i+acieaViCAqL1xyXG5cdFJFU0laRSxcclxuXHQvKiog5pu05paw5aSa6K+t6KiA57uE5Lu2ICovXHJcblx0VVBEQVRFX0xPQ0FMSVpFRF9DTVBULFxyXG5cclxuXHQvKiog5ri45oiP5pqC5YGcICovXHJcblx0R0FNRV9QQVVTRSxcclxuXHQvKiog5ri45oiP5oGi5aSNICovXHJcblx0R0FNRV9SRVNVTUUsXHJcblx0LyoqIOa4uOaIj+aXtumXtOe8qeaUvuWAvOS/ruaUuSAqL1xyXG5cdFRJTUVfU0NBTEUsXHJcblxyXG5cdC8qKiDnm7jmnLrnp7vliqggKi9cclxuXHRDQU1FUkFfTU9WRSxcclxuXHJcblx0RVZFTlRfVEVTVDEsXHJcblx0RVZFTlRfVEVTVDIsXHJcblxyXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcblx0VVBEQVRFX0NPSU4sXHJcblx0QUREX0NPSU4sXHJcblx0UkVEVUNFX0NPSU4sXHJcblxyXG5cdEpVREdfUkVTVUxULFxyXG5cclxuXHRFWENVVEVfR1VJREVfVEFTS1xyXG5cclxufTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/config/Zh.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '5cb62aDaJtA4pHlrSAKjTY2', 'Zh');
// scripts/common/config/Zh.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    lang: "中文",
    text1: "数字：%{num}",
    text2: "参数1: %{arg1}, 参数2: %{arg2}"
};

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjb25maWdcXFpoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0JBQWU7SUFDWCxJQUFJLEVBQUUsSUFBSTtJQUNWLEtBQUssRUFBRSxXQUFXO0lBQ2xCLEtBQUssRUFBRSw0QkFBNEI7Q0FDdEMsQ0FBQyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGxhbmc6IFwi5Lit5paHXCIsXHJcbiAgICB0ZXh0MTogXCLmlbDlrZfvvJole251bX1cIixcclxuICAgIHRleHQyOiBcIuWPguaVsDE6ICV7YXJnMX0sIOWPguaVsDI6ICV7YXJnMn1cIlxyXG59O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/hack/ButtonHack.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2aaa36JkjVLWItbzIIr6kKk', 'ButtonHack');
// scripts/common/hack/ButtonHack.ts

"use strict";
// 基于CocosCreator2.x 按钮组件hack代码
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonState = exports.ButtonHackEvent = void 0;
var ButtonHackEvent;
(function (ButtonHackEvent) {
    /** 按钮状态变更 */
    ButtonHackEvent["STATE_CHANGE"] = "ButtonHackEvent-STATE_CHANGE";
})(ButtonHackEvent = exports.ButtonHackEvent || (exports.ButtonHackEvent = {}));
var ButtonState;
(function (ButtonState) {
    ButtonState[ButtonState["NORMAL"] = 0] = "NORMAL";
    ButtonState[ButtonState["HOVER"] = 1] = "HOVER";
    ButtonState[ButtonState["PRESSED"] = 2] = "PRESSED";
    ButtonState[ButtonState["DISABLED"] = 3] = "DISABLED";
})(ButtonState = exports.ButtonState || (exports.ButtonState = {}));
// @ts-ignore
cc.Button.prototype._applyTransition = function (state) {
    var transition = this.transition;
    if (transition === cc.Button.Transition.COLOR) {
        this._updateColorTransition(state);
    }
    else if (transition === cc.Button.Transition.SPRITE) {
        this._updateSpriteTransition(state);
    }
    else if (transition === cc.Button.Transition.SCALE) {
        this._updateScaleTransition(state);
    }
    // 状态变更通知
    this.node.emit(ButtonHackEvent.STATE_CHANGE, state);
};

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxoYWNrXFxCdXR0b25IYWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7OztBQUUvQixJQUFZLGVBR1g7QUFIRCxXQUFZLGVBQWU7SUFDdkIsYUFBYTtJQUNiLGdFQUE2QyxDQUFBO0FBQ2pELENBQUMsRUFIVyxlQUFlLEdBQWYsdUJBQWUsS0FBZix1QkFBZSxRQUcxQjtBQUVELElBQVksV0FLWDtBQUxELFdBQVksV0FBVztJQUNuQixpREFBVSxDQUFBO0lBQ1YsK0NBQVMsQ0FBQTtJQUNULG1EQUFXLENBQUE7SUFDWCxxREFBWSxDQUFBO0FBQ2hCLENBQUMsRUFMVyxXQUFXLEdBQVgsbUJBQVcsS0FBWCxtQkFBVyxRQUt0QjtBQUVELGFBQWE7QUFDYixFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLEtBQVU7SUFDdkQsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUNqQyxJQUFJLFVBQVUsS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUU7UUFDM0MsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RDO1NBQU0sSUFBSSxVQUFVLEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO1FBQ25ELElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN2QztTQUFNLElBQUksVUFBVSxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRTtRQUNsRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDdEM7SUFFRCxTQUFTO0lBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztBQUN4RCxDQUFDLENBQUMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyIvLyDln7rkuo5Db2Nvc0NyZWF0b3IyLngg5oyJ6ZKu57uE5Lu2aGFja+S7o+eggVxyXG5cclxuZXhwb3J0IGVudW0gQnV0dG9uSGFja0V2ZW50IHtcclxuICAgIC8qKiDmjInpkq7nirbmgIHlj5jmm7QgKi9cclxuICAgIFNUQVRFX0NIQU5HRSA9IFwiQnV0dG9uSGFja0V2ZW50LVNUQVRFX0NIQU5HRVwiLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBCdXR0b25TdGF0ZSB7XHJcbiAgICBOT1JNQUwgPSAwLFxyXG4gICAgSE9WRVIgPSAxLFxyXG4gICAgUFJFU1NFRCA9IDIsXHJcbiAgICBESVNBQkxFRCA9IDMsXHJcbn1cclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuY2MuQnV0dG9uLnByb3RvdHlwZS5fYXBwbHlUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHtcclxuICAgIGxldCB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uO1xyXG4gICAgaWYgKHRyYW5zaXRpb24gPT09IGNjLkJ1dHRvbi5UcmFuc2l0aW9uLkNPTE9SKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3JUcmFuc2l0aW9uKHN0YXRlKTtcclxuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiA9PT0gY2MuQnV0dG9uLlRyYW5zaXRpb24uU1BSSVRFKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3ByaXRlVHJhbnNpdGlvbihzdGF0ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24gPT09IGNjLkJ1dHRvbi5UcmFuc2l0aW9uLlNDQUxFKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU2NhbGVUcmFuc2l0aW9uKHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDnirbmgIHlj5jmm7TpgJrnn6VcclxuICAgIHRoaXMubm9kZS5lbWl0KEJ1dHRvbkhhY2tFdmVudC5TVEFURV9DSEFOR0UsIHN0YXRlKTtcclxufTtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/runtime/UserInfo.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '23830xhEjVNzolJ3MKnKaIw', 'UserInfo');
// scripts/common/runtime/UserInfo.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserInfoStorge = void 0;
var Singleton_1 = require("../cmpt/base/Singleton");
// 属性装饰器：用于添加get和set方法
function GetSet(target, propertyKey) {
    Object.defineProperty(target, propertyKey, {
        configurable: true,
        enumerable: true,
        get: function () {
            return this["_" + propertyKey];
        },
        set: function (value) {
            this["_" + propertyKey] = value;
        },
    });
}
/**用户数据类 */
var UserInfo = /** @class */ (function (_super) {
    __extends(UserInfo, _super);
    function UserInfo() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._userName = ""; //用户名称
        _this._coin = 0; //金币
        _this._levelProgress = 1;
        _this._signInDays = 0;
        _this._lastSignInDate = null;
        _this._propConfig = [];
        _this._roleConfig = [];
        return _this;
    }
    Object.defineProperty(UserInfo, "instance", {
        get: function () {
            return _super.getInstance.call(this);
        },
        enumerable: false,
        configurable: true
    });
    /**初始化初始数据内容结构 */
    UserInfo.prototype.initUserInfo = function () {
        this.userName = "Ar";
        this.coin = 1000;
        this.levelProgress = 1;
        this.signInDays = 0;
        this.lastSignInDate = null;
        this.propConfig = [1, 1, 1, 1];
        this.roleConfig = [1107, 150, 580, 220];
    };
    /**设置用户数据 */
    UserInfo.prototype.setUserInfo = function (data) {
        if (!data)
            return;
        Object.assign(this, data);
    };
    /**获取用户数据 */
    UserInfo.prototype.getUserInfo = function () {
        var data = {
            userName: this.userName,
            coin: this.coin,
            levelProgress: this.levelProgress,
            signInDays: this.signInDays,
        };
        return data;
    };
    __decorate([
        GetSet
    ], UserInfo.prototype, "userName", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "coin", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "levelProgress", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "signInDays", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "lastSignInDate", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "propConfig", void 0);
    __decorate([
        GetSet
    ], UserInfo.prototype, "roleConfig", void 0);
    return UserInfo;
}(Singleton_1.default));
exports.default = UserInfo;
/**用户数据本地存储 */
var UserInfoStorge = /** @class */ (function () {
    function UserInfoStorge() {
    }
    /**储存数据 */
    UserInfoStorge.setUserInfo = function (value, key) {
        if (value === void 0) { value = UserInfo.instance.getUserInfo(); }
        if (key === void 0) { key = this.key; }
        cc.sys.localStorage.setItem(key, JSON.stringify(value));
    };
    /**获取数据 */
    UserInfoStorge.getUserInfo = function (key) {
        if (key === void 0) { key = this.key; }
        return JSON.parse(cc.sys.localStorage.getItem(key));
    };
    /**清除用户的本地数据 */
    UserInfoStorge.clearUserInfo = function (key) {
        if (key === void 0) { key = this.key; }
        cc.sys.localStorage.removeItem(key);
    };
    /**新增用户数据 -- value只包含新增的内容 */
    UserInfoStorge.addUserInfo = function (value, key) {
        if (key === void 0) { key = this.key; }
        var userInfo = this.getUserInfo(key);
        if (userInfo) {
            var addUserInfo = __assign(__assign({}, userInfo), value);
            this.setUserInfo(addUserInfo, key);
        }
    };
    /**是否存在本地数据 */
    UserInfoStorge.hasUserInfo = function (key) {
        if (key === void 0) { key = this.key; }
        return cc.sys.localStorage.getItem(key) !== null;
    };
    /**删除指定的本地数据 */
    UserInfoStorge.removeUserInfo = function (key) {
        cc.sys.localStorage.removeItem(key);
    };
    /**获取所有本地数据 */
    UserInfoStorge.getAllUserInfo = function () {
        var userInfo = [];
        for (var i = 0; i < cc.sys.localStorage.length; i++) {
            var key = cc.sys.localStorage.key(i);
            if (key.startsWith(this.key)) {
                var value = JSON.parse(cc.sys.localStorage.getItem(key));
                userInfo.push(value);
            }
        }
        return userInfo;
    };
    /**本地数据key */
    UserInfoStorge.key = "userInfo";
    return UserInfoStorge;
}());
exports.UserInfoStorge = UserInfoStorge;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxydW50aW1lXFxVc2VySW5mby50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBOEM7QUFFOUMsc0JBQXNCO0FBQ3RCLFNBQVMsTUFBTSxDQUFDLE1BQVcsRUFBRSxXQUFtQjtJQUM1QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxXQUFXLEVBQUU7UUFDdkMsWUFBWSxFQUFFLElBQUk7UUFDbEIsVUFBVSxFQUFFLElBQUk7UUFDaEIsR0FBRyxFQUFFO1lBQ0QsT0FBTyxJQUFJLENBQUMsTUFBSSxXQUFhLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBQ0QsR0FBRyxFQUFFLFVBQVUsS0FBVTtZQUNyQixJQUFJLENBQUMsTUFBSSxXQUFhLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDcEMsQ0FBQztLQUNKLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRCxXQUFXO0FBQ1g7SUFBc0MsNEJBQVM7SUFBL0M7UUFBQSxxRUFzREM7UUFqRFcsZUFBUyxHQUFXLEVBQUUsQ0FBQSxDQUFDLE1BQU07UUFHN0IsV0FBSyxHQUFXLENBQUMsQ0FBQSxDQUFDLElBQUk7UUFHdEIsb0JBQWMsR0FBVyxDQUFDLENBQUE7UUFHMUIsaUJBQVcsR0FBVyxDQUFDLENBQUE7UUFHdkIscUJBQWUsR0FBUSxJQUFJLENBQUE7UUFHM0IsaUJBQVcsR0FBYSxFQUFFLENBQUE7UUFHMUIsaUJBQVcsR0FBYSxFQUFFLENBQUE7O0lBK0J0QyxDQUFDO0lBckRHLHNCQUFXLG9CQUFRO2FBQW5CO1lBQ0ksT0FBTyxPQUFNLFdBQVcsV0FBWSxDQUFBO1FBQ3hDLENBQUM7OztPQUFBO0lBd0JELGlCQUFpQjtJQUNWLCtCQUFZLEdBQW5CO1FBQ0ksSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUE7UUFDcEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJ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Q0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUE7SUFDcEQsQ0FBQztJQUVELGVBQWU7SUFDRCw2QkFBYyxHQUE1QixVQUE2QixHQUFXO1FBQ3BDLEVBQUUsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUN2QyxDQUFDO0lBRUQsY0FBYztJQUNBLDZCQUFjLEdBQTVCO1FBQ0ksSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFBO1FBQ25CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDakQsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3RDLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzFCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7Z0JBQzFELFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDdkI7U0FDSjtRQUNELE9BQU8sUUFBUSxDQUFBO0lBQ25CLENBQUM7SUFoREQsYUFBYTtJQUNFLGtCQUFHLEdBQVcsVUFBVSxDQUFBO0lBaUQzQyxxQkFBQztDQW5ERCxBQW1EQyxJQUFBO0FBbkRZLHdDQUFjIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNpbmdsZXRvbiBmcm9tIFwiLi4vY21wdC9iYXNlL1NpbmdsZXRvblwiXG5cbi8vIOWxnuaAp+ijhemlsOWZqO+8mueUqOS6jua3u+WKoGdldOWSjHNldOaWueazlVxuZnVuY3Rpb24gR2V0U2V0KHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2BfJHtwcm9wZXJ0eUtleX1gXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWU6IGFueSkge1xuICAgICAgICAgICAgdGhpc1tgXyR7cHJvcGVydHlLZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoq55So5oi35pWw5o2u57G7ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2VySW5mbyBleHRlbmRzIFNpbmdsZXRvbiB7XG4gICAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldEluc3RhbmNlPFVzZXJJbmZvPigpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdXNlck5hbWU6IHN0cmluZyA9IFwiXCIgLy/nlKjmiLflkI3np7BcbiAgICBAR2V0U2V0IHVzZXJOYW1lOiBzdHJpbmdcblxuICAgIHByaXZhdGUgX2NvaW46IG51bWJlciA9IDAgLy/ph5HluIFcbiAgICBAR2V0U2V0IGNvaW46IG51bWJlclxuXG4gICAgcHJpdmF0ZSBfbGV2ZWxQcm9ncmVzczogbnVtYmVyID0gMVxuICAgIEBHZXRTZXQgbGV2ZWxQcm9ncmVzczogbnVtYmVyXG5cbiAgICBwcml2YXRlIF9zaWduSW5EYXlzOiBudW1iZXIgPSAwXG4gICAgQEdldFNldCBzaWduSW5EYXlzOiBudW1iZXJcblxuICAgIHByaXZhdGUgX2xhc3RTaWduSW5EYXRlOiBhbnkgPSBudWxsXG4gICAgQEdldFNldCBsYXN0U2lnbkluRGF0ZTogYW55XG5cbiAgICBwcml2YXRlIF9wcm9wQ29uZmlnOiBudW1iZXJbXSA9IFtdXG4gICAgQEdldFNldCBwcm9wQ29uZmlnOiBudW1iZXJbXVxuXG4gICAgcHJpdmF0ZSBfcm9sZUNvbmZpZzogbnVtYmVyW10gPSBbXVxuICAgIEBHZXRTZXQgcm9sZUNvbmZpZzogbnVtYmVyW11cblxuXG4gICAgLyoq5Yid5aeL5YyW5Yid5aeL5pWw5o2u5YaF5a6557uT5p6EICovXG4gICAgcHVibGljIGluaXRVc2VySW5mbygpIHtcbiAgICAgICAgdGhpcy51c2VyTmFtZSA9IFwiQXJcIlxuICAgICAgICB0aGlzLmNvaW4gPSAxMDAwXG4gICAgICAgIHRoaXMubGV2ZWxQcm9ncmVzcyA9IDFcbiAgICAgICAgdGhpcy5zaWduSW5EYXlzID0gMFxuICAgICAgICB0aGlzLmxhc3RTaWduSW5EYXRlID0gbnVsbFxuICAgICAgICB0aGlzLnByb3BDb25maWcgPSBbMSwgMSwgMSwgMV1cbiAgICAgICAgdGhpcy5yb2xlQ29uZmlnID0gWzExMDcsIDE1MCwgNTgwLCAyMjBdXG4gICAgfVxuXG4gICAgLyoq6K6+572u55So5oi35pWw5o2uICovXG4gICAgcHVibGljIHNldFVzZXJJbmZvKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkYXRhKVxuICAgIH1cblxuICAgIC8qKuiOt+WPlueUqOaIt+aVsOaNriAqL1xuICAgIHB1YmxpYyBnZXRVc2VySW5mbygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHVzZXJOYW1lOiB0aGlzLnVzZXJOYW1lLFxuICAgICAgICAgICAgY29pbjogdGhpcy5jb2luLFxuICAgICAgICAgICAgbGV2ZWxQcm9ncmVzczogdGhpcy5sZXZlbFByb2dyZXNzLFxuICAgICAgICAgICAgc2lnbkluRGF5czogdGhpcy5zaWduSW5EYXlzLFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgfVxufVxuXG4vKirnlKjmiLfmlbDmja7mnKzlnLDlrZjlgqggKi9cbmV4cG9ydCBjbGFzcyBVc2VySW5mb1N0b3JnZSB7XG4gICAgLyoq5pys5Zyw5pWw5o2ua2V5ICovXG4gICAgcHJpdmF0ZSBzdGF0aWMga2V5OiBzdHJpbmcgPSBcInVzZXJJbmZvXCJcblxuICAgIC8qKuWCqOWtmOaVsOaNriAqL1xuICAgIHB1YmxpYyBzdGF0aWMgc2V0VXNlckluZm8odmFsdWU6IGFueSA9IFVzZXJJbmZvLmluc3RhbmNlLmdldFVzZXJJbmZvKCksIGtleSA9IHRoaXMua2V5KSB7XG4gICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICB9XG5cbiAgICAvKirojrflj5bmlbDmja4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldFVzZXJJbmZvKGtleSA9IHRoaXMua2V5KSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxuICAgIH1cblxuICAgIC8qKua4hemZpOeUqOaIt+eahOacrOWcsOaVsOaNriAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXJVc2VySW5mbyhrZXkgPSB0aGlzLmtleSkge1xuICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgIH1cblxuICAgIC8qKuaWsOWinueUqOaIt+aVsOaNriAtLSB2YWx1ZeWPquWMheWQq+aWsOWinueahOWGheWuuSAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkVXNlckluZm8odmFsdWU6IGFueSwga2V5ID0gdGhpcy5rZXkpIHtcbiAgICAgICAgY29uc3QgdXNlckluZm8gPSB0aGlzLmdldFVzZXJJbmZvKGtleSlcbiAgICAgICAgaWYgKHVzZXJJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRVc2VySW5mbyA9IHsgLi4udXNlckluZm8sIC4uLnZhbHVlIH1cbiAgICAgICAgICAgIHRoaXMuc2V0VXNlckluZm8oYWRkVXNlckluZm8sIGtleSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKuaYr+WQpuWtmOWcqOacrOWcsOaVsOaNriAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaGFzVXNlckluZm8oa2V5ID0gdGhpcy5rZXkpIHtcbiAgICAgICAgcmV0dXJuIGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpICE9PSBudWxsXG4gICAgfVxuXG4gICAgLyoq5Yig6Zmk5oyH5a6a55qE5pys5Zyw5pWw5o2uICovXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVVc2VySW5mbyhrZXk6IHN0cmluZykge1xuICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgIH1cblxuICAgIC8qKuiOt+WPluaJgOacieacrOWcsOaVsOaNriAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QWxsVXNlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmZvID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYy5zeXMubG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmtleShpKVxuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHRoaXMua2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gSlNPTi5wYXJzZShjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbiAgICAgICAgICAgICAgICB1c2VySW5mby5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VySW5mb1xuICAgIH1cblxufSBcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Decorator.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '194e1Q1HWRNm4uMrCVIQinW', 'Decorator');
// scripts/common/util/Decorator.ts

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tool_1 = require("./Tool");
/**
 * 工具装饰器
 */
var Decorator = /** @class */ (function () {
    function Decorator() {
    }
    //#region 方法装饰器
    /**
     * 异步方法装饰器，多次调用时会按队列顺序依次执行
     * - 对于非静态成员，每一个对象实例都存在一个独立的队列
     * - 对于静态成员，仅存在一个队列
     */
    Decorator.queue = function (target, funcName, desc) {
        var old = desc.value;
        var queueMap = new Map();
        var queueRun = function () {
            return __awaiter(this, void 0, Promise, function () {
                var queue, data, resolve, reject, args, result, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            queue = queueMap.get(this);
                            if (queue === undefined) {
                                cc.error("[Decorator.queue] error: queue is undefined");
                                return [2 /*return*/];
                            }
                            if (queue.length === 0) {
                                queueMap.delete(this);
                                return [2 /*return*/];
                            }
                            data = queue[0];
                            resolve = data[0];
                            reject = data[1];
                            args = data[2];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, 4, 5]);
                            return [4 /*yield*/, old.apply(this, args)];
                        case 2:
                            result = _a.sent();
                            resolve(result);
                            return [3 /*break*/, 5];
                        case 3:
                            error_1 = _a.sent();
                            reject(error_1);
                            return [3 /*break*/, 5];
                        case 4:
                            queue.shift();
                            queueRun.apply(this);
                            return [7 /*endfinally*/];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        desc.value = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new Promise(function (resolve, reject) {
                var queue = queueMap.get(_this);
                if (queue === undefined) {
                    queue = [];
                    queueMap.set(_this, queue);
                }
                queue.push([resolve, reject, args]);
                if (queue.length === 1) {
                    queueRun.apply(_this);
                }
            });
        };
    };
    /**
     * 方法装饰器，方法开始执行至执行完毕后锁定一段时间，期间忽略所有对该方法的调用
     * - 忽略调用时不会有返回值
     * @param seconds 锁定的秒数
     */
    Decorator.lock = function (seconds) {
        if (seconds === void 0) { seconds = 0; }
        return function (target, funcName, desc) {
            var old = desc.value;
            var callingSet = new Set();
            desc.value = function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (callingSet.has(this)) {
                    return;
                }
                callingSet.add(this);
                var result = old.apply(this, args);
                if (result instanceof Promise) {
                    return new Promise(function (resolve, reject) {
                        result.then(function (value) {
                            Tool_1.default.wait(Math.max(seconds, 0)).then(function () { callingSet.delete(_this); });
                            resolve(value);
                        }, function (reason) {
                            Tool_1.default.wait(Math.max(seconds, 0)).then(function () { callingSet.delete(_this); });
                            reject(reason);
                        });
                    });
                }
                else {
                    Tool_1.default.wait(Math.max(seconds, 0)).then(function () { callingSet.delete(_this); });
                    return result;
                }
            };
        };
    };
    return Decorator;
}());
exports.default = Decorator;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxEZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBMEI7QUFTMUI7O0dBRUc7QUFDSDtJQUFBO0lBb0ZBLENBQUM7SUFuRkcsZUFBZTtJQUVmOzs7O09BSUc7SUFDVyxlQUFLLEdBQW5CLFVBQW9CLE1BQWUsRUFBRSxRQUFnQixFQUFFLElBQW1CO1FBQ3RFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDckIsSUFBSSxRQUFRLEdBQThCLElBQUksR0FBRyxFQUFFLENBQUM7UUFDcEQsSUFBSSxRQUFRLEdBQUc7MkNBQW1CLE9BQU87Ozs7OzRCQUNqQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDL0IsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO2dDQUNyQixFQUFFLENBQUMsS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7Z0NBQ3hELHNCQUFPOzZCQUNWOzRCQUNELElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0NBQ3BCLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7Z0NBQ3RCLHNCQUFPOzZCQUNWOzRCQUNHLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ2hCLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ2xCLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ2pCLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7NEJBRUYscUJBQU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUE7OzRCQUFwQyxNQUFNLEdBQUcsU0FBMkI7NEJBQ3hDLE9BQU8sQ0FB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Q0FBQyxLQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6RSxPQUFPLE1BQU0sQ0FBQztpQkFDakI7WUFDTCxDQUFDLENBQUM7UUFDTixDQUFDLENBQUM7SUFDTixDQUFDO0lBR0wsZ0JBQUM7QUFBRCxDQXBGQSxBQW9GQyxJQUFBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRvb2wgZnJvbSBcIi4vVG9vbFwiO1xyXG5cclxudHlwZSBBc3luY0RhdGEgPSBbKHZhbHVlOiB1bmtub3duKSA9PiB2b2lkLCAocmVhc29uPzogdW5rbm93bikgPT4gdm9pZCwgdW5rbm93bltdXTtcclxuXHJcbi8qKiDlvILmraXmiJDlkZjmlrnms5UgKi9cclxuaW50ZXJmYWNlIEFzeW5jUHJvcGVydHkgZXh0ZW5kcyBQcm9wZXJ0eURlc2NyaXB0b3Ige1xyXG4gICAgdmFsdWU/OiAoLi4uYXJnczogdW5rbm93bltdKSA9PiBQcm9taXNlPHVua25vd24+O1xyXG59XHJcblxyXG4vKipcclxuICog5bel5YW36KOF6aWw5ZmoXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNvcmF0b3Ige1xyXG4gICAgLy8jcmVnaW9uIOaWueazleijhemlsOWZqFxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5byC5q2l5pa55rOV6KOF6aWw5Zmo77yM5aSa5qyh6LCD55So5pe25Lya5oyJ6Zif5YiX6aG65bqP5L6d5qyh5omn6KGMXHJcbiAgICAgKiAtIOWvueS6jumdnumdmeaAgeaIkOWRmO+8jOavj+S4gOS4quWvueixoeWunuS+i+mDveWtmOWcqOS4gOS4queLrOeri+eahOmYn+WIl1xyXG4gICAgICogLSDlr7nkuo7pnZnmgIHmiJDlkZjvvIzku4XlrZjlnKjkuIDkuKrpmJ/liJdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBxdWV1ZSh0YXJnZXQ6IHVua25vd24sIGZ1bmNOYW1lOiBzdHJpbmcsIGRlc2M6IEFzeW5jUHJvcGVydHkpOiB2b2lkIHtcclxuICAgICAgICBsZXQgb2xkID0gZGVzYy52YWx1ZTtcclxuICAgICAgICBsZXQgcXVldWVNYXA6IE1hcDx1bmtub3duLCBBc3luY0RhdGFbXT4gPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbGV0IHF1ZXVlUnVuID0gYXN5bmMgZnVuY3Rpb24gKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBsZXQgcXVldWUgPSBxdWV1ZU1hcC5nZXQodGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjYy5lcnJvcihgW0RlY29yYXRvci5xdWV1ZV0gZXJyb3I6IHF1ZXVlIGlzIHVuZGVmaW5lZGApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlTWFwLmRlbGV0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHF1ZXVlWzBdO1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IGRhdGFbMF07XHJcbiAgICAgICAgICAgIGxldCByZWplY3QgPSBkYXRhWzFdO1xyXG4gICAgICAgICAgICBsZXQgYXJncyA9IGRhdGFbMl07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgb2xkLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVJ1bi5hcHBseSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVzYy52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzOiB1bmtub3duW10pOiBQcm9taXNlPHVua25vd24+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBxdWV1ZSA9IHF1ZXVlTWFwLmdldCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1hcC5zZXQodGhpcywgcXVldWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChbcmVzb2x2ZSwgcmVqZWN0LCBhcmdzXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVSdW4uYXBwbHkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmlrnms5Xoo4XppbDlmajvvIzmlrnms5XlvIDlp4vmiafooYzoh7PmiafooYzlrozmr5XlkI7plIHlrprkuIDmrrXml7bpl7TvvIzmnJ/pl7Tlv73nlaXmiYDmnInlr7nor6Xmlrnms5XnmoTosIPnlKhcclxuICAgICAqIC0g5b+955Wl6LCD55So5pe25LiN5Lya5pyJ6L+U5Zue5YC8XHJcbiAgICAgKiBAcGFyYW0gc2Vjb25kcyDplIHlrprnmoTnp5LmlbBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2NrKHNlY29uZHM6IG51bWJlciA9IDApOiAodGFyZ2V0OiB1bmtub3duLCBmdW5jTmFtZTogc3RyaW5nLCBkZXNjOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHZvaWQge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiB1bmtub3duLCBmdW5jTmFtZTogc3RyaW5nLCBkZXNjOiBQcm9wZXJ0eURlc2NyaXB0b3IpOiB2b2lkIHtcclxuICAgICAgICAgICAgbGV0IG9sZCA9IGRlc2MudmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBjYWxsaW5nU2V0OiBTZXQ8dW5rbm93bj4gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGRlc2MudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93biB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGluZ1NldC5oYXModGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsaW5nU2V0LmFkZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBvbGQuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZTogdW5rbm93bikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9vbC53YWl0KE1hdGgubWF4KHNlY29uZHMsIDApKS50aGVuKCgpID0+IHsgY2FsbGluZ1NldC5kZWxldGUodGhpcyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIChyZWFzb246IHVua25vd24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvb2wud2FpdChNYXRoLm1heChzZWNvbmRzLCAwKSkudGhlbigoKSA9PiB7IGNhbGxpbmdTZXQuZGVsZXRlKHRoaXMpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVG9vbC53YWl0KE1hdGgubWF4KHNlY29uZHMsIDApKS50aGVuKCgpID0+IHsgY2FsbGluZ1NldC5kZWxldGUodGhpcyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/game/Game.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1ee18MAKgRPz4Ig/89N8gDX', 'Game');
// scripts/showcase/game/Game.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var Game = /** @class */ (function (_super) {
    __extends(Game, _super);
    function Game() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Game = __decorate([
        ccclass
    ], Game);
    return Game;
}(cc.Component));
exports.default = Game;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGdhbWVcXEdhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ00sSUFBQSxLQUF3QixFQUFFLENBQUMsVUFBVSxFQUFuQyxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQWtCLENBQUM7QUFHNUM7SUFBa0Msd0JBQVk7SUFBOUM7O0lBRUEsQ0FBQztJQUZvQixJQUFJO1FBRHhCLE9BQU87T0FDYSxJQUFJLENBRXhCO0lBQUQsV0FBQztDQUZELEFBRUMsQ0FGaUMsRUFBRSxDQUFDLFNBQVMsR0FFN0M7a0JBRm9CLElBQUkiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG5cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/AnimatorSpineSecondary.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2488934/SlBPY9ngsu8UqWo', 'AnimatorSpineSecondary');
// scripts/animator/AnimatorSpineSecondary.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorSpine_1 = require("./AnimatorSpine");
var AnimatorBase_1 = require("./core/AnimatorBase");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, menu = _a.menu;
/**
 * Spine状态机组件（次状态机），同一节点可添加多个，用于在不同track中播放动画，trackIndex必须大于0
 */
var AnimatorSpineSecondary = /** @class */ (function (_super) {
    __extends(AnimatorSpineSecondary, _super);
    function AnimatorSpineSecondary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.trackIndex = 1;
        /** 主状态机 */
        _this._main = null;
        /** spine组件 */
        _this._spine = null;
        return _this;
    }
    AnimatorSpineSecondary.prototype.start = function () {
        if (!this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this._spine = this.getComponent(sp.Skeleton);
        this._main = this.getComponent(AnimatorSpine_1.default);
        this._main.addSecondaryListener(this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @override
     */
    AnimatorSpineSecondary.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this.initArgs.apply(this, args);
        this._spine = this.getComponent(sp.Skeleton);
        this._main = this.getComponent(AnimatorSpine_1.default);
        this._main.addSecondaryListener(this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 播放动画
     * @override
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorSpineSecondary.prototype.playAnimation = function (animName, loop) {
        if (animName) {
            this._spine.setAnimation(this.trackIndex, animName, loop);
        }
        else {
            this._spine.clearTrack(this.trackIndex);
        }
    };
    __decorate([
        property({ tooltip: CC_DEV && '动画播放的trackIndex，必须大于0' })
    ], AnimatorSpineSecondary.prototype, "trackIndex", void 0);
    AnimatorSpineSecondary = __decorate([
        ccclass,
        requireComponent(sp.Skeleton),
        menu('Framework/Animator/AnimatorSpineSecondary')
    ], AnimatorSpineSecondary);
    return AnimatorSpineSecondary;
}(AnimatorBase_1.default));
exports.default = AnimatorSpineSecondary;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXEFuaW1hdG9yU3BpbmVTZWNvbmRhcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBQTRDO0FBQzVDLG9EQUFvRTtBQUc5RCxJQUFBLEtBQWdELEVBQUUsQ0FBQyxVQUFVLEVBQTNELE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUVwRTs7R0FFRztBQUlIO0lBQW9ELDBDQUFZO0lBQWhFO1FBQUEscUVBNERDO1FBM0Q2RCxnQkFBVSxHQUFXLENBQUMsQ0FBQztRQUVqRixXQUFXO1FBQ0gsV0FBSyxHQUFrQixJQUFJLENBQUM7UUFDcEMsY0FBYztRQUNOLFlBQU0sR0FBZ0IsSUFBSSxDQUFDOztJQXNEdkMsQ0FBQztJQXBEYSxzQ0FBSyxHQUFmO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNwQyxPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUVyQixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyx1QkFBYSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTNELElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLHVDQUFNLEdBQWI7UUFBYyxjQUFrSDthQUFsSCxVQUFrSCxFQUFsSCxxQkFBa0gsRUFBbEgsSUFBa0g7WUFBbEgseUJBQWtIOztRQUM1SCxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNuQyxPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUVyQixJQUFJLENBQUMsUUFBUSxPQUFiLElBQUksRUFBYSxJQUFJLEVBQUU7UUFFdkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsdUJBQWEsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUzRCxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxFQUFFO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLDhDQUFhLEdBQXZCLFVBQXdCLFFBQWdCLEVBQUUsSUFBYTtRQUNuRCxJQUFJLFFBQVEsRUFBRTtZQUNWLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzdEO2FBQU07WUFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDM0M7SUFDTCxDQUFDO0lBMUR5RDtRQUF6RCxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLHVCQUF1QixFQUFFLENBQUM7OERBQXdCO0lBRGhFLHNCQUFzQjtRQUgxQyxPQUFPO1FBQ1AsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztRQUM3QixJQUFJLENBQUMsMkNBQTJDLENBQUM7T0FDN0Isc0JBQXNCLENBNEQxQztJQUFELDZCQUFDO0NBNURELEFBNERDLENBNURtRCxzQkFBWSxHQTREL0Q7a0JBNURvQixzQkFBc0IiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW5pbWF0b3JTcGluZSBmcm9tIFwiLi9BbmltYXRvclNwaW5lXCI7XHJcbmltcG9ydCBBbmltYXRvckJhc2UsIHsgQW5pbWF0aW9uUGxheWVyIH0gZnJvbSBcIi4vY29yZS9BbmltYXRvckJhc2VcIjtcclxuaW1wb3J0IEFuaW1hdG9yU3RhdGVMb2dpYyBmcm9tIFwiLi9jb3JlL0FuaW1hdG9yU3RhdGVMb2dpY1wiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgcmVxdWlyZUNvbXBvbmVudCwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKiBcclxuICogU3BpbmXnirbmgIHmnLrnu4Tku7bvvIjmrKHnirbmgIHmnLrvvInvvIzlkIzkuIDoioLngrnlj6/mt7vliqDlpJrkuKrvvIznlKjkuo7lnKjkuI3lkIx0cmFja+S4reaSreaUvuWKqOeUu++8jHRyYWNrSW5kZXjlv4XpobvlpKfkuo4wXHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AcmVxdWlyZUNvbXBvbmVudChzcC5Ta2VsZXRvbilcclxuQG1lbnUoJ0ZyYW1ld29yay9BbmltYXRvci9BbmltYXRvclNwaW5lU2Vjb25kYXJ5JylcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JTcGluZVNlY29uZGFyeSBleHRlbmRzIEFuaW1hdG9yQmFzZSB7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgJ+WKqOeUu+aSreaUvueahHRyYWNrSW5kZXjvvIzlv4XpobvlpKfkuo4wJyB9KSB0cmFja0luZGV4OiBudW1iZXIgPSAxO1xyXG5cclxuICAgIC8qKiDkuLvnirbmgIHmnLogKi9cclxuICAgIHByaXZhdGUgX21haW46IEFuaW1hdG9yU3BpbmUgPSBudWxsO1xyXG4gICAgLyoqIHNwaW5l57uE5Lu2ICovXHJcbiAgICBwcml2YXRlIF9zcGluZTogc3AuU2tlbGV0b24gPSBudWxsO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGxheU9uU3RhcnQgfHwgdGhpcy5faGFzSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc0luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9zcGluZSA9IHRoaXMuZ2V0Q29tcG9uZW50KHNwLlNrZWxldG9uKTtcclxuICAgICAgICB0aGlzLl9tYWluID0gdGhpcy5nZXRDb21wb25lbnQoQW5pbWF0b3JTcGluZSk7XHJcbiAgICAgICAgdGhpcy5fbWFpbi5hZGRTZWNvbmRhcnlMaXN0ZW5lcih0aGlzLm9uQW5pbUZpbmlzaGVkLCB0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXNzZXRSYXdVcmwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0SnNvbih0aGlzLmFzc2V0UmF3VXJsLmpzb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaJi+WKqOWIneWni+WMlueKtuaAgeacuu+8jOWPr+S8oOWFpTAtM+S4quWPguaVsO+8jOexu+Wei+WmguS4i1xyXG4gICAgICogLSBvblN0YXRlQ2hhbmdlQ2FsbCDnirbmgIHliIfmjaLml7bnmoTlm57osINcclxuICAgICAqIC0gc3RhdGVMb2dpY01hcCDlkITkuKrnirbmgIHpgLvovpHmjqfliLZcclxuICAgICAqIC0gYW5pbWF0aW9uUGxheWVyIOiHquWumuS5ieWKqOeUu+aOp+WItlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkluaXQoLi4uYXJnczogQXJyYXk8TWFwPHN0cmluZywgQW5pbWF0b3JTdGF0ZUxvZ2ljPiB8ICgoZnJvbVN0YXRlOiBzdHJpbmcsIHRvU3RhdGU6IHN0cmluZykgPT4gdm9pZCkgfCBBbmltYXRpb25QbGF5ZXI+KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGxheU9uU3RhcnQgfHwgdGhpcy5faGFzSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc0luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmluaXRBcmdzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLl9zcGluZSA9IHRoaXMuZ2V0Q29tcG9uZW50KHNwLlNrZWxldG9uKTtcclxuICAgICAgICB0aGlzLl9tYWluID0gdGhpcy5nZXRDb21wb25lbnQoQW5pbWF0b3JTcGluZSk7XHJcbiAgICAgICAgdGhpcy5fbWFpbi5hZGRTZWNvbmRhcnlMaXN0ZW5lcih0aGlzLm9uQW5pbUZpbmlzaGVkLCB0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXNzZXRSYXdVcmwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0SnNvbih0aGlzLmFzc2V0UmF3VXJsLmpzb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvuWKqOeUu1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gYW5pbU5hbWUg5Yqo55S75ZCNXHJcbiAgICAgKiBAcGFyYW0gbG9vcCDmmK/lkKblvqrnjq/mkq3mlL5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBsYXlBbmltYXRpb24oYW5pbU5hbWU6IHN0cmluZywgbG9vcDogYm9vbGVhbikge1xyXG4gICAgICAgIGlmIChhbmltTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGluZS5zZXRBbmltYXRpb24odGhpcy50cmFja0luZGV4LCBhbmltTmFtZSwgbG9vcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BpbmUuY2xlYXJUcmFjayh0aGlzLnRyYWNrSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorController.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'de785Aa4lpFH59CMCV1Eb74', 'AnimatorController');
// scripts/animator/core/AnimatorController.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorParams_1 = require("./AnimatorParams");
var AnimatorState_1 = require("./AnimatorState");
/**
 * 状态机控制类
 */
var AnimatorController = /** @class */ (function () {
    function AnimatorController(player, json) {
        this._jsonData = null;
        this._animator = null;
        this._params = null;
        this._states = null;
        this._anyState = null;
        this._curState = null;
        /** 状态切换次数 */
        this._changeCount = 0;
        /** 对应animComplete的状态 */
        this.animCompleteState = null;
        /** 动画播放完毕的标记 */
        this.animComplete = false;
        this._animator = player;
        this._jsonData = json;
        this._states = new Map();
        this._params = new AnimatorParams_1.default(json.parameters);
        this.init(json);
    }
    Object.defineProperty(AnimatorController.prototype, "curState", {
        /** 当前运行的状态 */
        get: function () { return this._curState; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorController.prototype, "params", {
        get: function () { return this._params; },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化状态机所有动画状态
     */
    AnimatorController.prototype.init = function (json) {
        if (json.states.length <= 0) {
            cc.error("[AnimatorController.init] \u72B6\u6001\u673Ajson\u9519\u8BEF");
            return;
        }
        this._anyState = new AnimatorState_1.default(json.anyState, this);
        for (var i = 0; i < json.states.length; i++) {
            var state = new AnimatorState_1.default(json.states[i], this);
            this._states.set(state.name, state);
        }
    };
    AnimatorController.prototype.updateState = function () {
        this._curState.checkAndTrans();
        if (this._curState !== this._anyState && this._anyState !== null) {
            this._anyState.checkAndTrans();
        }
    };
    /**
     * 更新状态机逻辑
     */
    AnimatorController.prototype.updateAnimator = function () {
        // 重置计数
        this._changeCount = 0;
        this.updateState();
        // 重置动画完成标记
        if (this.animComplete && this.animCompleteState.loop) {
            this.animComplete = false;
        }
        // 重置autoTrigger
        this.params.resetAllAutoTrigger();
    };
    AnimatorController.prototype.onAnimationComplete = function () {
        this.animComplete = true;
        this.animCompleteState = this._curState;
        // cc.log(`animation complete: ${this._curState.name}`);
    };
    /**
     * 无视条件直接跳转状态，如果当前已处于此状态则重置状态
     * @param 状态名
     */
    AnimatorController.prototype.play = function (stateName) {
        if (!this._states.has(stateName)) {
            return;
        }
        // 重置动画完成标记
        this.animComplete = false;
        var oldState = this._curState;
        this._curState = this._states.get(stateName);
        this._animator.onStateChange(oldState, this._curState);
        this.updateState();
    };
    /**
     * 切换动画状态
     */
    AnimatorController.prototype.changeState = function (stateName) {
        this._changeCount++;
        if (this._changeCount > 1000) {
            cc.error('[AnimatorController.changeState] error: 状态切换递归调用超过1000次，transition设置可能出错!');
            return;
        }
        if (this._states.has(stateName) && (this._curState === null || this._curState.name !== stateName)) {
            var oldState = this._curState;
            this._curState = this._states.get(stateName);
            this._animator.onStateChange(oldState, this._curState);
            this.updateState();
        }
        else {
            cc.error("[AnimatorController.changeState] error state: " + stateName);
        }
    };
    return AnimatorController;
}());
exports.default = AnimatorController;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yQ29udHJvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLG1EQUE4QztBQUM5QyxpREFBNEM7QUFFNUM7O0dBRUc7QUFDSDtJQW1CSSw0QkFBWSxNQUFvQixFQUFFLElBQVM7UUFsQm5DLGNBQVMsR0FBUSxJQUFJLENBQUM7UUFDdEIsY0FBUyxHQUFpQixJQUFJLENBQUM7UUFFL0IsWUFBTyxHQUFtQixJQUFJLENBQUM7UUFDL0IsWUFBTyxHQUErQixJQUFJLENBQUM7UUFDM0MsY0FBUyxHQUFrQixJQUFJLENBQUM7UUFDaEMsY0FBUyxHQUFrQixJQUFJLENBQUM7UUFFeEMsYUFBYTtRQUNMLGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBQ2pDLHdCQUF3QjtRQUNqQixzQkFBaUIsR0FBa0IsSUFBSSxDQUFDO1FBQy9DLGdCQUFnQjtRQUNULGlCQUFZLEdBQVksS0FBSyxDQUFDO1FBTWpDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQXlCLENBQUM7UUFDaEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLHdCQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQVRELHNCQUFXLHdDQUFRO1FBRG5CLGNBQWM7YUFDZCxjQUF1QyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUMvRCxzQkFBVyxzQ0FBTTthQUFqQixjQUFzQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQVU1RDs7T0FFRztJQUNLLGlDQUFJLEdBQVosVUFBYSxJQUFT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SSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUU3QyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRXZELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN0QjthQUFNO1lBQ0gsRUFBRSxDQUFDLEtBQUssQ0FBQyxtREFBaUQsU0FBVyxDQUFDLENBQUM7U0FDMUU7SUFDTCxDQUFDO0lBQ0wseUJBQUM7QUFBRCxDQS9HQSxBQStHQyxJQUFBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFuaW1hdG9yQmFzZSBmcm9tIFwiLi9BbmltYXRvckJhc2VcIjtcclxuaW1wb3J0IEFuaW1hdG9yUGFyYW1zIGZyb20gXCIuL0FuaW1hdG9yUGFyYW1zXCI7XHJcbmltcG9ydCBBbmltYXRvclN0YXRlIGZyb20gXCIuL0FuaW1hdG9yU3RhdGVcIjtcclxuXHJcbi8qKlxyXG4gKiDnirbmgIHmnLrmjqfliLbnsbtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yQ29udHJvbGxlciB7XHJcbiAgICBwcml2YXRlIF9qc29uRGF0YTogYW55ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2FuaW1hdG9yOiBBbmltYXRvckJhc2UgPSBudWxsO1xyXG5cclxuICAgIHByaXZhdGUgX3BhcmFtczogQW5pbWF0b3JQYXJhbXMgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfc3RhdGVzOiBNYXA8c3RyaW5nLCBBbmltYXRvclN0YXRlPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9hbnlTdGF0ZTogQW5pbWF0b3JTdGF0ZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9jdXJTdGF0ZTogQW5pbWF0b3JTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIOeKtuaAgeWIh+aNouasoeaVsCAqL1xyXG4gICAgcHJpdmF0ZSBfY2hhbmdlQ291bnQ6IG51bWJlciA9IDA7XHJcbiAgICAvKiog5a+55bqUYW5pbUNvbXBsZXRl55qE54q25oCBICovXHJcbiAgICBwdWJsaWMgYW5pbUNvbXBsZXRlU3RhdGU6IEFuaW1hdG9yU3RhdGUgPSBudWxsO1xyXG4gICAgLyoqIOWKqOeUu+aSreaUvuWujOavleeahOagh+iusCAqL1xyXG4gICAgcHVibGljIGFuaW1Db21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIOW9k+WJjei/kOihjOeahOeKtuaAgSAqL1xyXG4gICAgcHVibGljIGdldCBjdXJTdGF0ZSgpOiBBbmltYXRvclN0YXRlIHsgcmV0dXJuIHRoaXMuX2N1clN0YXRlOyB9XHJcbiAgICBwdWJsaWMgZ2V0IHBhcmFtcygpOiBBbmltYXRvclBhcmFtcyB7IHJldHVybiB0aGlzLl9wYXJhbXM7IH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbGF5ZXI6IEFuaW1hdG9yQmFzZSwganNvbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IgPSBwbGF5ZXI7XHJcbiAgICAgICAgdGhpcy5fanNvbkRhdGEgPSBqc29uO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBBbmltYXRvclN0YXRlPigpO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IG5ldyBBbmltYXRvclBhcmFtcyhqc29uLnBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaW5pdChqc29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMlueKtuaAgeacuuaJgOacieWKqOeUu+eKtuaAgVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGluaXQoanNvbjogYW55KSB7XHJcbiAgICAgICAgaWYgKGpzb24uc3RhdGVzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbQW5pbWF0b3JDb250cm9sbGVyLmluaXRdIOeKtuaAgeacumpzb27plJnor69gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fYW55U3RhdGUgPSBuZXcgQW5pbWF0b3JTdGF0ZShqc29uLmFueVN0YXRlLCB0aGlzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZTogQW5pbWF0b3JTdGF0ZSA9IG5ldyBBbmltYXRvclN0YXRlKGpzb24uc3RhdGVzW2ldLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGVzLnNldChzdGF0ZS5uYW1lLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlU3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VyU3RhdGUuY2hlY2tBbmRUcmFucygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJTdGF0ZSAhPT0gdGhpcy5fYW55U3RhdGUgJiYgdGhpcy5fYW55U3RhdGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW55U3RhdGUuY2hlY2tBbmRUcmFucygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOeKtuaAgeacuumAu+i+kVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlQW5pbWF0b3IoKSB7XHJcbiAgICAgICAgLy8g6YeN572u6K6h5pWwXHJcbiAgICAgICAgdGhpcy5fY2hhbmdlQ291bnQgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XHJcblxyXG4gICAgICAgIC8vIOmHjee9ruWKqOeUu+WujOaIkOagh+iusFxyXG4gICAgICAgIGlmICh0aGlzLmFuaW1Db21wbGV0ZSAmJiB0aGlzLmFuaW1Db21wbGV0ZVN0YXRlLmxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6YeN572uYXV0b1RyaWdnZXJcclxuICAgICAgICB0aGlzLnBhcmFtcy5yZXNldEFsbEF1dG9UcmlnZ2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQW5pbWF0aW9uQ29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5hbmltQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYW5pbUNvbXBsZXRlU3RhdGUgPSB0aGlzLl9jdXJTdGF0ZTtcclxuICAgICAgICAvLyBjYy5sb2coYGFuaW1hdGlvbiBjb21wbGV0ZTogJHt0aGlzLl9jdXJTdGF0ZS5uYW1lfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5peg6KeG5p2h5Lu255u05o6l6Lez6L2s54q25oCB77yM5aaC5p6c5b2T5YmN5bey5aSE5LqO5q2k54q25oCB5YiZ6YeN572u54q25oCBXHJcbiAgICAgKiBAcGFyYW0g54q25oCB5ZCNXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwbGF5KHN0YXRlTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXMuaGFzKHN0YXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g6YeN572u5Yqo55S75a6M5oiQ5qCH6K6wXHJcbiAgICAgICAgdGhpcy5hbmltQ29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICBsZXQgb2xkU3RhdGUgPSB0aGlzLl9jdXJTdGF0ZTtcclxuICAgICAgICB0aGlzLl9jdXJTdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQoc3RhdGVOYW1lKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRvci5vblN0YXRlQ2hhbmdlKG9sZFN0YXRlLCB0aGlzLl9jdXJTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YiH5o2i5Yqo55S754q25oCBXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjaGFuZ2VTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2NoYW5nZUNvdW50Kys7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUNvdW50ID4gMTAwMCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcignW0FuaW1hdG9yQ29udHJvbGxlci5jaGFuZ2VTdGF0ZV0gZXJyb3I6IOeKtuaAgeWIh+aNoumAkuW9kuiwg+eUqOi2hei/hzEwMDDmrKHvvIx0cmFuc2l0aW9u6K6+572u5Y+v6IO95Ye66ZSZIScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3RhdGVzLmhhcyhzdGF0ZU5hbWUpICYmICh0aGlzLl9jdXJTdGF0ZSA9PT0gbnVsbCB8fCB0aGlzLl9jdXJTdGF0ZS5uYW1lICE9PSBzdGF0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBvbGRTdGF0ZSA9IHRoaXMuX2N1clN0YXRlO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJTdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQoc3RhdGVOYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdG9yLm9uU3RhdGVDaGFuZ2Uob2xkU3RhdGUsIHRoaXMuX2N1clN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW0FuaW1hdG9yQ29udHJvbGxlci5jaGFuZ2VTdGF0ZV0gZXJyb3Igc3RhdGU6ICR7c3RhdGVOYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorParams.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '47250iiE8tKUZF6tjFUlfMo', 'AnimatorParams');
// scripts/animator/core/AnimatorParams.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorCondition_1 = require("./AnimatorCondition");
/**
 * 状态机参数
 */
var AnimatorParams = /** @class */ (function () {
    function AnimatorParams(dataArr) {
        var _this = this;
        this._paramMap = new Map();
        dataArr.forEach(function (data) {
            var param = {
                type: data.type,
                value: data.init
            };
            _this._paramMap.set(data.param, param);
        });
    }
    AnimatorParams.prototype.getParamType = function (key) {
        var param = this._paramMap.get(key);
        if (param) {
            return param.type;
        }
        else {
            return null;
        }
    };
    AnimatorParams.prototype.setNumber = function (key, value) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.NUMBER) {
            param.value = value;
        }
    };
    AnimatorParams.prototype.setBool = function (key, value) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.BOOLEAN) {
            param.value = value ? 1 : 0;
        }
    };
    AnimatorParams.prototype.setTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.TRIGGER) {
            param.value = 1;
        }
    };
    AnimatorParams.prototype.resetTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.TRIGGER) {
            param.value = 0;
        }
    };
    AnimatorParams.prototype.autoTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.AUTO_TRIGGER) {
            param.value = 1;
        }
    };
    AnimatorParams.prototype.resetAutoTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.AUTO_TRIGGER) {
            param.value = 0;
        }
    };
    AnimatorParams.prototype.resetAllAutoTrigger = function () {
        this._paramMap.forEach(function (param, key) {
            if (param.type === AnimatorCondition_1.ParamType.AUTO_TRIGGER) {
                param.value = 0;
            }
        });
    };
    AnimatorParams.prototype.getNumber = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.NUMBER) {
            return param.value;
        }
        else {
            return 0;
        }
    };
    AnimatorParams.prototype.getBool = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.BOOLEAN) {
            return param.value;
        }
        else {
            return 0;
        }
    };
    AnimatorParams.prototype.getTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.TRIGGER) {
            return param.value;
        }
        else {
            return 0;
        }
    };
    AnimatorParams.prototype.getAutoTrigger = function (key) {
        var param = this._paramMap.get(key);
        if (param && param.type === AnimatorCondition_1.ParamType.AUTO_TRIGGER) {
            return param.value;
        }
        else {
            return 0;
        }
    };
    return AnimatorParams;
}());
exports.default = AnimatorParams;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yUGFyYW1zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseURBQWdEO0FBVWhEOztHQUVHO0FBQ0g7SUFHSSx3QkFBWSxPQUFjO1FBQTFCLGlCQVFDO1FBVk8sY0FBUyxHQUF1QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRzlDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFTO1lBQ3RCLElBQUksS0FBSyxHQUFVO2dCQUNmLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUk7YUFDbkIsQ0FBQztZQUNGLEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU0scUNBQVksR0FBbkIsVUFBb0IsR0FBVztRQUMzQixJQUFJLEtBQUssR0FBVSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzQyxJQUFJLEtBQUssRUFBRTtZQUNQLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQztTQUNyQjthQUFNO1lBQ0gsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7SUFFTSxrQ0FBUyxHQUFoQixVQUFpQixHQUFXLEVBQUUsS0FBYTtRQUN2QyxJQUFJLEtBQUssR0FBVSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzQyxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFTLENBQUMsTUFBTSxFQUFFO1lBQzFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1NBQ3ZCO0lBQ0wsQ0FBQztJQUVNLGdDQUFPLEdBQWQsVUFBZSxHQUFXLEVBQUUsS0FBYztRQUN0QyxJQUFJLEtB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QyxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFTLENBQUMsT0FBTyxFQUFFO1lBQzNDLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQztTQUN0QjthQUFNO1lBQ0gsT0FBTyxDQUFDLENBQUM7U0FDWjtJQUNMLENBQUM7SUFFTSx1Q0FBYyxHQUFyQixVQUFzQixHQUFXO1FBQzdCLElBQUksS0FBSyxHQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNDLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQVMsQ0FBQyxZQUFZLEVBQUU7WUFDaEQsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQ3RCO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUNMLHFCQUFDO0FBQUQsQ0EzR0EsQUEyR0MsSUFBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL0FuaW1hdG9yQ29uZGl0aW9uXCI7XHJcblxyXG4vKipcclxuICog5Y+C5pWw57uT5p6EXHJcbiAqL1xyXG5pbnRlcmZhY2UgUGFyYW0ge1xyXG4gICAgdHlwZTogUGFyYW1UeXBlO1xyXG4gICAgdmFsdWU6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIOeKtuaAgeacuuWPguaVsFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JQYXJhbXMge1xyXG4gICAgcHJpdmF0ZSBfcGFyYW1NYXA6IE1hcDxzdHJpbmcsIFBhcmFtPiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhQXJyOiBhbnlbXSkge1xyXG4gICAgICAgIGRhdGFBcnIuZm9yRWFjaCgoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGF0YS5pbml0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtTWFwLnNldChkYXRhLnBhcmFtLCBwYXJhbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBhcmFtVHlwZShrZXk6IHN0cmluZyk6IFBhcmFtVHlwZSB7XHJcbiAgICAgICAgbGV0IHBhcmFtOiBQYXJhbSA9IHRoaXMuX3BhcmFtTWFwLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChwYXJhbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW0udHlwZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldE51bWJlcihrZXk6IHN0cmluZywgdmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLk5VTUJFUikge1xyXG4gICAgICAgICAgICBwYXJhbS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Qm9vbChrZXk6IHN0cmluZywgdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICBsZXQgcGFyYW06IFBhcmFtID0gdGhpcy5fcGFyYW1NYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKHBhcmFtICYmIHBhcmFtLnR5cGUgPT09IFBhcmFtVHlwZS5CT09MRUFOKSB7XHJcbiAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gdmFsdWUgPyAxIDogMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFRyaWdnZXIoa2V5OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgcGFyYW06IFBhcmFtID0gdGhpcy5fcGFyYW1NYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKHBhcmFtICYmIHBhcmFtLnR5cGUgPT09IFBhcmFtVHlwZS5UUklHR0VSKSB7XHJcbiAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2V0VHJpZ2dlcihrZXk6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLlRSSUdHRVIpIHtcclxuICAgICAgICAgICAgcGFyYW0udmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXV0b1RyaWdnZXIoa2V5OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgcGFyYW06IFBhcmFtID0gdGhpcy5fcGFyYW1NYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKHBhcmFtICYmIHBhcmFtLnR5cGUgPT09IFBhcmFtVHlwZS5BVVRPX1RSSUdHRVIpIHtcclxuICAgICAgICAgICAgcGFyYW0udmFsdWUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzZXRBdXRvVHJpZ2dlcihrZXk6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLkFVVE9fVFJJR0dFUikge1xyXG4gICAgICAgICAgICBwYXJhbS52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNldEFsbEF1dG9UcmlnZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuX3BhcmFtTWFwLmZvckVhY2goKHBhcmFtOiBQYXJhbSwga2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFBhcmFtVHlwZS5BVVRPX1RSSUdHRVIpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXROdW1iZXIoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLk5VTUJFUikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW0udmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCb29sKGtleTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgcGFyYW06IFBhcmFtID0gdGhpcy5fcGFyYW1NYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKHBhcmFtICYmIHBhcmFtLnR5cGUgPT09IFBhcmFtVHlwZS5CT09MRUFOKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbS52YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFRyaWdnZXIoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLlRSSUdHRVIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QXV0b1RyaWdnZXIoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBwYXJhbTogUGFyYW0gPSB0aGlzLl9wYXJhbU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAocGFyYW0gJiYgcGFyYW0udHlwZSA9PT0gUGFyYW1UeXBlLkFVVE9fVFJJR0dFUikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW0udmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/scenes/Main.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'eef8c5qJslOQ71iswi/FuxY', 'Main');
// scripts/showcase/scenes/Main.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Layer_1 = require("../../common/cmpt/base/Layer");
var Url_1 = require("../../common/const/Url");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    function Main() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Main.prototype.start = function () {
        Layer_1.default.inst.enterMain(Url_1.ResUrl.PREFAB.HOME);
        // 60s清理一次缓存
        // this.schedule(() => {
        //     Res.releaseAll();
        // }, 60);
    };
    Main.prototype.lateUpdate = function () { };
    Main = __decorate([
        ccclass
    ], Main);
    return Main;
}(cc.Component));
exports.default = Main;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXHNjZW5lc1xcTWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBaUQ7QUFDakQsOENBQWdEO0FBRzFDLElBQUEsS0FBd0IsRUFBRSxDQUFDLFVBQVUsRUFBbkMsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFrQixDQUFDO0FBRzVDO0lBQWtDLHdCQUFZO0lBQTlDOztJQVdBLENBQUM7SUFUYSxvQkFBSyxHQUFmO1FBQ0ksZUFBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxZQUFZO1FBQ1osd0JBQXdCO1FBQ3hCLHdCQUF3QjtRQUN4QixVQUFVO0lBQ2QsQ0FBQztJQUVTLHlCQUFVLEdBQXBCLGNBQXlCLENBQUM7SUFWVCxJQUFJO1FBRHhCLE9BQU87T0FDYSxJQUFJLENBV3hCO0lBQUQsV0FBQztDQVhELEFBV0MsQ0FYaUMsRUFBRSxDQUFDLFNBQVMsR0FXN0M7a0JBWG9CLElBQUkiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uLy4uL2NvbW1vbi9jbXB0L2Jhc2UvTGF5ZXJcIjtcclxuaW1wb3J0IHsgUmVzVXJsIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb25zdC9VcmxcIjtcclxuaW1wb3J0IFJlcyBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWwvUmVzXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXJ0KCkge1xyXG4gICAgICAgIExheWVyLmluc3QuZW50ZXJNYWluKFJlc1VybC5QUkVGQUIuSE9NRSk7XHJcbiAgICAgICAgLy8gNjBz5riF55CG5LiA5qyh57yT5a2YXHJcbiAgICAgICAgLy8gdGhpcy5zY2hlZHVsZSgoKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIFJlcy5yZWxlYXNlQWxsKCk7XHJcbiAgICAgICAgLy8gfSwgNjApO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBsYXRlVXBkYXRlKCkgeyB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorTransition.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '34b08BDtkZDiLlsqDHQh7XT', 'AnimatorTransition');
// scripts/animator/core/AnimatorTransition.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorCondition_1 = require("./AnimatorCondition");
/**
 * 状态过渡类
 */
var AnimatorTransition = /** @class */ (function () {
    function AnimatorTransition(data, ac) {
        this._toStateName = '';
        this._hasExitTime = false;
        this._conditions = [];
        this._ac = null;
        this._toStateName = data.toState;
        this._hasExitTime = data.hasExitTime;
        this._ac = ac;
        for (var i = 0; i < data.conditions.length; i++) {
            var condition = new AnimatorCondition_1.default(data.conditions[i], ac);
            this._conditions.push(condition);
        }
    }
    /**
     * 返回该transition是否有效，当未勾选hasExitTime以及没有添加任何condition时此transition无效并忽略
     */
    AnimatorTransition.prototype.isValid = function () {
        return this._hasExitTime || this._conditions.length > 0;
    };
    /**
     * 判断是否满足所有转换条件
     */
    AnimatorTransition.prototype.check = function () {
        if (this._toStateName === this._ac.curState.name) {
            return false;
        }
        if (this._hasExitTime && (this._ac.curState !== this._ac.animCompleteState || !this._ac.animComplete)) {
            return false;
        }
        for (var i = 0; i < this._conditions.length; i++) {
            if (!this._conditions[i].check()) {
                return false;
            }
        }
        return true;
    };
    /**
     * 转换状态
     */
    AnimatorTransition.prototype.doTrans = function () {
        // 满足条件时重置动画播完标记
        if (this._hasExitTime) {
            this._ac.animComplete = false;
        }
        // 满足状态转换条件时重置trigger和autoTrigger
        for (var i = 0; i < this._conditions.length; i++) {
            var type = this._conditions[i].getParamType();
            var name = this._conditions[i].getParamName();
            if (type === AnimatorCondition_1.ParamType.TRIGGER) {
                this._ac.params.resetTrigger(name);
            }
            else if (type === AnimatorCondition_1.ParamType.AUTO_TRIGGER) {
                this._ac.params.resetAutoTrigger(name);
            }
        }
        this._ac.changeState(this._toStateName);
    };
    return AnimatorTransition;
}());
exports.default = AnimatorTransition;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yVHJhbnNpdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlEQUFtRTtBQUduRTs7R0FFRztBQUNIO0lBTUksNEJBQVksSUFBUyxFQUFFLEVBQXNCO1FBTHJDLGlCQUFZLEdBQVcsRUFBRSxDQUFDO1FBQzFCLGlCQUFZLEdBQVksS0FBSyxDQUFDO1FBQzlCLGdCQUFXLEdBQXdCLEVBQUUsQ0FBQztRQUN0QyxRQUFHLEdBQXVCLElBQUksQ0FBQztRQUduQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzdDLElBQUksU0FBUyxHQUFzQixJQUFJLDJCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDcEM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxvQ0FBTyxHQUFkO1FBQ0ksT0FBTyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxrQ0FBSyxHQUFaO1FBQ0ksSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtZQUM5QyxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ25HLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUM5QixPQUFPLEtBQUssQ0FBQzthQUNoQjtTQUNKO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksb0NBQU8sR0FBZDtRQUNJLGdCQUFnQjtRQUNoQixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1NBQ2pDO1FBQ0QsaUNBQWlDO1FBQ2pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM5QyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzlDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDOUMsSUFBSSxJQUFJLEtBQUssNkJBQVMsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QztpQkFBTSxJQUFJLElBQUksS0FBSyw2QkFBUyxDQUFDLFlBQVksRUFBRTtnQkFDeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDMUM7U0FDSjtRQUVELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0wseUJBQUM7QUFBRCxDQWhFQSxBQWdFQyxJQUFBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFuaW1hdG9yQ29uZGl0aW9uLCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL0FuaW1hdG9yQ29uZGl0aW9uXCI7XHJcbmltcG9ydCBBbmltYXRvckNvbnRyb2xsZXIgZnJvbSBcIi4vQW5pbWF0b3JDb250cm9sbGVyXCI7XHJcblxyXG4vKipcclxuICog54q25oCB6L+H5rih57G7XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvclRyYW5zaXRpb24ge1xyXG4gICAgcHJpdmF0ZSBfdG9TdGF0ZU5hbWU6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfaGFzRXhpdFRpbWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2NvbmRpdGlvbnM6IEFuaW1hdG9yQ29uZGl0aW9uW10gPSBbXTtcclxuICAgIHByaXZhdGUgX2FjOiBBbmltYXRvckNvbnRyb2xsZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGE6IGFueSwgYWM6IEFuaW1hdG9yQ29udHJvbGxlcikge1xyXG4gICAgICAgIHRoaXMuX3RvU3RhdGVOYW1lID0gZGF0YS50b1N0YXRlO1xyXG4gICAgICAgIHRoaXMuX2hhc0V4aXRUaW1lID0gZGF0YS5oYXNFeGl0VGltZTtcclxuICAgICAgICB0aGlzLl9hYyA9IGFjO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jb25kaXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25kaXRpb246IEFuaW1hdG9yQ29uZGl0aW9uID0gbmV3IEFuaW1hdG9yQ29uZGl0aW9uKGRhdGEuY29uZGl0aW9uc1tpXSwgYWMpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57or6V0cmFuc2l0aW9u5piv5ZCm5pyJ5pWI77yM5b2T5pyq5Yu+6YCJaGFzRXhpdFRpbWXku6Xlj4rmsqHmnInmt7vliqDku7vkvZVjb25kaXRpb27ml7bmraR0cmFuc2l0aW9u5peg5pWI5bm25b+955WlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNFeGl0VGltZSB8fCB0aGlzLl9jb25kaXRpb25zLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq3mmK/lkKbmu6HotrPmiYDmnInovazmjaLmnaHku7ZcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNoZWNrKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLl90b1N0YXRlTmFtZSA9PT0gdGhpcy5fYWMuY3VyU3RhdGUubmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5faGFzRXhpdFRpbWUgJiYgKHRoaXMuX2FjLmN1clN0YXRlICE9PSB0aGlzLl9hYy5hbmltQ29tcGxldGVTdGF0ZSB8fCAhdGhpcy5fYWMuYW5pbUNvbXBsZXRlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbmRpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb25kaXRpb25zW2ldLmNoZWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rOaNoueKtuaAgVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZG9UcmFucygpIHtcclxuICAgICAgICAvLyDmu6HotrPmnaHku7bml7bph43nva7liqjnlLvmkq3lrozmoIforrBcclxuICAgICAgICBpZiAodGhpcy5faGFzRXhpdFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWMuYW5pbUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOa7oei2s+eKtuaAgei9rOaNouadoeS7tuaXtumHjee9rnRyaWdnZXLlkoxhdXRvVHJpZ2dlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29uZGl0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMuX2NvbmRpdGlvbnNbaV0uZ2V0UGFyYW1UeXBlKCk7XHJcbiAgICAgICAgICAgIGxldCBuYW1lID0gdGhpcy5fY29uZGl0aW9uc1tpXS5nZXRQYXJhbU5hbWUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBhcmFtVHlwZS5UUklHR0VSKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hYy5wYXJhbXMucmVzZXRUcmlnZ2VyKG5hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFBhcmFtVHlwZS5BVVRPX1RSSUdHRVIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjLnBhcmFtcy5yZXNldEF1dG9UcmlnZ2VyKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hYy5jaGFuZ2VTdGF0ZSh0aGlzLl90b1N0YXRlTmFtZSk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/AnimatorAnimation.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ddcbcHQdPFOfY+mAxuSRJ7E', 'AnimatorAnimation');
// scripts/animator/AnimatorAnimation.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorBase_1 = require("./core/AnimatorBase");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * Cocos Animation状态机组件
 */
var AnimatorAnimation = /** @class */ (function (_super) {
    __extends(AnimatorAnimation, _super);
    function AnimatorAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Animation组件 */
        _this._animation = null;
        /** 当前的动画实例 */
        _this._animState = null;
        /** 记录初始的wrapmode */
        _this._wrapModeMap = new Map();
        return _this;
    }
    AnimatorAnimation.prototype.start = function () {
        if (!this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this._animation = this.getComponent(cc.Animation);
        this._animation.on(cc.Animation.EventType.FINISHED, this.onAnimFinished, this);
        this._animation.on(cc.Animation.EventType.LASTFRAME, this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @override
     */
    AnimatorAnimation.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this.initArgs.apply(this, args);
        this._animation = this.getComponent(cc.Animation);
        this._animation.on(cc.Animation.EventType.FINISHED, this.onAnimFinished, this);
        this._animation.on(cc.Animation.EventType.LASTFRAME, this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 播放动画
     * @override
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorAnimation.prototype.playAnimation = function (animName, loop) {
        if (!animName) {
            return;
        }
        this._animState = this._animation.play(animName);
        if (!this._animState) {
            return;
        }
        if (!this._wrapModeMap.has(this._animState)) {
            this._wrapModeMap.set(this._animState, this._animState.wrapMode);
        }
        this._animState.wrapMode = loop ? cc.WrapMode.Loop : this._wrapModeMap.get(this._animState);
    };
    /**
     * 缩放动画播放速率
     * @override
     * @param scale 缩放倍率
     */
    AnimatorAnimation.prototype.scaleTime = function (scale) {
        if (this._animState) {
            this._animState.speed = scale;
        }
    };
    AnimatorAnimation = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(cc.Animation),
        menu('Framework/Animator/AnimatorAnimation')
    ], AnimatorAnimation);
    return AnimatorAnimation;
}(AnimatorBase_1.default));
exports.default = AnimatorAnimation;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXEFuaW1hdG9yQW5pbWF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUFvRTtBQUc5RCxJQUFBLEtBQWtFLEVBQUUsQ0FBQyxVQUFVLEVBQTdFLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUV0Rjs7R0FFRztBQUtIO0lBQStDLHFDQUFZO0lBQTNEO1FBQUEscUVBOEVDO1FBN0VHLGtCQUFrQjtRQUNWLGdCQUFVLEdBQWlCLElBQUksQ0FBQztRQUN4QyxjQUFjO1FBQ04sZ0JBQVUsR0FBc0IsSUFBSSxDQUFDO1FBQzdDLG9CQUFvQjtRQUNaLGtCQUFZLEdBQXdDLElBQUksR0FBRyxFQUFFLENBQUM7O0lBd0UxRSxDQUFDO0lBdEVhLGlDQUFLLEdBQWY7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ3BDLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXJCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDL0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFaEYsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUksRUFBRTtZQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEM7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksa0NBQU0sR0FBYjtRQUFjLGNBQWtIO2FBQWxILFVBQWtILEVBQWxILHFCQUFrSCxFQUFsSCxJQUFrSDtZQUFsSCx5QkFBa0g7O1FBQzVILElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ25DLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXJCLElBQUksQ0FBQyxRQUFRLE9BQWIsSUFBSSxFQUFhLElBQUksRUFBRTtRQUV2QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9FLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWhGLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08seUNBQWEsR0FBdkIsVUFBd0IsUUFBZ0IsRUFBRSxJQUFhO1FBQ25ELElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDWCxPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2xCLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDekMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hHLENBQUM7SUFFRDs7OztPQUlHO0lBQ08scUNBQVMsR0FBbkIsVUFBb0IsS0FBYTtRQUM3QixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1NBQ2pDO0lBQ0wsQ0FBQztJQTdFZ0IsaUJBQWlCO1FBSnJDLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQztRQUM5QixJQUFJLENBQUMsc0NBQXNDLENBQUM7T0FDeEIsaUJBQWlCLENBOEVyQztJQUFELHdCQUFDO0NBOUVELEFBOEVDLENBOUU4QyxzQkFBWSxHQThFMUQ7a0JBOUVvQixpQkFBaUIiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW5pbWF0b3JCYXNlLCB7IEFuaW1hdGlvblBsYXllciB9IGZyb20gXCIuL2NvcmUvQW5pbWF0b3JCYXNlXCI7XHJcbmltcG9ydCBBbmltYXRvclN0YXRlTG9naWMgZnJvbSBcIi4vY29yZS9BbmltYXRvclN0YXRlTG9naWNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIHJlcXVpcmVDb21wb25lbnQsIGRpc2FsbG93TXVsdGlwbGUsIG1lbnUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKiogXHJcbiAqIENvY29zIEFuaW1hdGlvbueKtuaAgeacuue7hOS7tlxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGRpc2FsbG93TXVsdGlwbGVcclxuQHJlcXVpcmVDb21wb25lbnQoY2MuQW5pbWF0aW9uKVxyXG5AbWVudSgnRnJhbWV3b3JrL0FuaW1hdG9yL0FuaW1hdG9yQW5pbWF0aW9uJylcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRvckJhc2Uge1xyXG4gICAgLyoqIEFuaW1hdGlvbue7hOS7tiAqL1xyXG4gICAgcHJpdmF0ZSBfYW5pbWF0aW9uOiBjYy5BbmltYXRpb24gPSBudWxsO1xyXG4gICAgLyoqIOW9k+WJjeeahOWKqOeUu+WunuS+iyAqL1xyXG4gICAgcHJpdmF0ZSBfYW5pbVN0YXRlOiBjYy5BbmltYXRpb25TdGF0ZSA9IG51bGw7XHJcbiAgICAvKiog6K6w5b2V5Yid5aeL55qEd3JhcG1vZGUgKi9cclxuICAgIHByaXZhdGUgX3dyYXBNb2RlTWFwOiBNYXA8Y2MuQW5pbWF0aW9uU3RhdGUsIGNjLldyYXBNb2RlPiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBsYXlPblN0YXJ0IHx8IHRoaXMuX2hhc0luaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYXNJbml0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gdGhpcy5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb24ub24oY2MuQW5pbWF0aW9uLkV2ZW50VHlwZS5GSU5JU0hFRCwgdGhpcy5vbkFuaW1GaW5pc2hlZCwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uLm9uKGNjLkFuaW1hdGlvbi5FdmVudFR5cGUuTEFTVEZSQU1FLCB0aGlzLm9uQW5pbUZpbmlzaGVkLCB0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXNzZXRSYXdVcmwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0SnNvbih0aGlzLmFzc2V0UmF3VXJsLmpzb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaJi+WKqOWIneWni+WMlueKtuaAgeacuu+8jOWPr+S8oOWFpTAtM+S4quWPguaVsO+8jOexu+Wei+WmguS4i1xyXG4gICAgICogLSBvblN0YXRlQ2hhbmdlQ2FsbCDnirbmgIHliIfmjaLml7bnmoTlm57osINcclxuICAgICAqIC0gc3RhdGVMb2dpY01hcCDlkITkuKrnirbmgIHpgLvovpHmjqfliLZcclxuICAgICAqIC0gYW5pbWF0aW9uUGxheWVyIOiHquWumuS5ieWKqOeUu+aOp+WItlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkluaXQoLi4uYXJnczogQXJyYXk8TWFwPHN0cmluZywgQW5pbWF0b3JTdGF0ZUxvZ2ljPiB8ICgoZnJvbVN0YXRlOiBzdHJpbmcsIHRvU3RhdGU6IHN0cmluZykgPT4gdm9pZCkgfCBBbmltYXRpb25QbGF5ZXI+KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGxheU9uU3RhcnQgfHwgdGhpcy5faGFzSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc0luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmluaXRBcmdzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB0aGlzLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbi5vbihjYy5BbmltYXRpb24uRXZlbnRUeXBlLkZJTklTSEVELCB0aGlzLm9uQW5pbUZpbmlzaGVkLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb24ub24oY2MuQW5pbWF0aW9uLkV2ZW50VHlwZS5MQVNURlJBTUUsIHRoaXMub25BbmltRmluaXNoZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hc3NldFJhd1VybCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRKc29uKHRoaXMuYXNzZXRSYXdVcmwuanNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pKt5pS+5Yqo55S7XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSBhbmltTmFtZSDliqjnlLvlkI1cclxuICAgICAqIEBwYXJhbSBsb29wIOaYr+WQpuW+queOr+aSreaUvlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGxheUFuaW1hdGlvbihhbmltTmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKCFhbmltTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9hbmltU3RhdGUgPSB0aGlzLl9hbmltYXRpb24ucGxheShhbmltTmFtZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hbmltU3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3dyYXBNb2RlTWFwLmhhcyh0aGlzLl9hbmltU3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyYXBNb2RlTWFwLnNldCh0aGlzLl9hbmltU3RhdGUsIHRoaXMuX2FuaW1TdGF0ZS53cmFwTW9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FuaW1TdGF0ZS53cmFwTW9kZSA9IGxvb3AgPyBjYy5XcmFwTW9kZS5Mb29wIDogdGhpcy5fd3JhcE1vZGVNYXAuZ2V0KHRoaXMuX2FuaW1TdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnvKnmlL7liqjnlLvmkq3mlL7pgJ/njodcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIHNjYWxlIOe8qeaUvuWAjeeOh1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2NhbGVUaW1lKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fYW5pbVN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1TdGF0ZS5zcGVlZCA9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/AnimatorDragonBones.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0592f2y1olA0bK1DdnYDaoE', 'AnimatorDragonBones');
// scripts/animator/AnimatorDragonBones.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorBase_1 = require("./core/AnimatorBase");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * DragonBones状态机组件
 */
var AnimatorDragonBones = /** @class */ (function (_super) {
    __extends(AnimatorDragonBones, _super);
    function AnimatorDragonBones() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** DragonBones组件 */
        _this._dragonBones = null;
        return _this;
    }
    AnimatorDragonBones.prototype.start = function () {
        if (!this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this._dragonBones = this.getComponent(dragonBones.ArmatureDisplay);
        this._dragonBones.addEventListener(dragonBones.EventObject.COMPLETE, this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @override
     */
    AnimatorDragonBones.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.playOnStart || this._hasInit) {
            return;
        }
        this._hasInit = true;
        this.initArgs.apply(this, args);
        this._dragonBones = this.getComponent(dragonBones.ArmatureDisplay);
        this._dragonBones.addEventListener(dragonBones.EventObject.COMPLETE, this.onAnimFinished, this);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 播放动画
     * @override
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorDragonBones.prototype.playAnimation = function (animName, loop) {
        animName && this._dragonBones.playAnimation(animName, loop ? 0 : -1);
    };
    /**
     * 缩放动画播放速率
     * @override
     * @param scale 缩放倍率
     */
    AnimatorDragonBones.prototype.scaleTime = function (scale) {
        this._dragonBones.timeScale = scale;
    };
    AnimatorDragonBones = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(dragonBones.ArmatureDisplay),
        menu('Framework/Animator/AnimatorDragonBones')
    ], AnimatorDragonBones);
    return AnimatorDragonBones;
}(AnimatorBase_1.default));
exports.default = AnimatorDragonBones;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXEFuaW1hdG9yRHJhZ29uQm9uZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQW9FO0FBRzlELElBQUEsS0FBa0UsRUFBRSxDQUFDLFVBQVUsRUFBN0UsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsSUFBSSxVQUFrQixDQUFDO0FBRXRGOztHQUVHO0FBS0g7SUFBaUQsdUNBQVk7SUFBN0Q7UUFBQSxxRUEyREM7UUExREcsb0JBQW9CO1FBQ1osa0JBQVksR0FBZ0MsSUFBSSxDQUFDOztJQXlEN0QsQ0FBQztJQXZEYSxtQ0FBSyxHQUFmO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNwQyxPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUVyQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVoRyxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxFQUFFO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QztJQUNMLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxvQ0FBTSxHQUFiO1FBQWMsY0FBa0g7YUFBbEgsVUFBa0gsRUFBbEgscUJBQWtILEVBQWxILElBQWtIO1lBQWxILHlCQUFrSDs7UUFDNUgsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbkMsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFckIsSUFBSSxDQUFDLFFBQVEsT0FBYixJQUFJLEVBQWEsSUFBSSxFQUFFO1FBRXZCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDbkUsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWhHLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sMkNBQWEsR0FBdkIsVUFBd0IsUUFBZ0IsRUFBRSxJQUFhO1FBQ25ELFFBQVEsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyx1Q0FBUyxHQUFuQixVQUFvQixLQUFhO1FBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUN4QyxDQUFDO0lBMURnQixtQkFBbUI7UUFKdkMsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDO1FBQzdDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQztPQUMxQixtQkFBbUIsQ0EyRHZDO0lBQUQsMEJBQUM7Q0EzREQsQUEyREMsQ0EzRGdELHNCQUFZLEdBMkQ1RDtrQkEzRG9CLG1CQUFtQiIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBbmltYXRvckJhc2UsIHsgQW5pbWF0aW9uUGxheWVyIH0gZnJvbSBcIi4vY29yZS9BbmltYXRvckJhc2VcIjtcclxuaW1wb3J0IEFuaW1hdG9yU3RhdGVMb2dpYyBmcm9tIFwiLi9jb3JlL0FuaW1hdG9yU3RhdGVMb2dpY1wiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgcmVxdWlyZUNvbXBvbmVudCwgZGlzYWxsb3dNdWx0aXBsZSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKiBcclxuICogRHJhZ29uQm9uZXPnirbmgIHmnLrnu4Tku7ZcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkByZXF1aXJlQ29tcG9uZW50KGRyYWdvbkJvbmVzLkFybWF0dXJlRGlzcGxheSlcclxuQG1lbnUoJ0ZyYW1ld29yay9BbmltYXRvci9BbmltYXRvckRyYWdvbkJvbmVzJylcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JEcmFnb25Cb25lcyBleHRlbmRzIEFuaW1hdG9yQmFzZSB7XHJcbiAgICAvKiogRHJhZ29uQm9uZXPnu4Tku7YgKi9cclxuICAgIHByaXZhdGUgX2RyYWdvbkJvbmVzOiBkcmFnb25Cb25lcy5Bcm1hdHVyZURpc3BsYXkgPSBudWxsO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGxheU9uU3RhcnQgfHwgdGhpcy5faGFzSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc0luaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9kcmFnb25Cb25lcyA9IHRoaXMuZ2V0Q29tcG9uZW50KGRyYWdvbkJvbmVzLkFybWF0dXJlRGlzcGxheSk7XHJcbiAgICAgICAgdGhpcy5fZHJhZ29uQm9uZXMuYWRkRXZlbnRMaXN0ZW5lcihkcmFnb25Cb25lcy5FdmVudE9iamVjdC5DT01QTEVURSwgdGhpcy5vbkFuaW1GaW5pc2hlZCwgdGhpcyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFzc2V0UmF3VXJsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEpzb24odGhpcy5hc3NldFJhd1VybC5qc29uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmiYvliqjliJ3lp4vljJbnirbmgIHmnLrvvIzlj6/kvKDlhaUwLTPkuKrlj4LmlbDvvIznsbvlnovlpoLkuItcclxuICAgICAqIC0gb25TdGF0ZUNoYW5nZUNhbGwg54q25oCB5YiH5o2i5pe255qE5Zue6LCDXHJcbiAgICAgKiAtIHN0YXRlTG9naWNNYXAg5ZCE5Liq54q25oCB6YC76L6R5o6n5Yi2XHJcbiAgICAgKiAtIGFuaW1hdGlvblBsYXllciDoh6rlrprkuYnliqjnlLvmjqfliLZcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25Jbml0KC4uLmFyZ3M6IEFycmF5PE1hcDxzdHJpbmcsIEFuaW1hdG9yU3RhdGVMb2dpYz4gfCAoKGZyb21TdGF0ZTogc3RyaW5nLCB0b1N0YXRlOiBzdHJpbmcpID0+IHZvaWQpIHwgQW5pbWF0aW9uUGxheWVyPikge1xyXG4gICAgICAgIGlmICh0aGlzLnBsYXlPblN0YXJ0IHx8IHRoaXMuX2hhc0luaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYXNJbml0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0QXJncyguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZHJhZ29uQm9uZXMgPSB0aGlzLmdldENvbXBvbmVudChkcmFnb25Cb25lcy5Bcm1hdHVyZURpc3BsYXkpO1xyXG4gICAgICAgIHRoaXMuX2RyYWdvbkJvbmVzLmFkZEV2ZW50TGlzdGVuZXIoZHJhZ29uQm9uZXMuRXZlbnRPYmplY3QuQ09NUExFVEUsIHRoaXMub25BbmltRmluaXNoZWQsIHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hc3NldFJhd1VybCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRKc29uKHRoaXMuYXNzZXRSYXdVcmwuanNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pKt5pS+5Yqo55S7XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSBhbmltTmFtZSDliqjnlLvlkI1cclxuICAgICAqIEBwYXJhbSBsb29wIOaYr+WQpuW+queOr+aSreaUvlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGxheUFuaW1hdGlvbihhbmltTmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuKSB7XHJcbiAgICAgICAgYW5pbU5hbWUgJiYgdGhpcy5fZHJhZ29uQm9uZXMucGxheUFuaW1hdGlvbihhbmltTmFtZSwgbG9vcCA/IDAgOiAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnvKnmlL7liqjnlLvmkq3mlL7pgJ/njodcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIHNjYWxlIOe8qeaUvuWAjeeOh1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2NhbGVUaW1lKHNjYWxlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9kcmFnb25Cb25lcy50aW1lU2NhbGUgPSBzY2FsZTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorBase.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '33dabcEWT5IlqYLTD/ozvjl', 'AnimatorBase');
// scripts/animator/core/AnimatorBase.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorController_1 = require("./AnimatorController");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executionOrder = _a.executionOrder;
/**
 * 状态机组件基类 优先执行生命周期
 */
var AnimatorBase = /** @class */ (function (_super) {
    __extends(AnimatorBase, _super);
    function AnimatorBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.assetRawUrl = null;
        _this.playOnStart = true;
        _this.autoUpdate = true;
        /** 是否初始化 */
        _this._hasInit = false;
        /** 状态机控制 */
        _this._ac = null;
        /** 各个状态逻辑控制，key为状态名 */
        _this._stateLogicMap = null;
        /** 状态切换时的回调 */
        _this._onStateChangeCall = null;
        /** 自定义的动画播放控制器 */
        _this._animationPlayer = null;
        _this._extraMulti = 1;
        return _this;
    }
    Object.defineProperty(AnimatorBase.prototype, "extraMulti", {
        /** 统一控制所有动画播放速度的参数 */
        get: function () { return this._extraMulti; },
        set: function (v) {
            if (this._extraMulti === v) {
                return;
            }
            this._extraMulti = v;
            this.updatePlaySpeed();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "curStateName", {
        /** 当前状态名 */
        get: function () { return this._ac.curState.name; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "curStateMotion", {
        /** 当前动画名 */
        get: function () { return this._ac.curState.motion; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "animComplete", {
        /** 当前动画是否播放完毕 */
        get: function () { return this._ac.animComplete; },
        enumerable: false,
        configurable: true
    });
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @virtual
     */
    AnimatorBase.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    /**
     * 处理初始化参数
     */
    AnimatorBase.prototype.initArgs = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        args.forEach(function (arg) {
            if (!arg) {
                return;
            }
            if (typeof arg === 'function') {
                _this._onStateChangeCall = arg;
            }
            else if (typeof arg === 'object') {
                if (arg instanceof Map) {
                    _this._stateLogicMap = arg;
                }
                else {
                    _this._animationPlayer = arg;
                    _this._animationPlayer.setFinishedCallback(_this.onAnimFinished, _this);
                }
            }
        });
    };
    /**
     * 更新动画播放速度
     */
    AnimatorBase.prototype.updatePlaySpeed = function () {
        // 混合当前动画播放速度
        var playSpeed = this._ac.curState.speed * this.extraMulti;
        if (this._ac.curState.multi) {
            playSpeed *= this._ac.params.getNumber(this._ac.curState.multi) || 1;
        }
        this.scaleTime(playSpeed);
    };
    AnimatorBase.prototype.updateAnimator = function () {
        // 更新动画播放速度
        this.updatePlaySpeed();
        // 更新AnimatorStateLogic
        if (this._stateLogicMap) {
            var curLogic = this._stateLogicMap.get(this._ac.curState.name);
            curLogic && curLogic.onUpdate();
        }
        // 更新状态机逻辑
        this._ac.updateAnimator();
    };
    AnimatorBase.prototype.update = function () {
        if (this._hasInit && this.autoUpdate) {
            this.updateAnimator();
        }
    };
    /**
     * 手动调用更新
     */
    AnimatorBase.prototype.manualUpdate = function () {
        if (this._hasInit && !this.autoUpdate) {
            this.updateAnimator();
        }
    };
    /**
     * 解析状态机json文件
     */
    AnimatorBase.prototype.initJson = function (json) {
        this._ac = new AnimatorController_1.default(this, json);
        // 执行默认状态
        this._ac.changeState(json.defaultState);
    };
    /**
     * 动画结束的回调
     */
    AnimatorBase.prototype.onAnimFinished = function () {
        this._ac.onAnimationComplete();
    };
    /**
     * 播放动画
     * @virtual
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorBase.prototype.playAnimation = function (animName, loop) {
    };
    /**
     * 缩放动画播放速率
     * @virtual
     * @param scale 缩放倍率
     */
    AnimatorBase.prototype.scaleTime = function (scale) {
    };
    /**
     * 状态切换时的逻辑（状态机内部方法，不能由外部直接调用）
     */
    AnimatorBase.prototype.onStateChange = function (fromState, toState) {
        this.playAnimation(toState.motion, toState.loop);
        var fromStateName = fromState ? fromState.name : '';
        if (this._stateLogicMap) {
            var fromLogic = this._stateLogicMap.get(fromStateName);
            fromLogic && fromLogic.onExit();
            var toLogic = this._stateLogicMap.get(toState.name);
            toLogic && toLogic.onEntry();
        }
        this._onStateChangeCall && this._onStateChangeCall(fromStateName, toState.name);
    };
    /**
     * 设置boolean类型参数的值
     */
    AnimatorBase.prototype.setBool = function (key, value) {
        this._ac.params.setBool(key, value);
    };
    /**
     * 获取boolean类型参数的值
     */
    AnimatorBase.prototype.getBool = function (key) {
        return this._ac.params.getBool(key) !== 0;
    };
    /**
     * 设置number类型参数的值
     */
    AnimatorBase.prototype.setNumber = function (key, value) {
        this._ac.params.setNumber(key, value);
    };
    /**
     * 获取number类型参数的值
     */
    AnimatorBase.prototype.getNumber = function (key) {
        return this._ac.params.getNumber(key);
    };
    /**
     * 设置trigger类型参数的值
     */
    AnimatorBase.prototype.setTrigger = function (key) {
        this._ac.params.setTrigger(key);
    };
    /**
     * 重置trigger类型参数的值
     */
    AnimatorBase.prototype.resetTrigger = function (key) {
        this._ac.params.resetTrigger(key);
    };
    /**
     * 设置autoTrigger类型参数的值（autoTrigger类型参数不需要主动reset，每次状态机更新结束后会自动reset）
     */
    AnimatorBase.prototype.autoTrigger = function (key) {
        this._ac.params.autoTrigger(key);
    };
    /**
     * 无视条件直接跳转状态，如果当前已处于此状态则重置状态
     * @param 状态名
     */
    AnimatorBase.prototype.play = function (stateName) {
        if (!this._hasInit) {
            return;
        }
        this._ac.play(stateName);
    };
    __decorate([
        property({ type: cc.JsonAsset, tooltip: CC_DEV && '状态机json文件' })
    ], AnimatorBase.prototype, "assetRawUrl", void 0);
    __decorate([
        property({ tooltip: CC_DEV && '是否在start中自动启动状态机' })
    ], AnimatorBase.prototype, "playOnStart", void 0);
    __decorate([
        property({ tooltip: CC_DEV && '是否在update中自动触发状态机逻辑更新' })
    ], AnimatorBase.prototype, "autoUpdate", void 0);
    AnimatorBase = __decorate([
        ccclass,
        executionOrder(-1000)
    ], AnimatorBase);
    return AnimatorBase;
}(cc.Component));
exports.default = AnimatorBase;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yQmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyREFBc0Q7QUFJaEQsSUFBQSxLQUF3QyxFQUFFLENBQUMsVUFBVSxFQUFuRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxjQUFjLG9CQUFrQixDQUFDO0FBYzVEOztHQUVHO0FBR0g7SUFBMEMsZ0NBQVk7SUFBdEQ7UUFBQSxxRUE4TkM7UUE1TmEsaUJBQVcsR0FBaUIsSUFBSSxDQUFDO1FBR2pDLGlCQUFXLEdBQVksSUFBSSxDQUFDO1FBRzVCLGdCQUFVLEdBQVksSUFBSSxDQUFDO1FBRXJDLFlBQVk7UUFDRixjQUFRLEdBQVksS0FBSyxDQUFDO1FBQ3BDLFlBQVk7UUFDRixTQUFHLEdBQXVCLElBQUksQ0FBQztRQUV6Qyx1QkFBdUI7UUFDYixvQkFBYyxHQUFvQyxJQUFJLENBQUM7UUFDakUsZUFBZTtRQUNMLHdCQUFrQixHQUFpRCxJQUFJLENBQUM7UUFDbEYsa0JBQWtCO1FBQ1Isc0JBQWdCLEdBQW9CLElBQUksQ0FBQztRQUV6QyxpQkFBVyxHQUFXLENBQUMsQ0FBQzs7SUF3TXRDLENBQUM7SUF0TUcsc0JBQVcsb0NBQVU7UUFEckIsc0JBQXNCO2FBQ3RCLGNBQWtDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDNUQsVUFBc0IsQ0FBUztZQUMzQixJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssQ0FBQyxFQUFFO2dCQUN4QixPQUFPO2FBQ1Y7WUFDRCxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztZQUNyQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDM0IsQ0FBQzs7O09BUDJEO0lBVTVELHNCQUFXLHNDQUFZO1FBRHZCLFlBQVk7YUFDWixjQUFvQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsUUFB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UUFBUSxFQUFFO1lBQ2hCLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUEzTkQ7UUFEQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLFdBQVcsRUFBRSxDQUFDO3FEQUN0QjtJQUczQztRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksa0JBQWtCLEVBQUUsQ0FBQztxREFDZDtJQUd0QztRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksdUJBQXVCLEVBQUUsQ0FBQztvREFDcEI7SUFScEIsWUFBWTtRQUZoQyxPQUFPO1FBQ1AsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDO09BQ0QsWUFBWSxDQThOaEM7SUFBRCxtQkFBQztDQTlORCxBQThOQyxDQTlOeUMsRUFBRSxDQUFDLFNBQVMsR0E4TnJEO2tCQTlOb0IsWUFBWSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBbmltYXRvckNvbnRyb2xsZXIgZnJvbSBcIi4vQW5pbWF0b3JDb250cm9sbGVyXCI7XHJcbmltcG9ydCBBbmltYXRvclN0YXRlIGZyb20gXCIuL0FuaW1hdG9yU3RhdGVcIjtcclxuaW1wb3J0IEFuaW1hdG9yU3RhdGVMb2dpYyBmcm9tIFwiLi9BbmltYXRvclN0YXRlTG9naWNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIGV4ZWN1dGlvbk9yZGVyIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOiHquWumuS5ieaOp+WItuWKqOeUu+aSreaUvueahOaOpeWPo1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25QbGF5ZXIge1xyXG4gICAgLyoqIOiuvue9ruWKqOeUu+aSreaUvue7k+adn+eahOWbnuiwgyAqL1xyXG4gICAgc2V0RmluaXNoZWRDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCwgdGFyZ2V0OiBhbnkpOiB2b2lkO1xyXG4gICAgLyoqIOaSreaUvuWKqOeUuyAqL1xyXG4gICAgcGxheUFuaW1hdGlvbihhbmltTmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuKTogdm9pZDtcclxuICAgIC8qKiDnvKnmlL7liqjnlLvmkq3mlL7pgJ/njocgKi9cclxuICAgIHNjYWxlVGltZShzY2FsZTogbnVtYmVyKTogdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIOeKtuaAgeacuue7hOS7tuWfuuexuyDkvJjlhYjmiafooYznlJ/lkb3lkajmnJ9cclxuICovXHJcbkBjY2NsYXNzXHJcbkBleGVjdXRpb25PcmRlcigtMTAwMClcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JCYXNlIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eSh7IHR5cGU6IGNjLkpzb25Bc3NldCwgdG9vbHRpcDogQ0NfREVWICYmICfnirbmgIHmnLpqc29u5paH5Lu2JyB9KVxyXG4gICAgcHJvdGVjdGVkIGFzc2V0UmF3VXJsOiBjYy5Kc29uQXNzZXQgPSBudWxsO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiAn5piv5ZCm5Zyoc3RhcnTkuK3oh6rliqjlkK/liqjnirbmgIHmnLonIH0pXHJcbiAgICBwcm90ZWN0ZWQgcGxheU9uU3RhcnQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiAn5piv5ZCm5ZyodXBkYXRl5Lit6Ieq5Yqo6Kem5Y+R54q25oCB5py66YC76L6R5pu05pawJyB9KVxyXG4gICAgcHJvdGVjdGVkIGF1dG9VcGRhdGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKiDmmK/lkKbliJ3lp4vljJYgKi9cclxuICAgIHByb3RlY3RlZCBfaGFzSW5pdDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIOeKtuaAgeacuuaOp+WItiAqL1xyXG4gICAgcHJvdGVjdGVkIF9hYzogQW5pbWF0b3JDb250cm9sbGVyID0gbnVsbDtcclxuXHJcbiAgICAvKiog5ZCE5Liq54q25oCB6YC76L6R5o6n5Yi277yMa2V55Li654q25oCB5ZCNICovXHJcbiAgICBwcm90ZWN0ZWQgX3N0YXRlTG9naWNNYXA6IE1hcDxzdHJpbmcsIEFuaW1hdG9yU3RhdGVMb2dpYz4gPSBudWxsO1xyXG4gICAgLyoqIOeKtuaAgeWIh+aNouaXtueahOWbnuiwgyAqL1xyXG4gICAgcHJvdGVjdGVkIF9vblN0YXRlQ2hhbmdlQ2FsbDogKGZyb21TdGF0ZTogc3RyaW5nLCB0b1N0YXRlOiBzdHJpbmcpID0+IHZvaWQgPSBudWxsO1xyXG4gICAgLyoqIOiHquWumuS5ieeahOWKqOeUu+aSreaUvuaOp+WItuWZqCAqL1xyXG4gICAgcHJvdGVjdGVkIF9hbmltYXRpb25QbGF5ZXI6IEFuaW1hdGlvblBsYXllciA9IG51bGw7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9leHRyYU11bHRpOiBudW1iZXIgPSAxO1xyXG4gICAgLyoqIOe7n+S4gOaOp+WItuaJgOacieWKqOeUu+aSreaUvumAn+W6pueahOWPguaVsCAqL1xyXG4gICAgcHVibGljIGdldCBleHRyYU11bHRpKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9leHRyYU11bHRpOyB9XHJcbiAgICBwdWJsaWMgc2V0IGV4dHJhTXVsdGkodjogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V4dHJhTXVsdGkgPT09IHYpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9leHRyYU11bHRpID0gdjtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBsYXlTcGVlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiDlvZPliY3nirbmgIHlkI0gKi9cclxuICAgIHB1YmxpYyBnZXQgY3VyU3RhdGVOYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9hYy5jdXJTdGF0ZS5uYW1lOyB9XHJcbiAgICAvKiog5b2T5YmN5Yqo55S75ZCNICovXHJcbiAgICBwdWJsaWMgZ2V0IGN1clN0YXRlTW90aW9uKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9hYy5jdXJTdGF0ZS5tb3Rpb247IH1cclxuICAgIC8qKiDlvZPliY3liqjnlLvmmK/lkKbmkq3mlL7lrozmr5UgKi9cclxuICAgIHB1YmxpYyBnZXQgYW5pbUNvbXBsZXRlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYWMuYW5pbUNvbXBsZXRlOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmiYvliqjliJ3lp4vljJbnirbmgIHmnLrvvIzlj6/kvKDlhaUwLTPkuKrlj4LmlbDvvIznsbvlnovlpoLkuItcclxuICAgICAqIC0gb25TdGF0ZUNoYW5nZUNhbGwg54q25oCB5YiH5o2i5pe255qE5Zue6LCDXHJcbiAgICAgKiAtIHN0YXRlTG9naWNNYXAg5ZCE5Liq54q25oCB6YC76L6R5o6n5Yi2XHJcbiAgICAgKiAtIGFuaW1hdGlvblBsYXllciDoh6rlrprkuYnliqjnlLvmjqfliLZcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkluaXQoLi4uYXJnczogQXJyYXk8TWFwPHN0cmluZywgQW5pbWF0b3JTdGF0ZUxvZ2ljPiB8ICgoZnJvbVN0YXRlOiBzdHJpbmcsIHRvU3RhdGU6IHN0cmluZykgPT4gdm9pZCkgfCBBbmltYXRpb25QbGF5ZXI+KSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlpITnkIbliJ3lp4vljJblj4LmlbBcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGluaXRBcmdzKC4uLmFyZ3M6IEFycmF5PE1hcDxzdHJpbmcsIEFuaW1hdG9yU3RhdGVMb2dpYz4gfCAoKGZyb21TdGF0ZTogc3RyaW5nLCB0b1N0YXRlOiBzdHJpbmcpID0+IHZvaWQpIHwgQW5pbWF0aW9uUGxheWVyPikge1xyXG4gICAgICAgIGFyZ3MuZm9yRWFjaCgoYXJnKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghYXJnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VDYWxsID0gYXJnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVMb2dpY01hcCA9IGFyZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUGxheWVyID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblBsYXllci5zZXRGaW5pc2hlZENhbGxiYWNrKHRoaXMub25BbmltRmluaXNoZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDliqjnlLvmkq3mlL7pgJ/luqZcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVQbGF5U3BlZWQoKSB7XHJcbiAgICAgICAgLy8g5re35ZCI5b2T5YmN5Yqo55S75pKt5pS+6YCf5bqmXHJcbiAgICAgICAgbGV0IHBsYXlTcGVlZCA9IHRoaXMuX2FjLmN1clN0YXRlLnNwZWVkICogdGhpcy5leHRyYU11bHRpO1xyXG4gICAgICAgIGlmICh0aGlzLl9hYy5jdXJTdGF0ZS5tdWx0aSkge1xyXG4gICAgICAgICAgICBwbGF5U3BlZWQgKj0gdGhpcy5fYWMucGFyYW1zLmdldE51bWJlcih0aGlzLl9hYy5jdXJTdGF0ZS5tdWx0aSkgfHwgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY2FsZVRpbWUocGxheVNwZWVkKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUFuaW1hdG9yKCkge1xyXG4gICAgICAgIC8vIOabtOaWsOWKqOeUu+aSreaUvumAn+W6plxyXG4gICAgICAgIHRoaXMudXBkYXRlUGxheVNwZWVkKCk7XHJcblxyXG4gICAgICAgIC8vIOabtOaWsEFuaW1hdG9yU3RhdGVMb2dpY1xyXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZUxvZ2ljTWFwKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJMb2dpYyA9IHRoaXMuX3N0YXRlTG9naWNNYXAuZ2V0KHRoaXMuX2FjLmN1clN0YXRlLm5hbWUpO1xyXG4gICAgICAgICAgICBjdXJMb2dpYyAmJiBjdXJMb2dpYy5vblVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pu05paw54q25oCB5py66YC76L6RXHJcbiAgICAgICAgdGhpcy5fYWMudXBkYXRlQW5pbWF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXNJbml0ICYmIHRoaXMuYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omL5Yqo6LCD55So5pu05pawXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYW51YWxVcGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc0luaXQgJiYgIXRoaXMuYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6Kej5p6Q54q25oCB5py6anNvbuaWh+S7tlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5pdEpzb24oanNvbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fYWMgPSBuZXcgQW5pbWF0b3JDb250cm9sbGVyKHRoaXMsIGpzb24pO1xyXG4gICAgICAgIC8vIOaJp+ihjOm7mOiupOeKtuaAgVxyXG4gICAgICAgIHRoaXMuX2FjLmNoYW5nZVN0YXRlKGpzb24uZGVmYXVsdFN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWKqOeUu+e7k+adn+eahOWbnuiwg1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25BbmltRmluaXNoZWQoKSB7XHJcbiAgICAgICAgdGhpcy5fYWMub25BbmltYXRpb25Db21wbGV0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pKt5pS+5Yqo55S7XHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQHBhcmFtIGFuaW1OYW1lIOWKqOeUu+WQjVxyXG4gICAgICogQHBhcmFtIGxvb3Ag5piv5ZCm5b6q546v5pKt5pS+XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwbGF5QW5pbWF0aW9uKGFuaW1OYW1lOiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4pIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8qeaUvuWKqOeUu+aSreaUvumAn+eOh1xyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqIEBwYXJhbSBzY2FsZSDnvKnmlL7lgI3njodcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNjYWxlVGltZShzY2FsZTogbnVtYmVyKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICog54q25oCB5YiH5o2i5pe255qE6YC76L6R77yI54q25oCB5py65YaF6YOo5pa55rOV77yM5LiN6IO955Sx5aSW6YOo55u05o6l6LCD55So77yJXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblN0YXRlQ2hhbmdlKGZyb21TdGF0ZTogQW5pbWF0b3JTdGF0ZSwgdG9TdGF0ZTogQW5pbWF0b3JTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMucGxheUFuaW1hdGlvbih0b1N0YXRlLm1vdGlvbiwgdG9TdGF0ZS5sb29wKTtcclxuXHJcbiAgICAgICAgbGV0IGZyb21TdGF0ZU5hbWUgPSBmcm9tU3RhdGUgPyBmcm9tU3RhdGUubmFtZSA6ICcnO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3RhdGVMb2dpY01hcCkge1xyXG4gICAgICAgICAgICBsZXQgZnJvbUxvZ2ljID0gdGhpcy5fc3RhdGVMb2dpY01hcC5nZXQoZnJvbVN0YXRlTmFtZSk7XHJcbiAgICAgICAgICAgIGZyb21Mb2dpYyAmJiBmcm9tTG9naWMub25FeGl0KCk7XHJcbiAgICAgICAgICAgIGxldCB0b0xvZ2ljID0gdGhpcy5fc3RhdGVMb2dpY01hcC5nZXQodG9TdGF0ZS5uYW1lKTtcclxuICAgICAgICAgICAgdG9Mb2dpYyAmJiB0b0xvZ2ljLm9uRW50cnkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX29uU3RhdGVDaGFuZ2VDYWxsICYmIHRoaXMuX29uU3RhdGVDaGFuZ2VDYWxsKGZyb21TdGF0ZU5hbWUsIHRvU3RhdGUubmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5ib29sZWFu57G75Z6L5Y+C5pWw55qE5YC8XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRCb29sKGtleTogc3RyaW5nLCB2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX2FjLnBhcmFtcy5zZXRCb29sKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WYm9vbGVhbuexu+Wei+WPguaVsOeahOWAvFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Qm9vbChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hYy5wYXJhbXMuZ2V0Qm9vbChrZXkpICE9PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572ubnVtYmVy57G75Z6L5Y+C5pWw55qE5YC8XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXROdW1iZXIoa2V5OiBzdHJpbmcsIHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9hYy5wYXJhbXMuc2V0TnVtYmVyKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WbnVtYmVy57G75Z6L5Y+C5pWw55qE5YC8XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXROdW1iZXIoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hYy5wYXJhbXMuZ2V0TnVtYmVyKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva50cmlnZ2Vy57G75Z6L5Y+C5pWw55qE5YC8XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUcmlnZ2VyKGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fYWMucGFyYW1zLnNldFRyaWdnZXIoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjee9rnRyaWdnZXLnsbvlnovlj4LmlbDnmoTlgLxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0VHJpZ2dlcihrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2FjLnBhcmFtcy5yZXNldFRyaWdnZXIoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rmF1dG9UcmlnZ2Vy57G75Z6L5Y+C5pWw55qE5YC877yIYXV0b1RyaWdnZXLnsbvlnovlj4LmlbDkuI3pnIDopoHkuLvliqhyZXNldO+8jOavj+asoeeKtuaAgeacuuabtOaWsOe7k+adn+WQjuS8muiHquWKqHJlc2V077yJXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdXRvVHJpZ2dlcihrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2FjLnBhcmFtcy5hdXRvVHJpZ2dlcihrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5peg6KeG5p2h5Lu255u05o6l6Lez6L2s54q25oCB77yM5aaC5p6c5b2T5YmN5bey5aSE5LqO5q2k54q25oCB5YiZ6YeN572u54q25oCBXHJcbiAgICAgKiBAcGFyYW0g54q25oCB5ZCNXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwbGF5KHN0YXRlTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNJbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWMucGxheShzdGF0ZU5hbWUpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/base/DialogBase.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9b83e2KZopKTb+TLQZNTspz', 'DialogBase');
// scripts/common/cmpt/base/DialogBase.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EditorTool_1 = require("../../util/EditorTool");
var Tool_1 = require("../../util/Tool");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * 弹窗基类
 */
var DialogBase = /** @class */ (function (_super) {
    __extends(DialogBase, _super);
    function DialogBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dlgAnim = null;
        _this.openClip = null;
        _this.closeClip = null;
        /** 外部的resolve函数，在弹窗close时调用 */
        _this._resolveList = [];
        _this._prefabUrl = "";
        return _this;
    }
    Object.defineProperty(DialogBase.prototype, "prefabUrl", {
        /** 弹窗prefab路径，规则同Res加载路径 */
        get: function () { return this._prefabUrl; },
        enumerable: false,
        configurable: true
    });
    DialogBase.prototype.onLoad = function () {
        if (this.dlgAnim) {
            this.openClip && this.dlgAnim.addClip(this.openClip);
            this.closeClip && this.dlgAnim.addClip(this.closeClip);
            this.dlgAnim.on(cc.Animation.EventType.FINISHED, this.onAnimFinished, this);
        }
    };
    DialogBase.prototype.resetInEditor = function () {
        var _this = this;
        if (!CC_EDITOR) {
            return;
        }
        // 动画
        for (var i = 0; i < this.node.childrenCount; i++) {
            var anim = this.node.children[i].getComponent(cc.Animation);
            if (anim) {
                this.dlgAnim = anim;
                EditorTool_1.default.load("res/animation/dialog/open.anim").then(function (v) { _this.openClip = v; });
                EditorTool_1.default.load("res/animation/dialog/close.anim").then(function (v) { _this.closeClip = v; });
                break;
            }
        }
        // 触摸拦截
        if (this.node.childrenCount <= 0 || !this.node.children[0].getComponent(cc.BlockInputEvents)) {
            var block = new cc.Node("Block");
            this.node.addChild(block);
            block.setSiblingIndex(0);
            block.setContentSize(this.node.getContentSize());
            block.addComponent(cc.BlockInputEvents);
            var widget = block.addComponent(cc.Widget);
            widget.isAlignTop = true;
            widget.isAlignBottom = true;
            widget.isAlignLeft = true;
            widget.isAlignRight = true;
        }
    };
    DialogBase.prototype.onAnimFinished = function () {
        if (this.dlgAnim.currentClip === this.closeClip) {
            this.close();
        }
    };
    /**
     * 打开动画
     */
    DialogBase.prototype.playOpen = function () {
        if (this.dlgAnim && this.openClip) {
            this.dlgAnim.play(this.openClip.name);
        }
    };
    /**
     * 关闭动画，动画结束回调中会调用close销毁
     */
    DialogBase.prototype.playClose = function () {
        if (this.dlgAnim && this.closeClip) {
            if (this.dlgAnim.getAnimationState(this.closeClip.name).isPlaying) {
                return;
            }
            this.dlgAnim.play(this.closeClip.name);
        }
        else {
            this.close();
        }
    };
    /**
     * 打开弹窗时的处理
     * @virtual
     */
    DialogBase.prototype.onOpen = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    /**
     * 关闭弹窗时的处理
     * @virtual
     */
    DialogBase.prototype.onClose = function () {
    };
    /**
     * 销毁弹窗节点时的处理。
     * - 必须使用此接口销毁，子类重写时请调用super.close()
     * @virtual
     */
    DialogBase.prototype.close = function () {
        this.onClose();
        this._resolveList.forEach(function (resolve) { resolve(); });
        this.node.removeFromParent();
        this.node.destroy();
    };
    /**
     * 关闭按钮回调
     * @virtual
     */
    DialogBase.prototype.onClickClose = function () {
        this.playClose();
    };
    /**
     * 添加外部resolve函数，在弹窗close时调用
     */
    DialogBase.prototype.addResolve = function (resolve) {
        Tool_1.default.arrayAdd(this._resolveList, resolve);
    };
    /** 弹窗prefab路径，规则同Res加载路径 */
    DialogBase.pUrl = "";
    __decorate([
        property(cc.Animation)
    ], DialogBase.prototype, "dlgAnim", void 0);
    __decorate([
        property({
            type: cc.AnimationClip,
            tooltip: CC_DEV && "打开弹窗的动画",
            visible: function () { return !!this.dlgAnim; }
        })
    ], DialogBase.prototype, "openClip", void 0);
    __decorate([
        property({
            type: cc.AnimationClip,
            tooltip: CC_DEV && "关闭弹窗的动画",
            visible: function () { return !!this.dlgAnim; }
        })
    ], DialogBase.prototype, "closeClip", void 0);
    DialogBase = __decorate([
        ccclass,
        disallowMultiple,
        menu("Framework/基础组件/DialogBase")
    ], DialogBase);
    return DialogBase;
}(cc.Component));
exports.default = DialogBase;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxiYXNlXFxEaWFsb2dCYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9EQUErQztBQUMvQyx3Q0FBbUM7QUFFN0IsSUFBQSxLQUFnRCxFQUFFLENBQUMsVUFBVSxFQUEzRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFFcEU7O0dBRUc7QUFJSDtJQUF3Qyw4QkFBWTtJQUFwRDtRQUFBLHFFQXNJQztRQWpJYSxhQUFPLEdBQWlCLElBQUksQ0FBQztRQU83QixjQUFRLEdBQXFCLElBQUksQ0FBQztRQU9sQyxlQUFTLEdBQXFCLElBQUksQ0FBQztRQUU3QywrQkFBK0I7UUFDdkIsa0JBQVksR0FBaUMsRUFBRSxDQUFDO1FBRWhELGdCQUFVLEdBQVcsRUFBRSxDQUFDOztJQThHcEMsQ0FBQztJQTVHRyxzQkFBVyxpQ0FBUztRQURwQiw0QkFBNEI7YUFDNUIsY0FBaUMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFFaEQsMkJBQU0sR0FBaEI7UUFDSSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDZCxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNyRCxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUN2RCxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUMvRTtJQUNMLENBQUM7SUFFUyxr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LElBQUksU0FBUztZQUM1QixPQUFPLGdCQUFLLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3ZDLENBQUM7aURBQzJDO0lBbkI1QixVQUFVO1FBSDlCLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDLDJCQUEyQixDQUFDO09BQ2IsVUFBVSxDQXNJOUI7SUFBRCxpQkFBQztDQXRJRCxBQXNJQyxDQXRJdUMsRUFBRSxDQUFDLFNBQVMsR0FzSW5EO2tCQXRJb0IsVUFBVSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFZGl0b3JUb29sIGZyb20gXCIuLi8uLi91dGlsL0VkaXRvclRvb2xcIjtcclxuaW1wb3J0IFRvb2wgZnJvbSBcIi4uLy4uL3V0aWwvVG9vbFwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgZGlzYWxsb3dNdWx0aXBsZSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiDlvLnnqpfln7rnsbtcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBtZW51KFwiRnJhbWV3b3JrL+WfuuehgOe7hOS7ti9EaWFsb2dCYXNlXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0Jhc2UgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgLyoqIOW8ueeql3ByZWZhYui3r+W+hO+8jOinhOWImeWQjFJlc+WKoOi9vei3r+W+hCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwVXJsOiBzdHJpbmcgPSBcIlwiO1xyXG5cclxuICAgIEBwcm9wZXJ0eShjYy5BbmltYXRpb24pXHJcbiAgICBwcm90ZWN0ZWQgZGxnQW5pbTogY2MuQW5pbWF0aW9uID0gbnVsbDtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLkFuaW1hdGlvbkNsaXAsXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5omT5byA5by556qX55qE5Yqo55S7XCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuICEhdGhpcy5kbGdBbmltOyB9XHJcbiAgICB9KVxyXG4gICAgcHJvdGVjdGVkIG9wZW5DbGlwOiBjYy5BbmltYXRpb25DbGlwID0gbnVsbDtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLkFuaW1hdGlvbkNsaXAsXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5YWz6Zet5by556qX55qE5Yqo55S7XCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuICEhdGhpcy5kbGdBbmltOyB9XHJcbiAgICB9KVxyXG4gICAgcHJvdGVjdGVkIGNsb3NlQ2xpcDogY2MuQW5pbWF0aW9uQ2xpcCA9IG51bGw7XHJcblxyXG4gICAgLyoqIOWklumDqOeahHJlc29sdmXlh73mlbDvvIzlnKjlvLnnqpdjbG9zZeaXtuiwg+eUqCAqL1xyXG4gICAgcHJpdmF0ZSBfcmVzb2x2ZUxpc3Q6IEFycmF5PCh2YWx1ZT86IGFueSkgPT4gdm9pZD4gPSBbXTtcclxuXHJcbiAgICBwcml2YXRlIF9wcmVmYWJVcmw6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAvKiog5by556qXcHJlZmFi6Lev5b6E77yM6KeE5YiZ5ZCMUmVz5Yqg6L296Lev5b6EICovXHJcbiAgICBwdWJsaWMgZ2V0IHByZWZhYlVybCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fcHJlZmFiVXJsOyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5kbGdBbmltKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbkNsaXAgJiYgdGhpcy5kbGdBbmltLmFkZENsaXAodGhpcy5vcGVuQ2xpcCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDbGlwICYmIHRoaXMuZGxnQW5pbS5hZGRDbGlwKHRoaXMuY2xvc2VDbGlwKTtcclxuICAgICAgICAgICAgdGhpcy5kbGdBbmltLm9uKGNjLkFuaW1hdGlvbi5FdmVudFR5cGUuRklOSVNIRUQsIHRoaXMub25BbmltRmluaXNoZWQsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVzZXRJbkVkaXRvcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIUNDX0VESVRPUikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWKqOeUu1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ub2RlLmNoaWxkcmVuQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYW5pbTogY2MuQW5pbWF0aW9uID0gdGhpcy5ub2RlLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoYW5pbSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kbGdBbmltID0gYW5pbTtcclxuICAgICAgICAgICAgICAgIEVkaXRvclRvb2wubG9hZDxjYy5BbmltYXRpb25DbGlwPihcInJlcy9hbmltYXRpb24vZGlhbG9nL29wZW4uYW5pbVwiKS50aGVuKCh2KSA9PiB7IHRoaXMub3BlbkNsaXAgPSB2OyB9KTtcclxuICAgICAgICAgICAgICAgIEVkaXRvclRvb2wubG9hZDxjYy5BbmltYXRpb25DbGlwPihcInJlcy9hbmltYXRpb24vZGlhbG9nL2Nsb3NlLmFuaW1cIikudGhlbigodikgPT4geyB0aGlzLmNsb3NlQ2xpcCA9IHY7IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6Kem5pG45oum5oiqXHJcbiAgICAgICAgaWYgKHRoaXMubm9kZS5jaGlsZHJlbkNvdW50IDw9IDAgfHwgIXRoaXMubm9kZS5jaGlsZHJlblswXS5nZXRDb21wb25lbnQoY2MuQmxvY2tJbnB1dEV2ZW50cykpIHtcclxuICAgICAgICAgICAgbGV0IGJsb2NrID0gbmV3IGNjLk5vZGUoXCJCbG9ja1wiKTtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFkZENoaWxkKGJsb2NrKTtcclxuICAgICAgICAgICAgYmxvY2suc2V0U2libGluZ0luZGV4KDApO1xyXG4gICAgICAgICAgICBibG9jay5zZXRDb250ZW50U2l6ZSh0aGlzLm5vZGUuZ2V0Q29udGVudFNpemUoKSk7XHJcbiAgICAgICAgICAgIGJsb2NrLmFkZENvbXBvbmVudChjYy5CbG9ja0lucHV0RXZlbnRzKTtcclxuICAgICAgICAgICAgbGV0IHdpZGdldCA9IGJsb2NrLmFkZENvbXBvbmVudChjYy5XaWRnZXQpO1xyXG4gICAgICAgICAgICB3aWRnZXQuaXNBbGlnblRvcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdpZGdldC5pc0FsaWduQm90dG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2lkZ2V0LmlzQWxpZ25MZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2lkZ2V0LmlzQWxpZ25SaWdodCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkFuaW1GaW5pc2hlZCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5kbGdBbmltLmN1cnJlbnRDbGlwID09PSB0aGlzLmNsb3NlQ2xpcCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5Yqo55S7XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwbGF5T3BlbigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5kbGdBbmltICYmIHRoaXMub3BlbkNsaXApIHtcclxuICAgICAgICAgICAgdGhpcy5kbGdBbmltLnBsYXkodGhpcy5vcGVuQ2xpcC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63liqjnlLvvvIzliqjnlLvnu5PmnZ/lm57osIPkuK3kvJrosIPnlKhjbG9zZemUgOavgVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGxheUNsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmRsZ0FuaW0gJiYgdGhpcy5jbG9zZUNsaXApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGxnQW5pbS5nZXRBbmltYXRpb25TdGF0ZSh0aGlzLmNsb3NlQ2xpcC5uYW1lKS5pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRsZ0FuaW0ucGxheSh0aGlzLmNsb3NlQ2xpcC5uYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5by556qX5pe255qE5aSE55CGXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25PcGVuKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63lvLnnqpfml7bnmoTlpITnkIZcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkNsb3NlKCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6ZSA5q+B5by556qX6IqC54K55pe255qE5aSE55CG44CCXHJcbiAgICAgKiAtIOW/hemhu+S9v+eUqOatpOaOpeWPo+mUgOavge+8jOWtkOexu+mHjeWGmeaXtuivt+iwg+eUqHN1cGVyLmNsb3NlKClcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlTGlzdC5mb3JFYWNoKChyZXNvbHZlKSA9PiB7IHJlc29sdmUoKTsgfSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YWz6Zet5oyJ6ZKu5Zue6LCDXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25DbGlja0Nsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGxheUNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDlpJbpg6hyZXNvbHZl5Ye95pWw77yM5Zyo5by556qXY2xvc2Xml7bosIPnlKhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFJlc29sdmUocmVzb2x2ZTogKHZhbHVlPzogYW55KSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgVG9vbC5hcnJheUFkZCh0aGlzLl9yZXNvbHZlTGlzdCwgcmVzb2x2ZSk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/shader/ShaderOutline.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'd2a0bLIldJHoqHhJxTVBs5H', 'ShaderOutline');
// scripts/common/cmpt/shader/ShaderOutline.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple, executeInEditMode = _a.executeInEditMode;
var OutlineType;
(function (OutlineType) {
    OutlineType[OutlineType["NONE"] = 0] = "NONE";
    /** 外描边 */
    OutlineType[OutlineType["OUT"] = 1] = "OUT";
    /** 内描边 */
    OutlineType[OutlineType["INNER"] = 2] = "INNER";
})(OutlineType || (OutlineType = {}));
var ShaderOutline = /** @class */ (function (_super) {
    __extends(ShaderOutline, _super);
    function ShaderOutline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.outlineColor = new cc.Color();
        _this.outLineWidth = 0;
        _this.outlineType = OutlineType.NONE;
        _this.textureSize = new cc.Size(1, 1);
        _this._mat = null;
        return _this;
    }
    Object.defineProperty(ShaderOutline.prototype, "mat", {
        get: function () {
            if (!this._mat) {
                this._mat = this.getComponent(cc.RenderComponent).getMaterial(0);
            }
            return this._mat;
        },
        enumerable: false,
        configurable: true
    });
    ShaderOutline.prototype.start = function () {
        this.updateShader();
    };
    ShaderOutline.prototype.update = function () {
        if (CC_EDITOR) {
            this.updateShader();
        }
    };
    ShaderOutline.prototype.updateShader = function () {
        this.mat.setProperty("outlineColor", this.outlineColor);
        this.mat.setProperty("outlineInfo", new cc.Vec4(this.textureSize.width, this.textureSize.height, this.outLineWidth, this.outlineType));
    };
    __decorate([
        property({ tooltip: CC_DEV && "描边颜色" })
    ], ShaderOutline.prototype, "outlineColor", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "描边宽度" })
    ], ShaderOutline.prototype, "outLineWidth", void 0);
    __decorate([
        property({ type: cc.Enum(OutlineType), tooltip: CC_DEV && "描边类型" })
    ], ShaderOutline.prototype, "outlineType", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "纹理大小" })
    ], ShaderOutline.prototype, "textureSize", void 0);
    ShaderOutline = __decorate([
        ccclass,
        disallowMultiple,
        executeInEditMode,
        menu("Framework/Shader/ShaderOutline")
    ], ShaderOutline);
    return ShaderOutline;
}(cc.Component));
exports.default = ShaderOutline;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxzaGFkZXJcXFNoYWRlck91dGxpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU0sSUFBQSxLQUFtRSxFQUFFLENBQUMsVUFBVSxFQUE5RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxpQkFBaUIsdUJBQWtCLENBQUM7QUFFdkYsSUFBSyxXQU1KO0FBTkQsV0FBSyxXQUFXO0lBQ1osNkNBQVEsQ0FBQTtJQUNSLFVBQVU7SUFDViwyQ0FBTyxDQUFBO0lBQ1AsVUFBVTtJQUNWLCtDQUFTLENBQUE7QUFDYixDQUFDLEVBTkksV0FBVyxLQUFYLFdBQVcsUUFNZjtBQU1EO0lBQTJDLGlDQUFZO0lBQXZEO1FBQUEscUVBZ0NDO1FBOUJVLGtCQUFZLEdBQWEsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFeEMsa0JBQVksR0FBVyxDQUFDLENBQUM7UUFFekIsaUJBQVcsR0FBZ0IsV0FBVyxDQUFDLElBQUksQ0FBQztRQUU1QyxpQkFBVyxHQUFZLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFeEMsVUFBSSxHQUFnQixJQUFJLENBQUM7O0lBc0JyQyxDQUFDO0lBckJHLHNCQUFXLDhCQUFHO2FBQWQ7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwRTtZQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyQixDQUFDOzs7T0FBQTtJQUVTLDZCQUFLLEdBQWY7UUFDSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVTLDhCQUFNLEdBQWhCO1FBQ0ksSUFBSSxTQUFTLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkI7SUFDTCxDQUFDO0lBRU0sb0NBQVksR0FBbkI7UUFDSSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUMzSSxDQUFDO0lBN0JEO1FBREMsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxNQUFNLEVBQUUsQ0FBQzt1REFDTztJQUUvQztRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7dURBQ1I7SUFFaEM7UUFEQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE1BQU0sRUFBRSxDQUFDO3NEQUNqQjtJQUVuRDtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7c0RBQ1E7SUFSL0IsYUFBYTtRQUpqQyxPQUFPO1FBQ1AsZ0JBQWdCO1FBQ2hCLGlCQUFpQjtRQUNqQixJQUFJLENBQUMsZ0NBQWdDLENBQUM7T0FDbEIsYUFBYSxDQWdDakM7SUFBRCxvQkFBQztDQWhDRCxBQWdDQyxDQWhDMEMsRUFBRSxDQUFDLFNBQVMsR0FnQ3REO2tCQWhDb0IsYUFBYSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUsIGRpc2FsbG93TXVsdGlwbGUsIGV4ZWN1dGVJbkVkaXRNb2RlIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuZW51bSBPdXRsaW5lVHlwZSB7XHJcbiAgICBOT05FID0gMCxcclxuICAgIC8qKiDlpJbmj4/ovrkgKi9cclxuICAgIE9VVCA9IDEsXHJcbiAgICAvKiog5YaF5o+P6L65ICovXHJcbiAgICBJTk5FUiA9IDIsXHJcbn1cclxuXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AbWVudShcIkZyYW1ld29yay9TaGFkZXIvU2hhZGVyT3V0bGluZVwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJPdXRsaW5lIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiBcIuaPj+i+ueminOiJslwiIH0pXHJcbiAgICBwdWJsaWMgb3V0bGluZUNvbG9yOiBjYy5Db2xvciA9IG5ldyBjYy5Db2xvcigpO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5o+P6L655a695bqmXCIgfSlcclxuICAgIHB1YmxpYyBvdXRMaW5lV2lkdGg6IG51bWJlciA9IDA7XHJcbiAgICBAcHJvcGVydHkoeyB0eXBlOiBjYy5FbnVtKE91dGxpbmVUeXBlKSwgdG9vbHRpcDogQ0NfREVWICYmIFwi5o+P6L6557G75Z6LXCIgfSlcclxuICAgIHB1YmxpYyBvdXRsaW5lVHlwZTogT3V0bGluZVR5cGUgPSBPdXRsaW5lVHlwZS5OT05FO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi57q555CG5aSn5bCPXCIgfSlcclxuICAgIHB1YmxpYyB0ZXh0dXJlU2l6ZTogY2MuU2l6ZSA9IG5ldyBjYy5TaXplKDEsIDEpO1xyXG5cclxuICAgIHByaXZhdGUgX21hdDogY2MuTWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgcHVibGljIGdldCBtYXQoKTogY2MuTWF0ZXJpYWwge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWF0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hdCA9IHRoaXMuZ2V0Q29tcG9uZW50KGNjLlJlbmRlckNvbXBvbmVudCkuZ2V0TWF0ZXJpYWwoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2hhZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoQ0NfRURJVE9SKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVTaGFkZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5tYXQuc2V0UHJvcGVydHkoXCJvdXRsaW5lQ29sb3JcIiwgdGhpcy5vdXRsaW5lQ29sb3IpO1xyXG4gICAgICAgIHRoaXMubWF0LnNldFByb3BlcnR5KFwib3V0bGluZUluZm9cIiwgbmV3IGNjLlZlYzQodGhpcy50ZXh0dXJlU2l6ZS53aWR0aCwgdGhpcy50ZXh0dXJlU2l6ZS5oZWlnaHQsIHRoaXMub3V0TGluZVdpZHRoLCB0aGlzLm91dGxpbmVUeXBlKSk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/base/Timer.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '435944whQBN4o91RvmJFpuA', 'Timer');
// scripts/common/cmpt/base/Timer.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EventName_1 = require("../../const/EventName");
var Events_1 = require("../../util/Events");
var Tween_1 = require("../../util/Tween");
var _a = cc._decorator, ccclass = _a.ccclass, executionOrder = _a.executionOrder, menu = _a.menu, disallowMultiple = _a.disallowMultiple;
if (!CC_EDITOR) {
    cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, function (scene) {
        if (Timer.timer) {
            return;
        }
        cc.log("addPersistRootNode: TIMER");
        var node = new cc.Node("TIMER");
        cc.game.addPersistRootNode(node);
        node.addComponent(Timer);
    });
}
/**
 * - 全局时间管理器，场景加载后会自动绑定常驻节点，保证全局有且只有一个
 * - 负责TWEEN和SCALE_TWEEN的管理与更新
 */
var Timer = /** @class */ (function (_super) {
    __extends(Timer, _super);
    function Timer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Timer_1 = Timer;
    Object.defineProperty(Timer, "timer", {
        get: function () {
            return this._timer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "timeScale", {
        /**
         * dt缩放倍数，1为正常速度，0为暂停
         * - 需要特别注意此值的修改和暂停、恢复如果同时多处调用产生的效果是否正确
         */
        get: function () { return this._timeScale; },
        set: function (v) {
            if (v === this._timeScale || v < 0) {
                return;
            }
            this._timeScale = v;
            Events_1.default.emit(EventName_1.EventName.TIME_SCALE);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "realDt", {
        /** 距上一帧间隔的真实时间 */
        get: function () { return this._realDt; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "scaleDt", {
        /** 距上一帧间隔经过timeScale缩放的时间 */
        get: function () { return this._realDt * this._timeScale; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "gameSec", {
        /** 游戏启动经过的时长 s */
        get: function () { return this._gameSec; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "gameMs", {
        /** 游戏启动经过的时长 ms */
        get: function () { return this._gameSec * 1000; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "scaleGameSec", {
        /** 游戏经过缩放的时长 s */
        get: function () { return this._scaleGameSec; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timer, "scaleGameMs", {
        /** 游戏经过缩放的时长 ms */
        get: function () { return this._scaleGameSec * 1000; },
        enumerable: false,
        configurable: true
    });
    /**
     * 重置 timeScale
     */
    Timer.reset = function () {
        this._puaseCount = 0;
        this._timeScale = 1;
        this._lastTimeScale = 1;
    };
    /**
     * 暂停游戏 timeScale设置为0 （需要与gameResume成对调用）
     */
    Timer.gamePause = function () {
        this._puaseCount++;
        if (this._puaseCount > 1) {
            return;
        }
        this._lastTimeScale = this._timeScale;
        this._timeScale = 0;
        Events_1.default.emit(EventName_1.EventName.GAME_PAUSE);
    };
    /**
     * 恢复游戏 （需要与gamePause成对调用）
     */
    Timer.gameResume = function () {
        if (this._puaseCount <= 0) {
            return;
        }
        this._puaseCount--;
        if (this._puaseCount <= 0) {
            this._timeScale = this._lastTimeScale;
            Events_1.default.emit(EventName_1.EventName.GAME_RESUME);
        }
    };
    //#endregion
    Timer.prototype.onLoad = function () {
        if (Timer_1._timer) {
            return;
        }
        Timer_1._timer = this;
    };
    Timer.prototype.onDestroy = function () {
        if (Timer_1._timer === this) {
            Timer_1._timer = null;
        }
        Tween_1.TWEEN.removeAll();
        Tween_1.SCALE_TWEEN.removeAll();
    };
    Timer.prototype.update = function (dt) {
        // 只启用第一个加载的组件
        if (Timer_1._timer !== this) {
            return;
        }
        Timer_1._realDt = dt;
        Timer_1._gameSec += dt;
        Timer_1._scaleGameSec += Timer_1.scaleDt;
        Tween_1.TWEEN.update(Timer_1.gameMs);
        // scaleDt大于0时更新SCALE_TWEEN
        if (Timer_1.scaleDt > 0) {
            Tween_1.SCALE_TWEEN.update(Timer_1.scaleGameMs);
        }
    };
    var Timer_1;
    //#region 静态成员
    /** 全局第一个加载的Timer组件 */
    Timer._timer = null;
    /** 游戏调用暂停的计数 */
    Timer._puaseCount = 0;
    Timer._lastTimeScale = 1;
    Timer._timeScale = 1;
    Timer._realDt = 0;
    Timer._gameSec = 0;
    Timer._scaleGameSec = 0;
    Timer = Timer_1 = __decorate([
        ccclass,
        disallowMultiple,
        executionOrder(-1000),
        menu("Framework/基础组件/Timer")
    ], Timer);
    return Timer;
}(cc.Component));
exports.default = Timer;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxiYXNlXFxUaW1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtREFBa0Q7QUFDbEQsNENBQXVDO0FBQ3ZDLDBDQUFzRDtBQUVoRCxJQUFBLEtBQXNELEVBQUUsQ0FBQyxVQUFVLEVBQWpFLE9BQU8sYUFBQSxFQUFFLGNBQWMsb0JBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFMUUsSUFBSSxDQUFDLFNBQVMsRUFBRTtJQUNaLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsd0JBQXdCLEVBQUUsVUFBQyxLQUFlO1FBQ2pFLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRTtZQUNiLE9BQU87U0FDVjtRQUVELEVBQUUsQ0FBQyxHQUFHLENBQUMsMkJBQTJCLENBQUMsQ0FBQztRQUNwQyxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEMsRUFBRSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdCLENBQUMsQ0FBQyxDQUFDO0NBQ047QUFFRDs7O0dBR0c7QUFLSDtJQUFtQyx5QkFBWTtJQUEvQzs7SUFrSEEsQ0FBQztjQWxIb0IsS0FBSztJQUt0QixzQkFBa0IsY0FBSzthQUF2QjtZQUNJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDOzs7T0FBQTtJQVdELHNCQUFrQixrQkFBUztRQUozQjs7O1dBR0c7YUFDSCxjQUF3QyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQ2pFLFVBQTRCLENBQVM7WUFDakMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFD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QUFDO1FBQ25CLE9BQUssQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDO1FBQ3JCLE9BQUssQ0FBQyxhQUFhLElBQUksT0FBSyxDQUFDLE9BQU8sQ0FBQztRQUVyQyxhQUFLLENBQUMsTUFBTSxDQUFDLE9BQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQiwyQkFBMkI7UUFDM0IsSUFBSSxPQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRTtZQUNuQixtQkFBVyxDQUFDLE1BQU0sQ0FBQyxPQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDekM7SUFDTCxDQUFDOztJQWhIRCxjQUFjO0lBRWQsc0JBQXNCO0lBQ1AsWUFBTSxHQUFVLElBQUksQ0FBQztJQUtwQyxnQkFBZ0I7SUFDRCxpQkFBVyxHQUFXLENBQUMsQ0FBQztJQUV4QixvQkFBYyxHQUFXLENBQUMsQ0FBQztJQUMzQixnQkFBVSxHQUFXLENBQUMsQ0FBQztJQWN2QixhQUFPLEdBQVcsQ0FBQyxDQUFDO0lBTXBCLGNBQVEsR0FBVyxDQUFDLENBQUM7SUFDckIsbUJBQWEsR0FBVyxDQUFDLENBQUM7SUFsQ3hCLEtBQUs7UUFKekIsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLHNCQUFzQixDQUFDO09BQ1IsS0FBSyxDQWtIekI7SUFBRCxZQUFDO0NBbEhELEFBa0hDLENBbEhrQyxFQUFFLENBQUMsU0FBUyxHQWtIOUM7a0JBbEhvQixLQUFLIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnROYW1lIH0gZnJvbSBcIi4uLy4uL2NvbnN0L0V2ZW50TmFtZVwiO1xyXG5pbXBvcnQgRXZlbnRzIGZyb20gXCIuLi8uLi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgeyBTQ0FMRV9UV0VFTiwgVFdFRU4gfSBmcm9tIFwiLi4vLi4vdXRpbC9Ud2VlblwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBleGVjdXRpb25PcmRlciwgbWVudSwgZGlzYWxsb3dNdWx0aXBsZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbmlmICghQ0NfRURJVE9SKSB7XHJcbiAgICBjYy5kaXJlY3Rvci5vbihjYy5EaXJlY3Rvci5FVkVOVF9BRlRFUl9TQ0VORV9MQVVOQ0gsIChzY2VuZTogY2MuU2NlbmUpID0+IHtcclxuICAgICAgICBpZiAoVGltZXIudGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MubG9nKFwiYWRkUGVyc2lzdFJvb3ROb2RlOiBUSU1FUlwiKTtcclxuICAgICAgICBsZXQgbm9kZSA9IG5ldyBjYy5Ob2RlKFwiVElNRVJcIik7XHJcbiAgICAgICAgY2MuZ2FtZS5hZGRQZXJzaXN0Um9vdE5vZGUobm9kZSk7XHJcbiAgICAgICAgbm9kZS5hZGRDb21wb25lbnQoVGltZXIpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAtIOWFqOWxgOaXtumXtOeuoeeQhuWZqO+8jOWcuuaZr+WKoOi9veWQjuS8muiHquWKqOe7keWumuW4uOmpu+iKgueCue+8jOS/neivgeWFqOWxgOacieS4lOWPquacieS4gOS4qlxyXG4gKiAtIOi0n+i0o1RXRUVO5ZKMU0NBTEVfVFdFRU7nmoTnrqHnkIbkuI7mm7TmlrBcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBleGVjdXRpb25PcmRlcigtMTAwMClcclxuQG1lbnUoXCJGcmFtZXdvcmsv5Z+656GA57uE5Lu2L1RpbWVyXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIC8vI3JlZ2lvbiDpnZnmgIHmiJDlkZhcclxuXHJcbiAgICAvKiog5YWo5bGA56ys5LiA5Liq5Yqg6L2955qEVGltZXLnu4Tku7YgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF90aW1lcjogVGltZXIgPSBudWxsO1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZXIoKTogVGltZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiog5ri45oiP6LCD55So5pqC5YGc55qE6K6h5pWwICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcHVhc2VDb3VudDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbGFzdFRpbWVTY2FsZTogbnVtYmVyID0gMTtcclxuICAgIHByaXZhdGUgc3RhdGljIF90aW1lU2NhbGU6IG51bWJlciA9IDE7XHJcbiAgICAvKiogXHJcbiAgICAgKiBkdOe8qeaUvuWAjeaVsO+8jDHkuLrmraPluLjpgJ/luqbvvIww5Li65pqC5YGcXHJcbiAgICAgKiAtIOmcgOimgeeJueWIq+azqOaEj+atpOWAvOeahOS/ruaUueWSjOaaguWBnOOAgeaBouWkjeWmguaenOWQjOaXtuWkmuWkhOiwg+eUqOS6p+eUn+eahOaViOaenOaYr+WQpuato+ehrlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU2NhbGUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgdGltZVNjYWxlKHY6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh2ID09PSB0aGlzLl90aW1lU2NhbGUgfHwgdiA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSB2O1xyXG4gICAgICAgIEV2ZW50cy5lbWl0KEV2ZW50TmFtZS5USU1FX1NDQUxFKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcmVhbER0OiBudW1iZXIgPSAwO1xyXG4gICAgLyoqIOi3neS4iuS4gOW4p+mXtOmalOeahOecn+WunuaXtumXtCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgcmVhbER0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9yZWFsRHQ7IH1cclxuICAgIC8qKiDot53kuIrkuIDluKfpl7TpmpTnu4/ov4d0aW1lU2NhbGXnvKnmlL7nmoTml7bpl7QgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHNjYWxlRHQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3JlYWxEdCAqIHRoaXMuX3RpbWVTY2FsZTsgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9nYW1lU2VjOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3NjYWxlR2FtZVNlYzogbnVtYmVyID0gMDtcclxuICAgIC8qKiDmuLjmiI/lkK/liqjnu4/ov4fnmoTml7bplb8gcyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZ2FtZVNlYygpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZ2FtZVNlYzsgfVxyXG4gICAgLyoqIOa4uOaIj+WQr+WKqOe7j+i/h+eahOaXtumVvyBtcyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZ2FtZU1zKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9nYW1lU2VjICogMTAwMDsgfVxyXG4gICAgLyoqIOa4uOaIj+e7j+i/h+e8qeaUvueahOaXtumVvyBzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBzY2FsZUdhbWVTZWMoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3NjYWxlR2FtZVNlYzsgfVxyXG4gICAgLyoqIOa4uOaIj+e7j+i/h+e8qeaUvueahOaXtumVvyBtcyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgc2NhbGVHYW1lTXMoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3NjYWxlR2FtZVNlYyAqIDEwMDA7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjee9riB0aW1lU2NhbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wdWFzZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2xhc3RUaW1lU2NhbGUgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pqC5YGc5ri45oiPIHRpbWVTY2FsZeiuvue9ruS4ujAg77yI6ZyA6KaB5LiOZ2FtZVJlc3VtZeaIkOWvueiwg+eUqO+8iVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdhbWVQYXVzZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wdWFzZUNvdW50Kys7XHJcbiAgICAgICAgaWYgKHRoaXMuX3B1YXNlQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdFRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZTtcclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSAwO1xyXG4gICAgICAgIEV2ZW50cy5lbWl0KEV2ZW50TmFtZS5HQU1FX1BBVVNFKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaBouWkjea4uOaIjyDvvIjpnIDopoHkuI5nYW1lUGF1c2XmiJDlr7nosIPnlKjvvIlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnYW1lUmVzdW1lKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9wdWFzZUNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wdWFzZUNvdW50LS07XHJcbiAgICAgICAgaWYgKHRoaXMuX3B1YXNlQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSB0aGlzLl9sYXN0VGltZVNjYWxlO1xyXG4gICAgICAgICAgICBFdmVudHMuZW1pdChFdmVudE5hbWUuR0FNRV9SRVNVTUUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChUaW1lci5fdGltZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaW1lci5fdGltZXIgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKFRpbWVyLl90aW1lciA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICBUaW1lci5fdGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVFdFRU4ucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgU0NBTEVfVFdFRU4ucmVtb3ZlQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZShkdDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8g5Y+q5ZCv55So56ys5LiA5Liq5Yqg6L2955qE57uE5Lu2XHJcbiAgICAgICAgaWYgKFRpbWVyLl90aW1lciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBUaW1lci5fcmVhbER0ID0gZHQ7XHJcbiAgICAgICAgVGltZXIuX2dhbWVTZWMgKz0gZHQ7XHJcbiAgICAgICAgVGltZXIuX3NjYWxlR2FtZVNlYyArPSBUaW1lci5zY2FsZUR0O1xyXG5cclxuICAgICAgICBUV0VFTi51cGRhdGUoVGltZXIuZ2FtZU1zKTtcclxuICAgICAgICAvLyBzY2FsZUR05aSn5LqOMOaXtuabtOaWsFNDQUxFX1RXRUVOXHJcbiAgICAgICAgaWYgKFRpbWVyLnNjYWxlRHQgPiAwKSB7XHJcbiAgICAgICAgICAgIFNDQUxFX1RXRUVOLnVwZGF0ZShUaW1lci5zY2FsZUdhbWVNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/shader/ShaderTile.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e6e3agdOnJF/o7rgEOg4Iq+', 'ShaderTile');
// scripts/common/cmpt/shader/ShaderTile.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple, executeInEditMode = _a.executeInEditMode;
var ShaderTile = /** @class */ (function (_super) {
    __extends(ShaderTile, _super);
    function ShaderTile() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scale = new cc.Vec2(1, 1);
        _this.offset = new cc.Vec2(0, 0);
        _this._mat = null;
        return _this;
    }
    Object.defineProperty(ShaderTile.prototype, "mat", {
        get: function () {
            if (!this._mat) {
                this._mat = this.getComponent(cc.RenderComponent).getMaterial(0);
            }
            return this._mat;
        },
        enumerable: false,
        configurable: true
    });
    ShaderTile.prototype.start = function () {
        this.updateShader();
    };
    ShaderTile.prototype.update = function () {
        if (CC_EDITOR) {
            this.updateShader();
        }
    };
    ShaderTile.prototype.updateShader = function () {
        this.mat.setProperty("tile", new cc.Vec4(this.scale.x, this.scale.y, this.offset.x, this.offset.y));
    };
    __decorate([
        property({ tooltip: CC_DEV && "uv坐标缩放倍数" })
    ], ShaderTile.prototype, "scale", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "uv坐标偏移值" })
    ], ShaderTile.prototype, "offset", void 0);
    ShaderTile = __decorate([
        ccclass,
        disallowMultiple,
        executeInEditMode,
        menu("Framework/Shader/ShaderTile")
    ], ShaderTile);
    return ShaderTile;
}(cc.Component));
exports.default = ShaderTile;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxzaGFkZXJcXFNoYWRlclRpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU0sSUFBQSxLQUFtRSxFQUFFLENBQUMsVUFBVSxFQUE5RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxpQkFBaUIsdUJBQWtCLENBQUM7QUFNdkY7SUFBd0MsOEJBQVk7SUFBcEQ7UUFBQSxxRUEyQkM7UUF6QlUsV0FBSyxHQUFZLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFbkMsWUFBTSxHQUFZLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFbkMsVUFBSSxHQUFnQixJQUFJLENBQUM7O0lBcUJyQyxDQUFDO0lBcEJHLHNCQUFXLDJCQUFHO2FBQWQ7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwRTtZQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyQixDQUFDOzs7T0FBQTtJQUVTLDBCQUFLLEdBQWY7UUFDSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVTLDJCQUFNLEdBQWhCO1FBQ0ksSUFBSSxTQUFTLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkI7SUFDTCxDQUFDO0lBRU0saUNBQVksR0FBbkI7UUFDSSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RyxDQUFDO0lBeEJEO1FBREMsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxVQUFVLEVBQUUsQ0FBQzs2Q0FDRjtJQUUxQztRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksU0FBUyxFQUFFLENBQUM7OENBQ0E7SUFKMUIsVUFBVTtRQUo5QixPQUFPO1FBQ1AsZ0JBQWdCO1FBQ2hCLGlCQUFpQjtRQUNqQixJQUFJLENBQUMsNkJBQTZCLENBQUM7T0FDZixVQUFVLENBMkI5QjtJQUFELGlCQUFDO0NBM0JELEFBMkJDLENBM0J1QyxFQUFFLENBQUMsU0FBUyxHQTJCbkQ7a0JBM0JvQixVQUFVIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgbWVudSwgZGlzYWxsb3dNdWx0aXBsZSwgZXhlY3V0ZUluRWRpdE1vZGUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG5AY2NjbGFzc1xyXG5AZGlzYWxsb3dNdWx0aXBsZVxyXG5AZXhlY3V0ZUluRWRpdE1vZGVcclxuQG1lbnUoXCJGcmFtZXdvcmsvU2hhZGVyL1NoYWRlclRpbGVcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyVGlsZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCJ1duWdkOagh+e8qeaUvuWAjeaVsFwiIH0pXHJcbiAgICBwdWJsaWMgc2NhbGU6IGNjLlZlYzIgPSBuZXcgY2MuVmVjMigxLCAxKTtcclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiBcInV25Z2Q5qCH5YGP56e75YC8XCIgfSlcclxuICAgIHB1YmxpYyBvZmZzZXQ6IGNjLlZlYzIgPSBuZXcgY2MuVmVjMigwLCAwKTtcclxuXHJcbiAgICBwcml2YXRlIF9tYXQ6IGNjLk1hdGVyaWFsID0gbnVsbDtcclxuICAgIHB1YmxpYyBnZXQgbWF0KCk6IGNjLk1hdGVyaWFsIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21hdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXQgPSB0aGlzLmdldENvbXBvbmVudChjYy5SZW5kZXJDb21wb25lbnQpLmdldE1hdGVyaWFsKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB1cGRhdGUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKENDX0VESVRPUikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlU2hhZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWF0LnNldFByb3BlcnR5KFwidGlsZVwiLCBuZXcgY2MuVmVjNCh0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSwgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSkpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/ShakeNode.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '936e8flAq9L248TlLh5Hzd0', 'ShakeNode');
// scripts/common/cmpt/ui/ShakeNode.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tween_1 = require("../../util/Tween");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple;
/**
 * 节点振动
 */
var ShakeNode = /** @class */ (function (_super) {
    __extends(ShakeNode, _super);
    function ShakeNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.shakePower = 5;
        _this.shakeTime = 0.16;
        _this.timeScale = false;
        _this._tween = null;
        return _this;
    }
    /**
     * 振动
     * @param times 振动几个周期
     */
    ShakeNode.prototype.shake = function (times) {
        if (times === void 0) { times = 5; }
        if ((this._tween && this._tween.isPlaying()) || times <= 0 || this.shakePower <= 0 || this.shakeTime <= 0) {
            return;
        }
        var sv = cc.v2(0, this.shakePower);
        this.node.setPosition(sv);
        var xArr = [];
        var yArr = [];
        for (var i = 1; i <= 8; i++) {
            var v = sv.rotate(Math.PI / 4 * (i * 3));
            xArr.push(v.x);
            yArr.push(v.y);
        }
        this._tween = this.timeScale ? new Tween_1.Tween(this.node, Tween_1.SCALE_TWEEN) : new Tween_1.Tween(this.node);
        this._tween.to({ x: xArr, y: yArr }, this.shakeTime * 1000)
            .repeat(times)
            .start();
    };
    __decorate([
        property({ tooltip: CC_DEV && "振动幅度" })
    ], ShakeNode.prototype, "shakePower", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "振动周期，单位：秒" })
    ], ShakeNode.prototype, "shakeTime", void 0);
    __decorate([
        property({
            tooltip: CC_DEV && "变化速度是否受到timeScale的影响"
        })
    ], ShakeNode.prototype, "timeScale", void 0);
    ShakeNode = __decorate([
        ccclass,
        disallowMultiple,
        menu("Framework/UI组件/ShakeNode")
    ], ShakeNode);
    return ShakeNode;
}(cc.Component));
exports.default = ShakeNode;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcU2hha2VOb2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDBDQUFzRDtBQUVoRCxJQUFBLEtBQWdELEVBQUUsQ0FBQyxVQUFVLEVBQTNELE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBQSxFQUFFLGdCQUFnQixzQkFBa0IsQ0FBQztBQUVwRTs7R0FFRztBQUlIO0lBQXVDLDZCQUFZO0lBQW5EO1FBQUEscUVBc0NDO1FBcENVLGdCQUFVLEdBQVcsQ0FBQyxDQUFDO1FBR3ZCLGVBQVMsR0FBVyxJQUFJLENBQUM7UUFLekIsZUFBUyxHQUFZLEtBQUssQ0FBQztRQUUxQixZQUFNLEdBQW1CLElBQUksQ0FBQzs7SUEwQjFDLENBQUM7SUF4Qkc7OztPQUdHO0lBQ0kseUJBQUssR0FBWixVQUFhLEtBQWlCO1FBQWpCLHNCQUFBLEVBQUEsU0FBaUI7UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLEVBQUU7WUFDdkcsT0FBTztTQUNWO1FBRUQsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzFCLElBQUksSUFBSSxHQUFhLEVBQUUsQ0FBQztRQUN4QixJQUFJLElBQUksR0FBYSxFQUFFLENBQUM7UUFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN6QixJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjtRQUVELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxtQkFBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksYUFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4RixJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO2FBQ3RELE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDYixLQUFLLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBbkNEO1FBREMsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxNQUFNLEVBQUUsQ0FBQztpREFDVjtJQUc5QjtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksV0FBVyxFQUFFLENBQUM7Z0RBQ2I7SUFLaEM7UUFIQyxRQUFRLENBQUM7WUFDTixPQUFPLEVBQUUsTUFBTSxJQUFJLHNCQUFzQjtTQUM1QyxDQUFDO2dEQUNnQztJQVZqQixTQUFTO1FBSDdCLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDLDBCQUEwQixDQUFDO09BQ1osU0FBUyxDQXNDN0I7SUFBRCxnQkFBQztDQXRDRCxBQXNDQyxDQXRDc0MsRUFBRSxDQUFDLFNBQVMsR0FzQ2xEO2tCQXRDb0IsU0FBUyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNDQUxFX1RXRUVOLCBUd2VlbiB9IGZyb20gXCIuLi8uLi91dGlsL1R3ZWVuXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCBkaXNhbGxvd011bHRpcGxlIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOiKgueCueaMr+WKqFxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGRpc2FsbG93TXVsdGlwbGVcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvU2hha2VOb2RlXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWtlTm9kZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmjK/liqjluYXluqZcIiB9KVxyXG4gICAgcHVibGljIHNoYWtlUG93ZXI6IG51bWJlciA9IDU7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5oyv5Yqo5ZGo5pyf77yM5Y2V5L2N77ya56eSXCIgfSlcclxuICAgIHB1YmxpYyBzaGFrZVRpbWU6IG51bWJlciA9IDAuMTY7XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLlj5jljJbpgJ/luqbmmK/lkKblj5fliLB0aW1lU2NhbGXnmoTlvbHlk41cIlxyXG4gICAgfSlcclxuICAgIHB1YmxpYyB0aW1lU2NhbGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIF90d2VlbjogVHdlZW48Y2MuTm9kZT4gPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5oyv5YqoXHJcbiAgICAgKiBAcGFyYW0gdGltZXMg5oyv5Yqo5Yeg5Liq5ZGo5pyfXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaGFrZSh0aW1lczogbnVtYmVyID0gNSkge1xyXG4gICAgICAgIGlmICgodGhpcy5fdHdlZW4gJiYgdGhpcy5fdHdlZW4uaXNQbGF5aW5nKCkpIHx8IHRpbWVzIDw9IDAgfHwgdGhpcy5zaGFrZVBvd2VyIDw9IDAgfHwgdGhpcy5zaGFrZVRpbWUgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3YgPSBjYy52MigwLCB0aGlzLnNoYWtlUG93ZXIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5zZXRQb3NpdGlvbihzdik7XHJcbiAgICAgICAgbGV0IHhBcnI6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgbGV0IHlBcnI6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gODsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2ID0gc3Yucm90YXRlKE1hdGguUEkgLyA0ICogKGkgKiAzKSk7XHJcbiAgICAgICAgICAgIHhBcnIucHVzaCh2LngpO1xyXG4gICAgICAgICAgICB5QXJyLnB1c2godi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3R3ZWVuID0gdGhpcy50aW1lU2NhbGUgPyBuZXcgVHdlZW4odGhpcy5ub2RlLCBTQ0FMRV9UV0VFTikgOiBuZXcgVHdlZW4odGhpcy5ub2RlKTtcclxuICAgICAgICB0aGlzLl90d2Vlbi50byh7IHg6IHhBcnIsIHk6IHlBcnIgfSwgdGhpcy5zaGFrZVRpbWUgKiAxMDAwKVxyXG4gICAgICAgICAgICAucmVwZWF0KHRpbWVzKVxyXG4gICAgICAgICAgICAuc3RhcnQoKTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorState.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c1d25xIgn5M3ZaxWIV1n5ii', 'AnimatorState');
// scripts/animator/core/AnimatorState.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorTransition_1 = require("./AnimatorTransition");
/**
 * 状态管理类
 */
var AnimatorState = /** @class */ (function () {
    function AnimatorState(data, ac) {
        this._name = "";
        this._motion = "";
        this._loop = false;
        this._speed = 1;
        this._multi = "";
        this._transitions = [];
        this._ac = null;
        this._name = data.state;
        this._motion = data.motion || '';
        this._loop = data.loop || false;
        this._speed = data.speed || 1;
        this._multi = data.multiplier || '';
        this._ac = ac;
        for (var i = 0; i < data.transitions.length; i++) {
            var transition = new AnimatorTransition_1.default(data.transitions[i], ac);
            transition.isValid() && this._transitions.push(transition);
        }
    }
    Object.defineProperty(AnimatorState.prototype, "name", {
        /** 状态名 */
        get: function () { return this._name; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorState.prototype, "motion", {
        /** 动画名 */
        get: function () { return this._motion; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorState.prototype, "loop", {
        /** 动画是否循环播放 */
        get: function () { return this._loop; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorState.prototype, "speed", {
        /** 动画播放速度 */
        get: function () { return this._speed; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorState.prototype, "multi", {
        /** 动画播放速度的混合参数 */
        get: function () { return this._multi; },
        enumerable: false,
        configurable: true
    });
    /**
     * 判断各个分支是否满足条件，满足则转换状态
     */
    AnimatorState.prototype.checkAndTrans = function () {
        for (var i = 0; i < this._transitions.length; i++) {
            var transition = this._transitions[i];
            if (transition && transition.check()) {
                transition.doTrans();
                return;
            }
        }
    };
    return AnimatorState;
}());
exports.default = AnimatorState;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yU3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSwyREFBc0Q7QUFFdEQ7O0dBRUc7QUFDSDtJQXFCSSx1QkFBWSxJQUFTLEVBQUUsRUFBc0I7UUFwQnJDLFVBQUssR0FBVyxFQUFFLENBQUM7UUFDbkIsWUFBTyxHQUFXLEVBQUUsQ0FBQztRQUNyQixVQUFLLEdBQVksS0FBSyxDQUFDO1FBQ3ZCLFdBQU0sR0FBVyxDQUFDLENBQUM7UUFDbkIsV0FBTSxHQUFXLEVBQUUsQ0FBQztRQUVwQixpQkFBWSxHQUF5QixFQUFFLENBQUM7UUFDeEMsUUFBRyxHQUF1QixJQUFJLENBQUM7UUFjbkMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQztRQUNoQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7UUFFcEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFFZCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDOUMsSUFBSSxVQUFVLEdBQXVCLElBQUksNEJBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNyRixVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDOUQ7SUFDTCxDQUFDO0lBdkJELHNCQUFXLCtCQUFJO1FBRGYsVUFBVTthQUNWLGNBQW9CLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBRXhDLHNCQUFXLGlDQUFNO1FBRGpCLFVBQVU7YUFDVixjQUFzQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUU1QyxzQkFBVywrQkFBSTtRQURmLGVBQWU7YUFDZixjQUFvQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUV4QyxzQkFBVyxnQ0FBSztRQURoQixhQUFhO2FBQ2IsY0FBcUIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFFMUMsc0JBQVcsZ0NBQUs7UUFEaEIsa0JBQWtCO2FBQ2xCLGNBQXFCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBaUIxQzs7T0FFRztJQUNJLHFDQUFhLEdBQXBCO1FBQ0ksS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9DLElBQUksVUFBVSxHQUF1QixJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFELElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDbEMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNyQixPQUFPO2FBQ1Y7U0FDSjtJQUNMLENBQUM7SUFDTCxvQkFBQztBQUFELENBaERBLEFBZ0RDLElBQUEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW5pbWF0b3JDb250cm9sbGVyIGZyb20gXCIuL0FuaW1hdG9yQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgQW5pbWF0b3JUcmFuc2l0aW9uIGZyb20gXCIuL0FuaW1hdG9yVHJhbnNpdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIOeKtuaAgeeuoeeQhuexu1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JTdGF0ZSB7XHJcbiAgICBwcml2YXRlIF9uYW1lOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHJpdmF0ZSBfbW90aW9uOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHJpdmF0ZSBfbG9vcDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfc3BlZWQ6IG51bWJlciA9IDE7XHJcbiAgICBwcml2YXRlIF9tdWx0aTogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICBwcml2YXRlIF90cmFuc2l0aW9uczogQW5pbWF0b3JUcmFuc2l0aW9uW10gPSBbXTtcclxuICAgIHByaXZhdGUgX2FjOiBBbmltYXRvckNvbnRyb2xsZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKiDnirbmgIHlkI0gKi9cclxuICAgIHB1YmxpYyBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH1cclxuICAgIC8qKiDliqjnlLvlkI0gKi9cclxuICAgIHB1YmxpYyBnZXQgbW90aW9uKCkgeyByZXR1cm4gdGhpcy5fbW90aW9uOyB9XHJcbiAgICAvKiog5Yqo55S75piv5ZCm5b6q546v5pKt5pS+ICovXHJcbiAgICBwdWJsaWMgZ2V0IGxvb3AoKSB7IHJldHVybiB0aGlzLl9sb29wOyB9XHJcbiAgICAvKiog5Yqo55S75pKt5pS+6YCf5bqmICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwZWVkKCkgeyByZXR1cm4gdGhpcy5fc3BlZWQ7IH1cclxuICAgIC8qKiDliqjnlLvmkq3mlL7pgJ/luqbnmoTmt7flkIjlj4LmlbAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXVsdGkoKSB7IHJldHVybiB0aGlzLl9tdWx0aTsgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRhdGE6IGFueSwgYWM6IEFuaW1hdG9yQ29udHJvbGxlcikge1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBkYXRhLnN0YXRlO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGRhdGEubW90aW9uIHx8ICcnO1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBkYXRhLmxvb3AgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBkYXRhLnNwZWVkIHx8IDE7XHJcbiAgICAgICAgdGhpcy5fbXVsdGkgPSBkYXRhLm11bHRpcGxpZXIgfHwgJyc7XHJcblxyXG4gICAgICAgIHRoaXMuX2FjID0gYWM7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS50cmFuc2l0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbjogQW5pbWF0b3JUcmFuc2l0aW9uID0gbmV3IEFuaW1hdG9yVHJhbnNpdGlvbihkYXRhLnRyYW5zaXRpb25zW2ldLCBhYyk7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uaXNWYWxpZCgpICYmIHRoaXMuX3RyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5pat5ZCE5Liq5YiG5pSv5piv5ZCm5ruh6Laz5p2h5Lu277yM5ruh6Laz5YiZ6L2s5o2i54q25oCBXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjaGVja0FuZFRyYW5zKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHJhbnNpdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb246IEFuaW1hdG9yVHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb25zW2ldO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB0cmFuc2l0aW9uLmNoZWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZG9UcmFucygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/CountdownLabel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a125eaLZLVO+LQud2BLjWcd', 'CountdownLabel');
// scripts/common/cmpt/ui/CountdownLabel.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tool_1 = require("../../util/Tool");
var Tween_1 = require("../../util/Tween");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
/**
 * 倒计时显示组件
 */
var CountdownLabel = /** @class */ (function (_super) {
    __extends(CountdownLabel, _super);
    function CountdownLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeScale = false;
        _this._tween = null;
        _this._updateCall = null;
        _this._completeCall = null;
        /** 格式化参数，详见`Tool.formatTimeString` */
        _this._format = "%{hh}:%{mm}:%{ss}";
        /** 剩余秒数 */
        _this._leftSec = 0;
        _this._leftFloorSec = 0;
        _this._label = null;
        return _this;
    }
    Object.defineProperty(CountdownLabel.prototype, "leftSec", {
        get: function () { return this._leftSec; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CountdownLabel.prototype, "label", {
        get: function () {
            var _a;
            if (!this._label) {
                this._label = (_a = this.getComponent(cc.Label)) !== null && _a !== void 0 ? _a : this.getComponent(cc.RichText);
            }
            return this._label;
        },
        enumerable: false,
        configurable: true
    });
    CountdownLabel.prototype.startCountdown = function (sec, format, updateCall, completeCall) {
        var _this = this;
        var _a;
        if (format === void 0) { format = "%{hh}:%{mm}:%{ss}"; }
        if (updateCall === void 0) { updateCall = null; }
        if (completeCall === void 0) { completeCall = null; }
        this._leftSec = sec;
        this._leftFloorSec = Math.floor(sec);
        this._format = format;
        this._updateCall = updateCall;
        this._completeCall = completeCall;
        (_a = this._tween) === null || _a === void 0 ? void 0 : _a.stop();
        this._tween = this.timeScale ? new Tween_1.Tween(this, Tween_1.SCALE_TWEEN) : new Tween_1.Tween(this);
        this._tween.to({ _leftSec: 0 }, sec * 1000)
            .onUpdate(function () {
            _this.onUpdate();
        })
            .onComplete(function () {
            _this.onComplete();
        })
            .start();
    };
    CountdownLabel.prototype.onUpdate = function () {
        var _a;
        // 每隔1s更新一次
        var floorSec = Math.floor(this._leftSec);
        if (floorSec === this._leftFloorSec) {
            return;
        }
        // 更新文本显示
        this._leftFloorSec = floorSec;
        if (this.label) {
            this.label.string = Tool_1.default.formatTimeString(this._leftFloorSec, this._format);
        }
        // 更新回调
        (_a = this._updateCall) === null || _a === void 0 ? void 0 : _a.call(this);
    };
    CountdownLabel.prototype.onComplete = function () {
        var _a;
        (_a = this._completeCall) === null || _a === void 0 ? void 0 : _a.call(this);
    };
    __decorate([
        property({
            tooltip: CC_DEV && "倒计时是否受到timeScale的影响"
        })
    ], CountdownLabel.prototype, "timeScale", void 0);
    CountdownLabel = __decorate([
        ccclass,
        menu("Framework/UI组件/CountdownLabel")
    ], CountdownLabel);
    return CountdownLabel;
}(cc.Component));
exports.default = CountdownLabel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcQ291bnRkb3duTGFiZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0NBQW1DO0FBQ25DLDBDQUFzRDtBQUVoRCxJQUFBLEtBQThCLEVBQUUsQ0FBQyxVQUFVLEVBQXpDLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUlsRDs7R0FFRztBQUdIO0lBQTRDLGtDQUFZO0lBQXhEO1FBQUEscUVBK0RDO1FBM0RVLGVBQVMsR0FBWSxLQUFLLENBQUM7UUFFMUIsWUFBTSxHQUFnQixJQUFJLENBQUM7UUFDM0IsaUJBQVcsR0FBZSxJQUFJLENBQUM7UUFDL0IsbUJBQWEsR0FBZSxJQUFJLENBQUM7UUFFekMsc0NBQXNDO1FBQzlCLGFBQU8sR0FBb0IsbUJBQW1CLENBQUM7UUFDdkQsV0FBVztRQUNILGNBQVEsR0FBVyxDQUFDLENBQUM7UUFFckIsbUJBQWEsR0FBVyxDQUFDLENBQUM7UUFFMUIsWUFBTSxHQUEyQixJQUFJLENBQUM7O0lBOENsRCxDQUFDO0lBakRHLHNCQUFXLG1DQUFPO2FBQWxCLGNBQStCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7OztPQUFBO0lBSXRELHNCQUFXLGlDQUFLO2FBQWhCOztZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNkLElBQUksQ0FBQyxNQUFNLFNBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLG1DQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQy9FO1lBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBRU0sdUNBQWMsR0FBckIsVUFBc0IsR0FBVyxFQUFFLE1BQTZDLEVBQUUsVUFBNkIsRUFBRSxZQUErQjtRQUFoSixpQkFnQkM7O1FBaEJrQyx1QkFBQSxFQUFBLDRCQUE2QztRQUFFLDJCQUFBLEVBQUEsaUJBQTZCO1FBQUUsNkJBQUEsRUFBQSxtQkFBK0I7UUFDNUksSUFBSSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO1FBQzlCLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDO1FBQ2xDLE1BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsSUFBSSxHQUFHO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFLLENBQUMsSUFBSSxFQUFFLG1CQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxhQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQzthQUN0QyxRQUFRLENBQUM7WUFDTixLQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDcEIsQ0FBQyxDQUFDO2FBQ0QsVUFBVSxDQUFDO1lBQ1IsS0FBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQzthQUNELEtBQUssRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFFTyxpQ0FBUSxHQUFoQjs7UUFDSSxXQUFXO1FBQ1gsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDekMsSUFBSSxRQUFRLEtBQUssSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNqQyxPQUFPO1NBQ1Y7UUFFRCxTQUFTO1FBQ1QsSUFBSSxDQUFDLGFBQWEsR0FBRyxRQUFRLENBQUM7UUFDOUIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsY0FBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQy9FO1FBRUQsT0FBTztRQUNQLE1BQUEsSUFBSSxDQUFDLFdBQVcsK0NBQWhCLElBQUksRUFBaUI7SUFDekIsQ0FBQztJQUVPLG1DQUFVLEdBQWxCOztRQUNJLE1BQUEsSUFBSSxDQUFDLGFBQWEsK0NBQWxCLElBQUksRUFBbUI7SUFDM0IsQ0FBQztJQTFERDtRQUhDLFFBQVEsQ0FBQztZQUNOLE9BQU8sRUFBRSxNQUFNLElBQUkscUJBQXFCO1NBQzNDLENBQUM7cURBQ2dDO0lBSmpCLGNBQWM7UUFGbEMsT0FBTztRQUNQLElBQUksQ0FBQywrQkFBK0IsQ0FBQztPQUNqQixjQUFjLENBK0RsQztJQUFELHFCQUFDO0NBL0RELEFBK0RDLENBL0QyQyxFQUFFLENBQUMsU0FBUyxHQStEdkQ7a0JBL0RvQixjQUFjIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRvb2wgZnJvbSBcIi4uLy4uL3V0aWwvVG9vbFwiO1xyXG5pbXBvcnQgeyBTQ0FMRV9UV0VFTiwgVHdlZW4gfSBmcm9tIFwiLi4vLi4vdXRpbC9Ud2VlblwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbnR5cGUgQ291bnRkb3duRm9ybWF0ID0gc3RyaW5nIHwgeyBcIlNcIjogc3RyaW5nOyBcIk1cIjogc3RyaW5nOyBcIkhcIjogc3RyaW5nOyBcIkRcIjogc3RyaW5nIH07XHJcblxyXG4vKipcclxuICog5YCS6K6h5pe25pi+56S657uE5Lu2XHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9Db3VudGRvd25MYWJlbFwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3VudGRvd25MYWJlbCBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuWAkuiuoeaXtuaYr+WQpuWPl+WIsHRpbWVTY2FsZeeahOW9seWTjVwiXHJcbiAgICB9KVxyXG4gICAgcHVibGljIHRpbWVTY2FsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgX3R3ZWVuOiBUd2Vlbjx0aGlzPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF91cGRhdGVDYWxsOiAoKSA9PiB2b2lkID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2NvbXBsZXRlQ2FsbDogKCkgPT4gdm9pZCA9IG51bGw7XHJcblxyXG4gICAgLyoqIOagvOW8j+WMluWPguaVsO+8jOivpuingWBUb29sLmZvcm1hdFRpbWVTdHJpbmdgICovXHJcbiAgICBwcml2YXRlIF9mb3JtYXQ6IENvdW50ZG93bkZvcm1hdCA9IFwiJXtoaH06JXttbX06JXtzc31cIjtcclxuICAgIC8qKiDliankvZnnp5LmlbAgKi9cclxuICAgIHByaXZhdGUgX2xlZnRTZWM6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgZ2V0IGxlZnRTZWMoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xlZnRTZWM7IH1cclxuICAgIHByaXZhdGUgX2xlZnRGbG9vclNlYzogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwcml2YXRlIF9sYWJlbDogY2MuTGFiZWwgfCBjYy5SaWNoVGV4dCA9IG51bGw7XHJcbiAgICBwdWJsaWMgZ2V0IGxhYmVsKCk6IGNjLkxhYmVsIHwgY2MuUmljaFRleHQge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSB0aGlzLmdldENvbXBvbmVudChjYy5MYWJlbCkgPz8gdGhpcy5nZXRDb21wb25lbnQoY2MuUmljaFRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXJ0Q291bnRkb3duKHNlYzogbnVtYmVyLCBmb3JtYXQ6IENvdW50ZG93bkZvcm1hdCA9IFwiJXtoaH06JXttbX06JXtzc31cIiwgdXBkYXRlQ2FsbDogKCkgPT4gdm9pZCA9IG51bGwsIGNvbXBsZXRlQ2FsbDogKCkgPT4gdm9pZCA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9sZWZ0U2VjID0gc2VjO1xyXG4gICAgICAgIHRoaXMuX2xlZnRGbG9vclNlYyA9IE1hdGguZmxvb3Ioc2VjKTtcclxuICAgICAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FsbCA9IHVwZGF0ZUNhbGw7XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVDYWxsID0gY29tcGxldGVDYWxsO1xyXG4gICAgICAgIHRoaXMuX3R3ZWVuPy5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5fdHdlZW4gPSB0aGlzLnRpbWVTY2FsZSA/IG5ldyBUd2Vlbih0aGlzLCBTQ0FMRV9UV0VFTikgOiBuZXcgVHdlZW4odGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdHdlZW4udG8oeyBfbGVmdFNlYzogMCB9LCBzZWMgKiAxMDAwKVxyXG4gICAgICAgICAgICAub25VcGRhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub25Db21wbGV0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvblVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyDmr4/pmpQxc+abtOaWsOS4gOasoVxyXG4gICAgICAgIGxldCBmbG9vclNlYyA9IE1hdGguZmxvb3IodGhpcy5fbGVmdFNlYyk7XHJcbiAgICAgICAgaWYgKGZsb29yU2VjID09PSB0aGlzLl9sZWZ0Rmxvb3JTZWMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pu05paw5paH5pys5pi+56S6XHJcbiAgICAgICAgdGhpcy5fbGVmdEZsb29yU2VjID0gZmxvb3JTZWM7XHJcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbC5zdHJpbmcgPSBUb29sLmZvcm1hdFRpbWVTdHJpbmcodGhpcy5fbGVmdEZsb29yU2VjLCB0aGlzLl9mb3JtYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5pu05paw5Zue6LCDXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FsbD8uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNvbXBsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlQ2FsbD8uKCk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/shader/ShaderFill.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '63dfaBxVipD7bEv99K+9+0u', 'ShaderFill');
// scripts/common/cmpt/shader/ShaderFill.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple, executeInEditMode = _a.executeInEditMode;
var ShaderFill = /** @class */ (function (_super) {
    __extends(ShaderFill, _super);
    function ShaderFill() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fillColor = new cc.Color();
        _this.fillPhase = 0;
        _this._mat = null;
        return _this;
    }
    Object.defineProperty(ShaderFill.prototype, "mat", {
        get: function () {
            if (!this._mat) {
                this._mat = this.getComponent(cc.RenderComponent).getMaterial(0);
            }
            return this._mat;
        },
        enumerable: false,
        configurable: true
    });
    ShaderFill.prototype.start = function () {
        this.updateShader();
    };
    ShaderFill.prototype.update = function () {
        if (CC_EDITOR) {
            this.updateShader();
        }
    };
    ShaderFill.prototype.updateShader = function () {
        this.mat.setProperty("fillColor", this.fillColor);
        this.mat.setProperty("fillPhase", this.fillPhase);
    };
    __decorate([
        property({ tooltip: CC_DEV && "填充颜色" })
    ], ShaderFill.prototype, "fillColor", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "填充率", range: [0, 1] })
    ], ShaderFill.prototype, "fillPhase", void 0);
    ShaderFill = __decorate([
        ccclass,
        disallowMultiple,
        executeInEditMode,
        menu("Framework/Shader/ShaderFill")
    ], ShaderFill);
    return ShaderFill;
}(cc.Component));
exports.default = ShaderFill;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxzaGFkZXJcXFNoYWRlckZpbGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU0sSUFBQSxLQUFtRSxFQUFFLENBQUMsVUFBVSxFQUE5RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxpQkFBaUIsdUJBQWtCLENBQUM7QUFNdkY7SUFBd0MsOEJBQVk7SUFBcEQ7UUFBQSxxRUE0QkM7UUExQlUsZUFBUyxHQUFhLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRXJDLGVBQVMsR0FBVyxDQUFDLENBQUM7UUFFckIsVUFBSSxHQUFnQixJQUFJLENBQUM7O0lBc0JyQyxDQUFDO0lBckJHLHNCQUFXLDJCQUFHO2FBQWQ7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwRTtZQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyQixDQUFDOzs7T0FBQTtJQUVTLDBCQUFLLEdBQWY7UUFDSSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVTLDJCQUFNLEdBQWhCO1FBQ0ksSUFBSSxTQUFTLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkI7SUFDTCxDQUFDO0lBRU0saUNBQVksR0FBbkI7UUFDSSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQXpCRDtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7aURBQ0k7SUFFNUM7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztpREFDekI7SUFKWixVQUFVO1FBSjlCLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsaUJBQWlCO1FBQ2pCLElBQUksQ0FBQyw2QkFBNkIsQ0FBQztPQUNmLFVBQVUsQ0E0QjlCO0lBQUQsaUJBQUM7Q0E1QkQsQUE0QkMsQ0E1QnVDLEVBQUUsQ0FBQyxTQUFTLEdBNEJuRDtrQkE1Qm9CLFVBQVUiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCBkaXNhbGxvd011bHRpcGxlLCBleGVjdXRlSW5FZGl0TW9kZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AbWVudShcIkZyYW1ld29yay9TaGFkZXIvU2hhZGVyRmlsbFwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJGaWxsIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IENDX0RFViAmJiBcIuWhq+WFheminOiJslwiIH0pXHJcbiAgICBwdWJsaWMgZmlsbENvbG9yOiBjYy5Db2xvciA9IG5ldyBjYy5Db2xvcigpO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5aGr5YWF546HXCIsIHJhbmdlOiBbMCwgMV0gfSlcclxuICAgIHB1YmxpYyBmaWxsUGhhc2U6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJpdmF0ZSBfbWF0OiBjYy5NYXRlcmlhbCA9IG51bGw7XHJcbiAgICBwdWJsaWMgZ2V0IG1hdCgpOiBjYy5NYXRlcmlhbCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tYXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF0ID0gdGhpcy5nZXRDb21wb25lbnQoY2MuUmVuZGVyQ29tcG9uZW50KS5nZXRNYXRlcmlhbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTaGFkZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChDQ19FRElUT1IpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVNoYWRlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1hdC5zZXRQcm9wZXJ0eShcImZpbGxDb2xvclwiLCB0aGlzLmZpbGxDb2xvcik7XHJcbiAgICAgICAgdGhpcy5tYXQuc2V0UHJvcGVydHkoXCJmaWxsUGhhc2VcIiwgdGhpcy5maWxsUGhhc2UpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/animValue/AnimValueProgress.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '7f95cXxJPhAJaQaqRBZkHaC', 'AnimValueProgress');
// scripts/common/cmpt/ui/animValue/AnimValueProgress.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimValue_1 = require("./AnimValue");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent, executeInEditMode = _a.executeInEditMode;
/**
 * 数值渐变的进度条
 */
var AnimValueProgress = /** @class */ (function (_super) {
    __extends(AnimValueProgress, _super);
    function AnimValueProgress() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._progressBar = null;
        return _this;
    }
    Object.defineProperty(AnimValueProgress.prototype, "progressBar", {
        get: function () {
            if (!this._progressBar)
                this._progressBar = this.getComponent(cc.ProgressBar);
            return this._progressBar;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @override
     */
    AnimValueProgress.prototype.onAnimUpdate = function () {
        this.progressBar.progress = this.curValue;
    };
    AnimValueProgress = __decorate([
        ccclass,
        executeInEditMode,
        requireComponent(cc.ProgressBar),
        menu("Framework/UI组件/AnimValueProgress")
    ], AnimValueProgress);
    return AnimValueProgress;
}(AnimValue_1.default));
exports.default = AnimValueProgress;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYW5pbVZhbHVlXFxBbmltVmFsdWVQcm9ncmVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBb0M7QUFFOUIsSUFBQSxLQUFtRSxFQUFFLENBQUMsVUFBVSxFQUE5RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxpQkFBaUIsdUJBQWtCLENBQUM7QUFFdkY7O0dBRUc7QUFLSDtJQUErQyxxQ0FBUztJQUF4RDtRQUFBLHFFQWNDO1FBWlcsa0JBQVksR0FBbUIsSUFBSSxDQUFDOztJQVloRCxDQUFDO0lBWEcsc0JBQVcsMENBQVc7YUFBdEI7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVk7Z0JBQUUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM5RSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDN0IsQ0FBQzs7O09BQUE7SUFFRDs7T0FFRztJQUNPLHdDQUFZLEdBQXRCO1FBQ0ksSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUM5QyxDQUFDO0lBYmdCLGlCQUFpQjtRQUpyQyxPQUFPO1FBQ1AsaUJBQWlCO1FBQ2pCLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDaEMsSUFBSSxDQUFDLGtDQUFrQyxDQUFDO09BQ3BCLGlCQUFpQixDQWNyQztJQUFELHdCQUFDO0NBZEQsQUFjQyxDQWQ4QyxtQkFBUyxHQWN2RDtrQkFkb0IsaUJBQWlCIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFuaW1WYWx1ZSBmcm9tIFwiLi9BbmltVmFsdWVcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUsIHJlcXVpcmVDb21wb25lbnQsIGV4ZWN1dGVJbkVkaXRNb2RlIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOaVsOWAvOa4kOWPmOeahOi/m+W6puadoVxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGV4ZWN1dGVJbkVkaXRNb2RlXHJcbkByZXF1aXJlQ29tcG9uZW50KGNjLlByb2dyZXNzQmFyKVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9BbmltVmFsdWVQcm9ncmVzc1wiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltVmFsdWVQcm9ncmVzcyBleHRlbmRzIEFuaW1WYWx1ZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBfcHJvZ3Jlc3NCYXI6IGNjLlByb2dyZXNzQmFyID0gbnVsbDtcclxuICAgIHB1YmxpYyBnZXQgcHJvZ3Jlc3NCYXIoKTogY2MuUHJvZ3Jlc3NCYXIge1xyXG4gICAgICAgIGlmICghdGhpcy5fcHJvZ3Jlc3NCYXIpIHRoaXMuX3Byb2dyZXNzQmFyID0gdGhpcy5nZXRDb21wb25lbnQoY2MuUHJvZ3Jlc3NCYXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzc0JhcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25BbmltVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIucHJvZ3Jlc3MgPSB0aGlzLmN1clZhbHVlO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/adapt/AdaptCanvas.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '2174f+PKGlGH7csvm0koWVs', 'AdaptCanvas');
// scripts/common/cmpt/ui/adapt/AdaptCanvas.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EventName_1 = require("../../../const/EventName");
var Events_1 = require("../../../util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, disallowMultiple = _a.disallowMultiple;
// 仅web有效
cc.view.setResizeCallback(function () {
    Events_1.default.emit(EventName_1.EventName.RESIZE);
});
/**
 * 分辨率适配组件，保证设计分辨率区域全部都能显示
 */
var AdaptCanvas = /** @class */ (function (_super) {
    __extends(AdaptCanvas, _super);
    function AdaptCanvas() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AdaptCanvas.prototype.onLoad = function () {
        this.adapt();
    };
    AdaptCanvas.prototype.adapt = function () {
        var resolutionRatio = cc.Canvas.instance.designResolution.width / cc.Canvas.instance.designResolution.height;
        var ratio = cc.winSize.width / cc.winSize.height;
        if (ratio > resolutionRatio) {
            cc.Canvas.instance.fitHeight = true;
            cc.Canvas.instance.fitWidth = false;
        }
        else {
            cc.Canvas.instance.fitHeight = false;
            cc.Canvas.instance.fitWidth = true;
        }
    };
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.RESIZE)
    ], AdaptCanvas.prototype, "adapt", null);
    AdaptCanvas = __decorate([
        ccclass,
        Events_1.eventsOnLoad(),
        disallowMultiple,
        menu("Framework/UI组件/AdaptCanvas")
    ], AdaptCanvas);
    return AdaptCanvas;
}(cc.Component));
exports.default = AdaptCanvas;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYWRhcHRcXEFkYXB0Q2FudmFzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNEQUFxRDtBQUNyRCwrQ0FBMEU7QUFFcEUsSUFBQSxLQUFnRCxFQUFFLENBQUMsVUFBVSxFQUEzRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFcEUsU0FBUztBQUNULEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFDdEIsZ0JBQU0sQ0FBQyxJQUFJLENBQUMscUJBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQztBQUVIOztHQUVHO0FBS0g7SUFBeUMsK0JBQVk7SUFBckQ7O0lBaUJBLENBQUM7SUFoQmEsNEJBQU0sR0FBaEI7UUFDSSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUdPLDJCQUFLLEdBQWI7UUFDSSxJQUFJLGVBQWUsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO1FBQzdHLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ2pELElBQUksS0FBSyxHQUFHLGVBQWUsRUFBRTtZQUN6QixFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ3BDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7U0FDdkM7YUFBTTtZQUNILEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDckMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztTQUN0QztJQUNMLENBQUM7SUFWRDtRQURDLHFCQUFZLENBQUMscUJBQVMsQ0FBQyxNQUFNLENBQUM7NENBVzlCO0lBaEJnQixXQUFXO1FBSi9CLE9BQU87UUFDUCxxQkFBWSxFQUFFO1FBQ2QsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQyw0QkFBNEIsQ0FBQztPQUNkLFdBQVcsQ0FpQi9CO0lBQUQsa0JBQUM7Q0FqQkQsQUFpQkMsQ0FqQndDLEVBQUUsQ0FBQyxTQUFTLEdBaUJwRDtrQkFqQm9CLFdBQVciLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudE5hbWUgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCBFdmVudHMsIHsgZXZlbnRzT25Mb2FkLCBwcmVsb2FkRXZlbnQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbC9FdmVudHNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUsIGRpc2FsbG93TXVsdGlwbGUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vLyDku4V3ZWLmnInmlYhcclxuY2Mudmlldy5zZXRSZXNpemVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBFdmVudHMuZW1pdChFdmVudE5hbWUuUkVTSVpFKTtcclxufSk7XHJcblxyXG4vKipcclxuICog5YiG6L6o546H6YCC6YWN57uE5Lu277yM5L+d6K+B6K6+6K6h5YiG6L6o546H5Yy65Z+f5YWo6YOo6YO96IO95pi+56S6XHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AZXZlbnRzT25Mb2FkKClcclxuQGRpc2FsbG93TXVsdGlwbGVcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvQWRhcHRDYW52YXNcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRhcHRDYW52YXMgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFkYXB0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgQHByZWxvYWRFdmVudChFdmVudE5hbWUuUkVTSVpFKVxyXG4gICAgcHJpdmF0ZSBhZGFwdCgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgcmVzb2x1dGlvblJhdGlvID0gY2MuQ2FudmFzLmluc3RhbmNlLmRlc2lnblJlc29sdXRpb24ud2lkdGggLyBjYy5DYW52YXMuaW5zdGFuY2UuZGVzaWduUmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgbGV0IHJhdGlvID0gY2Mud2luU2l6ZS53aWR0aCAvIGNjLndpblNpemUuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChyYXRpbyA+IHJlc29sdXRpb25SYXRpbykge1xyXG4gICAgICAgICAgICBjYy5DYW52YXMuaW5zdGFuY2UuZml0SGVpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2MuQ2FudmFzLmluc3RhbmNlLmZpdFdpZHRoID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2MuQ2FudmFzLmluc3RhbmNlLmZpdEhlaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYy5DYW52YXMuaW5zdGFuY2UuZml0V2lkdGggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/core/AnimatorStateLogic.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '67f80RtpchPbbZr6OYBU8NI', 'AnimatorStateLogic');
// scripts/animator/core/AnimatorStateLogic.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 状态逻辑基类
 */
var AnimatorStateLogic = /** @class */ (function () {
    function AnimatorStateLogic() {
    }
    /**
     * 进入状态时调用
     * @virtual
     */
    AnimatorStateLogic.prototype.onEntry = function () {
    };
    /**
     * 每次状态机逻辑更新时调用
     * @virtual
     */
    AnimatorStateLogic.prototype.onUpdate = function () {
    };
    /**
     * 离开状态时调用
     * @virtual
     */
    AnimatorStateLogic.prototype.onExit = function () {
    };
    return AnimatorStateLogic;
}());
exports.default = AnimatorStateLogic;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXGNvcmVcXEFuaW1hdG9yU3RhdGVMb2dpYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0g7SUFBQTtJQXFCQSxDQUFDO0lBcEJHOzs7T0FHRztJQUNJLG9DQUFPLEdBQWQ7SUFDQSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0kscUNBQVEsR0FBZjtJQUNBLENBQUM7SUFFRDs7O09BR0c7SUFDSSxtQ0FBTSxHQUFiO0lBQ0EsQ0FBQztJQUNMLHlCQUFDO0FBQUQsQ0FyQkEsQUFxQkMsSUFBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiDnirbmgIHpgLvovpHln7rnsbtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yU3RhdGVMb2dpYyB7XHJcbiAgICAvKipcclxuICAgICAqIOi/m+WFpeeKtuaAgeaXtuiwg+eUqFxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uRW50cnkoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmr4/mrKHnirbmgIHmnLrpgLvovpHmm7TmlrDml7bosIPnlKhcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblVwZGF0ZSgpIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOemu+W8gOeKtuaAgeaXtuiwg+eUqFxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uRXhpdCgpIHtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/animator/AnimatorCustomization.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '32e01QIrwtP4buKMSAxTJmr', 'AnimatorCustomization');
// scripts/animator/AnimatorCustomization.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimatorBase_1 = require("./core/AnimatorBase");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * 自定义动画控制的状态机组件
 */
var AnimatorCustomization = /** @class */ (function (_super) {
    __extends(AnimatorCustomization, _super);
    function AnimatorCustomization() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** 此组件必须主动调用onInit初始化 */
        _this.playOnStart = false;
        return _this;
    }
    /**
     * 手动初始化状态机，可传入0-3个参数，类型如下
     * - onStateChangeCall 状态切换时的回调
     * - stateLogicMap 各个状态逻辑控制
     * - animationPlayer 自定义动画控制
     * @override
     */
    AnimatorCustomization.prototype.onInit = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this._hasInit) {
            return;
        }
        this._hasInit = true;
        this.initArgs.apply(this, args);
        if (this.assetRawUrl !== null) {
            this.initJson(this.assetRawUrl.json);
        }
    };
    /**
     * 播放动画
     * @override
     * @param animName 动画名
     * @param loop 是否循环播放
     */
    AnimatorCustomization.prototype.playAnimation = function (animName, loop) {
        if (this._animationPlayer && animName) {
            this._animationPlayer.playAnimation(animName, loop);
        }
    };
    /**
     * 缩放动画播放速率
     * @override
     * @param scale 缩放倍率
     */
    AnimatorCustomization.prototype.scaleTime = function (scale) {
        if (this._animationPlayer) {
            this._animationPlayer.scaleTime(scale);
        }
    };
    __decorate([
        property({ override: true, visible: false })
    ], AnimatorCustomization.prototype, "playOnStart", void 0);
    AnimatorCustomization = __decorate([
        ccclass,
        disallowMultiple,
        menu('Framework/Animator/AnimatorCustomization')
    ], AnimatorCustomization);
    return AnimatorCustomization;
}(AnimatorBase_1.default));
exports.default = AnimatorCustomization;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcYW5pbWF0b3JcXEFuaW1hdG9yQ3VzdG9taXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBb0U7QUFHOUQsSUFBQSxLQUFrRSxFQUFFLENBQUMsVUFBVSxFQUE3RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFFdEY7O0dBRUc7QUFJSDtJQUFtRCx5Q0FBWTtJQUEvRDtRQUFBLHFFQStDQztRQTlDRyx5QkFBeUI7UUFFZixpQkFBVyxHQUFZLEtBQUssQ0FBQzs7SUE0QzNDLENBQUM7SUExQ0c7Ozs7OztPQU1HO0lBQ0ksc0NBQU0sR0FBYjtRQUFjLGNBQWtIO2FBQWxILFVBQWtILEVBQWxILHFCQUFrSCxFQUFsSCxJQUFrSDtZQUFsSCx5QkFBa0g7O1FBQzVILElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNmLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXJCLElBQUksQ0FBQyxRQUFRLE9BQWIsSUFBSSxFQUFhLElBQUksRUFBRTtRQUV2QixJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxFQUFFO1lBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLDZDQUFhLEdBQXZCLFVBQXdCLFFBQWdCLEVBQUUsSUFBYTtRQUNuRCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxRQUFRLEVBQUU7WUFDbkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdkQ7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLHlDQUFTLEdBQW5CLFVBQW9CLEtBQWE7UUFDN0IsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQztJQUNMLENBQUM7SUEzQ0Q7UUFEQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQzs4REFDTjtJQUh0QixxQkFBcUI7UUFIekMsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixJQUFJLENBQUMsMENBQTBDLENBQUM7T0FDNUIscUJBQXFCLENBK0N6QztJQUFELDRCQUFDO0NBL0NELEFBK0NDLENBL0NrRCxzQkFBWSxHQStDOUQ7a0JBL0NvQixxQkFBcUIiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQW5pbWF0b3JCYXNlLCB7IEFuaW1hdGlvblBsYXllciB9IGZyb20gXCIuL2NvcmUvQW5pbWF0b3JCYXNlXCI7XHJcbmltcG9ydCBBbmltYXRvclN0YXRlTG9naWMgZnJvbSBcIi4vY29yZS9BbmltYXRvclN0YXRlTG9naWNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIHJlcXVpcmVDb21wb25lbnQsIGRpc2FsbG93TXVsdGlwbGUsIG1lbnUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKiogXHJcbiAqIOiHquWumuS5ieWKqOeUu+aOp+WItueahOeKtuaAgeacuue7hOS7tlxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGRpc2FsbG93TXVsdGlwbGVcclxuQG1lbnUoJ0ZyYW1ld29yay9BbmltYXRvci9BbmltYXRvckN1c3RvbWl6YXRpb24nKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckN1c3RvbWl6YXRpb24gZXh0ZW5kcyBBbmltYXRvckJhc2Uge1xyXG4gICAgLyoqIOatpOe7hOS7tuW/hemhu+S4u+WKqOiwg+eUqG9uSW5pdOWIneWni+WMliAqL1xyXG4gICAgQHByb3BlcnR5KHsgb3ZlcnJpZGU6IHRydWUsIHZpc2libGU6IGZhbHNlIH0pXHJcbiAgICBwcm90ZWN0ZWQgcGxheU9uU3RhcnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaJi+WKqOWIneWni+WMlueKtuaAgeacuu+8jOWPr+S8oOWFpTAtM+S4quWPguaVsO+8jOexu+Wei+WmguS4i1xyXG4gICAgICogLSBvblN0YXRlQ2hhbmdlQ2FsbCDnirbmgIHliIfmjaLml7bnmoTlm57osINcclxuICAgICAqIC0gc3RhdGVMb2dpY01hcCDlkITkuKrnirbmgIHpgLvovpHmjqfliLZcclxuICAgICAqIC0gYW5pbWF0aW9uUGxheWVyIOiHquWumuS5ieWKqOeUu+aOp+WItlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkluaXQoLi4uYXJnczogQXJyYXk8TWFwPHN0cmluZywgQW5pbWF0b3JTdGF0ZUxvZ2ljPiB8ICgoZnJvbVN0YXRlOiBzdHJpbmcsIHRvU3RhdGU6IHN0cmluZykgPT4gdm9pZCkgfCBBbmltYXRpb25QbGF5ZXI+KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc0luaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYXNJbml0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0QXJncyguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXNzZXRSYXdVcmwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0SnNvbih0aGlzLmFzc2V0UmF3VXJsLmpzb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvuWKqOeUu1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gYW5pbU5hbWUg5Yqo55S75ZCNXHJcbiAgICAgKiBAcGFyYW0gbG9vcCDmmK/lkKblvqrnjq/mkq3mlL5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBsYXlBbmltYXRpb24oYW5pbU5hbWU6IHN0cmluZywgbG9vcDogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25QbGF5ZXIgJiYgYW5pbU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUGxheWVyLnBsYXlBbmltYXRpb24oYW5pbU5hbWUsIGxvb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8qeaUvuWKqOeUu+aSreaUvumAn+eOh1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUg57yp5pS+5YCN546HXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzY2FsZVRpbWUoc2NhbGU6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25QbGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUGxheWVyLnNjYWxlVGltZShzY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/animValue/AnimValueProgressHP.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c3afeSdbzBJDJZejppXH98u', 'AnimValueProgressHP');
// scripts/common/cmpt/ui/animValue/AnimValueProgressHP.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AnimValueProgress_1 = require("./AnimValueProgress");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent, executeInEditMode = _a.executeInEditMode;
/**
 * 血条组件
 */
var AnimValueProgressHP = /** @class */ (function (_super) {
    __extends(AnimValueProgressHP, _super);
    function AnimValueProgressHP() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.barShadow = null;
        return _this;
    }
    AnimValueProgressHP.prototype.setBarShadow = function (progress) {
        switch (this.progressBar.mode) {
            case cc.ProgressBar.Mode.HORIZONTAL:
                this.barShadow.node.width = this.progressBar.totalLength * progress;
                break;
            case cc.ProgressBar.Mode.VERTICAL:
                this.barShadow.node.height = this.progressBar.totalLength * progress;
                break;
            case cc.ProgressBar.Mode.FILLED:
                this.barShadow.fillRange = progress;
            default:
                break;
        }
    };
    /**
     * @override
     */
    AnimValueProgressHP.prototype.onAnimStart = function () {
        if (this.isAdd) {
        }
        else {
            this.progressBar.progress = this.endValue;
        }
    };
    /**
     * @override
     */
    AnimValueProgressHP.prototype.onAnimUpdate = function () {
        if (this.isAdd) {
            this.setBarShadow(this.curValue);
            this.progressBar.progress = this.curValue;
        }
        else {
            this.setBarShadow(this.curValue);
        }
    };
    __decorate([
        property({
            type: cc.Sprite,
            tooltip: CC_DEV && "血条阴影，如果barSprite渲染模式为filled模式，此sprite也要对应修改，保持一致"
        })
    ], AnimValueProgressHP.prototype, "barShadow", void 0);
    AnimValueProgressHP = __decorate([
        ccclass,
        executeInEditMode,
        requireComponent(cc.ProgressBar),
        menu("Framework/UI组件/AnimValueProgressHP")
    ], AnimValueProgressHP);
    return AnimValueProgressHP;
}(AnimValueProgress_1.default));
exports.default = AnimValueProgressHP;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYW5pbVZhbHVlXFxBbmltVmFsdWVQcm9ncmVzc0hQLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlEQUFvRDtBQUU5QyxJQUFBLEtBQW1FLEVBQUUsQ0FBQyxVQUFVLEVBQTlFLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLGlCQUFpQix1QkFBa0IsQ0FBQztBQUV2Rjs7R0FFRztBQUtIO0lBQWlELHVDQUFpQjtJQUFsRTtRQUFBLHFFQTRDQztRQXZDVSxlQUFTLEdBQWMsSUFBSSxDQUFDOztJQXVDdkMsQ0FBQztJQXJDVywwQ0FBWSxHQUFwQixVQUFxQixRQUFnQjtRQUNqQyxRQUFRLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFO1lBQzNCLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVTtnQkFDL0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztnQkFDcEUsTUFBTTtZQUNWLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUTtnQkFDN0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztnQkFDckUsTUFBTTtZQUNWLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTTtnQkFDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1lBQ3hDO2dCQUNJLE1BQU07U0FDYjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNPLHlDQUFXLEdBQXJCO1FBQ0ksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1NBRWY7YUFBTTtZQUNILElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDN0M7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDTywwQ0FBWSxHQUF0QjtRQUNJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNaLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDN0M7YUFBTTtZQUNILElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3BDO0lBQ0wsQ0FBQztJQXRDRDtRQUpDLFFBQVEsQ0FBQztZQUNOLElBQUksRUFBRSxFQUFFLENBQUMsTUFBTTtZQUNmLE9BQU8sRUFBRSxNQUFNLElBQUksa0RBQWtEO1NBQ3hFLENBQUM7MERBQ2lDO0lBTGxCLG1CQUFtQjtRQUp2QyxPQUFPO1FBQ1AsaUJBQWlCO1FBQ2pCLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDaEMsSUFBSSxDQUFDLG9DQUFvQyxDQUFDO09BQ3RCLG1CQUFtQixDQTRDdkM7SUFBRCwwQkFBQztDQTVDRCxBQTRDQyxDQTVDZ0QsMkJBQWlCLEdBNENqRTtrQkE1Q29CLG1CQUFtQiIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBbmltVmFsdWVQcm9ncmVzcyBmcm9tIFwiLi9BbmltVmFsdWVQcm9ncmVzc1wiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgbWVudSwgcmVxdWlyZUNvbXBvbmVudCwgZXhlY3V0ZUluRWRpdE1vZGUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKipcclxuICog6KGA5p2h57uE5Lu2XHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AZXhlY3V0ZUluRWRpdE1vZGVcclxuQHJlcXVpcmVDb21wb25lbnQoY2MuUHJvZ3Jlc3NCYXIpXHJcbkBtZW51KFwiRnJhbWV3b3JrL1VJ57uE5Lu2L0FuaW1WYWx1ZVByb2dyZXNzSFBcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbVZhbHVlUHJvZ3Jlc3NIUCBleHRlbmRzIEFuaW1WYWx1ZVByb2dyZXNzIHtcclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuU3ByaXRlLFxyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuihgOadoemYtOW9se+8jOWmguaenGJhclNwcml0Zea4suafk+aooeW8j+S4umZpbGxlZOaooeW8j++8jOatpHNwcml0ZeS5n+imgeWvueW6lOS/ruaUue+8jOS/neaMgeS4gOiHtFwiXHJcbiAgICB9KVxyXG4gICAgcHVibGljIGJhclNoYWRvdzogY2MuU3ByaXRlID0gbnVsbDtcclxuXHJcbiAgICBwcml2YXRlIHNldEJhclNoYWRvdyhwcm9ncmVzczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb2dyZXNzQmFyLm1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBjYy5Qcm9ncmVzc0Jhci5Nb2RlLkhPUklaT05UQUw6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhclNoYWRvdy5ub2RlLndpZHRoID0gdGhpcy5wcm9ncmVzc0Jhci50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuUHJvZ3Jlc3NCYXIuTW9kZS5WRVJUSUNBTDpcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFyU2hhZG93Lm5vZGUuaGVpZ2h0ID0gdGhpcy5wcm9ncmVzc0Jhci50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuUHJvZ3Jlc3NCYXIuTW9kZS5GSUxMRUQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhclNoYWRvdy5maWxsUmFuZ2UgPSBwcm9ncmVzcztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25BbmltU3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBZGQpIHtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5wcm9ncmVzcyA9IHRoaXMuZW5kVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbkFuaW1VcGRhdGUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBZGQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCYXJTaGFkb3codGhpcy5jdXJWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIucHJvZ3Jlc3MgPSB0aGlzLmN1clZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QmFyU2hhZG93KHRoaXMuY3VyVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/animValue/AnimValue.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'cfe49J1R7JHxIqVge927Yqj', 'AnimValue');
// scripts/common/cmpt/ui/animValue/AnimValue.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Tween_1 = require("../../../util/Tween");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, executeInEditMode = _a.executeInEditMode;
/**
 * 数值变化类型
 */
var AnimType;
(function (AnimType) {
    /** 以速度计算变化时长 */
    AnimType[AnimType["SPEED"] = 0] = "SPEED";
    /** 固定时长 */
    AnimType[AnimType["DURATION"] = 1] = "DURATION";
})(AnimType || (AnimType = {}));
/**
 * 固定时长时的缓动类型
 */
var EasingType;
(function (EasingType) {
    EasingType[EasingType["NONE"] = 0] = "NONE";
    EasingType[EasingType["IN"] = 1] = "IN";
    EasingType[EasingType["OUT"] = 2] = "OUT";
    EasingType[EasingType["IN_OUT"] = 3] = "IN_OUT";
})(EasingType || (EasingType = {}));
/**
 * 数值渐变组件基类，可根据此组件拓展各种数值渐变的组件
 */
var AnimValue = /** @class */ (function (_super) {
    __extends(AnimValue, _super);
    function AnimValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._endValue = 0;
        _this._curValue = 0;
        _this.animType = AnimType.SPEED;
        _this.speed = 1;
        _this.duration = 1;
        _this.easingType = EasingType.NONE;
        _this.timeScale = false;
        _this._tween = null;
        _this._isAdd = false;
        return _this;
    }
    Object.defineProperty(AnimValue.prototype, "initValue", {
        get: function () { return this._endValue; },
        set: function (v) {
            this._curValue = v;
            this._endValue = v;
            this.setValueImmediately(this._endValue);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimValue.prototype, "isAdd", {
        /** 当前是否为增量变化 */
        get: function () { return this._isAdd; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimValue.prototype, "endValue", {
        /** 变化的目标值 */
        get: function () { return this._endValue; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimValue.prototype, "curValue", {
        /** 变化过程的当前值 */
        get: function () { return this._curValue; },
        enumerable: false,
        configurable: true
    });
    /**
     * @virtual
     */
    AnimValue.prototype.onAnimStart = function () {
    };
    /**
     * @virtual
     */
    AnimValue.prototype.onAnimUpdate = function () {
    };
    /**
     * @virtual
     */
    AnimValue.prototype.onAnimComplete = function () {
        if (this._animResolve) {
            this._animResolve();
            this._animResolve = null;
        }
        if (this._tween) {
            this._tween.stop();
            this._tween = null;
        }
    };
    /**
     * 立即设置value，不执行动画
     * @virtual
     */
    AnimValue.prototype.setValueImmediately = function (end) {
        this._isAdd = this._endValue - this._curValue > 0;
        this._endValue = end;
        this._curValue = end;
        this.onAnimStart();
        this.onAnimUpdate();
        this.onAnimComplete();
    };
    /**
     * 设置进度值。进度动画结束后resolve
     * @virtual
     * @param end 目标进度值
     * @param anim 是否执行动画，默认true
     */
    AnimValue.prototype.setValue = function (end, anim) {
        var _this = this;
        if (anim === void 0) { anim = true; }
        return new Promise(function (resolve, reject) {
            var _a;
            if (!anim) {
                _this.setValueImmediately(end);
                resolve();
                return;
            }
            _this._animResolve = resolve;
            _this._endValue = end;
            _this._isAdd = _this._endValue - _this._curValue > 0;
            (_a = _this._tween) === null || _a === void 0 ? void 0 : _a.stop();
            _this._tween = _this.timeScale ? new Tween_1.Tween(_this, Tween_1.SCALE_TWEEN) : new Tween_1.Tween(_this);
            var duration = _this.animType === AnimType.DURATION ? _this.duration : Math.abs(_this._endValue - _this._curValue) / _this.speed;
            switch (_this.easingType) {
                case EasingType.IN:
                    _this._tween.easing(Tween_1.Easing.Quadratic.In);
                    break;
                case EasingType.OUT:
                    _this._tween.easing(Tween_1.Easing.Quadratic.Out);
                    break;
                case EasingType.IN_OUT:
                    _this._tween.easing(Tween_1.Easing.Quadratic.InOut);
                    break;
                default:
                    break;
            }
            _this._tween.to({ _curValue: _this._endValue }, duration * 1000)
                .onStart(function () {
                _this.onAnimStart();
            })
                .onUpdate(function () {
                _this.onAnimUpdate();
            })
                .onComplete(function () {
                _this.onAnimComplete();
            })
                .start();
        });
    };
    /**
     * 停止动画，并中止之前未结束的Promise
     * @virtual
     */
    AnimValue.prototype.stop = function () {
        if (this._animResolve) {
            this._animResolve = null;
        }
        if (this._tween) {
            this._tween.stop();
            this._tween = null;
        }
    };
    __decorate([
        property
    ], AnimValue.prototype, "_endValue", void 0);
    __decorate([
        property
    ], AnimValue.prototype, "_curValue", void 0);
    __decorate([
        property({
            tooltip: CC_DEV && "初始值"
        })
    ], AnimValue.prototype, "initValue", null);
    __decorate([
        property({
            type: cc.Enum(AnimType),
            tooltip: CC_DEV && "数值变化类型\nSPEED：以速度计算变化时长\nDURATION：固定时长"
        })
    ], AnimValue.prototype, "animType", void 0);
    __decorate([
        property({
            tooltip: CC_DEV && "每秒数值变化速度",
            visible: function () { return this.animType === AnimType.SPEED; }
        })
    ], AnimValue.prototype, "speed", void 0);
    __decorate([
        property({
            tooltip: CC_DEV && "数值变化的总时长",
            visible: function () { return this.animType === AnimType.DURATION; }
        })
    ], AnimValue.prototype, "duration", void 0);
    __decorate([
        property({
            type: cc.Enum(EasingType),
            tooltip: CC_DEV && "变化的缓动类型"
        })
    ], AnimValue.prototype, "easingType", void 0);
    __decorate([
        property({
            tooltip: CC_DEV && "变化速度是否受到timeScale的影响"
        })
    ], AnimValue.prototype, "timeScale", void 0);
    AnimValue = __decorate([
        ccclass,
        executeInEditMode,
        menu("Framework/UI组件/AnimValue")
    ], AnimValue);
    return AnimValue;
}(cc.Component));
exports.default = AnimValue;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYW5pbVZhbHVlXFxBbmltVmFsdWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQWlFO0FBRTNELElBQUEsS0FBaUQsRUFBRSxDQUFDLFVBQVUsRUFBNUQsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsSUFBSSxVQUFBLEVBQUUsaUJBQWlCLHVCQUFrQixDQUFDO0FBRXJFOztHQUVHO0FBQ0gsSUFBSyxRQUtKO0FBTEQsV0FBSyxRQUFRO0lBQ1QsZ0JBQWdCO0lBQ2hCLHlDQUFLLENBQUE7SUFDTCxXQUFXO0lBQ1gsK0NBQVEsQ0FBQTtBQUNaLENBQUMsRUFMSSxRQUFRLEtBQVIsUUFBUSxRQUtaO0FBRUQ7O0dBRUc7QUFDSCxJQUFLLFVBS0o7QUFMRCxXQUFLLFVBQVU7SUFDWCwyQ0FBSSxDQUFBO0lBQ0osdUNBQUUsQ0FBQTtJQUNGLHlDQUFHLENBQUE7SUFDSCwrQ0FBTSxDQUFBO0FBQ1YsQ0FBQyxFQUxJLFVBQVUsS0FBVixVQUFVLFFBS2Q7QUFFRDs7R0FFRztBQUlIO0lBQXVDLDZCQUFZO0lBQW5EO1FBQUEscUVBMEpDO1FBekpxQixlQUFTLEdBQVcsQ0FBQyxDQUFDO1FBQ3RCLGVBQVMsR0FBVyxDQUFDLENBQUM7UUFnQmpDLGNBQVEsR0FBYSxRQUFRLENBQUMsS0FBSyxDQUFDO1FBTXBDLFdBQUssR0FBVyxDQUFDLENBQUM7UUFNbEIsY0FBUSxHQUFXLENBQUMsQ0FBQztRQU1yQixnQkFBVSxHQUFlLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFLekMsZUFBUyxHQUFZLEtBQUssQ0FBQztRQUkxQixZQUFNLEdBQWdCLElBQUksQ0FBQztRQUMzQixZQUFNLEdBQVksS0FBSyxDQUFDOztJQTRHcEMsQ0FBQztJQW5KRyxzQkFBWSxnQ0FBUzthQUFyQixjQUFrQyxPQUFPLElBQUksQ0FBQyxTQUFTLENB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c291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFYXNpbmcsIFNDQUxFX1RXRUVOLCBUd2VlbiB9IGZyb20gXCIuLi8uLi8uLi91dGlsL1R3ZWVuXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCBleGVjdXRlSW5FZGl0TW9kZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiDmlbDlgLzlj5jljJbnsbvlnotcclxuICovXHJcbmVudW0gQW5pbVR5cGUge1xyXG4gICAgLyoqIOS7pemAn+W6puiuoeeul+WPmOWMluaXtumVvyAqL1xyXG4gICAgU1BFRUQsXHJcbiAgICAvKiog5Zu65a6a5pe26ZW/ICovXHJcbiAgICBEVVJBVElPTixcclxufVxyXG5cclxuLyoqXHJcbiAqIOWbuuWumuaXtumVv+aXtueahOe8k+WKqOexu+Wei1xyXG4gKi9cclxuZW51bSBFYXNpbmdUeXBlIHtcclxuICAgIE5PTkUsXHJcbiAgICBJTixcclxuICAgIE9VVCxcclxuICAgIElOX09VVCxcclxufVxyXG5cclxuLyoqXHJcbiAqIOaVsOWAvOa4kOWPmOe7hOS7tuWfuuexu++8jOWPr+agueaNruatpOe7hOS7tuaLk+WxleWQhOenjeaVsOWAvOa4kOWPmOeahOe7hOS7tlxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGV4ZWN1dGVJbkVkaXRNb2RlXHJcbkBtZW51KFwiRnJhbWV3b3JrL1VJ57uE5Lu2L0FuaW1WYWx1ZVwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltVmFsdWUgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgQHByb3BlcnR5IHByaXZhdGUgX2VuZFZhbHVlOiBudW1iZXIgPSAwO1xyXG4gICAgQHByb3BlcnR5IHByaXZhdGUgX2N1clZhbHVlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5Yid5aeL5YC8XCJcclxuICAgIH0pXHJcbiAgICBwcml2YXRlIGdldCBpbml0VmFsdWUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2VuZFZhbHVlOyB9XHJcbiAgICBwcml2YXRlIHNldCBpbml0VmFsdWUodjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VyVmFsdWUgPSB2O1xyXG4gICAgICAgIHRoaXMuX2VuZFZhbHVlID0gdjtcclxuICAgICAgICB0aGlzLnNldFZhbHVlSW1tZWRpYXRlbHkodGhpcy5fZW5kVmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuRW51bShBbmltVHlwZSksXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5pWw5YC85Y+Y5YyW57G75Z6LXFxuU1BFRUTvvJrku6XpgJ/luqborqHnrpflj5jljJbml7bplb9cXG5EVVJBVElPTu+8muWbuuWumuaXtumVv1wiXHJcbiAgICB9KVxyXG4gICAgcHVibGljIGFuaW1UeXBlOiBBbmltVHlwZSA9IEFuaW1UeXBlLlNQRUVEO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5q+P56eS5pWw5YC85Y+Y5YyW6YCf5bqmXCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMuYW5pbVR5cGUgPT09IEFuaW1UeXBlLlNQRUVEOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIHNwZWVkOiBudW1iZXIgPSAxO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5pWw5YC85Y+Y5YyW55qE5oC75pe26ZW/XCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMuYW5pbVR5cGUgPT09IEFuaW1UeXBlLkRVUkFUSU9OOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIGR1cmF0aW9uOiBudW1iZXIgPSAxO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuRW51bShFYXNpbmdUeXBlKSxcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLlj5jljJbnmoTnvJPliqjnsbvlnotcIlxyXG4gICAgfSlcclxuICAgIHB1YmxpYyBlYXNpbmdUeXBlOiBFYXNpbmdUeXBlID0gRWFzaW5nVHlwZS5OT05FO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5Y+Y5YyW6YCf5bqm5piv5ZCm5Y+X5YiwdGltZVNjYWxl55qE5b2x5ZONXCJcclxuICAgIH0pXHJcbiAgICBwdWJsaWMgdGltZVNjYWxlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIOe8k+WtmOWKqOeUu+eahHJlc29sdmUgKi9cclxuICAgIHByaXZhdGUgX2FuaW1SZXNvbHZlOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgX3R3ZWVuOiBUd2Vlbjx0aGlzPiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9pc0FkZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIOW9k+WJjeaYr+WQpuS4uuWinumHj+WPmOWMliAqL1xyXG4gICAgcHVibGljIGdldCBpc0FkZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzQWRkOyB9XHJcblxyXG4gICAgLyoqIOWPmOWMlueahOebruagh+WAvCAqL1xyXG4gICAgcHVibGljIGdldCBlbmRWYWx1ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZW5kVmFsdWU7IH1cclxuICAgIC8qKiDlj5jljJbov4fnqIvnmoTlvZPliY3lgLwgKi9cclxuICAgIHB1YmxpYyBnZXQgY3VyVmFsdWUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2N1clZhbHVlOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25BbmltU3RhcnQoKTogdm9pZCB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25BbmltVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uQW5pbUNvbXBsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbmltUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltUmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbmltUmVzb2x2ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl90d2Vlbikge1xyXG4gICAgICAgICAgICB0aGlzLl90d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnq4vljbPorr7nva52YWx1Ze+8jOS4jeaJp+ihjOWKqOeUu1xyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNldFZhbHVlSW1tZWRpYXRlbHkoZW5kOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9pc0FkZCA9IHRoaXMuX2VuZFZhbHVlIC0gdGhpcy5fY3VyVmFsdWUgPiAwO1xyXG4gICAgICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xyXG4gICAgICAgIHRoaXMuX2N1clZhbHVlID0gZW5kO1xyXG4gICAgICAgIHRoaXMub25BbmltU3RhcnQoKTtcclxuICAgICAgICB0aGlzLm9uQW5pbVVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMub25BbmltQ29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rui/m+W6puWAvOOAgui/m+W6puWKqOeUu+e7k+adn+WQjnJlc29sdmVcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKiBAcGFyYW0gZW5kIOebruagh+i/m+W6puWAvFxyXG4gICAgICogQHBhcmFtIGFuaW0g5piv5ZCm5omn6KGM5Yqo55S777yM6buY6K6kdHJ1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VmFsdWUoZW5kOiBudW1iZXIsIGFuaW06IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFhbmltKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlSW1tZWRpYXRlbHkoZW5kKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fYW5pbVJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRWYWx1ZSA9IGVuZDtcclxuICAgICAgICAgICAgdGhpcy5faXNBZGQgPSB0aGlzLl9lbmRWYWx1ZSAtIHRoaXMuX2N1clZhbHVlID4gMDtcclxuICAgICAgICAgICAgdGhpcy5fdHdlZW4/LnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5fdHdlZW4gPSB0aGlzLnRpbWVTY2FsZSA/IG5ldyBUd2Vlbih0aGlzLCBTQ0FMRV9UV0VFTikgOiBuZXcgVHdlZW4odGhpcyk7XHJcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuYW5pbVR5cGUgPT09IEFuaW1UeXBlLkRVUkFUSU9OID8gdGhpcy5kdXJhdGlvbiA6IE1hdGguYWJzKHRoaXMuX2VuZFZhbHVlIC0gdGhpcy5fY3VyVmFsdWUpIC8gdGhpcy5zcGVlZDtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmVhc2luZ1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRWFzaW5nVHlwZS5JTjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90d2Vlbi5lYXNpbmcoRWFzaW5nLlF1YWRyYXRpYy5Jbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVhc2luZ1R5cGUuT1VUOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3ZWVuLmVhc2luZyhFYXNpbmcuUXVhZHJhdGljLk91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEVhc2luZ1R5cGUuSU5fT1VUOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3ZWVuLmVhc2luZyhFYXNpbmcuUXVhZHJhdGljLkluT3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdHdlZW4udG8oeyBfY3VyVmFsdWU6IHRoaXMuX2VuZFZhbHVlIH0sIGR1cmF0aW9uICogMTAwMClcclxuICAgICAgICAgICAgICAgIC5vblN0YXJ0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQW5pbVN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uVXBkYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQW5pbVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbkNvbXBsZXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQW5pbUNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraLliqjnlLvvvIzlubbkuK3mraLkuYvliY3mnKrnu5PmnZ/nmoRQcm9taXNlXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fYW5pbVJlc29sdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbVJlc29sdmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fdHdlZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLl90d2VlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/button/ButtonChildPos.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1c34dZFfsxBlZKPpElUos3w', 'ButtonChildPos');
// scripts/common/cmpt/ui/button/ButtonChildPos.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonHack_1 = require("../../../hack/ButtonHack");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent;
/**
 * 根据button组件过渡状态，移动子节点坐标
 */
var ButtonChildPos = /** @class */ (function (_super) {
    __extends(ButtonChildPos, _super);
    function ButtonChildPos() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.normal = cc.v2(0, 0);
        _this.pressed = cc.v2(0, 0);
        _this.hover = cc.v2(0, 0);
        _this.disabled = cc.v2(0, 0);
        return _this;
    }
    ButtonChildPos.prototype.onLoad = function () {
        this.node.on(ButtonHack_1.ButtonHackEvent.STATE_CHANGE, this.onStateChange, this);
    };
    ButtonChildPos.prototype.onStateChange = function (state) {
        var pos = cc.v2(0, 0);
        switch (state) {
            case ButtonHack_1.ButtonState.NORMAL:
                pos = this.normal;
                break;
            case ButtonHack_1.ButtonState.PRESSED:
                pos = this.pressed;
                break;
            case ButtonHack_1.ButtonState.HOVER:
                pos = this.hover;
                break;
            case ButtonHack_1.ButtonState.DISABLED:
                pos = this.disabled;
                break;
            default:
                break;
        }
        this.node.children.forEach(function (e) {
            e.setPosition(pos);
        });
    };
    __decorate([
        property({ tooltip: CC_DEV && "普通状态下按钮子节点坐标" })
    ], ButtonChildPos.prototype, "normal", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "按下状态下按钮子节点坐标" })
    ], ButtonChildPos.prototype, "pressed", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "悬停状态下按钮子节点坐标" })
    ], ButtonChildPos.prototype, "hover", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "禁用状态下按钮子节点坐标" })
    ], ButtonChildPos.prototype, "disabled", void 0);
    ButtonChildPos = __decorate([
        ccclass,
        requireComponent(cc.Button),
        menu("Framework/UI组件/ButtonChildPos")
    ], ButtonChildPos);
    return ButtonChildPos;
}(cc.Component));
exports.default = ButtonChildPos;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYnV0dG9uXFxCdXR0b25DaGlsZFBvcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1REFBd0U7QUFFbEUsSUFBQSxLQUFnRCxFQUFFLENBQUMsVUFBVSxFQUEzRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFcEU7O0dBRUc7QUFJSDtJQUE0QyxrQ0FBWTtJQUF4RDtRQUFBLHFFQWdDQztRQS9CMkQsWUFBTSxHQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzlCLGFBQU8sR0FBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMvQixXQUFLLEdBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0IsY0FBUSxHQUFZLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztJQTRCNUYsQ0FBQztJQTFCYSwrQkFBTSxHQUFoQjtRQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLDRCQUFlLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVPLHNDQUFhLEdBQXJCLFVBQXNCLEtBQWtCO1FBQ3BDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLFFBQVEsS0FBSyxFQUFFO1lBQ1gsS0FBSyx3QkFBVyxDQUFDLE1BQU07Z0JBQ25CLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUNsQixNQUFNO1lBQ1YsS0FBSyx3QkFBVyxDQUFDLE9BQU87Z0JBQ3BCLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO2dCQUNuQixNQUFNO1lBQ1YsS0FBSyx3QkFBVyxDQUFDLEtBQUs7Z0JBQ2xCLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNqQixNQUFNO1lBQ1YsS0FBSyx3QkFBVyxDQUFDLFFBQVE7Z0JBQ3JCLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUNwQixNQUFNO1lBQ1Y7Z0JBQ0ksTUFBTTtTQUNiO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQztZQUN6QixDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQTlCZ0Q7UUFBaEQsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxjQUFjLEVBQUUsQ0FBQztrREFBc0M7SUFDckM7UUFBaEQsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxjQUFjLEVBQUUsQ0FBQzttREFBdUM7SUFDdEM7UUFBaEQsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxjQUFjLEVBQUUsQ0FBQztpREFBcUM7SUFDcEM7UUFBaEQsUUFBUSxDQUFDLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxjQUFjLEVBQUUsQ0FBQztvREFBd0M7SUFKdkUsY0FBYztRQUhsQyxPQUFPO1FBQ1AsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUMzQixJQUFJLENBQUMsK0JBQStCLENBQUM7T0FDakIsY0FBYyxDQWdDbEM7SUFBRCxxQkFBQztDQWhDRCxBQWdDQyxDQWhDMkMsRUFBRSxDQUFDLFNBQVMsR0FnQ3ZEO2tCQWhDb0IsY0FBYyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1dHRvbkhhY2tFdmVudCwgQnV0dG9uU3RhdGUgfSBmcm9tIFwiLi4vLi4vLi4vaGFjay9CdXR0b25IYWNrXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51LCByZXF1aXJlQ29tcG9uZW50IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOagueaNrmJ1dHRvbue7hOS7tui/h+a4oeeKtuaAge+8jOenu+WKqOWtkOiKgueCueWdkOagh1xyXG4gKi9cclxuQGNjY2xhc3NcclxuQHJlcXVpcmVDb21wb25lbnQoY2MuQnV0dG9uKVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9CdXR0b25DaGlsZFBvc1wiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25DaGlsZFBvcyBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmma7pgJrnirbmgIHkuIvmjInpkq7lrZDoioLngrnlnZDmoIdcIiB9KSBwdWJsaWMgbm9ybWFsOiBjYy5WZWMyID0gY2MudjIoMCwgMCk7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLmjInkuIvnirbmgIHkuIvmjInpkq7lrZDoioLngrnlnZDmoIdcIiB9KSBwdWJsaWMgcHJlc3NlZDogY2MuVmVjMiA9IGNjLnYyKDAsIDApO1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogQ0NfREVWICYmIFwi5oKs5YGc54q25oCB5LiL5oyJ6ZKu5a2Q6IqC54K55Z2Q5qCHXCIgfSkgcHVibGljIGhvdmVyOiBjYy5WZWMyID0gY2MudjIoMCwgMCk7XHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLnpoHnlKjnirbmgIHkuIvmjInpkq7lrZDoioLngrnlnZDmoIdcIiB9KSBwdWJsaWMgZGlzYWJsZWQ6IGNjLlZlYzIgPSBjYy52MigwLCAwKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm9kZS5vbihCdXR0b25IYWNrRXZlbnQuU1RBVEVfQ0hBTkdFLCB0aGlzLm9uU3RhdGVDaGFuZ2UsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25TdGF0ZUNoYW5nZShzdGF0ZTogQnV0dG9uU3RhdGUpOiB2b2lkIHtcclxuICAgICAgICBsZXQgcG9zID0gY2MudjIoMCwgMCk7XHJcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBjYXNlIEJ1dHRvblN0YXRlLk5PUk1BTDpcclxuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQnV0dG9uU3RhdGUuUFJFU1NFRDpcclxuICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMucHJlc3NlZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEJ1dHRvblN0YXRlLkhPVkVSOlxyXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5ob3ZlcjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEJ1dHRvblN0YXRlLkRJU0FCTEVEOlxyXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5kaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZS5jaGlsZHJlbi5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUuc2V0UG9zaXRpb24ocG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/button/ButtonChildGray.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '19687AwHRhAjoLcsGZTr1YH', 'ButtonChildGray');
// scripts/common/cmpt/ui/button/ButtonChildGray.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ButtonHack_1 = require("../../../hack/ButtonHack");
var Tool_1 = require("../../../util/Tool");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu, requireComponent = _a.requireComponent, executeInEditMode = _a.executeInEditMode;
/**
 * 根据button组件过渡状态，置灰子节点
 */
var ButtonChildGray = /** @class */ (function (_super) {
    __extends(ButtonChildGray, _super);
    function ButtonChildGray() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.relatedNodes = [];
        _this.normalMaterial = null;
        _this.grayMaterial = null;
        return _this;
    }
    ButtonChildGray.prototype.onLoad = function () {
        this.node.on(ButtonHack_1.ButtonHackEvent.STATE_CHANGE, this.onStateChange, this);
    };
    ButtonChildGray.prototype.onStateChange = function (state) {
        var _this = this;
        if (state === ButtonHack_1.ButtonState.DISABLED) {
            if (!this.grayMaterial) {
                this.grayMaterial = cc.Material.getBuiltinMaterial("2d-gray-sprite");
            }
            var cb = function (n) {
                var rc = n.getComponent(cc.RenderComponent);
                if (rc && (rc instanceof cc.Sprite || rc instanceof cc.Label)) {
                    rc.setMaterial(0, _this.grayMaterial);
                }
            };
            Tool_1.default.nodeRecursive(this.node.children, cb);
            Tool_1.default.nodeRecursive(this.relatedNodes, cb);
        }
        else {
            if (!this.normalMaterial) {
                this.normalMaterial = cc.Material.getBuiltinMaterial("2d-sprite");
            }
            var cb = function (n) {
                var rc = n.getComponent(cc.RenderComponent);
                if (rc && (rc instanceof cc.Sprite || rc instanceof cc.Label)) {
                    rc.setMaterial(0, _this.normalMaterial);
                }
            };
            Tool_1.default.nodeRecursive(this.node.children, cb);
            Tool_1.default.nodeRecursive(this.relatedNodes, cb);
        }
    };
    __decorate([
        property({ type: cc.Node, tooltip: CC_DEV && "需要同步置灰的关联节点" })
    ], ButtonChildGray.prototype, "relatedNodes", void 0);
    __decorate([
        property(cc.Material)
    ], ButtonChildGray.prototype, "normalMaterial", void 0);
    __decorate([
        property(cc.Material)
    ], ButtonChildGray.prototype, "grayMaterial", void 0);
    ButtonChildGray = __decorate([
        ccclass,
        executeInEditMode,
        requireComponent(cc.Button),
        menu("Framework/UI组件/ButtonChildGray")
    ], ButtonChildGray);
    return ButtonChildGray;
}(cc.Component));
exports.default = ButtonChildGray;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcYnV0dG9uXFxCdXR0b25DaGlsZEdyYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQXdFO0FBQ3hFLDJDQUFzQztBQUVoQyxJQUFBLEtBQW1FLEVBQUUsQ0FBQyxVQUFVLEVBQTlFLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLGlCQUFpQix1QkFBa0IsQ0FBQztBQUV2Rjs7R0FFRztBQUtIO0lBQTZDLG1DQUFZO0lBQXpEO1FBQUEscUVBcUNDO1FBbkN5RSxrQkFBWSxHQUFjLEVBQUUsQ0FBQztRQUNyRSxvQkFBYyxHQUFnQixJQUFJLENBQUM7UUFDbkMsa0JBQVksR0FBZ0IsSUFBSSxDQUFDOztJQWlDbkUsQ0FBQztJQS9CYSxnQ0FBTSxHQUFoQjtRQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLDRCQUFlLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVPLHVDQUFhLEdBQXJCLFVBQXNCLEtBQWtCO1FBQXhDLGlCQTBCQztRQXpCRyxJQUFJLEtBQUssS0FBSyx3QkFBVyxDQUFDLFFBQVEsRUFBRTtZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDcEIsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDeEU7WUFDRCxJQUFJLEVBQUUsR0FBRyxVQUFDLENBQVU7Z0JBQ2hCLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsTUFBTSxJQUFJLEVBQUUsWUFBWSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQzNELEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLEtBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztpQkFDeEM7WUFDTCxDQUFDLENBQUM7WUFDRixjQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzNDLGNBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUM3QzthQUFNO1lBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNyRTtZQUNELElBQUksRUFBRSxHQUFHLFVBQUMsQ0FBVTtnQkFDaEIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQzVDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxNQUFNLElBQUksRUFBRSxZQUFZLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDM0QsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsS0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2lCQUMxQztZQUNMLENBQUMsQ0FBQztZQUNGLGNBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0MsY0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzdDO0lBQ0wsQ0FBQztJQWxDOEQ7UUFBOUQsUUFBUSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sSUFBSSxhQUFhLEVBQUUsQ0FBQzt5REFBcUM7SUFDNUU7UUFBdEIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7MkRBQTJDO0lBQzFDO1FBQXRCLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO3lEQUF5QztJQUo5QyxlQUFlO1FBSm5DLE9BQU87UUFDUCxpQkFBaUI7UUFDakIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUMzQixJQUFJLENBQUMsZ0NBQWdDLENBQUM7T0FDbEIsZUFBZSxDQXFDbkM7SUFBRCxzQkFBQztDQXJDRCxBQXFDQyxDQXJDNEMsRUFBRSxDQUFDLFNBQVMsR0FxQ3hEO2tCQXJDb0IsZUFBZSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1dHRvbkhhY2tFdmVudCwgQnV0dG9uU3RhdGUgfSBmcm9tIFwiLi4vLi4vLi4vaGFjay9CdXR0b25IYWNrXCI7XHJcbmltcG9ydCBUb29sIGZyb20gXCIuLi8uLi8uLi91dGlsL1Rvb2xcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUsIHJlcXVpcmVDb21wb25lbnQsIGV4ZWN1dGVJbkVkaXRNb2RlIH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqXHJcbiAqIOagueaNrmJ1dHRvbue7hOS7tui/h+a4oeeKtuaAge+8jOe9rueBsOWtkOiKgueCuVxyXG4gKi9cclxuQGNjY2xhc3NcclxuQGV4ZWN1dGVJbkVkaXRNb2RlXHJcbkByZXF1aXJlQ29tcG9uZW50KGNjLkJ1dHRvbilcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvQnV0dG9uQ2hpbGRHcmF5XCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbkNoaWxkR3JheSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogY2MuTm9kZSwgdG9vbHRpcDogQ0NfREVWICYmIFwi6ZyA6KaB5ZCM5q2l572u54Gw55qE5YWz6IGU6IqC54K5XCIgfSkgcHVibGljIHJlbGF0ZWROb2RlczogY2MuTm9kZVtdID0gW107XHJcbiAgICBAcHJvcGVydHkoY2MuTWF0ZXJpYWwpIHB1YmxpYyBub3JtYWxNYXRlcmlhbDogY2MuTWF0ZXJpYWwgPSBudWxsO1xyXG4gICAgQHByb3BlcnR5KGNjLk1hdGVyaWFsKSBwdWJsaWMgZ3JheU1hdGVyaWFsOiBjYy5NYXRlcmlhbCA9IG51bGw7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm5vZGUub24oQnV0dG9uSGFja0V2ZW50LlNUQVRFX0NIQU5HRSwgdGhpcy5vblN0YXRlQ2hhbmdlLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uU3RhdGVDaGFuZ2Uoc3RhdGU6IEJ1dHRvblN0YXRlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSBCdXR0b25TdGF0ZS5ESVNBQkxFRCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ3JheU1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXlNYXRlcmlhbCA9IGNjLk1hdGVyaWFsLmdldEJ1aWx0aW5NYXRlcmlhbChcIjJkLWdyYXktc3ByaXRlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYiA9IChuOiBjYy5Ob2RlKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmMgPSBuLmdldENvbXBvbmVudChjYy5SZW5kZXJDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJjICYmIChyYyBpbnN0YW5jZW9mIGNjLlNwcml0ZSB8fCByYyBpbnN0YW5jZW9mIGNjLkxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJjLnNldE1hdGVyaWFsKDAsIHRoaXMuZ3JheU1hdGVyaWFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVG9vbC5ub2RlUmVjdXJzaXZlKHRoaXMubm9kZS5jaGlsZHJlbiwgY2IpO1xyXG4gICAgICAgICAgICBUb29sLm5vZGVSZWN1cnNpdmUodGhpcy5yZWxhdGVkTm9kZXMsIGNiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9ybWFsTWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9ybWFsTWF0ZXJpYWwgPSBjYy5NYXRlcmlhbC5nZXRCdWlsdGluTWF0ZXJpYWwoXCIyZC1zcHJpdGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNiID0gKG46IGNjLk5vZGUpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCByYyA9IG4uZ2V0Q29tcG9uZW50KGNjLlJlbmRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmMgJiYgKHJjIGluc3RhbmNlb2YgY2MuU3ByaXRlIHx8IHJjIGluc3RhbmNlb2YgY2MuTGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmMuc2V0TWF0ZXJpYWwoMCwgdGhpcy5ub3JtYWxNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRvb2wubm9kZVJlY3Vyc2l2ZSh0aGlzLm5vZGUuY2hpbGRyZW4sIGNiKTtcclxuICAgICAgICAgICAgVG9vbC5ub2RlUmVjdXJzaXZlKHRoaXMucmVsYXRlZE5vZGVzLCBjYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerRadialFilled.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '37463cgERBLhI8K7rCWzz1m', 'MultiAssemblerRadialFilled');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerRadialFilled.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MultiAssembler_1 = require("./MultiAssembler");
var PI_2 = Math.PI * 2;
var _vertPos = [cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0)];
var _vertices = [0, 0, 0, 0];
var _uvs = [0, 0, 0, 0, 0, 0, 0, 0];
var _intersectPoint_1 = [cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0)];
var _intersectPoint_2 = [cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0)];
var _center = cc.v2(0, 0);
var _triangles = [];
function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
    //left bottom, right, top
    var sinAngle = Math.sin(angle);
    var cosAngle = Math.cos(angle);
    var tanAngle, cotAngle;
    if (Math.cos(angle) !== 0) {
        tanAngle = sinAngle / cosAngle;
        //calculate right and left
        if ((left - center.x) * cosAngle > 0) {
            var yleft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yleft;
        }
        if ((right - center.x) * cosAngle > 0) {
            var yright = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yright;
        }
    }
    if (Math.sin(angle) !== 0) {
        cotAngle = cosAngle / sinAngle;
        //calculate  top and bottom
        if ((top - center.y) * sinAngle > 0) {
            var xtop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xtop;
            intersectPoints[3].y = top;
        }
        if ((bottom - center.y) * sinAngle > 0) {
            var xbottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xbottom;
            intersectPoints[1].y = bottom;
        }
    }
}
function _calculateVertices(sprite) {
    var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
    var l = -appx, b = -appy, r = width - appx, t = height - appy;
    var vertices = _vertices;
    vertices[0] = l;
    vertices[1] = b;
    vertices[2] = r;
    vertices[3] = t;
    var fillCenter = sprite._fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
    _vertPos[0].x = _vertPos[3].x = l;
    _vertPos[1].x = _vertPos[2].x = r;
    _vertPos[0].y = _vertPos[1].y = b;
    _vertPos[2].y = _vertPos[3].y = t;
    _triangles.length = 0;
    if (cx !== vertices[0]) {
        _triangles[0] = [3, 0];
    }
    if (cx !== vertices[2]) {
        _triangles[2] = [1, 2];
    }
    if (cy !== vertices[1]) {
        _triangles[1] = [0, 1];
    }
    if (cy !== vertices[3]) {
        _triangles[3] = [2, 3];
    }
}
function _calculateUVs(spriteFrame) {
    var atlasWidth = spriteFrame._texture.width;
    var atlasHeight = spriteFrame._texture.height;
    var textureRect = spriteFrame._rect;
    var u0, u1, v0, v1;
    var uvs = _uvs;
    if (spriteFrame._rotated) {
        u0 = (textureRect.x) / atlasWidth;
        u1 = (textureRect.x + textureRect.height) / atlasWidth;
        v0 = (textureRect.y) / atlasHeight;
        v1 = (textureRect.y + textureRect.width) / atlasHeight;
        uvs[0] = uvs[2] = u0;
        uvs[4] = uvs[6] = u1;
        uvs[3] = uvs[7] = v1;
        uvs[1] = uvs[5] = v0;
    }
    else {
        u0 = (textureRect.x) / atlasWidth;
        u1 = (textureRect.x + textureRect.width) / atlasWidth;
        v0 = (textureRect.y) / atlasHeight;
        v1 = (textureRect.y + textureRect.height) / atlasHeight;
        uvs[0] = uvs[4] = u0;
        uvs[2] = uvs[6] = u1;
        uvs[1] = uvs[3] = v1;
        uvs[5] = uvs[7] = v0;
    }
}
function _getVertAngle(start, end) {
    var placementX, placementY;
    placementX = end.x - start.x;
    placementY = end.y - start.y;
    if (placementX === 0 && placementY === 0) {
        return undefined;
    }
    else if (placementX === 0) {
        if (placementY > 0) {
            return Math.PI * 0.5;
        }
        else {
            return Math.PI * 1.5;
        }
    }
    else {
        var angle = Math.atan(placementY / placementX);
        if (placementX < 0) {
            angle += Math.PI;
        }
        return angle;
    }
}
var MultiAssemblerRadialFilled = /** @class */ (function (_super) {
    __extends(MultiAssemblerRadialFilled, _super);
    function MultiAssemblerRadialFilled() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiAssemblerRadialFilled.prototype.initData = function () {
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
        this.updateIndices();
    };
    MultiAssemblerRadialFilled.prototype.updateRenderData = function (sprite) {
        var frame = sprite.spriteFrame;
        this.packToDynamicAtlas(sprite, frame);
        if (sprite._vertsDirty) {
            var fillStart = sprite._fillStart;
            var fillRange = sprite._fillRange;
            if (fillRange < 0) {
                fillStart += fillRange;
                fillRange = -fillRange;
            }
            //do round fill start [0,1), include 0, exclude 1
            while (fillStart >= 1.0)
                fillStart -= 1.0;
            while (fillStart < 0.0)
                fillStart += 1.0;
            fillStart *= PI_2;
            fillRange *= PI_2;
            //build vertices
            _calculateVertices(sprite);
            //build uvs
            _calculateUVs(frame);
            _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);
            _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
            this.updateVerts(sprite, fillStart, fillRange);
            this.updateTextureIdx(sprite);
            sprite._vertsDirty = false;
        }
    };
    MultiAssemblerRadialFilled.prototype.updateVerts = function (sprite, fillStart, fillRange) {
        var fillEnd = fillStart + fillRange;
        var local = this._local;
        local.length = 0;
        var offset = 0;
        var floatsPerTriangle = 3 * this.floatsPerVert;
        for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
            var triangle = _triangles[triangleIndex];
            if (!triangle) {
                continue;
            }
            //all in
            if (fillRange >= PI_2) {
                local.length = offset + floatsPerTriangle;
                this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _vertPos[triangle[1]]);
                offset += floatsPerTriangle;
                continue;
            }
            //test against
            var startAngle = _getVertAngle(_center, _vertPos[triangle[0]]);
            var endAngle = _getVertAngle(_center, _vertPos[triangle[1]]);
            if (endAngle < startAngle)
                endAngle += PI_2;
            startAngle -= PI_2;
            endAngle -= PI_2;
            //testing
            for (var testIndex = 0; testIndex < 3; ++testIndex) {
                if (startAngle >= fillEnd) {
                    //all out
                }
                else if (startAngle >= fillStart) {
                    local.length = offset + floatsPerTriangle;
                    if (endAngle >= fillEnd) {
                        //startAngle to fillEnd
                        this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _intersectPoint_2[triangleIndex]);
                    }
                    else {
                        //startAngle to endAngle
                        this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _vertPos[triangle[1]]);
                    }
                    offset += floatsPerTriangle;
                }
                else {
                    //startAngle < fillStart
                    if (endAngle <= fillStart) {
                        //all out
                    }
                    else if (endAngle <= fillEnd) {
                        local.length = offset + floatsPerTriangle;
                        //fillStart to endAngle
                        this._generateTriangle(local, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle[1]]);
                        offset += floatsPerTriangle;
                    }
                    else {
                        local.length = offset + floatsPerTriangle;
                        //fillStart to fillEnd
                        this._generateTriangle(local, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);
                        offset += floatsPerTriangle;
                    }
                }
                //add 2 * PI
                startAngle += PI_2;
                endAngle += PI_2;
            }
        }
        this.allocWorldVerts(sprite);
        this.updateWorldVerts(sprite);
    };
    MultiAssemblerRadialFilled.prototype.allocWorldVerts = function (sprite) {
        var color = sprite.node._color._val;
        var renderData = this._renderData;
        var floatsPerVert = this.floatsPerVert;
        var local = this._local;
        var verticesCount = local.length / floatsPerVert;
        this.verticesCount = this.indicesCount = verticesCount;
        var flexBuffer = renderData._flexBuffer;
        if (flexBuffer.reserve(verticesCount, verticesCount)) {
            this.updateIndices();
        }
        flexBuffer.used(this.verticesCount, this.indicesCount);
        var verts = renderData.vDatas[0], uintVerts = renderData.uintVDatas[0];
        var uvOffset = this.uvOffset;
        for (var offset = 0; offset < local.length; offset += floatsPerVert) {
            var start = offset + uvOffset;
            verts[start] = local[start];
            verts[start + 1] = local[start + 1];
            uintVerts[start + 2] = color;
        }
    };
    MultiAssemblerRadialFilled.prototype.updateIndices = function () {
        var iData = this._renderData.iDatas[0];
        for (var i = 0; i < iData.length; i++) {
            iData[i] = i;
        }
    };
    MultiAssemblerRadialFilled.prototype.updateWorldVerts = function (sprite) {
        if (CC_NATIVERENDERER) {
            var local = this._local;
            var world = this._renderData.vDatas[0];
            var floatsPerVert = this.floatsPerVert;
            for (var offset = 0, l = world.length; offset < l; offset += floatsPerVert) {
                world[offset] = local[offset];
                world[offset + 1] = local[offset + 1];
            }
        }
        else {
            var node = sprite.node;
            var matrix = node._worldMatrix;
            var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
            var local = this._local;
            var world = this._renderData.vDatas[0];
            var floatsPerVert = this.floatsPerVert;
            for (var offset = 0; offset < local.length; offset += floatsPerVert) {
                var x = local[offset];
                var y = local[offset + 1];
                world[offset] = x * a + y * c + tx;
                world[offset + 1] = x * b + y * d + ty;
            }
        }
    };
    MultiAssemblerRadialFilled.prototype._generateTriangle = function (verts, offset, vert0, vert1, vert2) {
        var vertices = _vertices;
        var v0x = vertices[0];
        var v0y = vertices[1];
        var v1x = vertices[2];
        var v1y = vertices[3];
        var floatsPerVert = this.floatsPerVert;
        verts[offset] = vert0.x;
        verts[offset + 1] = vert0.y;
        verts[offset + floatsPerVert] = vert1.x;
        verts[offset + floatsPerVert + 1] = vert1.y;
        verts[offset + floatsPerVert * 2] = vert2.x;
        verts[offset + floatsPerVert * 2 + 1] = vert2.y;
        var uvOffset = this.uvOffset;
        var progressX, progressY;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + uvOffset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + floatsPerVert + uvOffset);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + floatsPerVert * 2 + uvOffset);
    };
    MultiAssemblerRadialFilled.prototype._generateUV = function (progressX, progressY, verts, offset) {
        var uvs = _uvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        verts[offset] = px1 + (px2 - px1) * progressY;
        verts[offset + 1] = py1 + (py2 - py1) * progressY;
    };
    return MultiAssemblerRadialFilled;
}(MultiAssembler_1.default));
exports.default = MultiAssemblerRadialFilled;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyUmFkaWFsRmlsbGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUE4QztBQUU5QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUV6QixJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEUsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM3QixJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwQyxJQUFJLGlCQUFpQixHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RSxJQUFJLGlCQUFpQixHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FB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Q0FBQztJQUM1QyxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUM5QyxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBRXBDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ25CLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQztJQUVmLElBQUksV0FBVyxDQUFDLFFBQVEsRUFBRTtRQUN0QixFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ2xDLEVBQUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FBQztRQUV2RCxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDO1FBQ25DLEVBQUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLFdBQVcsQ0FBQztRQUV2RCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNyQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNyQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNyQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUN4QjtTQUNJO1FBQ0QsRUFBRSxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztRQUNsQyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxVQUFVLENBQUM7UUFFdEQsRUFBRSxHQUFHLENBQUMs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QUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztRQUNqRCxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDO1FBQ2pELEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDO1FBQzlDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUN0RCxDQUFDO0lBQ0wsaUNBQUM7QUFBRCxDQWhOQSxBQWdOQyxDQWhOdUQsd0JBQWMsR0FnTnJFIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE11bHRpQXNzZW1ibGVyIGZyb20gXCIuL011bHRpQXNzZW1ibGVyXCI7XHJcblxyXG5jb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XHJcblxyXG5sZXQgX3ZlcnRQb3MgPSBbY2MudjIoMCwgMCksIGNjLnYyKDAsIDApLCBjYy52MigwLCAwKSwgY2MudjIoMCwgMCldO1xyXG5sZXQgX3ZlcnRpY2VzID0gWzAsIDAsIDAsIDBdO1xyXG5sZXQgX3V2cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcclxubGV0IF9pbnRlcnNlY3RQb2ludF8xID0gW2NjLnYyKDAsIDApLCBjYy52MigwLCAwKSwgY2MudjIoMCwgMCksIGNjLnYyKDAsIDApXTtcclxubGV0IF9pbnRlcnNlY3RQb2ludF8yID0gW2NjLnYyKDAsIDApLCBjYy52MigwLCAwKSwgY2MudjIoMCwgMCksIGNjLnYyKDAsIDApXTtcclxubGV0IF9jZW50ZXIgPSBjYy52MigwLCAwKTtcclxubGV0IF90cmlhbmdsZXMgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIF9jYWxjSW5zZWN0ZWRQb2ludHMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBjZW50ZXIsIGFuZ2xlLCBpbnRlcnNlY3RQb2ludHMpIHtcclxuICAgIC8vbGVmdCBib3R0b20sIHJpZ2h0LCB0b3BcclxuICAgIGxldCBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIGxldCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGxldCB0YW5BbmdsZSwgY290QW5nbGU7XHJcbiAgICBpZiAoTWF0aC5jb3MoYW5nbGUpICE9PSAwKSB7XHJcbiAgICAgICAgdGFuQW5nbGUgPSBzaW5BbmdsZSAvIGNvc0FuZ2xlO1xyXG4gICAgICAgIC8vY2FsY3VsYXRlIHJpZ2h0IGFuZCBsZWZ0XHJcbiAgICAgICAgaWYgKChsZWZ0IC0gY2VudGVyLngpICogY29zQW5nbGUgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCB5bGVmdCA9IGNlbnRlci55ICsgdGFuQW5nbGUgKiAobGVmdCAtIGNlbnRlci54KTtcclxuICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnRzWzBdLnggPSBsZWZ0O1xyXG4gICAgICAgICAgICBpbnRlcnNlY3RQb2ludHNbMF0ueSA9IHlsZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHJpZ2h0IC0gY2VudGVyLngpICogY29zQW5nbGUgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCB5cmlnaHQgPSBjZW50ZXIueSArIHRhbkFuZ2xlICogKHJpZ2h0IC0gY2VudGVyLngpO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnRzWzJdLnggPSByaWdodDtcclxuICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnRzWzJdLnkgPSB5cmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWF0aC5zaW4oYW5nbGUpICE9PSAwKSB7XHJcbiAgICAgICAgY290QW5nbGUgPSBjb3NBbmdsZSAvIHNpbkFuZ2xlO1xyXG4gICAgICAgIC8vY2FsY3VsYXRlICB0b3AgYW5kIGJvdHRvbVxyXG4gICAgICAgIGlmICgodG9wIC0gY2VudGVyLnkpICogc2luQW5nbGUgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCB4dG9wID0gY2VudGVyLnggKyBjb3RBbmdsZSAqICh0b3AgLSBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdFBvaW50c1szXS54ID0geHRvcDtcclxuICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnRzWzNdLnkgPSB0b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoYm90dG9tIC0gY2VudGVyLnkpICogc2luQW5nbGUgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCB4Ym90dG9tID0gY2VudGVyLnggKyBjb3RBbmdsZSAqIChib3R0b20gLSBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgIGludGVyc2VjdFBvaW50c1sxXS54ID0geGJvdHRvbTtcclxuICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnRzWzFdLnkgPSBib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2NhbGN1bGF0ZVZlcnRpY2VzKHNwcml0ZSkge1xyXG4gICAgbGV0IG5vZGUgPSBzcHJpdGUubm9kZSxcclxuICAgICAgICB3aWR0aCA9IG5vZGUud2lkdGgsIGhlaWdodCA9IG5vZGUuaGVpZ2h0LFxyXG4gICAgICAgIGFwcHggPSBub2RlLmFuY2hvclggKiB3aWR0aCwgYXBweSA9IG5vZGUuYW5jaG9yWSAqIGhlaWdodDtcclxuXHJcbiAgICBsZXQgbCA9IC1hcHB4LCBiID0gLWFwcHksXHJcbiAgICAgICAgciA9IHdpZHRoIC0gYXBweCwgdCA9IGhlaWdodCAtIGFwcHk7XHJcblxyXG4gICAgbGV0IHZlcnRpY2VzID0gX3ZlcnRpY2VzO1xyXG4gICAgdmVydGljZXNbMF0gPSBsO1xyXG4gICAgdmVydGljZXNbMV0gPSBiO1xyXG4gICAgdmVydGljZXNbMl0gPSByO1xyXG4gICAgdmVydGljZXNbM10gPSB0O1xyXG5cclxuICAgIGxldCBmaWxsQ2VudGVyID0gc3ByaXRlLl9maWxsQ2VudGVyLFxyXG4gICAgICAgIGN4ID0gX2NlbnRlci54ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZmlsbENlbnRlci54KSwgMSkgKiAociAtIGwpICsgbCxcclxuICAgICAgICBjeSA9IF9jZW50ZXIueSA9IE1hdGgubWluKE1hdGgubWF4KDAsIGZpbGxDZW50ZXIueSksIDEpICogKHQgLSBiKSArIGI7XHJcblxyXG4gICAgX3ZlcnRQb3NbMF0ueCA9IF92ZXJ0UG9zWzNdLnggPSBsO1xyXG4gICAgX3ZlcnRQb3NbMV0ueCA9IF92ZXJ0UG9zWzJdLnggPSByO1xyXG4gICAgX3ZlcnRQb3NbMF0ueSA9IF92ZXJ0UG9zWzFdLnkgPSBiO1xyXG4gICAgX3ZlcnRQb3NbMl0ueSA9IF92ZXJ0UG9zWzNdLnkgPSB0O1xyXG5cclxuICAgIF90cmlhbmdsZXMubGVuZ3RoID0gMDtcclxuICAgIGlmIChjeCAhPT0gdmVydGljZXNbMF0pIHtcclxuICAgICAgICBfdHJpYW5nbGVzWzBdID0gWzMsIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKGN4ICE9PSB2ZXJ0aWNlc1syXSkge1xyXG4gICAgICAgIF90cmlhbmdsZXNbMl0gPSBbMSwgMl07XHJcbiAgICB9XHJcbiAgICBpZiAoY3kgIT09IHZlcnRpY2VzWzFdKSB7XHJcbiAgICAgICAgX3RyaWFuZ2xlc1sxXSA9IFswLCAxXTtcclxuICAgIH1cclxuICAgIGlmIChjeSAhPT0gdmVydGljZXNbM10pIHtcclxuICAgICAgICBfdHJpYW5nbGVzWzNdID0gWzIsIDNdO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfY2FsY3VsYXRlVVZzKHNwcml0ZUZyYW1lKSB7XHJcbiAgICBsZXQgYXRsYXNXaWR0aCA9IHNwcml0ZUZyYW1lLl90ZXh0dXJlLndpZHRoO1xyXG4gICAgbGV0IGF0bGFzSGVpZ2h0ID0gc3ByaXRlRnJhbWUuX3RleHR1cmUuaGVpZ2h0O1xyXG4gICAgbGV0IHRleHR1cmVSZWN0ID0gc3ByaXRlRnJhbWUuX3JlY3Q7XHJcblxyXG4gICAgbGV0IHUwLCB1MSwgdjAsIHYxO1xyXG4gICAgbGV0IHV2cyA9IF91dnM7XHJcblxyXG4gICAgaWYgKHNwcml0ZUZyYW1lLl9yb3RhdGVkKSB7XHJcbiAgICAgICAgdTAgPSAodGV4dHVyZVJlY3QueCkgLyBhdGxhc1dpZHRoO1xyXG4gICAgICAgIHUxID0gKHRleHR1cmVSZWN0LnggKyB0ZXh0dXJlUmVjdC5oZWlnaHQpIC8gYXRsYXNXaWR0aDtcclxuXHJcbiAgICAgICAgdjAgPSAodGV4dHVyZVJlY3QueSkgLyBhdGxhc0hlaWdodDtcclxuICAgICAgICB2MSA9ICh0ZXh0dXJlUmVjdC55ICsgdGV4dHVyZVJlY3Qud2lkdGgpIC8gYXRsYXNIZWlnaHQ7XHJcblxyXG4gICAgICAgIHV2c1swXSA9IHV2c1syXSA9IHUwO1xyXG4gICAgICAgIHV2c1s0XSA9IHV2c1s2XSA9IHUxO1xyXG4gICAgICAgIHV2c1szXSA9IHV2c1s3XSA9IHYxO1xyXG4gICAgICAgIHV2c1sxXSA9IHV2c1s1XSA9IHYwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdTAgPSAodGV4dHVyZVJlY3QueCkgLyBhdGxhc1dpZHRoO1xyXG4gICAgICAgIHUxID0gKHRleHR1cmVSZWN0LnggKyB0ZXh0dXJlUmVjdC53aWR0aCkgLyBhdGxhc1dpZHRoO1xyXG5cclxuICAgICAgICB2MCA9ICh0ZXh0dXJlUmVjdC55KSAvIGF0bGFzSGVpZ2h0O1xyXG4gICAgICAgIHYxID0gKHRleHR1cmVSZWN0LnkgKyB0ZXh0dXJlUmVjdC5oZWlnaHQpIC8gYXRsYXNIZWlnaHQ7XHJcblxyXG4gICAgICAgIHV2c1swXSA9IHV2c1s0XSA9IHUwO1xyXG4gICAgICAgIHV2c1syXSA9IHV2c1s2XSA9IHUxO1xyXG4gICAgICAgIHV2c1sxXSA9IHV2c1szXSA9IHYxO1xyXG4gICAgICAgIHV2c1s1XSA9IHV2c1s3XSA9IHYwO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0VmVydEFuZ2xlKHN0YXJ0LCBlbmQpIHtcclxuICAgIGxldCBwbGFjZW1lbnRYLCBwbGFjZW1lbnRZO1xyXG4gICAgcGxhY2VtZW50WCA9IGVuZC54IC0gc3RhcnQueDtcclxuICAgIHBsYWNlbWVudFkgPSBlbmQueSAtIHN0YXJ0Lnk7XHJcblxyXG4gICAgaWYgKHBsYWNlbWVudFggPT09IDAgJiYgcGxhY2VtZW50WSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2UgaWYgKHBsYWNlbWVudFggPT09IDApIHtcclxuICAgICAgICBpZiAocGxhY2VtZW50WSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguUEkgKiAwLjU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguUEkgKiAxLjU7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4ocGxhY2VtZW50WSAvIHBsYWNlbWVudFgpO1xyXG4gICAgICAgIGlmIChwbGFjZW1lbnRYIDwgMCkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aUFzc2VtYmxlclJhZGlhbEZpbGxlZCBleHRlbmRzIE11bHRpQXNzZW1ibGVyIHtcclxuICAgIHB1YmxpYyBpbml0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJEYXRhLmNyZWF0ZUZsZXhEYXRhKDAsIDQsIDYsIHRoaXMuZ2V0VmZtdCgpKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUluZGljZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlUmVuZGVyRGF0YShzcHJpdGUpIHtcclxuICAgICAgICBsZXQgZnJhbWUgPSBzcHJpdGUuc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgdGhpcy5wYWNrVG9EeW5hbWljQXRsYXMoc3ByaXRlLCBmcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGUuX3ZlcnRzRGlydHkpIHtcclxuICAgICAgICAgICAgbGV0IGZpbGxTdGFydCA9IHNwcml0ZS5fZmlsbFN0YXJ0O1xyXG4gICAgICAgICAgICBsZXQgZmlsbFJhbmdlID0gc3ByaXRlLl9maWxsUmFuZ2U7XHJcbiAgICAgICAgICAgIGlmIChmaWxsUmFuZ2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxsU3RhcnQgKz0gZmlsbFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgZmlsbFJhbmdlID0gLWZpbGxSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kbyByb3VuZCBmaWxsIHN0YXJ0IFswLDEpLCBpbmNsdWRlIDAsIGV4Y2x1ZGUgMVxyXG4gICAgICAgICAgICB3aGlsZSAoZmlsbFN0YXJ0ID49IDEuMCkgZmlsbFN0YXJ0IC09IDEuMDtcclxuICAgICAgICAgICAgd2hpbGUgKGZpbGxTdGFydCA8IDAuMCkgZmlsbFN0YXJ0ICs9IDEuMDtcclxuXHJcbiAgICAgICAgICAgIGZpbGxTdGFydCAqPSBQSV8yO1xyXG4gICAgICAgICAgICBmaWxsUmFuZ2UgKj0gUElfMjtcclxuXHJcbiAgICAgICAgICAgIC8vYnVpbGQgdmVydGljZXNcclxuICAgICAgICAgICAgX2NhbGN1bGF0ZVZlcnRpY2VzKHNwcml0ZSk7XHJcbiAgICAgICAgICAgIC8vYnVpbGQgdXZzXHJcbiAgICAgICAgICAgIF9jYWxjdWxhdGVVVnMoZnJhbWUpO1xyXG5cclxuICAgICAgICAgICAgX2NhbGNJbnNlY3RlZFBvaW50cyhfdmVydGljZXNbMF0sIF92ZXJ0aWNlc1syXSwgX3ZlcnRpY2VzWzFdLCBfdmVydGljZXNbM10sIF9jZW50ZXIsIGZpbGxTdGFydCwgX2ludGVyc2VjdFBvaW50XzEpO1xyXG4gICAgICAgICAgICBfY2FsY0luc2VjdGVkUG9pbnRzKF92ZXJ0aWNlc1swXSwgX3ZlcnRpY2VzWzJdLCBfdmVydGljZXNbMV0sIF92ZXJ0aWNlc1szXSwgX2NlbnRlciwgZmlsbFN0YXJ0ICsgZmlsbFJhbmdlLCBfaW50ZXJzZWN0UG9pbnRfMik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZlcnRzKHNwcml0ZSwgZmlsbFN0YXJ0LCBmaWxsUmFuZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVJZHgoc3ByaXRlKTtcclxuXHJcbiAgICAgICAgICAgIHNwcml0ZS5fdmVydHNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlVmVydHMoc3ByaXRlLCBmaWxsU3RhcnQsIGZpbGxSYW5nZSkge1xyXG4gICAgICAgIGxldCBmaWxsRW5kID0gZmlsbFN0YXJ0ICsgZmlsbFJhbmdlO1xyXG5cclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICBsb2NhbC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgZmxvYXRzUGVyVHJpYW5nbGUgPSAzICogdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgIGZvciAobGV0IHRyaWFuZ2xlSW5kZXggPSAwOyB0cmlhbmdsZUluZGV4IDwgNDsgKyt0cmlhbmdsZUluZGV4KSB7XHJcbiAgICAgICAgICAgIGxldCB0cmlhbmdsZSA9IF90cmlhbmdsZXNbdHJpYW5nbGVJbmRleF07XHJcbiAgICAgICAgICAgIGlmICghdHJpYW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vYWxsIGluXHJcbiAgICAgICAgICAgIGlmIChmaWxsUmFuZ2UgPj0gUElfMikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWwubGVuZ3RoID0gb2Zmc2V0ICsgZmxvYXRzUGVyVHJpYW5nbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVRyaWFuZ2xlKGxvY2FsLCBvZmZzZXQsIF9jZW50ZXIsIF92ZXJ0UG9zW3RyaWFuZ2xlWzBdXSwgX3ZlcnRQb3NbdHJpYW5nbGVbMV1dKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmbG9hdHNQZXJUcmlhbmdsZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdGVzdCBhZ2FpbnN0XHJcbiAgICAgICAgICAgIGxldCBzdGFydEFuZ2xlID0gX2dldFZlcnRBbmdsZShfY2VudGVyLCBfdmVydFBvc1t0cmlhbmdsZVswXV0pO1xyXG4gICAgICAgICAgICBsZXQgZW5kQW5nbGUgPSBfZ2V0VmVydEFuZ2xlKF9jZW50ZXIsIF92ZXJ0UG9zW3RyaWFuZ2xlWzFdXSk7XHJcbiAgICAgICAgICAgIGlmIChlbmRBbmdsZSA8IHN0YXJ0QW5nbGUpIGVuZEFuZ2xlICs9IFBJXzI7XHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgLT0gUElfMjtcclxuICAgICAgICAgICAgZW5kQW5nbGUgLT0gUElfMjtcclxuICAgICAgICAgICAgLy90ZXN0aW5nXHJcbiAgICAgICAgICAgIGZvciAobGV0IHRlc3RJbmRleCA9IDA7IHRlc3RJbmRleCA8IDM7ICsrdGVzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRBbmdsZSA+PSBmaWxsRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbGwgb3V0XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0QW5nbGUgPj0gZmlsbFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWwubGVuZ3RoID0gb2Zmc2V0ICsgZmxvYXRzUGVyVHJpYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEFuZ2xlID49IGZpbGxFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdGFydEFuZ2xlIHRvIGZpbGxFbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVUcmlhbmdsZShsb2NhbCwgb2Zmc2V0LCBfY2VudGVyLCBfdmVydFBvc1t0cmlhbmdsZVswXV0sIF9pbnRlcnNlY3RQb2ludF8yW3RyaWFuZ2xlSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0QW5nbGUgdG8gZW5kQW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVUcmlhbmdsZShsb2NhbCwgb2Zmc2V0LCBfY2VudGVyLCBfdmVydFBvc1t0cmlhbmdsZVswXV0sIF92ZXJ0UG9zW3RyaWFuZ2xlWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBmbG9hdHNQZXJUcmlhbmdsZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdGFydEFuZ2xlIDwgZmlsbFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEFuZ2xlIDw9IGZpbGxTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FsbCBvdXRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEFuZ2xlIDw9IGZpbGxFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwubGVuZ3RoID0gb2Zmc2V0ICsgZmxvYXRzUGVyVHJpYW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlsbFN0YXJ0IHRvIGVuZEFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlVHJpYW5nbGUobG9jYWwsIG9mZnNldCwgX2NlbnRlciwgX2ludGVyc2VjdFBvaW50XzFbdHJpYW5nbGVJbmRleF0sIF92ZXJ0UG9zW3RyaWFuZ2xlWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBmbG9hdHNQZXJUcmlhbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbC5sZW5ndGggPSBvZmZzZXQgKyBmbG9hdHNQZXJUcmlhbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maWxsU3RhcnQgdG8gZmlsbEVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVRyaWFuZ2xlKGxvY2FsLCBvZmZzZXQsIF9jZW50ZXIsIF9pbnRlcnNlY3RQb2ludF8xW3RyaWFuZ2xlSW5kZXhdLCBfaW50ZXJzZWN0UG9pbnRfMlt0cmlhbmdsZUluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBmbG9hdHNQZXJUcmlhbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2FkZCAyICogUElcclxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gUElfMjtcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJXzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWxsb2NXb3JsZFZlcnRzKHNwcml0ZSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFsbG9jV29ybGRWZXJ0cyhzcHJpdGUpIHtcclxuICAgICAgICBsZXQgY29sb3IgPSBzcHJpdGUubm9kZS5fY29sb3IuX3ZhbDtcclxuICAgICAgICBsZXQgcmVuZGVyRGF0YSA9IHRoaXMuX3JlbmRlckRhdGE7XHJcbiAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQ7XHJcblxyXG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xyXG4gICAgICAgIGxldCB2ZXJ0aWNlc0NvdW50ID0gbG9jYWwubGVuZ3RoIC8gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSB0aGlzLmluZGljZXNDb3VudCA9IHZlcnRpY2VzQ291bnQ7XHJcblxyXG4gICAgICAgIGxldCBmbGV4QnVmZmVyID0gcmVuZGVyRGF0YS5fZmxleEJ1ZmZlcjtcclxuICAgICAgICBpZiAoZmxleEJ1ZmZlci5yZXNlcnZlKHZlcnRpY2VzQ291bnQsIHZlcnRpY2VzQ291bnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kaWNlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmbGV4QnVmZmVyLnVzZWQodGhpcy52ZXJ0aWNlc0NvdW50LCB0aGlzLmluZGljZXNDb3VudCk7XHJcblxyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHJlbmRlckRhdGEudkRhdGFzWzBdLFxyXG4gICAgICAgICAgICB1aW50VmVydHMgPSByZW5kZXJEYXRhLnVpbnRWRGF0YXNbMF07XHJcblxyXG4gICAgICAgIGxldCB1dk9mZnNldCA9IHRoaXMudXZPZmZzZXQ7XHJcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbG9jYWwubGVuZ3RoOyBvZmZzZXQgKz0gZmxvYXRzUGVyVmVydCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyB1dk9mZnNldDtcclxuICAgICAgICAgICAgdmVydHNbc3RhcnRdID0gbG9jYWxbc3RhcnRdO1xyXG4gICAgICAgICAgICB2ZXJ0c1tzdGFydCArIDFdID0gbG9jYWxbc3RhcnQgKyAxXTtcclxuICAgICAgICAgICAgdWludFZlcnRzW3N0YXJ0ICsgMl0gPSBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZUluZGljZXMoKSB7XHJcbiAgICAgICAgbGV0IGlEYXRhID0gdGhpcy5fcmVuZGVyRGF0YS5pRGF0YXNbMF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpRGF0YVtpXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSkge1xyXG4gICAgICAgIGlmIChDQ19OQVRJVkVSRU5ERVJFUikge1xyXG4gICAgICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5fcmVuZGVyRGF0YS52RGF0YXNbMF07XHJcbiAgICAgICAgICAgIGxldCBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBsID0gd29ybGQubGVuZ3RoOyBvZmZzZXQgPCBsOyBvZmZzZXQgKz0gZmxvYXRzUGVyVmVydCkge1xyXG4gICAgICAgICAgICAgICAgd29ybGRbb2Zmc2V0XSA9IGxvY2FsW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICB3b3JsZFtvZmZzZXQgKyAxXSA9IGxvY2FsW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBzcHJpdGUubm9kZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtYXRyaXggPSBub2RlLl93b3JsZE1hdHJpeDtcclxuICAgICAgICAgICAgbGV0IG1hdHJpeG0gPSBtYXRyaXgubSxcclxuICAgICAgICAgICAgICAgIGEgPSBtYXRyaXhtWzBdLCBiID0gbWF0cml4bVsxXSwgYyA9IG1hdHJpeG1bNF0sIGQgPSBtYXRyaXhtWzVdLFxyXG4gICAgICAgICAgICAgICAgdHggPSBtYXRyaXhtWzEyXSwgdHkgPSBtYXRyaXhtWzEzXTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xyXG4gICAgICAgICAgICBsZXQgd29ybGQgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcclxuICAgICAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGxvY2FsLmxlbmd0aDsgb2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gbG9jYWxbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gbG9jYWxbb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgICAgICB3b3JsZFtvZmZzZXRdID0geCAqIGEgKyB5ICogYyArIHR4O1xyXG4gICAgICAgICAgICAgICAgd29ybGRbb2Zmc2V0ICsgMV0gPSB4ICogYiArIHkgKiBkICsgdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9nZW5lcmF0ZVRyaWFuZ2xlKHZlcnRzLCBvZmZzZXQsIHZlcnQwLCB2ZXJ0MSwgdmVydDIpIHtcclxuICAgICAgICBsZXQgdmVydGljZXMgPSBfdmVydGljZXM7XHJcbiAgICAgICAgbGV0IHYweCA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgIGxldCB2MHkgPSB2ZXJ0aWNlc1sxXTtcclxuICAgICAgICBsZXQgdjF4ID0gdmVydGljZXNbMl07XHJcbiAgICAgICAgbGV0IHYxeSA9IHZlcnRpY2VzWzNdO1xyXG5cclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICB2ZXJ0c1tvZmZzZXRdID0gdmVydDAueDtcclxuICAgICAgICB2ZXJ0c1tvZmZzZXQgKyAxXSA9IHZlcnQwLnk7XHJcbiAgICAgICAgdmVydHNbb2Zmc2V0ICsgZmxvYXRzUGVyVmVydF0gPSB2ZXJ0MS54O1xyXG4gICAgICAgIHZlcnRzW29mZnNldCArIGZsb2F0c1BlclZlcnQgKyAxXSA9IHZlcnQxLnk7XHJcbiAgICAgICAgdmVydHNbb2Zmc2V0ICsgZmxvYXRzUGVyVmVydCAqIDJdID0gdmVydDIueDtcclxuICAgICAgICB2ZXJ0c1tvZmZzZXQgKyBmbG9hdHNQZXJWZXJ0ICogMiArIDFdID0gdmVydDIueTtcclxuXHJcbiAgICAgICAgbGV0IHV2T2Zmc2V0ID0gdGhpcy51dk9mZnNldDtcclxuICAgICAgICBsZXQgcHJvZ3Jlc3NYLCBwcm9ncmVzc1k7XHJcbiAgICAgICAgcHJvZ3Jlc3NYID0gKHZlcnQwLnggLSB2MHgpIC8gKHYxeCAtIHYweCk7XHJcbiAgICAgICAgcHJvZ3Jlc3NZID0gKHZlcnQwLnkgLSB2MHkpIC8gKHYxeSAtIHYweSk7XHJcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVVVihwcm9ncmVzc1gsIHByb2dyZXNzWSwgdmVydHMsIG9mZnNldCArIHV2T2Zmc2V0KTtcclxuXHJcbiAgICAgICAgcHJvZ3Jlc3NYID0gKHZlcnQxLnggLSB2MHgpIC8gKHYxeCAtIHYweCk7XHJcbiAgICAgICAgcHJvZ3Jlc3NZID0gKHZlcnQxLnkgLSB2MHkpIC8gKHYxeSAtIHYweSk7XHJcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVVVihwcm9ncmVzc1gsIHByb2dyZXNzWSwgdmVydHMsIG9mZnNldCArIGZsb2F0c1BlclZlcnQgKyB1dk9mZnNldCk7XHJcblxyXG4gICAgICAgIHByb2dyZXNzWCA9ICh2ZXJ0Mi54IC0gdjB4KSAvICh2MXggLSB2MHgpO1xyXG4gICAgICAgIHByb2dyZXNzWSA9ICh2ZXJ0Mi55IC0gdjB5KSAvICh2MXkgLSB2MHkpO1xyXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlVVYocHJvZ3Jlc3NYLCBwcm9ncmVzc1ksIHZlcnRzLCBvZmZzZXQgKyBmbG9hdHNQZXJWZXJ0ICogMiArIHV2T2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2dlbmVyYXRlVVYocHJvZ3Jlc3NYLCBwcm9ncmVzc1ksIHZlcnRzLCBvZmZzZXQpIHtcclxuICAgICAgICBsZXQgdXZzID0gX3V2cztcclxuICAgICAgICBsZXQgcHgxID0gdXZzWzBdICsgKHV2c1syXSAtIHV2c1swXSkgKiBwcm9ncmVzc1g7XHJcbiAgICAgICAgbGV0IHB4MiA9IHV2c1s0XSArICh1dnNbNl0gLSB1dnNbNF0pICogcHJvZ3Jlc3NYO1xyXG4gICAgICAgIGxldCBweTEgPSB1dnNbMV0gKyAodXZzWzNdIC0gdXZzWzFdKSAqIHByb2dyZXNzWDtcclxuICAgICAgICBsZXQgcHkyID0gdXZzWzVdICsgKHV2c1s3XSAtIHV2c1s1XSkgKiBwcm9ncmVzc1g7XHJcbiAgICAgICAgdmVydHNbb2Zmc2V0XSA9IHB4MSArIChweDIgLSBweDEpICogcHJvZ3Jlc3NZO1xyXG4gICAgICAgIHZlcnRzW29mZnNldCArIDFdID0gcHkxICsgKHB5MiAtIHB5MSkgKiBwcm9ncmVzc1k7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSimple.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'aa9e0lVvBJP9I4EFlhtYCJc', 'MultiAssemblerSimple');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSimple.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MultiAssembler_1 = require("./MultiAssembler");
var MultiAssemblerSimple = /** @class */ (function (_super) {
    __extends(MultiAssemblerSimple, _super);
    function MultiAssemblerSimple() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiAssemblerSimple.prototype.updateRenderData = function (sprite) {
        this.packToDynamicAtlas(sprite, sprite._spriteFrame);
        if (sprite._vertsDirty) {
            this.updateUVs(sprite);
            this.updateVerts(sprite);
            this.updateTextureIdx(sprite);
            sprite._vertsDirty = false;
        }
    };
    MultiAssemblerSimple.prototype.updateUVs = function (sprite) {
        var uv = sprite._spriteFrame.uv;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        for (var i = 0; i < 4; i++) {
            var srcOffset = i * 2;
            var dstOffset = floatsPerVert * i + uvOffset;
            verts[dstOffset] = uv[srcOffset];
            verts[dstOffset + 1] = uv[srcOffset + 1];
        }
    };
    MultiAssemblerSimple.prototype.updateVerts = function (sprite) {
        var node = sprite.node, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        if (sprite.trim) {
            l = -appx;
            b = -appy;
            r = cw - appx;
            t = ch - appy;
        }
        else {
            var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
            var trimLeft = offset.x + (ow - rw) / 2;
            var trimRight = offset.x - (ow - rw) / 2;
            var trimBottom = offset.y + (oh - rh) / 2;
            var trimTop = offset.y - (oh - rh) / 2;
            l = trimLeft * scaleX - appx;
            b = trimBottom * scaleY - appy;
            r = cw + trimRight * scaleX - appx;
            t = ch + trimTop * scaleY - appy;
        }
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(sprite);
    };
    return MultiAssemblerSimple;
}(MultiAssembler_1.default));
exports.default = MultiAssemblerSimple;
if (CC_NATIVERENDERER) {
    var proto = MultiAssemblerSimple.prototype;
    //@ts-ignore
    var nativeProto_1 = renderer.SimpleSprite2D.prototype;
    proto.updateWorldVerts = function (comp) {
        //@ts-ignore
        this._dirtyPtr[0] |= cc.Assembler.FLAG_VERTICES_DIRTY;
    };
    //@ts-ignore
    proto._extendNative = function () {
        nativeProto_1.ctor.call(this);
    };
    proto.initLocal = function () {
        this._local = new Float32Array(8);
        nativeProto_1.setLocalData.call(this, this._local);
    };
}

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyU2ltcGxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUE4QztBQUU5QztJQUFrRCx3Q0FBYztJQUFoRTs7SUEyREEsQ0FBQztJQTFEVSwrQ0FBZ0IsR0FBdkIsVUFBd0IsTUFBTTtRQUMxQixJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUVyRCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN2QixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QixNQUFNLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztTQUM5QjtJQUNMLENBQUM7SUFFTSx3Q0FBUyxHQUFoQixVQUFpQixNQUFNO1FBQ25CLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1FBQ2hDLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDN0IsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUN2QyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hCLElBQUksU0FBUyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEIsSUFBSSxTQUFTLEdBQUcsYUFBYSxHQUFHLENBQUMsR0FBRyxRQUFRLENB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LFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO0lBRXBELEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLElBQUk7UUFDbkMsWUFBWTtRQUNaLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQztJQUMxRCxDQUFDLENBQUM7SUFFRixZQUFZO0lBQ1osS0FBSyxDQUFDLGFBQWEsR0FBRztRQUNsQixhQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDLENBQUM7SUFFRixLQUFLLENBQUMsU0FBUyxHQUFHO1FBQ2QsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxhQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELENBQUMsQ0FBQztDQUNMIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE11bHRpQXNzZW1ibGVyIGZyb20gXCIuL011bHRpQXNzZW1ibGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aUFzc2VtYmxlclNpbXBsZSBleHRlbmRzIE11bHRpQXNzZW1ibGVyIHtcclxuICAgIHB1YmxpYyB1cGRhdGVSZW5kZXJEYXRhKHNwcml0ZSkge1xyXG4gICAgICAgIHRoaXMucGFja1RvRHluYW1pY0F0bGFzKHNwcml0ZSwgc3ByaXRlLl9zcHJpdGVGcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGUuX3ZlcnRzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVVnMoc3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWZXJ0cyhzcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVJZHgoc3ByaXRlKTtcclxuICAgICAgICAgICAgc3ByaXRlLl92ZXJ0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVVVnMoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IHV2ID0gc3ByaXRlLl9zcHJpdGVGcmFtZS51djtcclxuICAgICAgICBsZXQgdXZPZmZzZXQgPSB0aGlzLnV2T2Zmc2V0O1xyXG4gICAgICAgIGxldCBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzcmNPZmZzZXQgPSBpICogMjtcclxuICAgICAgICAgICAgbGV0IGRzdE9mZnNldCA9IGZsb2F0c1BlclZlcnQgKiBpICsgdXZPZmZzZXQ7XHJcbiAgICAgICAgICAgIHZlcnRzW2RzdE9mZnNldF0gPSB1dltzcmNPZmZzZXRdO1xyXG4gICAgICAgICAgICB2ZXJ0c1tkc3RPZmZzZXQgKyAxXSA9IHV2W3NyY09mZnNldCArIDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlVmVydHMoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBzcHJpdGUubm9kZSxcclxuICAgICAgICAgICAgY3cgPSBub2RlLndpZHRoLCBjaCA9IG5vZGUuaGVpZ2h0LFxyXG4gICAgICAgICAgICBhcHB4ID0gbm9kZS5hbmNob3JYICogY3csIGFwcHkgPSBub2RlLmFuY2hvclkgKiBjaCxcclxuICAgICAgICAgICAgbCwgYiwgciwgdDtcclxuICAgICAgICBpZiAoc3ByaXRlLnRyaW0pIHtcclxuICAgICAgICAgICAgbCA9IC1hcHB4O1xyXG4gICAgICAgICAgICBiID0gLWFwcHk7XHJcbiAgICAgICAgICAgIHIgPSBjdyAtIGFwcHg7XHJcbiAgICAgICAgICAgIHQgPSBjaCAtIGFwcHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZnJhbWUgPSBzcHJpdGUuc3ByaXRlRnJhbWUsXHJcbiAgICAgICAgICAgICAgICBvdyA9IGZyYW1lLl9vcmlnaW5hbFNpemUud2lkdGgsIG9oID0gZnJhbWUuX29yaWdpbmFsU2l6ZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBydyA9IGZyYW1lLl9yZWN0LndpZHRoLCByaCA9IGZyYW1lLl9yZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGZyYW1lLl9vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBzY2FsZVggPSBjdyAvIG93LCBzY2FsZVkgPSBjaCAvIG9oO1xyXG4gICAgICAgICAgICBsZXQgdHJpbUxlZnQgPSBvZmZzZXQueCArIChvdyAtIHJ3KSAvIDI7XHJcbiAgICAgICAgICAgIGxldCB0cmltUmlnaHQgPSBvZmZzZXQueCAtIChvdyAtIHJ3KSAvIDI7XHJcbiAgICAgICAgICAgIGxldCB0cmltQm90dG9tID0gb2Zmc2V0LnkgKyAob2ggLSByaCkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgdHJpbVRvcCA9IG9mZnNldC55IC0gKG9oIC0gcmgpIC8gMjtcclxuICAgICAgICAgICAgbCA9IHRyaW1MZWZ0ICogc2NhbGVYIC0gYXBweDtcclxuICAgICAgICAgICAgYiA9IHRyaW1Cb3R0b20gKiBzY2FsZVkgLSBhcHB5O1xyXG4gICAgICAgICAgICByID0gY3cgKyB0cmltUmlnaHQgKiBzY2FsZVggLSBhcHB4O1xyXG4gICAgICAgICAgICB0ID0gY2ggKyB0cmltVG9wICogc2NhbGVZIC0gYXBweTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xyXG4gICAgICAgIGxvY2FsWzBdID0gbDtcclxuICAgICAgICBsb2NhbFsxXSA9IGI7XHJcbiAgICAgICAgbG9jYWxbMl0gPSByO1xyXG4gICAgICAgIGxvY2FsWzNdID0gdDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVmVydHMoc3ByaXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuaWYgKENDX05BVElWRVJFTkRFUkVSKSB7XHJcbiAgICBsZXQgcHJvdG8gPSBNdWx0aUFzc2VtYmxlclNpbXBsZS5wcm90b3R5cGU7XHJcbiAgICAvL0B0cy1pZ25vcmVcclxuICAgIGxldCBuYXRpdmVQcm90byA9IHJlbmRlcmVyLlNpbXBsZVNwcml0ZTJELnByb3RvdHlwZTtcclxuXHJcbiAgICBwcm90by51cGRhdGVXb3JsZFZlcnRzID0gZnVuY3Rpb24gKGNvbXApIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLl9kaXJ0eVB0clswXSB8PSBjYy5Bc3NlbWJsZXIuRkxBR19WRVJUSUNFU19ESVJUWTtcclxuICAgIH07XHJcblxyXG4gICAgLy9AdHMtaWdub3JlXHJcbiAgICBwcm90by5fZXh0ZW5kTmF0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG5hdGl2ZVByb3RvLmN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdG8uaW5pdExvY2FsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcclxuICAgICAgICBuYXRpdmVQcm90by5zZXRMb2NhbERhdGEuY2FsbCh0aGlzLCB0aGlzLl9sb2NhbCk7XHJcbiAgICB9O1xyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/i18n/I18nSprite.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '80273mEm6FKI6l1JI2ok2rH', 'I18nSprite');
// scripts/common/cmpt/ui/i18n/I18nSprite.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EventName_1 = require("../../../const/EventName");
var Events_1 = require("../../../util/Events");
var I18n_1 = require("../../../util/I18n");
var ResSprite_1 = require("../res/ResSprite");
var _a = cc._decorator, ccclass = _a.ccclass, menu = _a.menu, requireComponent = _a.requireComponent;
var I18nSprite = /** @class */ (function (_super) {
    __extends(I18nSprite, _super);
    function I18nSprite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._sprite = null;
        _this._imageKey = "";
        return _this;
    }
    Object.defineProperty(I18nSprite.prototype, "imageKey", {
        /** 图片名 */
        get: function () { return this._imageKey; },
        set: function (v) {
            if (this._imageKey === v) {
                return;
            }
            this._imageKey = v;
            this.updateSprite();
        },
        enumerable: false,
        configurable: true
    });
    I18nSprite.prototype.onLoad = function () {
        try {
            I18n_1.default.init();
            this._sprite = this.getComponent(ResSprite_1.default);
            if (this._sprite.spriteFrame) {
                this.imageKey = this._sprite.spriteFrame.name;
            }
        }
        catch (err) {
            cc.error(err);
        }
    };
    I18nSprite.prototype.updateSprite = function () {
        if (!this.imageKey) {
            return;
        }
        var url = "";
        switch (I18n_1.default.curLang) {
            case I18n_1.LangType.ZH:
                url = "textures/localizedImage/zh/";
                break;
            case I18n_1.LangType.EN:
                url = "textures/localizedImage/en/";
                break;
            default:
                return;
        }
        url += this.imageKey;
        this._sprite.setSpriteFrame(url);
    };
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.UPDATE_LOCALIZED_CMPT)
    ], I18nSprite.prototype, "updateSprite", null);
    I18nSprite = __decorate([
        ccclass,
        Events_1.eventsOnLoad(),
        requireComponent(ResSprite_1.default),
        menu("Framework/I18N/I18nSprite")
    ], I18nSprite);
    return I18nSprite;
}(cc.Component));
exports.default = I18nSprite;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcaTE4blxcSTE4blNwcml0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBcUQ7QUFDckQsK0NBQWtFO0FBQ2xFLDJDQUFvRDtBQUNwRCw4Q0FBeUM7QUFFbkMsSUFBQSxLQUFzQyxFQUFFLENBQUMsVUFBVSxFQUFqRCxPQUFPLGFBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFNMUQ7SUFBd0MsOEJBQVk7SUFBcEQ7UUFBQSxxRUE4Q0M7UUE3Q1csYUFBTyxHQUFjLElBQUksQ0FBQztRQUMxQixlQUFTLEdBQVcsRUFBRSxDQUFDOztJQTRDbkMsQ0FBQztJQTFDRyxzQkFBVyxnQ0FBUTtRQURuQixVQUFVO2FBQ1YsY0FBZ0MsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzthQUN4RCxVQUFvQixDQUFTO1lBQ3pCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3RCLE9BQU87YUFDVjtZQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1lBQ25CLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixDQUFDOzs7T0FQdUQ7SUFTOUMsMkJBQU0sR0FBaEI7UUFDSSxJQUFJO1lBQ0EsY0FBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBRVosSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFTLENBQUMsQ0FBQztZQUM1QyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFO2dCQUMxQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQzthQUNqRDtTQUNKO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDVixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pCO0lBQ0wsQ0FBQztJQUdNLGlDQUFZLEdBQW5CO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDaEIsT0FBTztTQUNWO1FBRUQsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2IsUUFBUSxjQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xCLEtBQUssZUFBUSxDQUFDLEVBQUU7Z0JBQ1osR0FBRyxHQUFHLDZCQUE2QixDQUFDO2dCQUNwQyxNQUFNO1lBQ1YsS0FBSyxlQUFRLENBQUMsRUFBRTtnQkFDWixHQUFHLEdBQUcsNkJBQTZCLENBQUM7Z0JBQ3BDLE1BQU07WUFDVjtnQkFDSSxPQUFPO1NBQ2Q7UUFDRCxHQUFHLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBbEJEO1FBREMscUJBQVksQ0FBQyxxQkFBUyxDQUFDLHFCQUFxQixDQUFDO2tEQW1CN0M7SUE3Q2dCLFVBQVU7UUFKOUIsT0FBTztRQUNQLHFCQUFZLEVBQUU7UUFDZCxnQkFBZ0IsQ0FBQyxtQkFBUyxDQUFDO1FBQzNCLElBQUksQ0FBQywyQkFBMkIsQ0FBQztPQUNiLFVBQVUsQ0E4QzlCO0lBQUQsaUJBQUM7Q0E5Q0QsQUE4Q0MsQ0E5Q3VDLEVBQUUsQ0FBQyxTQUFTLEdBOENuRDtrQkE5Q29CLFVBQVUiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudE5hbWUgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCB7IGV2ZW50c09uTG9hZCwgcHJlbG9hZEV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvRXZlbnRzXCI7XHJcbmltcG9ydCBJMThuLCB7IExhbmdUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvSTE4blwiO1xyXG5pbXBvcnQgUmVzU3ByaXRlIGZyb20gXCIuLi9yZXMvUmVzU3ByaXRlXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIG1lbnUsIHJlcXVpcmVDb21wb25lbnQgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG5AY2NjbGFzc1xyXG5AZXZlbnRzT25Mb2FkKClcclxuQHJlcXVpcmVDb21wb25lbnQoUmVzU3ByaXRlKVxyXG5AbWVudShcIkZyYW1ld29yay9JMThOL0kxOG5TcHJpdGVcIilcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSTE4blNwcml0ZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBwcml2YXRlIF9zcHJpdGU6IFJlc1Nwcml0ZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9pbWFnZUtleTogc3RyaW5nID0gXCJcIjtcclxuICAgIC8qKiDlm77niYflkI0gKi9cclxuICAgIHB1YmxpYyBnZXQgaW1hZ2VLZXkoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2ltYWdlS2V5OyB9XHJcbiAgICBwdWJsaWMgc2V0IGltYWdlS2V5KHY6IHN0cmluZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbWFnZUtleSA9PT0gdikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ltYWdlS2V5ID0gdjtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNwcml0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkxvYWQoKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgSTE4bi5pbml0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSB0aGlzLmdldENvbXBvbmVudChSZXNTcHJpdGUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3ByaXRlLnNwcml0ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlS2V5ID0gdGhpcy5fc3ByaXRlLnNwcml0ZUZyYW1lLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQHByZWxvYWRFdmVudChFdmVudE5hbWUuVVBEQVRFX0xPQ0FMSVpFRF9DTVBUKVxyXG4gICAgcHVibGljIHVwZGF0ZVNwcml0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1hZ2VLZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XHJcbiAgICAgICAgc3dpdGNoIChJMThuLmN1ckxhbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBMYW5nVHlwZS5aSDpcclxuICAgICAgICAgICAgICAgIHVybCA9IFwidGV4dHVyZXMvbG9jYWxpemVkSW1hZ2UvemgvXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBMYW5nVHlwZS5FTjpcclxuICAgICAgICAgICAgICAgIHVybCA9IFwidGV4dHVyZXMvbG9jYWxpemVkSW1hZ2UvZW4vXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXJsICs9IHRoaXMuaW1hZ2VLZXk7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlLnNldFNwcml0ZUZyYW1lKHVybCk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/MultiSprite.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c922bwmEw5OV4VVCBcsN/cG', 'MultiSprite');
// scripts/common/cmpt/ui/multiTexture/MultiSprite.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var EditorTool_1 = require("../../../util/EditorTool");
var MultiAssemblerBarFilled_1 = require("./assembler/MultiAssemblerBarFilled");
var MultiAssemblerRadialFilled_1 = require("./assembler/MultiAssemblerRadialFilled");
var MultiAssemblerSimple_1 = require("./assembler/MultiAssemblerSimple");
var MultiAssemblerSliced_1 = require("./assembler/MultiAssemblerSliced");
var MultiAssemblerTiled_1 = require("./assembler/MultiAssemblerTiled");
var MultiTextureManager_1 = require("./MultiTextureManager");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, menu = _a.menu, inspector = _a.inspector;
/**
 * Multi-Texture 渲染组件，兼容web与native，支持simple、sliced、tiled、filled
 */
var MultiSprite = /** @class */ (function (_super) {
    __extends(MultiSprite, _super);
    function MultiSprite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._textureIdx = 0;
        return _this;
    }
    Object.defineProperty(MultiSprite.prototype, "textureIdx", {
        /** 当前渲染组件使用的纹理下标，不需要主动调用，该组件内部会自行处理 */
        get: function () { return this._textureIdx; },
        set: function (v) {
            this._textureIdx = cc.misc.clampf(v, 0, MultiTextureManager_1.MultiTextureManager.MAX_TEXTURE_NUM - 1);
            this["setVertsDirty"]();
        },
        enumerable: false,
        configurable: true
    });
    MultiSprite.prototype.resetInEditor = function () {
        var _this = this;
        EditorTool_1.default.load("res/shader/materials/multiTexture.mtl").then(function (mat) {
            if (mat) {
                _this.setMaterial(0, mat);
            }
        });
    };
    MultiSprite.prototype.onLoad = function () {
        var _a;
        (_a = _super.prototype.onLoad) === null || _a === void 0 ? void 0 : _a.call(this);
        MultiTextureManager_1.MultiTextureManager.addSprite(this);
    };
    MultiSprite.prototype.onDestroy = function () {
        var _a;
        (_a = _super.prototype.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
        MultiTextureManager_1.MultiTextureManager.removeSprite(this);
    };
    /**
     * 设置spriteFrame和material时引擎内部会调用，更新textureIdx，更新材质属性
     * @override
     */
    MultiSprite.prototype._updateMaterial = function () {
        // make sure material is belong to self.
        var material = this.getMaterial(0);
        if (material) {
            var texture = null;
            var textureImpl = null;
            if (this.spriteFrame) {
                texture = this.spriteFrame.getTexture();
                textureImpl = texture && texture.getImpl();
            }
            if (material.name.indexOf("multiTexture") >= 0) {
                // 初始化纹理管理器
                MultiTextureManager_1.MultiTextureManager.init(material["_material"]);
                // 更新textureIdx
                var idx = MultiTextureManager_1.MultiTextureManager.getIdx(texture);
                if (idx >= 0) {
                    this.textureIdx = idx;
                }
                if (material.getProperty("texture" + this.textureIdx, 0) !== textureImpl) {
                    material.setProperty("texture" + this.textureIdx, texture);
                }
            }
            else {
                if (material.getProperty("texture", 0) !== textureImpl) {
                    material.setProperty("texture", texture);
                }
            }
        }
        cc.BlendFunc.prototype["_updateMaterial"].call(this);
    };
    MultiSprite = __decorate([
        ccclass,
        menu("Framework/UI组件/MultiSprite"),
        inspector("packages://inspector/inspectors/comps/sprite.js")
    ], MultiSprite);
    return MultiSprite;
}(cc.Sprite));
exports.default = MultiSprite;
cc.Assembler.register(MultiSprite, {
    getConstructor: function (sprite) {
        var ctor = MultiAssemblerSimple_1.default;
        switch (sprite.type) {
            case cc.Sprite.Type.SLICED:
                ctor = MultiAssemblerSliced_1.default;
                break;
            case cc.Sprite.Type.TILED:
                ctor = MultiAssemblerTiled_1.default;
                break;
            case cc.Sprite.Type.FILLED:
                if (sprite._fillType === cc.Sprite.FillType.RADIAL) {
                    ctor = MultiAssemblerRadialFilled_1.default;
                }
                else {
                    ctor = MultiAssemblerBarFilled_1.default;
                }
                break;
        }
        return ctor;
    }
});

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxNdWx0aVNwcml0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1REFBa0Q7QUFDbEQsK0VBQTBFO0FBQzFFLHFGQUFnRjtBQUNoRix5RUFBb0U7QUFDcEUseUVBQW9FO0FBQ3BFLHVFQUFrRTtBQUNsRSw2REFBNEQ7QUFFdEQsSUFBQSxLQUEyRCxFQUFFLENBQUMsVUFBVSxFQUF0RSxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxnQkFBZ0Isc0JBQUEsRUFBRSxJQUFJLFVBQUEsRUFBRSxTQUFTLGVBQWtCLENBQUM7QUFFL0U7O0dBRUc7QUFJSDtJQUF5QywrQkFBUztJQUFsRDtRQUFBLHFFQThEQztRQTVEVyxpQkFBVyxHQUFXLENBQUMsQ0FBQzs7SUE0RHBDLENBQUM7SUExREcsc0JBQVksbUNBQVU7UUFEdEIsdUNBQXVDO2FBQ3ZDLGNBQW1DLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDN0QsVUFBdUIsQ0FBUztZQUM1QixJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUseUNBQW1CLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pGLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1FBQzVCLENBQUM7OztPQUo0RDtJQU1uRCxtQ0FBYSxHQUF2QjtRQUFBLGlCQU1DO1FBTEcsb0JBQVUsQ0FBQyxJQUFJLENBQWMsdUNBQXVDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxHQUFHO1lBQzNFLElBQUksR0FBRyxFQUFFO2dCQUNMLEtBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQzVCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFD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Q0FBMEIsQ0FBQztpQkFDckM7cUJBQU07b0JBQ0gsSUFBSSxHQUFHLGlDQUF1QixDQUFDO2lCQUNsQztnQkFDRCxNQUFNO1NBQ2I7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0osQ0FBQyxDQUFDIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVkaXRvclRvb2wgZnJvbSBcIi4uLy4uLy4uL3V0aWwvRWRpdG9yVG9vbFwiO1xyXG5pbXBvcnQgTXVsdGlBc3NlbWJsZXJCYXJGaWxsZWQgZnJvbSBcIi4vYXNzZW1ibGVyL011bHRpQXNzZW1ibGVyQmFyRmlsbGVkXCI7XHJcbmltcG9ydCBNdWx0aUFzc2VtYmxlclJhZGlhbEZpbGxlZCBmcm9tIFwiLi9hc3NlbWJsZXIvTXVsdGlBc3NlbWJsZXJSYWRpYWxGaWxsZWRcIjtcclxuaW1wb3J0IE11bHRpQXNzZW1ibGVyU2ltcGxlIGZyb20gXCIuL2Fzc2VtYmxlci9NdWx0aUFzc2VtYmxlclNpbXBsZVwiO1xyXG5pbXBvcnQgTXVsdGlBc3NlbWJsZXJTbGljZWQgZnJvbSBcIi4vYXNzZW1ibGVyL011bHRpQXNzZW1ibGVyU2xpY2VkXCI7XHJcbmltcG9ydCBNdWx0aUFzc2VtYmxlclRpbGVkIGZyb20gXCIuL2Fzc2VtYmxlci9NdWx0aUFzc2VtYmxlclRpbGVkXCI7XHJcbmltcG9ydCB7IE11bHRpVGV4dHVyZU1hbmFnZXIgfSBmcm9tIFwiLi9NdWx0aVRleHR1cmVNYW5hZ2VyXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCByZXF1aXJlQ29tcG9uZW50LCBtZW51LCBpbnNwZWN0b3IgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKipcclxuICogTXVsdGktVGV4dHVyZSDmuLLmn5Pnu4Tku7bvvIzlhbzlrrl3ZWLkuI5uYXRpdmXvvIzmlK/mjIFzaW1wbGXjgIFzbGljZWTjgIF0aWxlZOOAgWZpbGxlZFxyXG4gKi9cclxuQGNjY2xhc3NcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvTXVsdGlTcHJpdGVcIilcclxuQGluc3BlY3RvcihcInBhY2thZ2VzOi8vaW5zcGVjdG9yL2luc3BlY3RvcnMvY29tcHMvc3ByaXRlLmpzXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpU3ByaXRlIGV4dGVuZHMgY2MuU3ByaXRlIHtcclxuXHJcbiAgICBwcml2YXRlIF90ZXh0dXJlSWR4OiBudW1iZXIgPSAwO1xyXG4gICAgLyoqIOW9k+WJjea4suafk+e7hOS7tuS9v+eUqOeahOe6ueeQhuS4i+agh++8jOS4jemcgOimgeS4u+WKqOiwg+eUqO+8jOivpee7hOS7tuWGhemDqOS8muiHquihjOWkhOeQhiAqL1xyXG4gICAgcHJpdmF0ZSBnZXQgdGV4dHVyZUlkeCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGV4dHVyZUlkeDsgfVxyXG4gICAgcHJpdmF0ZSBzZXQgdGV4dHVyZUlkeCh2OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlSWR4ID0gY2MubWlzYy5jbGFtcGYodiwgMCwgTXVsdGlUZXh0dXJlTWFuYWdlci5NQVhfVEVYVFVSRV9OVU0gLSAxKTtcclxuICAgICAgICB0aGlzW1wic2V0VmVydHNEaXJ0eVwiXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZXNldEluRWRpdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIEVkaXRvclRvb2wubG9hZDxjYy5NYXRlcmlhbD4oXCJyZXMvc2hhZGVyL21hdGVyaWFscy9tdWx0aVRleHR1cmUubXRsXCIpLnRoZW4oKG1hdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWF0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1hdGVyaWFsKDAsIG1hdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm9uTG9hZD8uKCk7XHJcbiAgICAgICAgTXVsdGlUZXh0dXJlTWFuYWdlci5hZGRTcHJpdGUodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5vbkRlc3Ryb3k/LigpO1xyXG4gICAgICAgIE11bHRpVGV4dHVyZU1hbmFnZXIucmVtb3ZlU3ByaXRlKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572uc3ByaXRlRnJhbWXlkoxtYXRlcmlhbOaXtuW8leaTjuWGhemDqOS8muiwg+eUqO+8jOabtOaWsHRleHR1cmVJZHjvvIzmm7TmlrDmnZDotKjlsZ7mgKdcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgX3VwZGF0ZU1hdGVyaWFsKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBtYXRlcmlhbCBpcyBiZWxvbmcgdG8gc2VsZi5cclxuICAgICAgICBsZXQgbWF0ZXJpYWwgPSB0aGlzLmdldE1hdGVyaWFsKDApO1xyXG4gICAgICAgIGlmIChtYXRlcmlhbCkge1xyXG4gICAgICAgICAgICBsZXQgdGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlSW1wbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNwcml0ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdGhpcy5zcHJpdGVGcmFtZS5nZXRUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlSW1wbCA9IHRleHR1cmUgJiYgdGV4dHVyZS5nZXRJbXBsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hdGVyaWFsLm5hbWUuaW5kZXhPZihcIm11bHRpVGV4dHVyZVwiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDliJ3lp4vljJbnurnnkIbnrqHnkIblmahcclxuICAgICAgICAgICAgICAgIE11bHRpVGV4dHVyZU1hbmFnZXIuaW5pdChtYXRlcmlhbFtcIl9tYXRlcmlhbFwiXSk7XHJcbiAgICAgICAgICAgICAgICAvLyDmm7TmlrB0ZXh0dXJlSWR4XHJcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gTXVsdGlUZXh0dXJlTWFuYWdlci5nZXRJZHgodGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVJZHggPSBpZHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0ZXJpYWwuZ2V0UHJvcGVydHkoYHRleHR1cmUke3RoaXMudGV4dHVyZUlkeH1gLCAwKSAhPT0gdGV4dHVyZUltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbC5zZXRQcm9wZXJ0eShgdGV4dHVyZSR7dGhpcy50ZXh0dXJlSWR4fWAsIHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLmdldFByb3BlcnR5KGB0ZXh0dXJlYCwgMCkgIT09IHRleHR1cmVJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWwuc2V0UHJvcGVydHkoYHRleHR1cmVgLCB0ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MuQmxlbmRGdW5jLnByb3RvdHlwZVtcIl91cGRhdGVNYXRlcmlhbFwiXS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jYy5Bc3NlbWJsZXIucmVnaXN0ZXIoTXVsdGlTcHJpdGUsIHtcclxuICAgIGdldENvbnN0cnVjdG9yKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBjdG9yOiBhbnkgPSBNdWx0aUFzc2VtYmxlclNpbXBsZTtcclxuICAgICAgICBzd2l0Y2ggKHNwcml0ZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuU3ByaXRlLlR5cGUuU0xJQ0VEOlxyXG4gICAgICAgICAgICAgICAgY3RvciA9IE11bHRpQXNzZW1ibGVyU2xpY2VkO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY2MuU3ByaXRlLlR5cGUuVElMRUQ6XHJcbiAgICAgICAgICAgICAgICBjdG9yID0gTXVsdGlBc3NlbWJsZXJUaWxlZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGNjLlNwcml0ZS5UeXBlLkZJTExFRDpcclxuICAgICAgICAgICAgICAgIGlmIChzcHJpdGUuX2ZpbGxUeXBlID09PSBjYy5TcHJpdGUuRmlsbFR5cGUuUkFESUFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RvciA9IE11bHRpQXNzZW1ibGVyUmFkaWFsRmlsbGVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdG9yID0gTXVsdGlBc3NlbWJsZXJCYXJGaWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0b3I7XHJcbiAgICB9XHJcbn0pO1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSliced.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '0f3a2cHs8tKfqzmBuX9KEnV', 'MultiAssemblerSliced');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerSliced.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MultiAssembler_1 = require("./MultiAssembler");
var MultiAssemblerSliced = /** @class */ (function (_super) {
    __extends(MultiAssemblerSliced, _super);
    function MultiAssemblerSliced() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MultiAssemblerSliced.prototype.initData = function () {
        this.verticesCount = 16;
        this.indicesCount = 54;
        if (this._renderData.meshCount > 0)
            return;
        var data = this._renderData;
        // createFlexData支持创建指定格式的renderData
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        var indices = this._renderData.iDatas[0];
        var indexOffset = 0;
        for (var r = 0; r < 3; ++r) {
            for (var c = 0; c < 3; ++c) {
                var start = r * 4 + c;
                indices[indexOffset++] = start;
                indices[indexOffset++] = start + 1;
                indices[indexOffset++] = start + 4;
                indices[indexOffset++] = start + 1;
                indices[indexOffset++] = start + 5;
                indices[indexOffset++] = start + 4;
            }
        }
    };
    MultiAssemblerSliced.prototype.initLocal = function () {
        this._local = [];
        this._local.length = 8;
    };
    MultiAssemblerSliced.prototype.updateRenderData = function (sprite) {
        var frame = sprite._spriteFrame;
        this.packToDynamicAtlas(sprite, frame);
        if (sprite._vertsDirty) {
            this.updateUVs(sprite);
            this.updateVerts(sprite);
            this.updateTextureIdx(sprite);
            sprite._vertsDirty = false;
        }
    };
    MultiAssemblerSliced.prototype.updateVerts = function (sprite) {
        var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = (isNaN(xScale) || xScale > 1) ? 1 : xScale;
        yScale = (isNaN(yScale) || yScale > 1) ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        // update local
        var local = this._local;
        local[0] = -appx;
        local[1] = -appy;
        local[2] = leftWidth * xScale - appx;
        local[3] = bottomHeight * yScale - appy;
        local[4] = local[2] + sizableWidth;
        local[5] = local[3] + sizableHeight;
        local[6] = width - appx;
        local[7] = height - appy;
        this.updateWorldVerts(sprite);
    };
    MultiAssemblerSliced.prototype.updateUVs = function (sprite) {
        var verts = this._renderData.vDatas[0];
        var uvSliced = sprite.spriteFrame.uvSliced;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        for (var row = 0; row < 4; ++row) {
            for (var col = 0; col < 4; ++col) {
                var vid = row * 4 + col;
                var uv = uvSliced[vid];
                var voffset = vid * floatsPerVert;
                verts[voffset + uvOffset] = uv.u;
                verts[voffset + uvOffset + 1] = uv.v;
            }
        }
    };
    MultiAssemblerSliced.prototype.updateWorldVerts = function (sprite) {
        var matrix = sprite.node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var row = 0; row < 4; ++row) {
            var localRowY = local[row * 2 + 1];
            for (var col = 0; col < 4; ++col) {
                var localColX = local[col * 2];
                var worldIndex = (row * 4 + col) * floatsPerVert;
                world[worldIndex] = localColX * a + localRowY * c + tx;
                world[worldIndex + 1] = localColX * b + localRowY * d + ty;
            }
        }
    };
    return MultiAssemblerSliced;
}(MultiAssembler_1.default));
exports.default = MultiAssemblerSliced;
if (CC_NATIVERENDERER) {
    var proto = MultiAssemblerSliced.prototype;
    //@ts-ignore
    var nativeProto_1 = renderer.SlicedSprite2D.prototype;
    proto.updateWorldVerts = function (comp) {
        //@ts-ignore
        this._dirtyPtr[0] |= cc.Assembler.FLAG_VERTICES_DIRTY;
    };
    //@ts-ignore
    proto._extendNative = function () {
        nativeProto_1.ctor.call(this);
    };
    proto.initLocal = function () {
        this._local = new Float32Array(8);
        nativeProto_1.setLocalData.call(this, this._local);
    };
}

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyU2xpY2VkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUE4QztBQUU5QztJQUFrRCx3Q0FBYztJQUFoRTs7SUFnSEEsQ0FBQztJQS9HVSx1Q0FBUSxHQUFmO1FBQ0ksSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7UUFFdkIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxDQUFDO1lBQUUsT0FBTztRQUMzQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQzVCLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFFOUUsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtnQkFDeEIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDL0IsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsS0FBSyxHQUFH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Q0FBQyxDQUFDO0lBQ3JELENBQUMsQ0FBQztDQUNMIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE11bHRpQXNzZW1ibGVyIGZyb20gXCIuL011bHRpQXNzZW1ibGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aUFzc2VtYmxlclNsaWNlZCBleHRlbmRzIE11bHRpQXNzZW1ibGVyIHtcclxuICAgIHB1YmxpYyBpbml0RGF0YSgpIHtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSAxNjtcclxuICAgICAgICB0aGlzLmluZGljZXNDb3VudCA9IDU0O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyRGF0YS5tZXNoQ291bnQgPiAwKSByZXR1cm47XHJcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9yZW5kZXJEYXRhO1xyXG4gICAgICAgIC8vIGNyZWF0ZUZsZXhEYXRh5pSv5oyB5Yib5bu65oyH5a6a5qC85byP55qEcmVuZGVyRGF0YVxyXG4gICAgICAgIGRhdGEuY3JlYXRlRmxleERhdGEoMCwgdGhpcy52ZXJ0aWNlc0NvdW50LCB0aGlzLmluZGljZXNDb3VudCwgdGhpcy5nZXRWZm10KCkpO1xyXG5cclxuICAgICAgICBsZXQgaW5kaWNlcyA9IHRoaXMuX3JlbmRlckRhdGEuaURhdGFzWzBdO1xyXG4gICAgICAgIGxldCBpbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCAzOyArK3IpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCAzOyArK2MpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHIgKiA0ICsgYztcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydDtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0KytdID0gc3RhcnQgKyA0O1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldCsrXSA9IHN0YXJ0ICsgMTtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXQrK10gPSBzdGFydCArIDU7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0KytdID0gc3RhcnQgKyA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbml0TG9jYWwoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWwgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2NhbC5sZW5ndGggPSA4O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVSZW5kZXJEYXRhKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBmcmFtZSA9IHNwcml0ZS5fc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgdGhpcy5wYWNrVG9EeW5hbWljQXRsYXMoc3ByaXRlLCBmcmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChzcHJpdGUuX3ZlcnRzRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVVnMoc3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWZXJ0cyhzcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVJZHgoc3ByaXRlKTtcclxuICAgICAgICAgICAgc3ByaXRlLl92ZXJ0c0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVWZXJ0cyhzcHJpdGUpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHNwcml0ZS5ub2RlLFxyXG4gICAgICAgICAgICB3aWR0aCA9IG5vZGUud2lkdGgsIGhlaWdodCA9IG5vZGUuaGVpZ2h0LFxyXG4gICAgICAgICAgICBhcHB4ID0gbm9kZS5hbmNob3JYICogd2lkdGgsIGFwcHkgPSBub2RlLmFuY2hvclkgKiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIGxldCBmcmFtZSA9IHNwcml0ZS5zcHJpdGVGcmFtZTtcclxuICAgICAgICBsZXQgbGVmdFdpZHRoID0gZnJhbWUuaW5zZXRMZWZ0O1xyXG4gICAgICAgIGxldCByaWdodFdpZHRoID0gZnJhbWUuaW5zZXRSaWdodDtcclxuICAgICAgICBsZXQgdG9wSGVpZ2h0ID0gZnJhbWUuaW5zZXRUb3A7XHJcbiAgICAgICAgbGV0IGJvdHRvbUhlaWdodCA9IGZyYW1lLmluc2V0Qm90dG9tO1xyXG5cclxuICAgICAgICBsZXQgc2l6YWJsZVdpZHRoID0gd2lkdGggLSBsZWZ0V2lkdGggLSByaWdodFdpZHRoO1xyXG4gICAgICAgIGxldCBzaXphYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gdG9wSGVpZ2h0IC0gYm90dG9tSGVpZ2h0O1xyXG4gICAgICAgIGxldCB4U2NhbGUgPSB3aWR0aCAvIChsZWZ0V2lkdGggKyByaWdodFdpZHRoKTtcclxuICAgICAgICBsZXQgeVNjYWxlID0gaGVpZ2h0IC8gKHRvcEhlaWdodCArIGJvdHRvbUhlaWdodCk7XHJcbiAgICAgICAgeFNjYWxlID0gKGlzTmFOKHhTY2FsZSkgfHwgeFNjYWxlID4gMSkgPyAxIDogeFNjYWxlO1xyXG4gICAgICAgIHlTY2FsZSA9IChpc05hTih5U2NhbGUpIHx8IHlTY2FsZSA+IDEpID8gMSA6IHlTY2FsZTtcclxuICAgICAgICBzaXphYmxlV2lkdGggPSBzaXphYmxlV2lkdGggPCAwID8gMCA6IHNpemFibGVXaWR0aDtcclxuICAgICAgICBzaXphYmxlSGVpZ2h0ID0gc2l6YWJsZUhlaWdodCA8IDAgPyAwIDogc2l6YWJsZUhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGxvY2FsXHJcbiAgICAgICAgbGV0IGxvY2FsID0gdGhpcy5fbG9jYWw7XHJcbiAgICAgICAgbG9jYWxbMF0gPSAtYXBweDtcclxuICAgICAgICBsb2NhbFsxXSA9IC1hcHB5O1xyXG4gICAgICAgIGxvY2FsWzJdID0gbGVmdFdpZHRoICogeFNjYWxlIC0gYXBweDtcclxuICAgICAgICBsb2NhbFszXSA9IGJvdHRvbUhlaWdodCAqIHlTY2FsZSAtIGFwcHk7XHJcbiAgICAgICAgbG9jYWxbNF0gPSBsb2NhbFsyXSArIHNpemFibGVXaWR0aDtcclxuICAgICAgICBsb2NhbFs1XSA9IGxvY2FsWzNdICsgc2l6YWJsZUhlaWdodDtcclxuICAgICAgICBsb2NhbFs2XSA9IHdpZHRoIC0gYXBweDtcclxuICAgICAgICBsb2NhbFs3XSA9IGhlaWdodCAtIGFwcHk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRWZXJ0cyhzcHJpdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVVVnMoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IHZlcnRzID0gdGhpcy5fcmVuZGVyRGF0YS52RGF0YXNbMF07XHJcbiAgICAgICAgbGV0IHV2U2xpY2VkID0gc3ByaXRlLnNwcml0ZUZyYW1lLnV2U2xpY2VkO1xyXG4gICAgICAgIGxldCB1dk9mZnNldCA9IHRoaXMudXZPZmZzZXQ7XHJcbiAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgNDsgKytyb3cpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgNDsgKytjb2wpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2aWQgPSByb3cgKiA0ICsgY29sO1xyXG4gICAgICAgICAgICAgICAgbGV0IHV2ID0gdXZTbGljZWRbdmlkXTtcclxuICAgICAgICAgICAgICAgIGxldCB2b2Zmc2V0ID0gdmlkICogZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZvZmZzZXQgKyB1dk9mZnNldF0gPSB1di51O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdm9mZnNldCArIHV2T2Zmc2V0ICsgMV0gPSB1di52O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBzcHJpdGUubm9kZS5fd29ybGRNYXRyaXg7XHJcbiAgICAgICAgbGV0IG1hdHJpeG0gPSBtYXRyaXgubSxcclxuICAgICAgICAgICAgYSA9IG1hdHJpeG1bMF0sIGIgPSBtYXRyaXhtWzFdLCBjID0gbWF0cml4bVs0XSwgZCA9IG1hdHJpeG1bNV0sXHJcbiAgICAgICAgICAgIHR4ID0gbWF0cml4bVsxMl0sIHR5ID0gbWF0cml4bVsxM107XHJcblxyXG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xyXG4gICAgICAgIGxldCB3b3JsZCA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG5cclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCA0OyArK3Jvdykge1xyXG4gICAgICAgICAgICBsZXQgbG9jYWxSb3dZID0gbG9jYWxbcm93ICogMiArIDFdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCA0OyArK2NvbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsQ29sWCA9IGxvY2FsW2NvbCAqIDJdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHdvcmxkSW5kZXggPSAocm93ICogNCArIGNvbCkgKiBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgd29ybGRbd29ybGRJbmRleF0gPSBsb2NhbENvbFggKiBhICsgbG9jYWxSb3dZICogYyArIHR4O1xyXG4gICAgICAgICAgICAgICAgd29ybGRbd29ybGRJbmRleCArIDFdID0gbG9jYWxDb2xYICogYiArIGxvY2FsUm93WSAqIGQgKyB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuaWYgKENDX05BVElWRVJFTkRFUkVSKSB7XHJcbiAgICBsZXQgcHJvdG8gPSBNdWx0aUFzc2VtYmxlclNsaWNlZC5wcm90b3R5cGU7XHJcbiAgICAvL0B0cy1pZ25vcmVcclxuICAgIGxldCBuYXRpdmVQcm90byA9IHJlbmRlcmVyLlNsaWNlZFNwcml0ZTJELnByb3RvdHlwZTtcclxuXHJcbiAgICBwcm90by51cGRhdGVXb3JsZFZlcnRzID0gZnVuY3Rpb24gKGNvbXApIHtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLl9kaXJ0eVB0clswXSB8PSBjYy5Bc3NlbWJsZXIuRkxBR19WRVJUSUNFU19ESVJUWTtcclxuICAgIH07XHJcblxyXG4gICAgLy9AdHMtaWdub3JlXHJcbiAgICBwcm90by5fZXh0ZW5kTmF0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG5hdGl2ZVByb3RvLmN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdG8uaW5pdExvY2FsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcclxuICAgICAgICBuYXRpdmVQcm90by5zZXRMb2NhbERhdGEuY2FsbCh0aGlzLCB0aGlzLl9sb2NhbCk7XHJcbiAgICB9O1xyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/MultiTextureManager.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4fc9cgEvWxKZK0hYF2jjQq7', 'MultiTextureManager');
// scripts/common/cmpt/ui/multiTexture/MultiTextureManager.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiTextureManager = void 0;
/**
 * Multi-Texture 管理器
 */
var MultiTextureManager = /** @class */ (function () {
    function MultiTextureManager() {
    }
    /**
     * 初始化纹理管理器
     */
    MultiTextureManager.init = function (mat) {
        if (this._init || !(mat instanceof cc.Material) || mat instanceof cc.MaterialVariant) {
            return;
        }
        this._init = true;
        this._mat = mat;
        // 处理引用计数
        this._mat.addRef();
    };
    MultiTextureManager.addSprite = function (sp) {
        this._sprites.add(sp);
    };
    MultiTextureManager.removeSprite = function (sp) {
        this._sprites.delete(sp);
    };
    /**
     * 设置合批纹理
     * @param idx 纹理id
     * @param tex 纹理对象
     * @returns
     */
    MultiTextureManager.setTexture = function (idx, tex) {
        var _this = this;
        if (!this._init) {
            cc.error("[MultiSpriteManager.setTexture] 未初始化MultiSpriteManager");
            return;
        }
        if (!(tex instanceof cc.Texture2D)) {
            cc.error("[MultiSpriteManager.setTexture] 参数类型错误");
            return;
        }
        idx = cc.misc.clampf(idx, 0, MultiTextureManager.MAX_TEXTURE_NUM - 1);
        var oldTex = this._texMap.get(idx);
        if (oldTex === tex) {
            return;
        }
        // 处理引用计数
        if (oldTex) {
            oldTex.decRef();
        }
        tex.addRef();
        this._texMap.set(idx, tex);
        // 修改共享材质属性
        this._mat.setProperty("texture" + idx, tex);
        // 修改已存在的渲染组件上材质变体的属性，同时更新渲染组件textureIdx
        this._sprites.forEach(function (v) {
            /**
             * @bug
             * 2.4.5之前材质hash计算在utils.js中serializeUniforms有bug, 里面for-in遍历材质属性顺序受k-v对插入顺序影响(即setProperty顺序), 即使属性完全一致, hash却不一定一致
             * 因此在此直接创建新的材质
             */
            // v.setMaterial(0, this._mat);
            // 材质变体中的属性必须完全一致, 材质的hash值计算才会一致
            var material = v.getMaterial(0);
            for (var i = 0; i < MultiTextureManager.MAX_TEXTURE_NUM; i++) {
                var texture = _this._texMap.get(i);
                if (!texture) {
                    continue;
                }
                var textureImpl = texture.getImpl();
                if (material.getProperty("texture" + i, 0) !== textureImpl) {
                    material.setProperty("texture" + i, texture);
                }
            }
            // 修改共享材质属性后，必须手动设置材质变体的_effect._dirty，不然不会重新计算材质变体的hash值
            material["_effect"]._dirty = true;
            // 更新textureIdx与材质属性
            v._updateMaterial();
        });
    };
    /**
     * 根据纹理获取对应的textureIdx
     * @param tex
     * @returns
     */
    MultiTextureManager.getIdx = function (tex) {
        if (!this._init) {
            cc.error("[MultiSpriteManager.getIdx] 未初始化MultiSpriteManager");
            return;
        }
        for (var i = 0; i < MultiTextureManager.MAX_TEXTURE_NUM; i++) {
            if (this._texMap.get(i) === tex || this._mat.getProperty("texture" + i, 0) === tex.getImpl()) {
                return i;
            }
        }
        return -1;
    };
    /** 纹理最大数量 */
    MultiTextureManager.MAX_TEXTURE_NUM = 8;
    MultiTextureManager._init = false;
    /** 共享材质 */
    MultiTextureManager._mat = null;
    MultiTextureManager._texMap = new Map();
    MultiTextureManager._sprites = new Set();
    return MultiTextureManager;
}());
exports.MultiTextureManager = MultiTextureManager;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxNdWx0aVRleHR1cmVNYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztHQUVHO0FBQ0g7SUFBQTtJQThHQSxDQUFDO0lBcEdHOztPQUVHO0lBQ1csd0JBQUksR0FBbEIsVUFBbUIsR0FBZ0I7UUFDL0IsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsWUFBWSxFQUFFLENBQUMsZUFBZSxFQUFFO1lBQ2xGLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ2hCLFNBQVM7UUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ3ZCLENBQUM7SUFFYSw2QkFBUyxHQUF2QixVQUF3QixFQUFlO1FBQ25DLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFYSxnQ0FBWSxHQUExQixVQUEyQixFQUFlO1FBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNXLDhCQUFVLEdBQXhCLFVBQXlCLEdBQVcsRUFBRSxHQUFpQjtRQUF2RCxpQkFxREM7UUFwREcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDYixFQUFFLENBQUMsS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7WUFDbkUsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLENBQUMsR0FBRyxZQUFZLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNoQyxFQUFFLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxDQUFD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ImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNdWx0aVNwcml0ZSBmcm9tIFwiLi9NdWx0aVNwcml0ZVwiO1xyXG5cclxuLyoqXHJcbiAqIE11bHRpLVRleHR1cmUg566h55CG5ZmoXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTXVsdGlUZXh0dXJlTWFuYWdlciB7XHJcbiAgICAvKiog57q555CG5pyA5aSn5pWw6YePICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1BWF9URVhUVVJFX05VTSA9IDg7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2luaXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8qKiDlhbHkuqvmnZDotKggKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9tYXQ6IGNjLk1hdGVyaWFsID0gbnVsbDtcclxuICAgIHByaXZhdGUgc3RhdGljIF90ZXhNYXA6IE1hcDxudW1iZXIsIGNjLlRleHR1cmUyRD4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfc3ByaXRlczogU2V0PE11bHRpU3ByaXRlPiA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMlue6ueeQhueuoeeQhuWZqFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXQobWF0OiBjYy5NYXRlcmlhbCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbml0IHx8ICEobWF0IGluc3RhbmNlb2YgY2MuTWF0ZXJpYWwpIHx8IG1hdCBpbnN0YW5jZW9mIGNjLk1hdGVyaWFsVmFyaWFudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX21hdCA9IG1hdDtcclxuICAgICAgICAvLyDlpITnkIblvJXnlKjorqHmlbBcclxuICAgICAgICB0aGlzLl9tYXQuYWRkUmVmKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhZGRTcHJpdGUoc3A6IE11bHRpU3ByaXRlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlcy5hZGQoc3ApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVtb3ZlU3ByaXRlKHNwOiBNdWx0aVNwcml0ZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZXMuZGVsZXRlKHNwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9ruWQiOaJuee6ueeQhlxyXG4gICAgICogQHBhcmFtIGlkeCDnurnnkIZpZFxyXG4gICAgICogQHBhcmFtIHRleCDnurnnkIblr7nosaFcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldFRleHR1cmUoaWR4OiBudW1iZXIsIHRleDogY2MuVGV4dHVyZTJEKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0KSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKFwiW011bHRpU3ByaXRlTWFuYWdlci5zZXRUZXh0dXJlXSDmnKrliJ3lp4vljJZNdWx0aVNwcml0ZU1hbmFnZXJcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghKHRleCBpbnN0YW5jZW9mIGNjLlRleHR1cmUyRCkpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoXCJbTXVsdGlTcHJpdGVNYW5hZ2VyLnNldFRleHR1cmVdIOWPguaVsOexu+Wei+mUmeivr1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWR4ID0gY2MubWlzYy5jbGFtcGYoaWR4LCAwLCBNdWx0aVRleHR1cmVNYW5hZ2VyLk1BWF9URVhUVVJFX05VTSAtIDEpO1xyXG4gICAgICAgIGxldCBvbGRUZXggPSB0aGlzLl90ZXhNYXAuZ2V0KGlkeCk7XHJcbiAgICAgICAgaWYgKG9sZFRleCA9PT0gdGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIOWkhOeQhuW8leeUqOiuoeaVsFxyXG4gICAgICAgIGlmIChvbGRUZXgpIHtcclxuICAgICAgICAgICAgb2xkVGV4LmRlY1JlZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXguYWRkUmVmKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3RleE1hcC5zZXQoaWR4LCB0ZXgpO1xyXG4gICAgICAgIC8vIOS/ruaUueWFseS6q+adkOi0qOWxnuaAp1xyXG4gICAgICAgIHRoaXMuX21hdC5zZXRQcm9wZXJ0eShgdGV4dHVyZSR7aWR4fWAsIHRleCk7XHJcbiAgICAgICAgLy8g5L+u5pS55bey5a2Y5Zyo55qE5riy5p+T57uE5Lu25LiK5p2Q6LSo5Y+Y5L2T55qE5bGe5oCn77yM5ZCM5pe25pu05paw5riy5p+T57uE5Lu2dGV4dHVyZUlkeFxyXG4gICAgICAgIHRoaXMuX3Nwcml0ZXMuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQGJ1Z1xyXG4gICAgICAgICAgICAgKiAyLjQuNeS5i+WJjeadkOi0qGhhc2jorqHnrpflnKh1dGlscy5qc+S4rXNlcmlhbGl6ZVVuaWZvcm1z5pyJYnVnLCDph4zpnaJmb3ItaW7pgY3ljobmnZDotKjlsZ7mgKfpobrluo/lj5drLXblr7nmj5LlhaXpobrluo/lvbHlk40o5Y2zc2V0UHJvcGVydHnpobrluo8pLCDljbPkvb/lsZ7mgKflrozlhajkuIDoh7QsIGhhc2jljbTkuI3kuIDlrprkuIDoh7RcclxuICAgICAgICAgICAgICog5Zug5q2k5Zyo5q2k55u05o6l5Yib5bu65paw55qE5p2Q6LSoXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyB2LnNldE1hdGVyaWFsKDAsIHRoaXMuX21hdCk7XHJcblxyXG4gICAgICAgICAgICAvLyDmnZDotKjlj5jkvZPkuK3nmoTlsZ7mgKflv4XpobvlrozlhajkuIDoh7QsIOadkOi0qOeahGhhc2jlgLzorqHnrpfmiY3kvJrkuIDoh7RcclxuICAgICAgICAgICAgbGV0IG1hdGVyaWFsID0gdi5nZXRNYXRlcmlhbCgwKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNdWx0aVRleHR1cmVNYW5hZ2VyLk1BWF9URVhUVVJFX05VTTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZSA9IHRoaXMuX3RleE1hcC5nZXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlSW1wbCA9IHRleHR1cmUuZ2V0SW1wbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGVyaWFsLmdldFByb3BlcnR5KGB0ZXh0dXJlJHtpfWAsIDApICE9PSB0ZXh0dXJlSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsLnNldFByb3BlcnR5KGB0ZXh0dXJlJHtpfWAsIHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOS/ruaUueWFseS6q+adkOi0qOWxnuaAp+WQju+8jOW/hemhu+aJi+WKqOiuvue9ruadkOi0qOWPmOS9k+eahF9lZmZlY3QuX2RpcnR577yM5LiN54S25LiN5Lya6YeN5paw6K6h566X5p2Q6LSo5Y+Y5L2T55qEaGFzaOWAvFxyXG4gICAgICAgICAgICBtYXRlcmlhbFtcIl9lZmZlY3RcIl0uX2RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIOabtOaWsHRleHR1cmVJZHjkuI7mnZDotKjlsZ7mgKdcclxuICAgICAgICAgICAgdi5fdXBkYXRlTWF0ZXJpYWwoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrue6ueeQhuiOt+WPluWvueW6lOeahHRleHR1cmVJZHhcclxuICAgICAqIEBwYXJhbSB0ZXggXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRJZHgodGV4OiBjYy5UZXh0dXJlMkQpOiBudW1iZXIge1xyXG4gICAgICAgIGlmICghdGhpcy5faW5pdCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihcIltNdWx0aVNwcml0ZU1hbmFnZXIuZ2V0SWR4XSDmnKrliJ3lp4vljJZNdWx0aVNwcml0ZU1hbmFnZXJcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNdWx0aVRleHR1cmVNYW5hZ2VyLk1BWF9URVhUVVJFX05VTTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXhNYXAuZ2V0KGkpID09PSB0ZXggfHwgdGhpcy5fbWF0LmdldFByb3BlcnR5KGB0ZXh0dXJlJHtpfWAsIDApID09PSB0ZXguZ2V0SW1wbCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerTiled.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '825c0CUhQhLHIOj5ulatGUZ', 'MultiAssemblerTiled');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssemblerTiled.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MultiAssembler_1 = require("./MultiAssembler");
var MultiAssemblerTiled = /** @class */ (function (_super) {
    __extends(MultiAssemblerTiled, _super);
    function MultiAssemblerTiled() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.contentWidth = 0;
        _this.contentHeight = 0;
        _this.rectWidth = 0;
        _this.rectHeight = 0;
        _this.hRepeat = 0;
        _this.vRepeat = 0;
        _this.row = 0;
        _this.col = 0;
        _this.sizableWidth = 0;
        _this.sizableHeight = 0;
        return _this;
    }
    MultiAssemblerTiled.prototype.initData = function () {
        this.verticesCount = 0;
        this.contentWidth = 0;
        this.contentHeight = 0;
        this.rectWidth = 0;
        this.rectHeight = 0;
        this.hRepeat = 0;
        this.vRepeat = 0;
        this.row = 0;
        this.col = 0;
        if (this._renderData.meshCount > 0)
            return;
        var data = this._renderData;
        // createFlexData支持创建指定格式的renderData
        data.createFlexData(0, 4, 6, this.getVfmt());
        this._updateIndices();
    };
    MultiAssemblerTiled.prototype.initLocal = function () {
        this._local = { x: [], y: [] };
    };
    MultiAssemblerTiled.prototype._updateIndices = function () {
        var iData = this._renderData.iDatas[0];
        for (var i = 0, vid = 0, l = iData.length; i < l; i += 6, vid += 4) {
            iData[i] = vid;
            iData[i + 1] = vid + 1;
            iData[i + 2] = vid + 2;
            iData[i + 3] = vid + 1;
            iData[i + 4] = vid + 3;
            iData[i + 5] = vid + 2;
        }
    };
    MultiAssemblerTiled.prototype.updateRenderData = function (sprite) {
        var frame = sprite._spriteFrame;
        this.packToDynamicAtlas(sprite, frame);
        var node = sprite.node;
        var contentWidth = this.contentWidth = Math.abs(node.width);
        var contentHeight = this.contentHeight = Math.abs(node.height);
        var rect = frame._rect;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        this.sizableWidth = contentWidth - leftWidth - rightWidth;
        this.sizableHeight = contentHeight - topHeight - bottomHeight;
        this.sizableWidth = this.sizableWidth > 0 ? this.sizableWidth : 0;
        this.sizableHeight = this.sizableHeight > 0 ? this.sizableHeight : 0;
        var hRepeat = this.hRepeat = centerWidth === 0 ? this.sizableWidth : this.sizableWidth / centerWidth;
        var vRepeat = this.vRepeat = centerHeight === 0 ? this.sizableHeight : this.sizableHeight / centerHeight;
        var row = this.row = Math.ceil(vRepeat + 2);
        var col = this.col = Math.ceil(hRepeat + 2);
        // update data property
        var count = row * col;
        this.verticesCount = count * 4;
        this.indicesCount = count * 6;
        var renderData = this._renderData;
        var flexBuffer = renderData._flexBuffer;
        if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
            this._updateIndices();
            this.updateColor(sprite);
        }
        flexBuffer.used(this.verticesCount, this.indicesCount);
        if (sprite._vertsDirty) {
            this.updateUVs(sprite);
            this.updateVerts(sprite);
            this.updateTextureIdx(sprite);
            sprite._vertsDirty = false;
        }
    };
    MultiAssemblerTiled.prototype.updateVerts = function (sprite) {
        var frame = sprite._spriteFrame;
        var rect = frame._rect;
        var node = sprite.node, appx = node.anchorX * node.width, appy = node.anchorY * node.height;
        var _a = this, row = _a.row, col = _a.col, contentWidth = _a.contentWidth, contentHeight = _a.contentHeight;
        var _b = this._local, x = _b.x, y = _b.y;
        x.length = y.length = 0;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        var xScale = (node.width / (leftWidth + rightWidth)) > 1 ? 1 : (node.width / (leftWidth + rightWidth));
        var yScale = (node.height / (topHeight + bottomHeight)) > 1 ? 1 : (node.height / (topHeight + bottomHeight));
        var offsetWidth = 0, offsetHeight = 0;
        if (centerWidth > 0) {
            /*
             * Because the float numerical calculation in javascript is not accurate enough,
             * there is an expected result of 1.0, but the actual result is 1.000001.
             */
            offsetWidth = Math.floor(this.sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : this.sizableWidth % centerWidth;
        }
        else {
            offsetWidth = this.sizableWidth;
        }
        if (centerHeight > 0) {
            offsetHeight = Math.floor(this.sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : this.sizableHeight % centerHeight;
        }
        else {
            offsetHeight = this.sizableHeight;
        }
        for (var i = 0; i <= col; i++) {
            if (i === 0) {
                x[i] = -appx;
            }
            else if (i > 0 && i < col) {
                if (i === 1) {
                    x[i] = leftWidth * xScale + Math.min(centerWidth, this.sizableWidth) - appx;
                }
                else {
                    if (centerWidth > 0) {
                        if (i === (col - 1)) {
                            x[i] = leftWidth + offsetWidth + centerWidth * (i - 2) - appx;
                        }
                        else {
                            x[i] = leftWidth + Math.min(centerWidth, this.sizableWidth) + centerWidth * (i - 2) - appx;
                        }
                    }
                    else {
                        x[i] = leftWidth + this.sizableWidth - appx;
                    }
                }
            }
            else if (i === col) {
                x[i] = Math.min(leftWidth + this.sizableWidth + rightWidth, contentWidth) - appx;
            }
        }
        for (var i = 0; i <= row; i++) {
            if (i === 0) {
                y[i] = -appy;
            }
            else if (i > 0 && i < row) {
                if (i === 1) {
                    y[i] = bottomHeight * yScale + Math.min(centerHeight, this.sizableHeight) - appy;
                }
                else {
                    if (centerHeight > 0) {
                        if (i === (row - 1)) {
                            y[i] = bottomHeight + offsetHeight + (i - 2) * centerHeight - appy;
                        }
                        else {
                            y[i] = bottomHeight + Math.min(centerHeight, this.sizableHeight) + (i - 2) * centerHeight - appy;
                        }
                    }
                    else {
                        y[i] = bottomHeight + this.sizableHeight - appy;
                    }
                }
            }
            else if (i === row) {
                y[i] = Math.min(bottomHeight + this.sizableHeight + topHeight, contentHeight) - appy;
            }
        }
        this.updateWorldVerts(sprite);
    };
    MultiAssemblerTiled.prototype.updateWorldVerts = function (sprite) {
        var renderData = this._renderData;
        var local = this._local;
        var localX = local.x, localY = local.y;
        var world = renderData.vDatas[0];
        var _a = this, row = _a.row, col = _a.col;
        var matrix = sprite.node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var x, x1, y, y1;
        var floatsPerVert = this.floatsPerVert;
        var vertexOffset = 0;
        if (CC_NATIVERENDERER) {
            for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
                y = localY[yindex];
                y1 = localY[yindex + 1];
                for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                    x = localX[xindex];
                    x1 = localX[xindex + 1];
                    // lb
                    world[vertexOffset] = x;
                    world[vertexOffset + 1] = y;
                    vertexOffset += floatsPerVert;
                    // rb
                    world[vertexOffset] = x1;
                    world[vertexOffset + 1] = y;
                    vertexOffset += floatsPerVert;
                    // lt
                    world[vertexOffset] = x;
                    world[vertexOffset + 1] = y1;
                    vertexOffset += floatsPerVert;
                    // rt
                    world[vertexOffset] = x1;
                    world[vertexOffset + 1] = y1;
                    vertexOffset += floatsPerVert;
                }
            }
        }
        else {
            for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
                y = localY[yindex];
                y1 = localY[yindex + 1];
                for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                    x = localX[xindex];
                    x1 = localX[xindex + 1];
                    // lb
                    world[vertexOffset] = x * a + y * c + tx;
                    world[vertexOffset + 1] = x * b + y * d + ty;
                    vertexOffset += floatsPerVert;
                    // rb
                    world[vertexOffset] = x1 * a + y * c + tx;
                    world[vertexOffset + 1] = x1 * b + y * d + ty;
                    vertexOffset += floatsPerVert;
                    // lt
                    world[vertexOffset] = x * a + y1 * c + tx;
                    world[vertexOffset + 1] = x * b + y1 * d + ty;
                    vertexOffset += floatsPerVert;
                    // rt
                    world[vertexOffset] = x1 * a + y1 * c + tx;
                    world[vertexOffset + 1] = x1 * b + y1 * d + ty;
                    vertexOffset += floatsPerVert;
                }
            }
        }
    };
    MultiAssemblerTiled.prototype.updateUVs = function (sprite) {
        var verts = this._renderData.vDatas[0];
        if (!verts)
            return;
        var frame = sprite._spriteFrame;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        var _a = this, row = _a.row, col = _a.col, hRepeat = _a.hRepeat, vRepeat = _a.vRepeat;
        var coefu = 0, coefv = 0;
        var uv = sprite.spriteFrame.uv;
        var uvSliced = sprite.spriteFrame.uvSliced;
        var rotated = sprite.spriteFrame._rotated;
        var floatsPerVert = this.floatsPerVert, uvOffset = this.uvOffset;
        var tempXVerts = [], tempYVerts = [];
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
            if (this.sizableHeight > centerHeight) {
                if (this.sizableHeight >= yindex * centerHeight) {
                    coefv = 1;
                }
                else {
                    coefv = vRepeat % 1;
                }
            }
            else {
                coefv = vRepeat;
            }
            for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                if (this.sizableWidth > centerWidth) {
                    if (this.sizableWidth >= xindex * centerWidth) {
                        coefu = 1;
                    }
                    else {
                        coefu = hRepeat % 1;
                    }
                }
                else {
                    coefu = hRepeat;
                }
                if (rotated) {
                    if (yindex === 0) {
                        tempXVerts[0] = uvSliced[0].u;
                        tempXVerts[1] = uvSliced[0].u;
                        tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefv;
                    }
                    else if (yindex < (row - 1)) {
                        tempXVerts[0] = uvSliced[4].u;
                        tempXVerts[1] = uvSliced[4].u;
                        tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefv;
                    }
                    else if (yindex === (row - 1)) {
                        tempXVerts[0] = uvSliced[8].u;
                        tempXVerts[1] = uvSliced[8].u;
                        tempXVerts[2] = uvSliced[12].u;
                    }
                    if (xindex === 0) {
                        tempYVerts[0] = uvSliced[0].v;
                        tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefu;
                        tempYVerts[2] = uvSliced[0].v;
                    }
                    else if (xindex < (col - 1)) {
                        tempYVerts[0] = uvSliced[1].v;
                        tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefu;
                        tempYVerts[2] = uvSliced[1].v;
                    }
                    else if (xindex === (col - 1)) {
                        tempYVerts[0] = uvSliced[2].v;
                        tempYVerts[1] = uvSliced[3].v;
                        tempYVerts[2] = uvSliced[2].v;
                    }
                    tempXVerts[3] = tempXVerts[2];
                    tempYVerts[3] = tempYVerts[1];
                }
                else {
                    if (xindex === 0) {
                        tempXVerts[0] = uvSliced[0].u;
                        tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefu;
                        tempXVerts[2] = uv[0];
                    }
                    else if (xindex < (col - 1)) {
                        tempXVerts[0] = uvSliced[1].u;
                        tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefu;
                        tempXVerts[2] = uvSliced[1].u;
                    }
                    else if (xindex === (col - 1)) {
                        tempXVerts[0] = uvSliced[2].u;
                        tempXVerts[1] = uvSliced[3].u;
                        tempXVerts[2] = uvSliced[2].u;
                    }
                    if (yindex === 0) {
                        tempYVerts[0] = uvSliced[0].v;
                        tempYVerts[1] = uvSliced[0].v;
                        tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefv;
                    }
                    else if (yindex < (row - 1)) {
                        tempYVerts[0] = uvSliced[4].v;
                        tempYVerts[1] = uvSliced[4].v;
                        tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefv;
                    }
                    else if (yindex === (row - 1)) {
                        tempYVerts[0] = uvSliced[8].v;
                        tempYVerts[1] = uvSliced[8].v;
                        tempYVerts[2] = uvSliced[12].v;
                    }
                    tempXVerts[3] = tempXVerts[1];
                    tempYVerts[3] = tempYVerts[2];
                }
                // lb
                verts[uvOffset] = tempXVerts[0];
                verts[uvOffset + 1] = tempYVerts[0];
                uvOffset += floatsPerVert;
                // rb
                verts[uvOffset] = tempXVerts[1];
                verts[uvOffset + 1] = tempYVerts[1];
                uvOffset += floatsPerVert;
                // lt
                verts[uvOffset] = tempXVerts[2];
                verts[uvOffset + 1] = tempYVerts[2];
                uvOffset += floatsPerVert;
                // rt
                verts[uvOffset] = tempXVerts[3];
                verts[uvOffset + 1] = tempYVerts[3];
                uvOffset += floatsPerVert;
            }
        }
    };
    return MultiAssemblerTiled;
}(MultiAssembler_1.default));
exports.default = MultiAssemblerTiled;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyVGlsZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbURBQThDO0FBRTlDO0lBQWlELHVDQUFjO0lBQS9EO1FBQUEscUVBNldDO1FBNVdXLGtCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBQ3pCLG1CQUFhLEdBQVcsQ0FBQyxDQUFDO1FBQzFCLGVBQVMsR0FBVyxDQUFDLENBQUM7UUFDdEIsZ0JBQVUsR0FBVyxDQUFDLENBQUM7UUFDdkIsYUFBTyxHQUFXLENBQUMsQ0FBQztRQUNwQixhQUFPLEdBQVcsQ0FBQyxDQUFDO1FBQ3BCLFNBQUcsR0FBVyxDQUFDLENBQUM7UUFDaEIsU0FBRyxHQUFXLENBQUMsQ0FBQztRQUNoQixrQkFBWSxHQUFXLENBQUMsQ0FBQztRQUN6QixtQkFBYSxHQUFXLENBQUMsQ0FBQzs7SUFtV3RDLENBQUM7SUFqV1Usc0NBQVEsR0FBZjtRQUNJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFFYixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLENBQUM7WUFBRSxPQUFPO1FBQzNDLElBQUksSUFBSSxH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QUFDLENBQUM7d0JBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDbEM7b0JBQ0QsSUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFO3dCQUNkLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzt3QkFDeEUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ2pDO3lCQUFNLElBQUksTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO3dCQUMzQixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7d0JBQ3hFLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNqQzt5QkFBTSxJQUFJLE1BQU0sS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTt3QkFDN0IsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDakM7b0JBQ0QsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDOUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDakM7cUJBQ0k7b0JBQ0QsSUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFO3dCQUNkLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzt3QkFDeEUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDekI7eUJBQU0sSUFBSSxNQUFNLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7d0JBQzNCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzt3QkFDeEUsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ2pDO3lCQUFNLElBQUksTUFBTSxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO3dCQUM3QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNqQztvQkFDRCxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7d0JBQ2QsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztxQkFDM0U7eUJBQU0sSUFBSSxNQUFNLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7d0JBQzNCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7cUJBQzNFO3lCQUFNLElBQUksTUFBTSxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO3dCQUM3QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzlCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNsQztvQkFDRCxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM5QixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNqQztnQkFDRCxLQUFLO2dCQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxRQUFRLElBQUksYUFBYSxDQUFDO2dCQUMxQixLQUFLO2dCQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxRQUFRLElBQUksYUFBYSxDQUFDO2dCQUMxQixLQUFLO2dCQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxRQUFRLElBQUksYUFBYSxDQUFDO2dCQUMxQixLQUFLO2dCQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNwQyxRQUFRLElBQUksYUFBYSxDQUFDO2FBQzdCO1NBQ0o7SUFDTCxDQUFDO0lBQ0wsMEJBQUM7QUFBRCxDQTdXQSxBQTZXQyxDQTdXZ0Qsd0JBQWMsR0E2VzlEIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE11bHRpQXNzZW1ibGVyIGZyb20gXCIuL011bHRpQXNzZW1ibGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aUFzc2VtYmxlclRpbGVkIGV4dGVuZHMgTXVsdGlBc3NlbWJsZXIge1xyXG4gICAgcHJpdmF0ZSBjb250ZW50V2lkdGg6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGNvbnRlbnRIZWlnaHQ6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHJlY3RXaWR0aDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgcmVjdEhlaWdodDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgaFJlcGVhdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgdlJlcGVhdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgcm93OiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBjb2w6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHNpemFibGVXaWR0aDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc2l6YWJsZUhlaWdodDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwdWJsaWMgaW5pdERhdGEoKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmNvbnRlbnRXaWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLnJlY3RXaWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWN0SGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmhSZXBlYXQgPSAwO1xyXG4gICAgICAgIHRoaXMudlJlcGVhdCA9IDA7XHJcbiAgICAgICAgdGhpcy5yb3cgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlckRhdGEubWVzaENvdW50ID4gMCkgcmV0dXJuO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fcmVuZGVyRGF0YTtcclxuICAgICAgICAvLyBjcmVhdGVGbGV4RGF0YeaUr+aMgeWIm+W7uuaMh+WumuagvOW8j+eahHJlbmRlckRhdGFcclxuICAgICAgICBkYXRhLmNyZWF0ZUZsZXhEYXRhKDAsIDQsIDYsIHRoaXMuZ2V0VmZtdCgpKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSW5kaWNlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbml0TG9jYWwoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWwgPSB7IHg6IFtdLCB5OiBbXSB9IGFzIGFueTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF91cGRhdGVJbmRpY2VzKCkge1xyXG4gICAgICAgIGxldCBpRGF0YSA9IHRoaXMuX3JlbmRlckRhdGEuaURhdGFzWzBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB2aWQgPSAwLCBsID0gaURhdGEubGVuZ3RoOyBpIDwgbDsgaSArPSA2LCB2aWQgKz0gNCkge1xyXG4gICAgICAgICAgICBpRGF0YVtpXSA9IHZpZDtcclxuICAgICAgICAgICAgaURhdGFbaSArIDFdID0gdmlkICsgMTtcclxuICAgICAgICAgICAgaURhdGFbaSArIDJdID0gdmlkICsgMjtcclxuICAgICAgICAgICAgaURhdGFbaSArIDNdID0gdmlkICsgMTtcclxuICAgICAgICAgICAgaURhdGFbaSArIDRdID0gdmlkICsgMztcclxuICAgICAgICAgICAgaURhdGFbaSArIDVdID0gdmlkICsgMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVJlbmRlckRhdGEoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IGZyYW1lID0gc3ByaXRlLl9zcHJpdGVGcmFtZTtcclxuICAgICAgICB0aGlzLnBhY2tUb0R5bmFtaWNBdGxhcyhzcHJpdGUsIGZyYW1lKTtcclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBzcHJpdGUubm9kZTtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMuY29udGVudFdpZHRoID0gTWF0aC5hYnMobm9kZS53aWR0aCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRIZWlnaHQgPSB0aGlzLmNvbnRlbnRIZWlnaHQgPSBNYXRoLmFicyhub2RlLmhlaWdodCk7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBmcmFtZS5fcmVjdDtcclxuICAgICAgICBsZXQgbGVmdFdpZHRoID0gZnJhbWUuaW5zZXRMZWZ0LCByaWdodFdpZHRoID0gZnJhbWUuaW5zZXRSaWdodCwgY2VudGVyV2lkdGggPSByZWN0LndpZHRoIC0gbGVmdFdpZHRoIC0gcmlnaHRXaWR0aCxcclxuICAgICAgICAgICAgdG9wSGVpZ2h0ID0gZnJhbWUuaW5zZXRUb3AsIGJvdHRvbUhlaWdodCA9IGZyYW1lLmluc2V0Qm90dG9tLCBjZW50ZXJIZWlnaHQgPSByZWN0LmhlaWdodCAtIHRvcEhlaWdodCAtIGJvdHRvbUhlaWdodDtcclxuICAgICAgICB0aGlzLnNpemFibGVXaWR0aCA9IGNvbnRlbnRXaWR0aCAtIGxlZnRXaWR0aCAtIHJpZ2h0V2lkdGg7XHJcbiAgICAgICAgdGhpcy5zaXphYmxlSGVpZ2h0ID0gY29udGVudEhlaWdodCAtIHRvcEhlaWdodCAtIGJvdHRvbUhlaWdodDtcclxuICAgICAgICB0aGlzLnNpemFibGVXaWR0aCA9IHRoaXMuc2l6YWJsZVdpZHRoID4gMCA/IHRoaXMuc2l6YWJsZVdpZHRoIDogMDtcclxuICAgICAgICB0aGlzLnNpemFibGVIZWlnaHQgPSB0aGlzLnNpemFibGVIZWlnaHQgPiAwID8gdGhpcy5zaXphYmxlSGVpZ2h0IDogMDtcclxuICAgICAgICBsZXQgaFJlcGVhdCA9IHRoaXMuaFJlcGVhdCA9IGNlbnRlcldpZHRoID09PSAwID8gdGhpcy5zaXphYmxlV2lkdGggOiB0aGlzLnNpemFibGVXaWR0aCAvIGNlbnRlcldpZHRoO1xyXG4gICAgICAgIGxldCB2UmVwZWF0ID0gdGhpcy52UmVwZWF0ID0gY2VudGVySGVpZ2h0ID09PSAwID8gdGhpcy5zaXphYmxlSGVpZ2h0IDogdGhpcy5zaXphYmxlSGVpZ2h0IC8gY2VudGVySGVpZ2h0O1xyXG4gICAgICAgIGxldCByb3cgPSB0aGlzLnJvdyA9IE1hdGguY2VpbCh2UmVwZWF0ICsgMik7XHJcbiAgICAgICAgbGV0IGNvbCA9IHRoaXMuY29sID0gTWF0aC5jZWlsKGhSZXBlYXQgKyAyKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgcHJvcGVydHlcclxuICAgICAgICBsZXQgY291bnQgPSByb3cgKiBjb2w7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0NvdW50ID0gY291bnQgKiA0O1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc0NvdW50ID0gY291bnQgKiA2O1xyXG5cclxuICAgICAgICBsZXQgcmVuZGVyRGF0YSA9IHRoaXMuX3JlbmRlckRhdGE7XHJcbiAgICAgICAgbGV0IGZsZXhCdWZmZXIgPSByZW5kZXJEYXRhLl9mbGV4QnVmZmVyO1xyXG4gICAgICAgIGlmIChmbGV4QnVmZmVyLnJlc2VydmUodGhpcy52ZXJ0aWNlc0NvdW50LCB0aGlzLmluZGljZXNDb3VudCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSW5kaWNlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbG9yKHNwcml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsZXhCdWZmZXIudXNlZCh0aGlzLnZlcnRpY2VzQ291bnQsIHRoaXMuaW5kaWNlc0NvdW50KTtcclxuXHJcbiAgICAgICAgaWYgKHNwcml0ZS5fdmVydHNEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVWcyhzcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZlcnRzKHNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZUlkeChzcHJpdGUpO1xyXG4gICAgICAgICAgICBzcHJpdGUuX3ZlcnRzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVZlcnRzKHNwcml0ZSkge1xyXG4gICAgICAgIGxldCBmcmFtZSA9IHNwcml0ZS5fc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBmcmFtZS5fcmVjdDtcclxuICAgICAgICBsZXQgbm9kZSA9IHNwcml0ZS5ub2RlLFxyXG4gICAgICAgICAgICBhcHB4ID0gbm9kZS5hbmNob3JYICogbm9kZS53aWR0aCwgYXBweSA9IG5vZGUuYW5jaG9yWSAqIG5vZGUuaGVpZ2h0O1xyXG5cclxuICAgICAgICBsZXQgeyByb3csIGNvbCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0IH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHRoaXMuX2xvY2FsIGFzIGFueTtcclxuICAgICAgICB4Lmxlbmd0aCA9IHkubGVuZ3RoID0gMDtcclxuICAgICAgICBsZXQgbGVmdFdpZHRoID0gZnJhbWUuaW5zZXRMZWZ0LCByaWdodFdpZHRoID0gZnJhbWUuaW5zZXRSaWdodCwgY2VudGVyV2lkdGggPSByZWN0LndpZHRoIC0gbGVmdFdpZHRoIC0gcmlnaHRXaWR0aCxcclxuICAgICAgICAgICAgdG9wSGVpZ2h0ID0gZnJhbWUuaW5zZXRUb3AsIGJvdHRvbUhlaWdodCA9IGZyYW1lLmluc2V0Qm90dG9tLCBjZW50ZXJIZWlnaHQgPSByZWN0LmhlaWdodCAtIHRvcEhlaWdodCAtIGJvdHRvbUhlaWdodDtcclxuICAgICAgICBsZXQgeFNjYWxlID0gKG5vZGUud2lkdGggLyAobGVmdFdpZHRoICsgcmlnaHRXaWR0aCkpID4gMSA/IDEgOiAobm9kZS53aWR0aCAvIChsZWZ0V2lkdGggKyByaWdodFdpZHRoKSk7XHJcbiAgICAgICAgbGV0IHlTY2FsZSA9IChub2RlLmhlaWdodCAvICh0b3BIZWlnaHQgKyBib3R0b21IZWlnaHQpKSA+IDEgPyAxIDogKG5vZGUuaGVpZ2h0IC8gKHRvcEhlaWdodCArIGJvdHRvbUhlaWdodCkpO1xyXG4gICAgICAgIGxldCBvZmZzZXRXaWR0aCA9IDAsIG9mZnNldEhlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKGNlbnRlcldpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBCZWNhdXNlIHRoZSBmbG9hdCBudW1lcmljYWwgY2FsY3VsYXRpb24gaW4gamF2YXNjcmlwdCBpcyBub3QgYWNjdXJhdGUgZW5vdWdoLCBcclxuICAgICAgICAgICAgICogdGhlcmUgaXMgYW4gZXhwZWN0ZWQgcmVzdWx0IG9mIDEuMCwgYnV0IHRoZSBhY3R1YWwgcmVzdWx0IGlzIDEuMDAwMDAxLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBNYXRoLmZsb29yKHRoaXMuc2l6YWJsZVdpZHRoICogMTAwMCkgLyAxMDAwICUgY2VudGVyV2lkdGggPT09IDAgPyBjZW50ZXJXaWR0aCA6IHRoaXMuc2l6YWJsZVdpZHRoICUgY2VudGVyV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvZmZzZXRXaWR0aCA9IHRoaXMuc2l6YWJsZVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2VudGVySGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuc2l6YWJsZUhlaWdodCAqIDEwMDApIC8gMTAwMCAlIGNlbnRlckhlaWdodCA9PT0gMCA/IGNlbnRlckhlaWdodCA6IHRoaXMuc2l6YWJsZUhlaWdodCAlIGNlbnRlckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IHRoaXMuc2l6YWJsZUhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB4W2ldID0gLSBhcHB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIGkgPCBjb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFtpXSA9IGxlZnRXaWR0aCAqIHhTY2FsZSArIE1hdGgubWluKGNlbnRlcldpZHRoLCB0aGlzLnNpemFibGVXaWR0aCkgLSBhcHB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlcldpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gKGNvbCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4W2ldID0gbGVmdFdpZHRoICsgb2Zmc2V0V2lkdGggKyBjZW50ZXJXaWR0aCAqIChpIC0gMikgLSBhcHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFtpXSA9IGxlZnRXaWR0aCArIE1hdGgubWluKGNlbnRlcldpZHRoLCB0aGlzLnNpemFibGVXaWR0aCkgKyBjZW50ZXJXaWR0aCAqIChpIC0gMikgLSBhcHB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4W2ldID0gbGVmdFdpZHRoICsgdGhpcy5zaXphYmxlV2lkdGggLSBhcHB4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSBjb2wpIHtcclxuICAgICAgICAgICAgICAgIHhbaV0gPSBNYXRoLm1pbihsZWZ0V2lkdGggKyB0aGlzLnNpemFibGVXaWR0aCArIHJpZ2h0V2lkdGgsIGNvbnRlbnRXaWR0aCkgLSBhcHB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvdzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB5W2ldID0gLSBhcHB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIGkgPCByb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVtpXSA9IGJvdHRvbUhlaWdodCAqIHlTY2FsZSArIE1hdGgubWluKGNlbnRlckhlaWdodCwgdGhpcy5zaXphYmxlSGVpZ2h0KSAtIGFwcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VudGVySGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gKHJvdyAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5W2ldID0gYm90dG9tSGVpZ2h0ICsgb2Zmc2V0SGVpZ2h0ICsgKGkgLSAyKSAqIGNlbnRlckhlaWdodCAtIGFwcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5W2ldID0gYm90dG9tSGVpZ2h0ICsgTWF0aC5taW4oY2VudGVySGVpZ2h0LCB0aGlzLnNpemFibGVIZWlnaHQpICsgKGkgLSAyKSAqIGNlbnRlckhlaWdodCAtIGFwcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlbaV0gPSBib3R0b21IZWlnaHQgKyB0aGlzLnNpemFibGVIZWlnaHQgLSBhcHB5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSByb3cpIHtcclxuICAgICAgICAgICAgICAgIHlbaV0gPSBNYXRoLm1pbihib3R0b21IZWlnaHQgKyB0aGlzLnNpemFibGVIZWlnaHQgKyB0b3BIZWlnaHQsIGNvbnRlbnRIZWlnaHQpIC0gYXBweTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFZlcnRzKHNwcml0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVdvcmxkVmVydHMoc3ByaXRlKSB7XHJcbiAgICAgICAgbGV0IHJlbmRlckRhdGEgPSB0aGlzLl9yZW5kZXJEYXRhO1xyXG4gICAgICAgIGxldCBsb2NhbDogYW55ID0gdGhpcy5fbG9jYWw7XHJcbiAgICAgICAgbGV0IGxvY2FsWCA9IGxvY2FsLngsIGxvY2FsWSA9IGxvY2FsLnk7XHJcbiAgICAgICAgbGV0IHdvcmxkID0gcmVuZGVyRGF0YS52RGF0YXNbMF07XHJcbiAgICAgICAgbGV0IHsgcm93LCBjb2wgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IHNwcml0ZS5ub2RlLl93b3JsZE1hdHJpeDtcclxuICAgICAgICBsZXQgbWF0cml4bSA9IG1hdHJpeC5tO1xyXG4gICAgICAgIGxldCBhID0gbWF0cml4bVswXSwgYiA9IG1hdHJpeG1bMV0sIGMgPSBtYXRyaXhtWzRdLCBkID0gbWF0cml4bVs1XSxcclxuICAgICAgICAgICAgdHggPSBtYXRyaXhtWzEyXSwgdHkgPSBtYXRyaXhtWzEzXTtcclxuXHJcbiAgICAgICAgbGV0IHgsIHgxLCB5LCB5MTtcclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICBsZXQgdmVydGV4T2Zmc2V0ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKENDX05BVElWRVJFTkRFUkVSKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHlpbmRleCA9IDAsIHlsZW5ndGggPSByb3c7IHlpbmRleCA8IHlsZW5ndGg7ICsreWluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gbG9jYWxZW3lpbmRleF07XHJcbiAgICAgICAgICAgICAgICB5MSA9IGxvY2FsWVt5aW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHhpbmRleCA9IDAsIHhsZW5ndGggPSBjb2w7IHhpbmRleCA8IHhsZW5ndGg7ICsreGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGxvY2FsWFt4aW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHgxID0gbG9jYWxYW3hpbmRleCArIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBsYlxyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldCArIDFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgICAgICAgICAvLyByYlxyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldF0gPSB4MTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFt2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbHRcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFt2ZXJ0ZXhPZmZzZXRdID0geDtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFt2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ0XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0XSA9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldCArIDFdID0geTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5aW5kZXggPSAwLCB5bGVuZ3RoID0gcm93OyB5aW5kZXggPCB5bGVuZ3RoOyArK3lpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgeSA9IGxvY2FsWVt5aW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgeTEgPSBsb2NhbFlbeWluZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB4aW5kZXggPSAwLCB4bGVuZ3RoID0gY29sOyB4aW5kZXggPCB4bGVuZ3RoOyArK3hpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBsb2NhbFhbeGluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB4MSA9IGxvY2FsWFt4aW5kZXggKyAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGJcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFt2ZXJ0ZXhPZmZzZXRdID0geCAqIGEgKyB5ICogYyArIHR4O1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldCArIDFdID0geCAqIGIgKyB5ICogZCArIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJiXHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0XSA9IHgxICogYSArIHkgKiBjICsgdHg7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0ICsgMV0gPSB4MSAqIGIgKyB5ICogZCArIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGx0XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0XSA9IHggKiBhICsgeTEgKiBjICsgdHg7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0ICsgMV0gPSB4ICogYiArIHkxICogZCArIHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleE9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJ0XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRbdmVydGV4T2Zmc2V0XSA9IHgxICogYSArIHkxICogYyArIHR4O1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkW3ZlcnRleE9mZnNldCArIDFdID0geDEgKiBiICsgeTEgKiBkICsgdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVVWcyhzcHJpdGUpIHtcclxuICAgICAgICBsZXQgdmVydHMgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcclxuICAgICAgICBpZiAoIXZlcnRzKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBmcmFtZSA9IHNwcml0ZS5fc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBmcmFtZS5fcmVjdDtcclxuICAgICAgICBsZXQgbGVmdFdpZHRoID0gZnJhbWUuaW5zZXRMZWZ0LCByaWdodFdpZHRoID0gZnJhbWUuaW5zZXRSaWdodCwgY2VudGVyV2lkdGggPSByZWN0LndpZHRoIC0gbGVmdFdpZHRoIC0gcmlnaHRXaWR0aCxcclxuICAgICAgICAgICAgdG9wSGVpZ2h0ID0gZnJhbWUuaW5zZXRUb3AsIGJvdHRvbUhlaWdodCA9IGZyYW1lLmluc2V0Qm90dG9tLCBjZW50ZXJIZWlnaHQgPSByZWN0LmhlaWdodCAtIHRvcEhlaWdodCAtIGJvdHRvbUhlaWdodDtcclxuXHJcbiAgICAgICAgbGV0IHsgcm93LCBjb2wsIGhSZXBlYXQsIHZSZXBlYXQgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGNvZWZ1ID0gMCwgY29lZnYgPSAwO1xyXG4gICAgICAgIGxldCB1diA9IHNwcml0ZS5zcHJpdGVGcmFtZS51djtcclxuICAgICAgICBsZXQgdXZTbGljZWQgPSBzcHJpdGUuc3ByaXRlRnJhbWUudXZTbGljZWQ7XHJcbiAgICAgICAgbGV0IHJvdGF0ZWQgPSBzcHJpdGUuc3ByaXRlRnJhbWUuX3JvdGF0ZWQ7XHJcbiAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQsIHV2T2Zmc2V0ID0gdGhpcy51dk9mZnNldDtcclxuICAgICAgICBsZXQgdGVtcFhWZXJ0cyA9IFtdLCB0ZW1wWVZlcnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgeWluZGV4ID0gMCwgeWxlbmd0aCA9IHJvdzsgeWluZGV4IDwgeWxlbmd0aDsgKyt5aW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2l6YWJsZUhlaWdodCA+IGNlbnRlckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2l6YWJsZUhlaWdodCA+PSB5aW5kZXggKiBjZW50ZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2VmdiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2VmdiA9IHZSZXBlYXQgJSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29lZnYgPSB2UmVwZWF0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHhpbmRleCA9IDAsIHhsZW5ndGggPSBjb2w7IHhpbmRleCA8IHhsZW5ndGg7ICsreGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaXphYmxlV2lkdGggPiBjZW50ZXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpemFibGVXaWR0aCA+PSB4aW5kZXggKiBjZW50ZXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmdSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmdSA9IGhSZXBlYXQgJSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZ1ID0gaFJlcGVhdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocm90YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5aW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1swXSA9IHV2U2xpY2VkWzBdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMV0gPSB1dlNsaWNlZFswXS51O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzJdID0gdXZTbGljZWRbNF0udSArICh1dlNsaWNlZFs4XS51IC0gdXZTbGljZWRbNF0udSkgKiBjb2VmdjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHlpbmRleCA8IChyb3cgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzBdID0gdXZTbGljZWRbNF0udTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1sxXSA9IHV2U2xpY2VkWzRdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMl0gPSB1dlNsaWNlZFs0XS51ICsgKHV2U2xpY2VkWzhdLnUgLSB1dlNsaWNlZFs0XS51KSAqIGNvZWZ2O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeWluZGV4ID09PSAocm93IC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1swXSA9IHV2U2xpY2VkWzhdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMV0gPSB1dlNsaWNlZFs4XS51O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzJdID0gdXZTbGljZWRbMTJdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1swXSA9IHV2U2xpY2VkWzBdLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMV0gPSB1dlNsaWNlZFsxXS52ICsgKHV2U2xpY2VkWzJdLnYgLSB1dlNsaWNlZFsxXS52KSAqIGNvZWZ1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzJdID0gdXZTbGljZWRbMF0udjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhpbmRleCA8IChjb2wgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzBdID0gdXZTbGljZWRbMV0udjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1sxXSA9IHV2U2xpY2VkWzFdLnYgKyAodXZTbGljZWRbMl0udiAtIHV2U2xpY2VkWzFdLnYpICogY29lZnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMl0gPSB1dlNsaWNlZFsxXS52O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeGluZGV4ID09PSAoY29sIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1swXSA9IHV2U2xpY2VkWzJdLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMV0gPSB1dlNsaWNlZFszXS52O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzJdID0gdXZTbGljZWRbMl0udjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1szXSA9IHRlbXBYVmVydHNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1szXSA9IHRlbXBZVmVydHNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMF0gPSB1dlNsaWNlZFswXS51O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzFdID0gdXZTbGljZWRbMV0udSArICh1dlNsaWNlZFsyXS51IC0gdXZTbGljZWRbMV0udSkgKiBjb2VmdTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1syXSA9IHV2WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeGluZGV4IDwgKGNvbCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMF0gPSB1dlNsaWNlZFsxXS51O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzFdID0gdXZTbGljZWRbMV0udSArICh1dlNsaWNlZFsyXS51IC0gdXZTbGljZWRbMV0udSkgKiBjb2VmdTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1syXSA9IHV2U2xpY2VkWzFdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4aW5kZXggPT09IChjb2wgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzBdID0gdXZTbGljZWRbMl0udTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFhWZXJ0c1sxXSA9IHV2U2xpY2VkWzNdLnU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBYVmVydHNbMl0gPSB1dlNsaWNlZFsyXS51O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeWluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMF0gPSB1dlNsaWNlZFswXS52O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzFdID0gdXZTbGljZWRbMF0udjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1syXSA9IHV2U2xpY2VkWzRdLnYgKyAodXZTbGljZWRbOF0udiAtIHV2U2xpY2VkWzRdLnYpICogY29lZnY7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5aW5kZXggPCAocm93IC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1swXSA9IHV2U2xpY2VkWzRdLnY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMV0gPSB1dlNsaWNlZFs0XS52O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzJdID0gdXZTbGljZWRbNF0udiArICh1dlNsaWNlZFs4XS52IC0gdXZTbGljZWRbNF0udikgKiBjb2VmdjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHlpbmRleCA9PT0gKHJvdyAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBZVmVydHNbMF0gPSB1dlNsaWNlZFs4XS52O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzFdID0gdXZTbGljZWRbOF0udjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFlWZXJ0c1syXSA9IHV2U2xpY2VkWzEyXS52O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZW1wWFZlcnRzWzNdID0gdGVtcFhWZXJ0c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wWVZlcnRzWzNdID0gdGVtcFlWZXJ0c1syXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGxiXHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldF0gPSB0ZW1wWFZlcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXQgKyAxXSA9IHRlbXBZVmVydHNbMF07XHJcbiAgICAgICAgICAgICAgICB1dk9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAgICAgLy8gcmJcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0XSA9IHRlbXBYVmVydHNbMV07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldCArIDFdID0gdGVtcFlWZXJ0c1sxXTtcclxuICAgICAgICAgICAgICAgIHV2T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBsdFxyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXRdID0gdGVtcFhWZXJ0c1syXTtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3V2T2Zmc2V0ICsgMV0gPSB0ZW1wWVZlcnRzWzJdO1xyXG4gICAgICAgICAgICAgICAgdXZPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgICAgIC8vIHJ0XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t1dk9mZnNldF0gPSB0ZW1wWFZlcnRzWzNdO1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdXZPZmZzZXQgKyAxXSA9IHRlbXBZVmVydHNbM107XHJcbiAgICAgICAgICAgICAgICB1dk9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/res/ResSprite.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1e608kcfHNDl6sxF57wMNFE', 'ResSprite');
// scripts/common/cmpt/ui/res/ResSprite.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Res_1 = require("../../../util/Res");
var _a = cc._decorator, ccclass = _a.ccclass, menu = _a.menu, disallowMultiple = _a.disallowMultiple, requireComponent = _a.requireComponent;
/**
 * 精灵组件，自动管理资源的引用计数
 */
var ResSprite = /** @class */ (function (_super) {
    __extends(ResSprite, _super);
    function ResSprite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // 动态加载的资源
        _this._asset = null;
        _this._url = "";
        _this._atlasKey = "";
        _this._sprite = null;
        return _this;
    }
    Object.defineProperty(ResSprite.prototype, "sprite", {
        get: function () {
            if (!this._sprite) {
                this._sprite = this.getComponent(cc.Sprite);
            }
            return this._sprite;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResSprite.prototype, "spriteFrame", {
        get: function () {
            return this.sprite.spriteFrame;
        },
        set: function (v) {
            var _a;
            if (!this.isValid || this.sprite.spriteFrame === v) {
                return;
            }
            v === null || v === void 0 ? void 0 : v.addRef();
            (_a = this._asset) === null || _a === void 0 ? void 0 : _a.decRef();
            this._asset = v;
            this.sprite.spriteFrame = v;
        },
        enumerable: false,
        configurable: true
    });
    ResSprite.prototype.onDestroy = function () {
        var _a;
        (_a = this._asset) === null || _a === void 0 ? void 0 : _a.decRef();
    };
    /**
     * 加载并设置spriteFrame
     * @param url 图片或图集路径，规则同Res加载路径
     * @param key 如果需要加载的url为图集时，需传入图集的key
     */
    ResSprite.prototype.setSpriteFrame = function (url, key) {
        if (key === void 0) { key = ""; }
        return __awaiter(this, void 0, Promise, function () {
            var type, result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this._url = url;
                        this._atlasKey = key;
                        type = key ? cc.SpriteAtlas : cc.SpriteFrame;
                        _a = Res_1.default.get(url, type);
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, Res_1.default.load(url, type)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        result = _a;
                        // 如短时间内多次调用，需保证显示最新一次加载的资源
                        if (result instanceof type && this._url === url && this._atlasKey === key) {
                            this.spriteFrame = result instanceof cc.SpriteAtlas ? result.getSpriteFrame(key) : result;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ResSprite = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(cc.Sprite),
        menu("Framework/UI组件/ResSprite")
    ], ResSprite);
    return ResSprite;
}(cc.Component));
exports.default = ResSprite;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxccmVzXFxSZXNTcHJpdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQW9DO0FBRTlCLElBQUEsS0FBd0QsRUFBRSxDQUFDLFVBQVUsRUFBbkUsT0FBTyxhQUFBLEVBQUUsSUFBSSxVQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsZ0JBQWdCLHNCQUFrQixDQUFDO0FBRTVFOztHQUVHO0FBS0g7SUFBdUMsNkJBQVk7SUFBbkQ7UUFBQSxxRUErQ0M7UUE5Q0csVUFBVTtRQUNGLFlBQU0sR0FBb0MsSUFBSSxDQUFDO1FBRS9DLFVBQUksR0FBVyxFQUFFLENBQUM7UUFDbEIsZUFBUyxHQUFXLEVBQUUsQ0FBQztRQUV2QixhQUFPLEdBQWMsSUFBSSxDQUFDOztJQXdDdEMsQ0FBQztJQXZDRyxzQkFBWSw2QkFBTTthQUFsQjtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDL0M7WUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDeEIsQ0FBQzs7O09BQUE7SUFFRCxzQkFBVyxrQ0FBVzthQUF0QjtZQUNJLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFDbkMsQ0FBQzthQUNELFVBQXVCLENBQWlCOztZQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7Z0JBQ2hELE9BQU87YUFDVjtZQUNELENBQUMsYUFBRCxDQUFDLHVCQUFELENBQUMsQ0FBRSxNQUFNLEdBQUc7WUFDWixNQUFBLElBQUksQ0FBQyxNQUFNLDBDQUFFLE1BQU0sR0FBRztZQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDaEMsQ0FBQzs7O09BVEE7SUFXUyw2QkFBUyxHQUFuQjs7UUFDSSxNQUFBLElBQUksQ0FBQyxNQUFNLDBDQUFFLE1BQU0sR0FBRztJQUMxQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNVLGtDQUFjLEdBQTNCLFVBQTRCLEdBQVcsRUFBRSxHQUFnQjtRQUFoQixvQkFBQSxFQUFBLFFBQWdCO3VDQUFHLE9BQU87Ozs7O3dCQUMvRCxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQzt3QkFDaEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUM7d0JBQ2pCLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7d0JBQ3BDLEtBQUEsYUFBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUE7Z0NBQWxCLHdCQUFrQjt3QkFBSSxxQkFBTSxhQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBQTs7OEJBQXpCLFNBQXlCOzs7d0JBQXhELE1BQU0sS0FBa0Q7d0JBQzVELDJCQUEyQjt3QkFDM0IsSUFBSSxNQUFNLFlBQVksSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssR0FBRyxFQUFFOzRCQUN2RSxJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7eUJBQzdGOzs7OztLQUNKO0lBOUNnQixTQUFTO1FBSjdCLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUMzQixJQUFJLENBQUMsMEJBQTBCLENBQUM7T0FDWixTQUFTLENBK0M3QjtJQUFELGdCQUFDO0NBL0NELEFBK0NDLENBL0NzQyxFQUFFLENBQUMsU0FBUyxHQStDbEQ7a0JBL0NvQixTQUFTIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlcyBmcm9tIFwiLi4vLi4vLi4vdXRpbC9SZXNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgbWVudSwgZGlzYWxsb3dNdWx0aXBsZSwgcmVxdWlyZUNvbXBvbmVudCB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiDnsr7ngbXnu4Tku7bvvIzoh6rliqjnrqHnkIbotYTmupDnmoTlvJXnlKjorqHmlbBcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkByZXF1aXJlQ29tcG9uZW50KGNjLlNwcml0ZSlcclxuQG1lbnUoXCJGcmFtZXdvcmsvVUnnu4Tku7YvUmVzU3ByaXRlXCIpXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc1Nwcml0ZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICAvLyDliqjmgIHliqDovb3nmoTotYTmupBcclxuICAgIHByaXZhdGUgX2Fzc2V0OiBjYy5TcHJpdGVGcmFtZSB8IGNjLlNwcml0ZUF0bGFzID0gbnVsbDtcclxuXHJcbiAgICBwcml2YXRlIF91cmw6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIF9hdGxhc0tleTogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICBwcml2YXRlIF9zcHJpdGU6IGNjLlNwcml0ZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIGdldCBzcHJpdGUoKTogY2MuU3ByaXRlIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Nwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSB0aGlzLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgc3ByaXRlRnJhbWUoKTogY2MuU3ByaXRlRnJhbWUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZS5zcHJpdGVGcmFtZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaXRlRnJhbWUodjogY2MuU3ByaXRlRnJhbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCB0aGlzLnNwcml0ZS5zcHJpdGVGcmFtZSA9PT0gdikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHY/LmFkZFJlZigpO1xyXG4gICAgICAgIHRoaXMuX2Fzc2V0Py5kZWNSZWYoKTtcclxuICAgICAgICB0aGlzLl9hc3NldCA9IHY7XHJcbiAgICAgICAgdGhpcy5zcHJpdGUuc3ByaXRlRnJhbWUgPSB2O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fYXNzZXQ/LmRlY1JlZigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L295bm26K6+572uc3ByaXRlRnJhbWVcclxuICAgICAqIEBwYXJhbSB1cmwg5Zu+54mH5oiW5Zu+6ZuG6Lev5b6E77yM6KeE5YiZ5ZCMUmVz5Yqg6L296Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ga2V5IOWmguaenOmcgOimgeWKoOi9veeahHVybOS4uuWbvumbhuaXtu+8jOmcgOS8oOWFpeWbvumbhueahGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2V0U3ByaXRlRnJhbWUodXJsOiBzdHJpbmcsIGtleTogc3RyaW5nID0gXCJcIik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcclxuICAgICAgICB0aGlzLl9hdGxhc0tleSA9IGtleTtcclxuICAgICAgICBsZXQgdHlwZSA9IGtleSA/IGNjLlNwcml0ZUF0bGFzIDogY2MuU3ByaXRlRnJhbWU7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJlcy5nZXQodXJsLCB0eXBlKSB8fCBhd2FpdCBSZXMubG9hZCh1cmwsIHR5cGUpO1xyXG4gICAgICAgIC8vIOWmguefreaXtumXtOWGheWkmuasoeiwg+eUqO+8jOmcgOS/neivgeaYvuekuuacgOaWsOS4gOasoeWKoOi9veeahOi1hOa6kFxyXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiB0eXBlICYmIHRoaXMuX3VybCA9PT0gdXJsICYmIHRoaXMuX2F0bGFzS2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVGcmFtZSA9IHJlc3VsdCBpbnN0YW5jZW9mIGNjLlNwcml0ZUF0bGFzID8gcmVzdWx0LmdldFNwcml0ZUZyYW1lKGtleSkgOiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/multiTexture/assembler/MultiAssembler.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ac3d4pn45pPbIIUTWTJWqn4', 'MultiAssembler');
// scripts/common/cmpt/ui/multiTexture/assembler/MultiAssembler.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var gfx = cc["gfx"];
var vfmtPosUvColorIndex = new gfx.VertexFormat([
    { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
    { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
    { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_UINT8, num: 4, normalize: true },
    { name: "a_texture_idx", type: gfx.ATTR_TYPE_FLOAT32, num: 1 },
]);
var MultiAssembler = /** @class */ (function (_super) {
    __extends(MultiAssembler, _super);
    function MultiAssembler() {
        var _this = _super.call(this) || this;
        /** 每个顶点的数据长度 */
        _this.floatsPerVert = 6;
        _this.verticesCount = 4;
        _this.indicesCount = 6;
        _this.uvOffset = 2;
        _this.colorOffset = 4;
        _this.textureIdxOffset = 5;
        _this._renderData = null;
        _this._local = [];
        _this._renderData = new cc["RenderData"]();
        _this._renderData.init(_this);
        _this.initData();
        _this.initLocal();
        return _this;
    }
    Object.defineProperty(MultiAssembler.prototype, "verticesFloats", {
        get: function () {
            return this.verticesCount * this.floatsPerVert;
        },
        enumerable: false,
        configurable: true
    });
    MultiAssembler.prototype.initData = function () {
        var data = this._renderData;
        // createFlexData支持创建指定格式的renderData
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        // createFlexData不会填充顶点索引信息，手动补充一下
        var indices = data.iDatas[0];
        var count = indices.length / 6;
        for (var i = 0, idx = 0; i < count; i++) {
            var vertextID = i * 4;
            indices[idx++] = vertextID;
            indices[idx++] = vertextID + 1;
            indices[idx++] = vertextID + 2;
            indices[idx++] = vertextID + 1;
            indices[idx++] = vertextID + 3;
            indices[idx++] = vertextID + 2;
        }
    };
    MultiAssembler.prototype.initLocal = function () {
        this._local = [];
        this._local.length = 4;
    };
    MultiAssembler.prototype.getBuffer = function (v) {
        return cc.renderer["_handle"].getBuffer("mesh", this.getVfmt());
    };
    MultiAssembler.prototype.getVfmt = function () {
        return vfmtPosUvColorIndex;
    };
    MultiAssembler.prototype.updateColor = function (comp, color) {
        if (CC_NATIVERENDERER) {
            this["_dirtyPtr"][0] |= cc.Assembler["FLAG_VERTICES_OPACITY_CHANGED"];
        }
        var uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts)
            return;
        color = color != null ? color : comp.node.color._val;
        var floatsPerVert = this.floatsPerVert;
        var colorOffset = this.colorOffset;
        for (var i = colorOffset, l = uintVerts.length; i < l; i += floatsPerVert) {
            uintVerts[i] = color;
        }
    };
    MultiAssembler.prototype.updateTextureIdx = function (sprite) {
        var verts = this._renderData.vDatas[0];
        for (var i = 0; i < this.verticesCount; i++) {
            var dstOffset = this.floatsPerVert * i + this.textureIdxOffset;
            verts[dstOffset] = sprite.textureIdx;
        }
    };
    MultiAssembler.prototype.updateWorldVerts = function (comp) {
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var matrix = comp.node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var floatsPerVert = this.floatsPerVert;
        var vertexOffset = 0;
        var justTranslate = a === 1 && b === 0 && c === 0 && d === 1;
        if (CC_NATIVERENDERER) {
            // left bottom
            verts[vertexOffset] = vl;
            verts[vertexOffset + 1] = vb;
            vertexOffset += floatsPerVert;
            // right bottom
            verts[vertexOffset] = vr;
            verts[vertexOffset + 1] = vb;
            vertexOffset += floatsPerVert;
            // left top
            verts[vertexOffset] = vl;
            verts[vertexOffset + 1] = vt;
            vertexOffset += floatsPerVert;
            // right top
            verts[vertexOffset] = vr;
            verts[vertexOffset + 1] = vt;
        }
        else {
            if (justTranslate) {
                // left bottom
                verts[vertexOffset] = vl + tx;
                verts[vertexOffset + 1] = vb + ty;
                vertexOffset += floatsPerVert;
                // right bottom
                verts[vertexOffset] = vr + tx;
                verts[vertexOffset + 1] = vb + ty;
                vertexOffset += floatsPerVert;
                // left top
                verts[vertexOffset] = vl + tx;
                verts[vertexOffset + 1] = vt + ty;
                vertexOffset += floatsPerVert;
                // right top
                verts[vertexOffset] = vr + tx;
                verts[vertexOffset + 1] = vt + ty;
            }
            else {
                var al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
                // left bottom
                verts[vertexOffset] = al + cb + tx;
                verts[vertexOffset + 1] = bl + db + ty;
                vertexOffset += floatsPerVert;
                // right bottom
                verts[vertexOffset] = ar + cb + tx;
                verts[vertexOffset + 1] = br + db + ty;
                vertexOffset += floatsPerVert;
                // left top
                verts[vertexOffset] = al + ct + tx;
                verts[vertexOffset + 1] = bl + dt + ty;
                vertexOffset += floatsPerVert;
                // right top
                verts[vertexOffset] = ar + ct + tx;
                verts[vertexOffset + 1] = br + dt + ty;
            }
        }
    };
    MultiAssembler.prototype.fillBuffers = function (comp, renderer) {
        if (renderer.worldMatDirty) {
            this.updateWorldVerts(comp);
        }
        var renderData = this._renderData;
        var vData = renderData.vDatas[0];
        var iData = renderData.iDatas[0];
        var buffer = this.getBuffer(renderer);
        var offsetInfo = buffer.request(this.verticesCount, this.indicesCount);
        // buffer data may be realloc, need get reference after request.
        // fill vertices
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        if (vData.length + vertexOffset > vbuf.length) {
            vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset);
        }
        else {
            vbuf.set(vData, vertexOffset);
        }
        // fill indices
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = iData.length; i < l; i++) {
            ibuf[indiceOffset++] = vertexId + iData[i];
        }
    };
    MultiAssembler.prototype.packToDynamicAtlas = function (comp, frame) {
        if (CC_TEST)
            return;
        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {
            var packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
            if (packedFrame) {
                frame._setDynamicAtlasFrame(packedFrame);
            }
        }
        var material = comp._materials[0];
        if (!material)
            return;
        if (material.getProperty("texture") !== frame._texture._texture) {
            // texture was packed to dynamic atlas, should update uvs
            comp._vertsDirty = true;
            comp._updateMaterial();
        }
    };
    return MultiAssembler;
}(cc.Assembler));
exports.default = MultiAssembler;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcbXVsdGlUZXh0dXJlXFxhc3NlbWJsZXJcXE11bHRpQXNzZW1ibGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0QixJQUFNLG1CQUFtQixHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksQ0FBQztJQUM3QyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsYUFBYSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRTtJQUNoRSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsaUJBQWlCLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRTtJQUMzRCxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRTtJQUM1RSxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO0NBQ2pFLENBQUMsQ0FBQztBQUVIO0lBQTRDLGtDQUFZO0lBZ0JwRDtRQUFBLFlBQ0ksaUJBQU8sU0FPVjtRQXZCRCxnQkFBZ0I7UUFDTixtQkFBYSxHQUFXLENBQUMsQ0FBQztRQUMxQixtQkFBYSxHQUFXLENBQUMsQ0FBQztRQUMxQixrQkFBWSxHQUFXLENBQUMsQ0FBQztRQUN6QixjQUFRLEdBQVcsQ0FBQyxDQUFDO1FBQ3JCLGlCQUFXLEdBQVcsQ0FBQyxDQUFDO1FBQ3hCLHNCQUFnQixHQUFXLENBQUMsQ0FBQztRQUU3QixpQkFBVyxHQUFHLElBQUksQ0FBQztRQUNuQixZ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UUFBUSxFQUFFO1lBQ3ZFLElBQUksV0FBVyxHQUFRLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2RSxJQUFJLFdBQVcsRUFBRTtnQkFDYixLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDNUM7U0FDSjtRQUNELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVE7WUFBRSxPQUFPO1FBRXRCLElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsS0FBSyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRTtZQUM3RCx5REFBeUQ7WUFDekQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDeEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1NBQzFCO0lBQ0wsQ0FBQztJQUNMLHFCQUFDO0FBQUQsQ0E5TUEsQUE4TUMsQ0E5TTJDLEVBQUUsQ0FBQyxTQUFTLEdBOE12RCIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdmeCA9IGNjW1wiZ2Z4XCJdO1xyXG5jb25zdCB2Zm10UG9zVXZDb2xvckluZGV4ID0gbmV3IGdmeC5WZXJ0ZXhGb3JtYXQoW1xyXG4gICAgeyBuYW1lOiBnZnguQVRUUl9QT1NJVElPTiwgdHlwZTogZ2Z4LkFUVFJfVFlQRV9GTE9BVDMyLCBudW06IDIgfSxcclxuICAgIHsgbmFtZTogZ2Z4LkFUVFJfVVYwLCB0eXBlOiBnZnguQVRUUl9UWVBFX0ZMT0FUMzIsIG51bTogMiB9LFxyXG4gICAgeyBuYW1lOiBnZnguQVRUUl9DT0xPUiwgdHlwZTogZ2Z4LkFUVFJfVFlQRV9VSU5UOCwgbnVtOiA0LCBub3JtYWxpemU6IHRydWUgfSxcclxuICAgIHsgbmFtZTogXCJhX3RleHR1cmVfaWR4XCIsIHR5cGU6IGdmeC5BVFRSX1RZUEVfRkxPQVQzMiwgbnVtOiAxIH0sXHJcbl0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXVsdGlBc3NlbWJsZXIgZXh0ZW5kcyBjYy5Bc3NlbWJsZXIge1xyXG4gICAgLyoqIOavj+S4qumhtueCueeahOaVsOaNrumVv+W6piAqL1xyXG4gICAgcHJvdGVjdGVkIGZsb2F0c1BlclZlcnQ6IG51bWJlciA9IDY7XHJcbiAgICBwcm90ZWN0ZWQgdmVydGljZXNDb3VudDogbnVtYmVyID0gNDtcclxuICAgIHByb3RlY3RlZCBpbmRpY2VzQ291bnQ6IG51bWJlciA9IDY7XHJcbiAgICBwcm90ZWN0ZWQgdXZPZmZzZXQ6IG51bWJlciA9IDI7XHJcbiAgICBwcm90ZWN0ZWQgY29sb3JPZmZzZXQ6IG51bWJlciA9IDQ7XHJcbiAgICBwcm90ZWN0ZWQgdGV4dHVyZUlkeE9mZnNldDogbnVtYmVyID0gNTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX3JlbmRlckRhdGEgPSBudWxsO1xyXG4gICAgcHJvdGVjdGVkIF9sb2NhbCA9IFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCBnZXQgdmVydGljZXNGbG9hdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNDb3VudCAqIHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLl9yZW5kZXJEYXRhID0gbmV3IGNjW1wiUmVuZGVyRGF0YVwiXSgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckRhdGEuaW5pdCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0RGF0YSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdExvY2FsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluaXREYXRhKCkge1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fcmVuZGVyRGF0YTtcclxuICAgICAgICAvLyBjcmVhdGVGbGV4RGF0YeaUr+aMgeWIm+W7uuaMh+WumuagvOW8j+eahHJlbmRlckRhdGFcclxuICAgICAgICBkYXRhLmNyZWF0ZUZsZXhEYXRhKDAsIHRoaXMudmVydGljZXNDb3VudCwgdGhpcy5pbmRpY2VzQ291bnQsIHRoaXMuZ2V0VmZtdCgpKTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlRmxleERhdGHkuI3kvJrloavlhYXpobbngrnntKLlvJXkv6Hmga/vvIzmiYvliqjooaXlhYXkuIDkuItcclxuICAgICAgICBsZXQgaW5kaWNlcyA9IGRhdGEuaURhdGFzWzBdO1xyXG4gICAgICAgIGxldCBjb3VudCA9IGluZGljZXMubGVuZ3RoIC8gNjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWR4ID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHZlcnRleHRJRCA9IGkgKiA0O1xyXG4gICAgICAgICAgICBpbmRpY2VzW2lkeCsrXSA9IHZlcnRleHRJRDtcclxuICAgICAgICAgICAgaW5kaWNlc1tpZHgrK10gPSB2ZXJ0ZXh0SUQgKyAxO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2lkeCsrXSA9IHZlcnRleHRJRCArIDI7XHJcbiAgICAgICAgICAgIGluZGljZXNbaWR4KytdID0gdmVydGV4dElEICsgMTtcclxuICAgICAgICAgICAgaW5kaWNlc1tpZHgrK10gPSB2ZXJ0ZXh0SUQgKyAzO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2lkeCsrXSA9IHZlcnRleHRJRCArIDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbml0TG9jYWwoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWwgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2NhbC5sZW5ndGggPSA0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCdWZmZXIodikge1xyXG4gICAgICAgIHJldHVybiBjYy5yZW5kZXJlcltcIl9oYW5kbGVcIl0uZ2V0QnVmZmVyKFwibWVzaFwiLCB0aGlzLmdldFZmbXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFZmbXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZmbXRQb3NVdkNvbG9ySW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZUNvbG9yKGNvbXAsIGNvbG9yPykge1xyXG4gICAgICAgIGlmIChDQ19OQVRJVkVSRU5ERVJFUikge1xyXG4gICAgICAgICAgICB0aGlzW1wiX2RpcnR5UHRyXCJdWzBdIHw9IGNjLkFzc2VtYmxlcltcIkZMQUdfVkVSVElDRVNfT1BBQ0lUWV9DSEFOR0VEXCJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdWludFZlcnRzID0gdGhpcy5fcmVuZGVyRGF0YS51aW50VkRhdGFzWzBdO1xyXG4gICAgICAgIGlmICghdWludFZlcnRzKSByZXR1cm47XHJcbiAgICAgICAgY29sb3IgPSBjb2xvciAhPSBudWxsID8gY29sb3IgOiBjb21wLm5vZGUuY29sb3IuX3ZhbDtcclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICBsZXQgY29sb3JPZmZzZXQgPSB0aGlzLmNvbG9yT2Zmc2V0O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjb2xvck9mZnNldCwgbCA9IHVpbnRWZXJ0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGZsb2F0c1BlclZlcnQpIHtcclxuICAgICAgICAgICAgdWludFZlcnRzW2ldID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVUZXh0dXJlSWR4KHNwcml0ZSkge1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBkc3RPZmZzZXQgPSB0aGlzLmZsb2F0c1BlclZlcnQgKiBpICsgdGhpcy50ZXh0dXJlSWR4T2Zmc2V0O1xyXG4gICAgICAgICAgICB2ZXJ0c1tkc3RPZmZzZXRdID0gc3ByaXRlLnRleHR1cmVJZHg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVXb3JsZFZlcnRzKGNvbXApIHtcclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcclxuICAgICAgICBsZXQgdmVydHMgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcclxuXHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IGNvbXAubm9kZS5fd29ybGRNYXRyaXg7XHJcbiAgICAgICAgbGV0IG1hdHJpeG0gPSBtYXRyaXgubSxcclxuICAgICAgICAgICAgYSA9IG1hdHJpeG1bMF0sIGIgPSBtYXRyaXhtWzFdLCBjID0gbWF0cml4bVs0XSwgZCA9IG1hdHJpeG1bNV0sXHJcbiAgICAgICAgICAgIHR4ID0gbWF0cml4bVsxMl0sIHR5ID0gbWF0cml4bVsxM107XHJcblxyXG4gICAgICAgIGxldCB2bCA9IGxvY2FsWzBdLCB2ciA9IGxvY2FsWzJdLFxyXG4gICAgICAgICAgICB2YiA9IGxvY2FsWzFdLCB2dCA9IGxvY2FsWzNdO1xyXG5cclxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcclxuICAgICAgICBsZXQgdmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQganVzdFRyYW5zbGF0ZSA9IGEgPT09IDEgJiYgYiA9PT0gMCAmJiBjID09PSAwICYmIGQgPT09IDE7XHJcblxyXG4gICAgICAgIGlmIChDQ19OQVRJVkVSRU5ERVJFUikge1xyXG4gICAgICAgICAgICAvLyBsZWZ0IGJvdHRvbVxyXG4gICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXRdID0gdmw7XHJcbiAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldCArIDFdID0gdmI7XHJcbiAgICAgICAgICAgIHZlcnRleE9mZnNldCArPSBmbG9hdHNQZXJWZXJ0O1xyXG4gICAgICAgICAgICAvLyByaWdodCBib3R0b21cclxuICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IHZyO1xyXG4gICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHZiO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgLy8gbGVmdCB0b3BcclxuICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IHZsO1xyXG4gICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHZ0O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgLy8gcmlnaHQgdG9wXHJcbiAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldF0gPSB2cjtcclxuICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0ICsgMV0gPSB2dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoanVzdFRyYW5zbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbGVmdCBib3R0b21cclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldF0gPSB2bCArIHR4O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0ICsgMV0gPSB2YiArIHR5O1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyByaWdodCBib3R0b21cclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldF0gPSB2ciArIHR4O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0ICsgMV0gPSB2YiArIHR5O1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcFxyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IHZsICsgdHg7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHZ0ICsgdHk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IHRvcFxyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IHZyICsgdHg7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXQgKyAxXSA9IHZ0ICsgdHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWwgPSBhICogdmwsIGFyID0gYSAqIHZyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsID0gYiAqIHZsLCBiciA9IGIgKiB2cixcclxuICAgICAgICAgICAgICAgICAgICBjYiA9IGMgKiB2YiwgY3QgPSBjICogdnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGIgPSBkICogdmIsIGR0ID0gZCAqIHZ0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGxlZnQgYm90dG9tXHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXRdID0gYWwgKyBjYiArIHR4O1xyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0ICsgMV0gPSBibCArIGRiICsgdHk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQgKz0gZmxvYXRzUGVyVmVydDtcclxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IGFyICsgY2IgKyB0eDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldCArIDFdID0gYnIgKyBkYiArIHR5O1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IHRvcFxyXG4gICAgICAgICAgICAgICAgdmVydHNbdmVydGV4T2Zmc2V0XSA9IGFsICsgY3QgKyB0eDtcclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldCArIDFdID0gYmwgKyBkdCArIHR5O1xyXG4gICAgICAgICAgICAgICAgdmVydGV4T2Zmc2V0ICs9IGZsb2F0c1BlclZlcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyByaWdodCB0b3BcclxuICAgICAgICAgICAgICAgIHZlcnRzW3ZlcnRleE9mZnNldF0gPSBhciArIGN0ICsgdHg7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0c1t2ZXJ0ZXhPZmZzZXQgKyAxXSA9IGJyICsgZHQgKyB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZmlsbEJ1ZmZlcnMoY29tcCwgcmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAocmVuZGVyZXIud29ybGRNYXREaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVmVydHMoY29tcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVuZGVyRGF0YSA9IHRoaXMuX3JlbmRlckRhdGE7XHJcbiAgICAgICAgbGV0IHZEYXRhID0gcmVuZGVyRGF0YS52RGF0YXNbMF07XHJcbiAgICAgICAgbGV0IGlEYXRhID0gcmVuZGVyRGF0YS5pRGF0YXNbMF07XHJcblxyXG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihyZW5kZXJlcik7XHJcbiAgICAgICAgbGV0IG9mZnNldEluZm8gPSBidWZmZXIucmVxdWVzdCh0aGlzLnZlcnRpY2VzQ291bnQsIHRoaXMuaW5kaWNlc0NvdW50KTtcclxuXHJcbiAgICAgICAgLy8gYnVmZmVyIGRhdGEgbWF5IGJlIHJlYWxsb2MsIG5lZWQgZ2V0IHJlZmVyZW5jZSBhZnRlciByZXF1ZXN0LlxyXG5cclxuICAgICAgICAvLyBmaWxsIHZlcnRpY2VzXHJcbiAgICAgICAgbGV0IHZlcnRleE9mZnNldCA9IG9mZnNldEluZm8uYnl0ZU9mZnNldCA+PiAyLFxyXG4gICAgICAgICAgICB2YnVmID0gYnVmZmVyLl92RGF0YTtcclxuXHJcbiAgICAgICAgaWYgKHZEYXRhLmxlbmd0aCArIHZlcnRleE9mZnNldCA+IHZidWYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZidWYuc2V0KHZEYXRhLnN1YmFycmF5KDAsIHZidWYubGVuZ3RoIC0gdmVydGV4T2Zmc2V0KSwgdmVydGV4T2Zmc2V0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YnVmLnNldCh2RGF0YSwgdmVydGV4T2Zmc2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbGwgaW5kaWNlc1xyXG4gICAgICAgIGxldCBpYnVmID0gYnVmZmVyLl9pRGF0YSxcclxuICAgICAgICAgICAgaW5kaWNlT2Zmc2V0ID0gb2Zmc2V0SW5mby5pbmRpY2VPZmZzZXQsXHJcbiAgICAgICAgICAgIHZlcnRleElkID0gb2Zmc2V0SW5mby52ZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpRGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWJ1ZltpbmRpY2VPZmZzZXQrK10gPSB2ZXJ0ZXhJZCArIGlEYXRhW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcGFja1RvRHluYW1pY0F0bGFzKGNvbXAsIGZyYW1lKSB7XHJcbiAgICAgICAgaWYgKENDX1RFU1QpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFmcmFtZS5fb3JpZ2luYWwgJiYgY2MuZHluYW1pY0F0bGFzTWFuYWdlciAmJiBmcmFtZS5fdGV4dHVyZS5wYWNrYWJsZSkge1xyXG4gICAgICAgICAgICBsZXQgcGFja2VkRnJhbWU6IGFueSA9IGNjLmR5bmFtaWNBdGxhc01hbmFnZXIuaW5zZXJ0U3ByaXRlRnJhbWUoZnJhbWUpO1xyXG4gICAgICAgICAgICBpZiAocGFja2VkRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGZyYW1lLl9zZXREeW5hbWljQXRsYXNGcmFtZShwYWNrZWRGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hdGVyaWFsID0gY29tcC5fbWF0ZXJpYWxzWzBdO1xyXG4gICAgICAgIGlmICghbWF0ZXJpYWwpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKG1hdGVyaWFsLmdldFByb3BlcnR5KFwidGV4dHVyZVwiKSAhPT0gZnJhbWUuX3RleHR1cmUuX3RleHR1cmUpIHtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZSB3YXMgcGFja2VkIHRvIGR5bmFtaWMgYXRsYXMsIHNob3VsZCB1cGRhdGUgdXZzXHJcbiAgICAgICAgICAgIGNvbXAuX3ZlcnRzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb21wLl91cGRhdGVNYXRlcmlhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/scrollList/VirtualList.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '8815fg/3FJEjohj/PrC9n21', 'VirtualList');
// scripts/common/cmpt/ui/scrollList/VirtualList.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OtherLayoutData = exports.MainLayoutData = exports.OtherTemplateType = exports.MainTemplateType = void 0;
var EditorTool_1 = require("../../../util/EditorTool");
var Tool_1 = require("../../../util/Tool");
var VirtualLayout_1 = require("./VirtualLayout");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, executeInEditMode = _a.executeInEditMode, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/** 主元素模板类型 */
var MainTemplateType;
(function (MainTemplateType) {
    MainTemplateType[MainTemplateType["NODE"] = 0] = "NODE";
    MainTemplateType[MainTemplateType["PREFAB"] = 1] = "PREFAB";
})(MainTemplateType = exports.MainTemplateType || (exports.MainTemplateType = {}));
/** 副元素模板类型 */
var OtherTemplateType;
(function (OtherTemplateType) {
    OtherTemplateType[OtherTemplateType["NODE"] = 0] = "NODE";
    OtherTemplateType[OtherTemplateType["PREFAB"] = 1] = "PREFAB";
    OtherTemplateType[OtherTemplateType["MAIN_ITEM_CHILD"] = 2] = "MAIN_ITEM_CHILD";
})(OtherTemplateType = exports.OtherTemplateType || (exports.OtherTemplateType = {}));
/**
 * 虚拟列表主容器
 */
var MainLayoutData = /** @class */ (function () {
    function MainLayoutData() {
        this.content = null;
        this._templateType = MainTemplateType.PREFAB;
        this._templatePrefab = null;
        this._templateNode = null;
        this.editorCall = null;
    }
    Object.defineProperty(MainLayoutData.prototype, "templateType", {
        get: function () { return this._templateType; },
        set: function (v) {
            if (this._templateType === v) {
                return;
            }
            this._templateType = v;
            this.resetMainItemChild(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MainLayoutData.prototype, "templatePrefab", {
        get: function () { return this._templatePrefab; },
        set: function (v) {
            if (this._templatePrefab === v) {
                return;
            }
            this._templatePrefab = v;
            this.resetMainItemChild(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MainLayoutData.prototype, "templateNode", {
        get: function () { return this._templateNode; },
        set: function (v) {
            if (this._templateNode === v) {
                return;
            }
            this._templateNode = v;
            this.resetMainItemChild(true);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 更新枚举内容
     * @param refresh 是否强制刷新inspector
     * @returns
     */
    MainLayoutData.prototype.resetMainItemChild = function (refresh) {
        var _a;
        if (refresh === void 0) { refresh = false; }
        if (!CC_EDITOR) {
            return;
        }
        var mainItemChild = {};
        if (this.templateType === MainTemplateType.NODE && this.templateNode) {
            this.templateNode.children.forEach(function (c, i) { mainItemChild[c.name] = i; });
        }
        else if (this.templateType === MainTemplateType.PREFAB && this.templatePrefab) {
            this.templatePrefab.data.children.forEach(function (c, i) { mainItemChild[c.name] = i; });
        }
        (_a = this.editorCall) === null || _a === void 0 ? void 0 : _a.call(this, mainItemChild, refresh);
    };
    __decorate([
        property({
            type: cc.Node,
            tooltip: CC_DEV && "列表容器节点",
            visible: function () { return false; }
        })
    ], MainLayoutData.prototype, "content", void 0);
    __decorate([
        property({ type: cc.Enum(MainTemplateType) })
    ], MainLayoutData.prototype, "_templateType", void 0);
    __decorate([
        property({
            type: cc.Enum(MainTemplateType),
            tooltip: CC_DEV && "列表元素模板类型"
        })
    ], MainLayoutData.prototype, "templateType", null);
    __decorate([
        property(cc.Prefab)
    ], MainLayoutData.prototype, "_templatePrefab", void 0);
    __decorate([
        property({
            type: cc.Prefab,
            tooltip: CC_DEV && "列表元素模板预制体",
            visible: function () { return this.templateType === MainTemplateType.PREFAB; }
        })
    ], MainLayoutData.prototype, "templatePrefab", null);
    __decorate([
        property(cc.Node)
    ], MainLayoutData.prototype, "_templateNode", void 0);
    __decorate([
        property({
            type: cc.Node,
            tooltip: CC_DEV && "列表元素模板节点",
            visible: function () { return this.templateType === MainTemplateType.NODE; }
        })
    ], MainLayoutData.prototype, "templateNode", null);
    MainLayoutData = __decorate([
        ccclass("MainLayoutData")
    ], MainLayoutData);
    return MainLayoutData;
}());
exports.MainLayoutData = MainLayoutData;
/**
 * 虚拟列表副容器
 */
var OtherLayoutData = /** @class */ (function () {
    function OtherLayoutData() {
        this.content = null;
        this.templateType = OtherTemplateType.PREFAB;
        this.templatePrefab = null;
        this.templateNode = null;
        this.templateChild = -1;
    }
    __decorate([
        property({
            type: cc.Node,
            tooltip: CC_DEV && "列表容器节点",
        })
    ], OtherLayoutData.prototype, "content", void 0);
    __decorate([
        property({
            type: cc.Enum(OtherTemplateType),
            tooltip: CC_DEV && "列表元素模板类型"
        })
    ], OtherLayoutData.prototype, "templateType", void 0);
    __decorate([
        property({
            type: cc.Prefab,
            tooltip: CC_DEV && "列表元素模板预制体",
            visible: function () { return this.templateType === OtherTemplateType.PREFAB; }
        })
    ], OtherLayoutData.prototype, "templatePrefab", void 0);
    __decorate([
        property({
            type: cc.Node,
            tooltip: CC_DEV && "列表元素模板节点",
            visible: function () { return this.templateType === OtherTemplateType.NODE; }
        })
    ], OtherLayoutData.prototype, "templateNode", void 0);
    __decorate([
        property({
            type: cc.Enum({}),
            tooltip: CC_DEV && "以列表主元素的子节点作为模板节点",
            visible: function () { return this.templateType === OtherTemplateType.MAIN_ITEM_CHILD; }
        })
    ], OtherLayoutData.prototype, "templateChild", void 0);
    OtherLayoutData = __decorate([
        ccclass("OtherLayoutData")
    ], OtherLayoutData);
    return OtherLayoutData;
}());
exports.OtherLayoutData = OtherLayoutData;
/**
 * 虚拟列表
 */
var VirtualList = /** @class */ (function (_super) {
    __extends(VirtualList, _super);
    function VirtualList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.main = new MainLayoutData();
        _this.others = [];
        _this.isFixedSize = true;
        _this._scrollView = null;
        _this._layout = null;
        _this._argsArr = [];
        _this._calcItemSize = null;
        return _this;
    }
    Object.defineProperty(VirtualList.prototype, "scrollView", {
        get: function () {
            if (!this._scrollView) {
                this._scrollView = this.getComponent(cc.ScrollView);
            }
            return this._scrollView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VirtualList.prototype, "layout", {
        get: function () {
            if (!this._layout) {
                this._layout = this.scrollView.content.getComponent(VirtualLayout_1.default);
            }
            return this._layout;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VirtualList.prototype, "argsArr", {
        /** 列表缓存的所有数据 */
        get: function () { return this._argsArr; },
        set: function (v) {
            this._argsArr = v;
            this.layout.rearrange();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VirtualList.prototype, "calcItemSize", {
        /** 根据参数计算元素大小的接口（isFixedSize为false时必须提供） */
        get: function () { return this._calcItemSize; },
        enumerable: false,
        configurable: true
    });
    ;
    VirtualList.prototype.onLoad = function () {
        if (CC_EDITOR) {
            this.runEditor();
            return;
        }
        if (this.layout) {
            this.layout.onInit(this);
        }
    };
    VirtualList.prototype.resetInEditor = function () {
        this.runEditor();
    };
    VirtualList.prototype.onFocusInEditor = function () {
        this.main.resetMainItemChild();
    };
    /**
     * 编辑器模式下的一些设置
     */
    VirtualList.prototype.runEditor = function () {
        var _this = this;
        if (!CC_EDITOR) {
            return;
        }
        var scrollView = this.getComponent(cc.ScrollView);
        var layout = scrollView.content.getComponent(VirtualLayout_1.default);
        if (!this.main.content) {
            this.main.content = scrollView.content;
        }
        if (!layout) {
            scrollView.content.addComponent(VirtualLayout_1.default);
        }
        this.main.editorCall = function (mainItemChild, refresh) {
            var hasChildType = false;
            for (var i = 0; i < _this.others.length; i++) {
                if (_this.others[i].templateType === OtherTemplateType.MAIN_ITEM_CHILD) {
                    hasChildType = true;
                    break;
                }
            }
            if (hasChildType) {
                EditorTool_1.default.setClassAttrPropEnum(OtherLayoutData, "templateChild", cc.Enum["getList"](mainItemChild));
                if (refresh) {
                    EditorTool_1.default.refreshSelectedInspector(_this.node);
                }
            }
        };
        this.main.resetMainItemChild();
    };
    /**
     * 滚动元素节点到view的指定位置
     * @param idx 元素下标
     * @param itemAnchor 元素的锚点位置（左下角为0点）
     * @param viewAnchor view的锚点位置（左下角为0点）
     * @param t 时间 s
     * @param a 加速度是否衰减，为true且滚动距离大时滚动会不准确
     */
    VirtualList.prototype.scrollItemToView = function (idx, itemAnchor, viewAnchor, t, a) {
        if (itemAnchor === void 0) { itemAnchor = cc.v2(); }
        if (viewAnchor === void 0) { viewAnchor = cc.v2(); }
        if (t === void 0) { t = 0; }
        if (a === void 0) { a = true; }
        this.scrollView.scrollToOffset(this.layout.getScrollOffset(idx, itemAnchor, viewAnchor), t, a);
    };
    /**
     * 滚动到视图顶部
     */
    VirtualList.prototype.scrollToTop = function (timeInSecond, attenuated) {
        if (timeInSecond === void 0) { timeInSecond = 0; }
        if (attenuated === void 0) { attenuated = true; }
        this.scrollView.scrollToTop(timeInSecond, attenuated);
    };
    /**
     * 滚动到视图底部
     */
    VirtualList.prototype.scrollToBottom = function (timeInSecond, attenuated) {
        if (timeInSecond === void 0) { timeInSecond = 0; }
        if (attenuated === void 0) { attenuated = true; }
        this.scrollView.scrollToBottom(timeInSecond, attenuated);
    };
    /**
     * 滚动到视图左部
     */
    VirtualList.prototype.scrollToLeft = function (timeInSecond, attenuated) {
        if (timeInSecond === void 0) { timeInSecond = 0; }
        if (attenuated === void 0) { attenuated = true; }
        this.scrollView.scrollToLeft(timeInSecond, attenuated);
    };
    /**
     * 滚动到视图右部
     */
    VirtualList.prototype.scrollToRight = function (timeInSecond, attenuated) {
        if (timeInSecond === void 0) { timeInSecond = 0; }
        if (attenuated === void 0) { attenuated = true; }
        this.scrollView.scrollToRight(timeInSecond, attenuated);
    };
    /**
     * 根据参数计算元素大小的接口（isFixedSize为false时必须提供）
     */
    VirtualList.prototype.setCalcItemSize = function (call) {
        this._calcItemSize = call;
    };
    /**
     * 立即更新布局
     */
    VirtualList.prototype.forceUpdate = function () {
        this.layout.forceUpdate();
    };
    /**
     * 刷新所有激活的item
     */
    VirtualList.prototype.refreshAllItems = function () {
        this.layout.refreshAllItems();
    };
    /**
     * 重置某个元素数据
     * @param index
     * @param args 元素所需参数
     */
    VirtualList.prototype.reset = function (index, args) {
        if (Tool_1.default.inRange(0, this._argsArr.length - 1, index)) {
            this._argsArr[index] = args;
            this.layout.rearrange();
        }
    };
    /**
     * 添加元素数据到尾部
     * @param args 元素所需参数
     */
    VirtualList.prototype.push = function (args) {
        var result = this._argsArr.push(args);
        this.layout.rearrange(false);
        return result;
    };
    /**
     * 删除尾部元素数据
     */
    VirtualList.prototype.pop = function () {
        var result = this._argsArr.pop();
        this.layout.rearrange();
        return result;
    };
    /**
     * 添加元素数据到头部
     * @param args
     */
    VirtualList.prototype.unshift = function (args) {
        var result = this._argsArr.unshift(args);
        this.layout.rearrange();
        return result;
    };
    /**
     * 删除头部元素数据
     */
    VirtualList.prototype.shift = function () {
        var result = this._argsArr.shift();
        this.layout.rearrange();
        return result;
    };
    /**
     * 插入或删除元素 用法同数组splice
     */
    VirtualList.prototype.splice = function (start, deleteCount) {
        var _a;
        var argsArr = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            argsArr[_i - 2] = arguments[_i];
        }
        var result;
        if (deleteCount === undefined) {
            result = this._argsArr.splice(start);
        }
        else {
            if (argsArr === undefined || argsArr.length === 0) {
                result = this._argsArr.splice(start, deleteCount);
            }
            else {
                result = (_a = this._argsArr).splice.apply(_a, __spreadArrays([start, deleteCount], argsArr));
            }
        }
        this.layout.rearrange();
        return result;
    };
    /**
     * 数据排序
     * @param call
     */
    VirtualList.prototype.sort = function (call) {
        var result = this._argsArr.sort(call);
        this.layout.rearrange();
        return result;
    };
    /**
     * 数据过滤
     */
    VirtualList.prototype.filter = function (call) {
        this._argsArr = this._argsArr.filter(call);
        this.layout.rearrange();
        return this._argsArr;
    };
    __decorate([
        property({ type: MainLayoutData, tooltip: CC_DEV && "列表主容器" })
    ], VirtualList.prototype, "main", void 0);
    __decorate([
        property({ type: OtherLayoutData, tooltip: CC_DEV && "列表副容器\n需要分层显示时使用，一般用于降低draw call" })
    ], VirtualList.prototype, "others", void 0);
    __decorate([
        property({ tooltip: CC_DEV && "元素节点大小是否一致\n大小不一致时必须提供calcItemSize接口，且暂不支持grid排版" })
    ], VirtualList.prototype, "isFixedSize", void 0);
    VirtualList = __decorate([
        ccclass,
        disallowMultiple,
        executeInEditMode,
        requireComponent(cc.ScrollView),
        menu("Framework/UI组件/VirtualList")
    ], VirtualList);
    return VirtualList;
}(cc.Component));
exports.default = VirtualList;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcc2Nyb2xsTGlzdFxcVmlydHVhbExpc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1REFBa0Q7QUFDbEQsMkNBQXNDO0FBQ3RDLGlEQUE0QztBQUV0QyxJQUFBLEtBQXFGLEVBQUUsQ0FBQyxVQUFVLEVBQWhHLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLGlCQUFpQix1QkFBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUV6RyxjQUFjO0FBQ2QsSUFBWSxnQkFHWDtBQUhELFdBQVksZ0JBQWdCO0lBQ3hCLHVEQUFJLENBQUE7SUFDSiwyREFBTSxDQUFBO0FBQ1YsQ0FBQyxFQUhXLGdCQUFnQixHQUFoQix3QkFBZ0IsS0FBaEIsd0JBQWdCLFFBRzNCO0FBRUQsY0FBYztBQUNkLElBQVksaUJBSVg7QUFKRCxXQUFZLGlCQUFpQjtJQUN6Qix5REFBSSxDQUFBO0lBQ0osNkRBQU0sQ0FBQTtJQUNOLCtFQUFlLENBQUE7QUFDbkIsQ0FBQyxFQUpXLGlCQUFpQixHQUFqQix5QkFBaUIsS0FBakIseUJBQWlCLFFBSTVCO0FBS0Q7O0dBRUc7QUFFSDtJQUFBO1FBTVcsWUFBTyxHQUFZLElBQUksQ0FBQztRQUd2QixrQkFBYSxHQUFxQixnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7UUFlMUQsb0JBQWUsR0FBYyxJQUFJLENBQUM7UUFnQmxDLGtCQUFhLEdBQVksSUFBSSxDQUFDO1FBZS9CLGVBQVUsR0FBdUQsSUFBSSxDQUFDO0lBbUJqRixDQUFDO0lBNURHLHNCQUFXLHdDQUFZO2FBQXZCLGNBQThDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7YUFDMUUsVUFBd0IsQ0FBbUI7WUFDdkMsSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLENBQUMsRUFBRTtnQkFDMUIsT0FBTzthQUNWO1lBQ0QsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xDLENBQUM7OztPQVB5RTtJQWdCMUUsc0JBQVcsMENBQWM7YUFBekIsY0FBeUMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQzthQUN2RSxVQUEwQixDQUFZO1lBQ2xDLElBQUksSUFBSSxDQUFDLGVBQWUsS0FBSyxDQUFDLEVBQUU7Z0JBQzVCLE9BQU87YUFDVjtZQUNELElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQyxDQUFDOzs7T0FQc0U7SUFnQnZFLHNCQUFXLHdDQUFZO2FBQXZCLGNBQXFDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7YUFDakUsVUFBd0IsQ0FBVTtZQUM5QixJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQyxFQUFFO2dCQUMxQixPQUFPO2FBQ1Y7WUFDRCxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztZQUN2QixJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEMsQ0FBQzs7O09BUGdFO0lBV2pFOzs7O09BSUc7SUFDSSwyQ0FBa0IsR0FBekIsVUFBMEIsT0FBd0I7O1FBQXhCLHdCQUFBLEVBQUEsZUFBd0I7UUFDOUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNaLE9BQU87U0FDVjtRQUNELElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssZ0JBQWdCLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBTyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hGO2FBQU0sSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLGdCQUFnQixDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQzdFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFPLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkY7UUFDRCxNQUFBLElBQUksQ0FBQyxVQUFVLCtDQUFmLElBQUksRUFBYyxhQUFhLEVBQUUsT0FBTyxFQUFFO0lBQzlDLENBQUM7SUFuRUQ7UUFMQyxRQUFRLENBQUM7WUFDTixJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUk7WUFDYixPQUFPLEVBQUUsTUFBTSxJQUFJLFFBQVE7WUFDM0IsT0FBTyxnQkFBSyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDOUIsQ0FBQzttREFDNkI7SUFHL0I7UUFEQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUM7eURBQ29CO0lBS2xFO1FBSkMsUUFBUSxDQUFDO1lBQ04sSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7WUFDL0IsT0FBTyxFQUFFLE1BQU0sSUFBSSxVQUFVO1NBQ2hDLENBQUM7c0RBQ3dFO0lBVTFFO1FBREMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUM7MkRBQ3NCO0lBTTFDO1FBTEMsUUFBUSxDQUFDO1lBQ04sSUFBSSxFQUFFLEVBQUUsQ0FBQyxNQUFNO1lBQ2YsT0FBTyxFQUFFLE1BQU0sSUFBSSxXQUFXO1lBQzlCLE9BQU8sZ0JBQUssT0FBTyxJQUFJLENBQUMsWUFBWSxLQUFLLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDdEUsQ0FBQzt3REFDcUU7SUFVdkU7UUFEQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQzt5REFDb0I7SUFNdEM7UUFMQyxRQUFRLENBQUM7WUFDTixJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUk7WUFDYixPQUFPLEVBQUUsTUFBTSxJQUFJLFVBQVU7WUFDN0IsT0FBTyxnQkFBSyxPQUFPLElBQUksQ0FBQyxZQUFZLEtBQUssZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNwRSxDQUFDO3NEQUMrRDtJQTlDeEQsY0FBYztRQUQxQixPQUFPLENBQUMsZ0JBQWdCLENBQUM7T0FDYixjQUFjLENBMEUxQjtJQUFELHFCQUFDO0NBMUVELEFBMEVDLElBQUE7QUExRVksd0NBQWM7QUE0RTNCOztHQUVHO0FBRUg7SUFBQTtRQUtXLFlBQU8sR0FBWSxJQUFJLENBQUM7UUFNeEIsaUJBQVksR0FBc0IsaUJBQWlCLENBQUMsTUFBTSxDQUFDO1FBTzNELG1CQUFjLEdBQWMsSUFBSSxDQUFDO1FBT2pDLGlCQUFZLEdBQVksSUFBSSxDQUFDO1FBTzdCLGtCQUFhLEdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQTVCRztRQUpDLFFBQVEsQ0FBQztZQUNOLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSTtZQUNiLE9BQU8sRUFBRSxNQUFNLElBQUksUUFBUTtTQUM5QixDQUFDO29EQUM2QjtJQU0vQjtRQUpDLFFBQVEsQ0FBQztZQUNOLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1lBQ2hDLE9BQU8sRUFBRSxNQUFNLElBQUksVUFBVTtTQUNoQyxDQUFDO3lEQUNnRTtJQU9sRTtRQUxDLFFBQVEsQ0FBQztZQUNOLElBQUksRUFBRSxFQUFFLENBQUMsTUFBTTtZQUNmLE9BQU8sRUFBRSxNQUFNLElBQUksV0FBVztZQUM5QixPQUFPLGdCQUFLLE9BQU8sSUFBSSxDQUFDLFlBQVksS0FBSyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ3ZFLENBQUM7MkRBQ3NDO0lBT3hDO1FBTEMsUUFBUSxDQUFDO1lBQ04sSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO1lBQ2IsT0FBTyxFQUFFLE1BQU0sSUFBSSxVQUFVO1lBQzdCLE9BQU8sZ0JBQUssT0FBTyxJQUFJLENBQUMsWUFBWSxLQUFLLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDckUsQ0FBQzt5REFDa0M7SUFPcEM7UUFMQyxRQUFRLENBQUM7WUFDTixJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDakIsT0FBTyxFQUFFLE1BQU0sSUFBSSxrQkFBa0I7WUFDckMsT0FBTyxnQkFBSyxPQUFPLElBQUksQ0FBQyxZQUFZLEtBQUssaUJBQWlCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztTQUNoRixDQUFDOzBEQUNnQztJQWhDekIsZUFBZTtRQUQzQixPQUFPLENBQUMsaUJBQWlCLENBQUM7T0FDZCxlQUFlLENBaUMzQjtJQUFELHNCQUFDO0NBakNELEFBaUNDLElBQUE7QUFqQ1ksMENBQWU7QUFtQzVCOztHQUVHO0FBTUg7SUFBZ0UsK0JBQVk7SUFBNUU7UUFBQSxxRUE4T0M7UUE1T1UsVUFBSSxHQUFtQixJQUFJLGNBQWMsRUFBRSxDQUFDO1FBRzVDLFlBQU0sR0FBc0IsRUFBRSxDQUFDO1FBRy9CLGlCQUFXLEdBQVksSUFBSSxDQUFDO1FBRTNCLGlCQUFXLEdBQWtCLElBQUksQ0FBQztRQVFsQyxhQUFPLEdBQXFCLElBQUksQ0FBQztRQVFqQyxjQUFRLEdBQVEsRUFBRSxDQUFDO1FBUW5CLG1CQUFhLEdBQXlCLElBQUksQ0FBQzs7SUE0TXZELENBQUM7SUFuT0csc0JBQVcsbUNBQVU7YUFBckI7WUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDbkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUN2RDtZQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUM1QixDQUFDOzs7T0FBQTtJQUdELHNCQUFXLCtCQUFNO2FBQWpCO1lBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsdUJBQWEsQ0FBQyxDQUFDO2FBQ3RFO1lBQ0QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3hCLENBQUM7OztPQUFBO0lBSUQsc0JBQVcsZ0NBQU87UUFEbEIsZ0JBQWdCO2FBQ2hCLGNBQTRCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7YUFDbkQsVUFBbUIsQ0FBTTtZQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzVCLENBQUM7OztPQUprRDtJQVFuRCxzQkFBVyxxQ0FBWTtRQUR2Qiw0Q0FBNEM7YUFDNUMsY0FBa0QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFBQSxDQUFDO0lBRXJFLDRCQUFNLEdBQWhCO1FBQ0ksSUFBSSxTQUFTLEVBQUU7WUFDWCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDakIsT0FBTztTQUNWO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDNUI7SUFDTCxDQUFDO0lBRVMsbUNBQWEsR0FBdkI7UUFDSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVTLHFDQUFlLEdBQXpCO1FBQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNLLCtCQUFTLEdBQWpCO1FBQUEsaUJBNEJDO1FBM0JHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDWixPQUFPO1NBQ1Y7UUFDRCxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsRCxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyx1QkFBYSxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUM7U0FDMUM7UUFDRCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsdUJBQWEsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBQyxhQUFzQixFQUFFLE9BQWdCO1lBQzVELElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQztZQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3pDLElBQUksS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEtBQUssaUJBQWlCLENBQUMsZUFBZSxFQUFFO29CQUNuRSxZQUFZLEdBQUcsSUFBSSxDQUFDO29CQUNwQixNQUFNO2lCQUNUO2FBQ0o7WUFDRCxJQUFJLFlBQVksRUFBRTtnQkFDZCxvQkFBVSxDQUFDLG9CQUFvQixDQUFDLGVBQWUsRUFBRSxlQUFlLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2dCQUNyRyxJQUFJLE9BQU8sRUFBRTtvQkFDVCxvQkFBVSxDQUFDLHdCQUF3QixDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbEQ7YUFDSjtRQUNMLENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLHNDQUFnQixHQUF2QixVQUF3QixHQUFXLEVBQUUsVUFBNkIsRUFBRSxVQUE2QixFQUFFLENBQWEsRUFBRSxDQUFpQjtRQUE5RiwyQkFBQSxFQUFBLGFBQXNCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFBRSwyQkFBQSxFQUFBLGFBQXNCLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFBRSxrQkFBQSxFQUFBLEtBQWE7UUFBRSxrQkFBQSxFQUFBLFFBQWlCO1FBQy9ILElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25HLENBQUM7SUFFRDs7T0FFRztJQUNJLGlDQUFXLEdBQWxCLFVBQW1CLFlBQXdCLEVBQUUsVUFBMEI7UUFBcEQsNkJBQUEsRUFBQSxnQkFBd0I7UUFBRSwyQkFBQSxFQUFBLGlCQUEwQjtRQUNuRSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksb0NBQWMsR0FBckIsVUFBc0IsWUFBd0IsRUFBRSxVQUEwQjtRQUFwRCw2QkFBQSxFQUFBLGdCQUF3QjtRQUFFLDJCQUFBLEVBQUEsaUJBQTBCO1FBQ3RFLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxrQ0FBWSxHQUFuQixVQUFvQixZQUF3QixFQUFFLFVBQTBCO1FBQXBELDZCQUFBLEVBQUEsZ0JBQXdCO1FBQUUsMkJBQUEsRUFBQSxpQkFBMEI7UUFDcEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7T0FFRztJQUNJLG1DQUFhLEdBQXBCLFVBQXFCLFlBQXdCLEVBQUUsVUFBMEI7UUFBcEQsNkJBQUEsRUFBQSxnQkFBd0I7UUFBRSwyQkFBQSxFQUFBLGlCQUEwQjtRQUNyRSxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVEOztPQUVHO0lBQ0kscUNBQWUsR0FBdEIsVUFBdUIsSUFBMEI7UUFDN0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksaUNBQVcsR0FBbEI7UUFDSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNJLHFDQUFlLEdBQXRCO1FBQ0ksSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLDJCQUFLLEdBQVosVUFBYSxLQUFhLEVBQUUsSUFBTztRQUMvQixJQUFJLGNBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRTtZQUNsRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztZQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQzNCO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDBCQUFJLEdBQVgsVUFBWSxJQUFPO1FBQ2YsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0kseUJBQUcsR0FBVjtRQUNJLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN4QixPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksNkJBQU8sR0FBZCxVQUFlLElBQU87UUFDbEIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN4QixPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7SUFDSSwyQkFBSyxHQUFaO1FBQ0ksSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLDRCQUFNLEdBQWIsVUFBYyxLQUFhLEVBQUUsV0FBb0I7O1FBQUUsaUJBQWU7YUFBZixVQUFlLEVBQWYscUJBQWUsRUFBZixJQUFlO1lBQWYsZ0NBQWU7O1FBQzlELElBQUksTUFBVyxDQUFDO1FBQ2hCLElBQUksV0FBVyxLQUFLLFNBQVMsRUFBRTtZQUMzQixNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDeEM7YUFBTTtZQUNILElBQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDL0MsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQzthQUNyRDtpQkFBTTtnQkFDSCxNQUFNLEdBQUcsQ0FBQSxLQUFBLElBQUksQ0FBQyxRQUFRLENBQUEsQ0FBQyxNQUFNLDJCQUFDLEtBQUssRUFBRSxXQUFXLEdBQUssT0FBTyxFQUFDLENBQUM7YUFDakU7U0FDSjtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEIsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDBCQUFJLEdBQVgsVUFBWSxJQUE0QjtRQUNwQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLDRCQUFNLEdBQWIsVUFBYyxJQUFzRDtRQUNoRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUEzT0Q7UUFEQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksT0FBTyxFQUFFLENBQUM7NkNBQ1o7SUFHbkQ7UUFEQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksa0NBQWtDLEVBQUUsQ0FBQzsrQ0FDckQ7SUFHdEM7UUFEQyxRQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLGtEQUFrRCxFQUFFLENBQUM7b0RBQ2pEO0lBUmxCLFdBQVc7UUFML0IsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixpQkFBaUI7UUFDakIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQztRQUMvQixJQUFJLENBQUMsNEJBQTRCLENBQUM7T0FDZCxXQUFXLENBOE8vQjtJQUFELGtCQUFDO0NBOU9ELEFBOE9DLENBOU8rRCxFQUFFLENBQUMsU0FBUyxHQThPM0U7a0JBOU9vQixXQUFXIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVkaXRvclRvb2wgZnJvbSBcIi4uLy4uLy4uL3V0aWwvRWRpdG9yVG9vbFwiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Ub29sXCI7XHJcbmltcG9ydCBWaXJ0dWFsTGF5b3V0IGZyb20gXCIuL1ZpcnR1YWxMYXlvdXRcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIHJlcXVpcmVDb21wb25lbnQsIGV4ZWN1dGVJbkVkaXRNb2RlLCBkaXNhbGxvd011bHRpcGxlLCBtZW51IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuLyoqIOS4u+WFg+e0oOaooeadv+exu+WeiyAqL1xyXG5leHBvcnQgZW51bSBNYWluVGVtcGxhdGVUeXBlIHtcclxuICAgIE5PREUsXHJcbiAgICBQUkVGQUJcclxufVxyXG5cclxuLyoqIOWJr+WFg+e0oOaooeadv+exu+WeiyAqL1xyXG5leHBvcnQgZW51bSBPdGhlclRlbXBsYXRlVHlwZSB7XHJcbiAgICBOT0RFLFxyXG4gICAgUFJFRkFCLFxyXG4gICAgTUFJTl9JVEVNX0NISUxELFxyXG59XHJcblxyXG4vKiog6Jma5ouf5YiX6KGo5YWD57Sg5Y+C5pWw57G75Z6LICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbEFyZ3MgeyB9XHJcblxyXG4vKipcclxuICog6Jma5ouf5YiX6KGo5Li75a655ZmoXHJcbiAqL1xyXG5AY2NjbGFzcyhcIk1haW5MYXlvdXREYXRhXCIpXHJcbmV4cG9ydCBjbGFzcyBNYWluTGF5b3V0RGF0YSB7XHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLk5vZGUsXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5YiX6KGo5a655Zmo6IqC54K5XCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIGNvbnRlbnQ6IGNjLk5vZGUgPSBudWxsO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHR5cGU6IGNjLkVudW0oTWFpblRlbXBsYXRlVHlwZSkgfSlcclxuICAgIHByaXZhdGUgX3RlbXBsYXRlVHlwZTogTWFpblRlbXBsYXRlVHlwZSA9IE1haW5UZW1wbGF0ZVR5cGUuUFJFRkFCO1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBjYy5FbnVtKE1haW5UZW1wbGF0ZVR5cGUpLFxyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuWIl+ihqOWFg+e0oOaooeadv+exu+Wei1wiXHJcbiAgICB9KVxyXG4gICAgcHVibGljIGdldCB0ZW1wbGF0ZVR5cGUoKTogTWFpblRlbXBsYXRlVHlwZSB7IHJldHVybiB0aGlzLl90ZW1wbGF0ZVR5cGU7IH1cclxuICAgIHB1YmxpYyBzZXQgdGVtcGxhdGVUeXBlKHY6IE1haW5UZW1wbGF0ZVR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVUeXBlID09PSB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVUeXBlID0gdjtcclxuICAgICAgICB0aGlzLnJlc2V0TWFpbkl0ZW1DaGlsZCh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBAcHJvcGVydHkoY2MuUHJlZmFiKVxyXG4gICAgcHJpdmF0ZSBfdGVtcGxhdGVQcmVmYWI6IGNjLlByZWZhYiA9IG51bGw7XHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLlByZWZhYixcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajlhYPntKDmqKHmnb/pooTliLbkvZNcIixcclxuICAgICAgICB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZVR5cGUgPT09IE1haW5UZW1wbGF0ZVR5cGUuUFJFRkFCOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIGdldCB0ZW1wbGF0ZVByZWZhYigpOiBjYy5QcmVmYWIgeyByZXR1cm4gdGhpcy5fdGVtcGxhdGVQcmVmYWI7IH1cclxuICAgIHB1YmxpYyBzZXQgdGVtcGxhdGVQcmVmYWIodjogY2MuUHJlZmFiKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlUHJlZmFiID09PSB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVQcmVmYWIgPSB2O1xyXG4gICAgICAgIHRoaXMucmVzZXRNYWluSXRlbUNoaWxkKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBwcm9wZXJ0eShjYy5Ob2RlKVxyXG4gICAgcHJpdmF0ZSBfdGVtcGxhdGVOb2RlOiBjYy5Ob2RlID0gbnVsbDtcclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuTm9kZSxcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajlhYPntKDmqKHmnb/oioLngrlcIixcclxuICAgICAgICB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZVR5cGUgPT09IE1haW5UZW1wbGF0ZVR5cGUuTk9ERTsgfVxyXG4gICAgfSlcclxuICAgIHB1YmxpYyBnZXQgdGVtcGxhdGVOb2RlKCk6IGNjLk5vZGUgeyByZXR1cm4gdGhpcy5fdGVtcGxhdGVOb2RlOyB9XHJcbiAgICBwdWJsaWMgc2V0IHRlbXBsYXRlTm9kZSh2OiBjYy5Ob2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlTm9kZSA9PT0gdikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlTm9kZSA9IHY7XHJcbiAgICAgICAgdGhpcy5yZXNldE1haW5JdGVtQ2hpbGQodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVkaXRvckNhbGw6IChtYWluSXRlbUNoaWxkOiB1bmtub3duLCByZWZyZXNoOiBib29sZWFuKSA9PiB2b2lkID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOaemuS4vuWGheWuuVxyXG4gICAgICogQHBhcmFtIHJlZnJlc2gg5piv5ZCm5by65Yi25Yi35pawaW5zcGVjdG9yIFxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldE1haW5JdGVtQ2hpbGQocmVmcmVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFDQ19FRElUT1IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWFpbkl0ZW1DaGlsZCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlVHlwZSA9PT0gTWFpblRlbXBsYXRlVHlwZS5OT0RFICYmIHRoaXMudGVtcGxhdGVOb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVOb2RlLmNoaWxkcmVuLmZvckVhY2goKGMsIGkpID0+IHsgbWFpbkl0ZW1DaGlsZFtjLm5hbWVdID0gaTsgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRlbXBsYXRlVHlwZSA9PT0gTWFpblRlbXBsYXRlVHlwZS5QUkVGQUIgJiYgdGhpcy50ZW1wbGF0ZVByZWZhYikge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlUHJlZmFiLmRhdGEuY2hpbGRyZW4uZm9yRWFjaCgoYywgaSkgPT4geyBtYWluSXRlbUNoaWxkW2MubmFtZV0gPSBpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lZGl0b3JDYWxsPy4obWFpbkl0ZW1DaGlsZCwgcmVmcmVzaCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDomZrmi5/liJfooajlia/lrrnlmahcclxuICovXHJcbkBjY2NsYXNzKFwiT3RoZXJMYXlvdXREYXRhXCIpXHJcbmV4cG9ydCBjbGFzcyBPdGhlckxheW91dERhdGEge1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBjYy5Ob2RlLFxyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuWIl+ihqOWuueWZqOiKgueCuVwiLFxyXG4gICAgfSlcclxuICAgIHB1YmxpYyBjb250ZW50OiBjYy5Ob2RlID0gbnVsbDtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLkVudW0oT3RoZXJUZW1wbGF0ZVR5cGUpLFxyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuWIl+ihqOWFg+e0oOaooeadv+exu+Wei1wiXHJcbiAgICB9KVxyXG4gICAgcHVibGljIHRlbXBsYXRlVHlwZTogT3RoZXJUZW1wbGF0ZVR5cGUgPSBPdGhlclRlbXBsYXRlVHlwZS5QUkVGQUI7XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBjYy5QcmVmYWIsXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5YiX6KGo5YWD57Sg5qih5p2/6aKE5Yi25L2TXCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudGVtcGxhdGVUeXBlID09PSBPdGhlclRlbXBsYXRlVHlwZS5QUkVGQUI7IH1cclxuICAgIH0pXHJcbiAgICBwdWJsaWMgdGVtcGxhdGVQcmVmYWI6IGNjLlByZWZhYiA9IG51bGw7XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBjYy5Ob2RlLFxyXG4gICAgICAgIHRvb2x0aXA6IENDX0RFViAmJiBcIuWIl+ihqOWFg+e0oOaooeadv+iKgueCuVwiLFxyXG4gICAgICAgIHZpc2libGUoKSB7IHJldHVybiB0aGlzLnRlbXBsYXRlVHlwZSA9PT0gT3RoZXJUZW1wbGF0ZVR5cGUuTk9ERTsgfVxyXG4gICAgfSlcclxuICAgIHB1YmxpYyB0ZW1wbGF0ZU5vZGU6IGNjLk5vZGUgPSBudWxsO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuRW51bSh7fSksXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5Lul5YiX6KGo5Li75YWD57Sg55qE5a2Q6IqC54K55L2c5Li65qih5p2/6IqC54K5XCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudGVtcGxhdGVUeXBlID09PSBPdGhlclRlbXBsYXRlVHlwZS5NQUlOX0lURU1fQ0hJTEQ7IH1cclxuICAgIH0pXHJcbiAgICBwdWJsaWMgdGVtcGxhdGVDaGlsZDogbnVtYmVyID0gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDomZrmi5/liJfooahcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AcmVxdWlyZUNvbXBvbmVudChjYy5TY3JvbGxWaWV3KVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9WaXJ0dWFsTGlzdFwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXJ0dWFsTGlzdDxUIGV4dGVuZHMgVmlydHVhbEFyZ3M+IGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eSh7IHR5cGU6IE1haW5MYXlvdXREYXRhLCB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajkuLvlrrnlmahcIiB9KVxyXG4gICAgcHVibGljIG1haW46IE1haW5MYXlvdXREYXRhID0gbmV3IE1haW5MYXlvdXREYXRhKCk7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogT3RoZXJMYXlvdXREYXRhLCB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajlia/lrrnlmahcXG7pnIDopoHliIblsYLmmL7npLrml7bkvb/nlKjvvIzkuIDoiKznlKjkuo7pmY3kvY5kcmF3IGNhbGxcIiB9KVxyXG4gICAgcHVibGljIG90aGVyczogT3RoZXJMYXlvdXREYXRhW10gPSBbXTtcclxuXHJcbiAgICBAcHJvcGVydHkoeyB0b29sdGlwOiBDQ19ERVYgJiYgXCLlhYPntKDoioLngrnlpKflsI/mmK/lkKbkuIDoh7RcXG7lpKflsI/kuI3kuIDoh7Tml7blv4Xpobvmj5DkvptjYWxjSXRlbVNpemXmjqXlj6PvvIzkuJTmmoLkuI3mlK/mjIFncmlk5o6S54mIXCIgfSlcclxuICAgIHB1YmxpYyBpc0ZpeGVkU2l6ZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHJpdmF0ZSBfc2Nyb2xsVmlldzogY2MuU2Nyb2xsVmlldyA9IG51bGw7XHJcbiAgICBwdWJsaWMgZ2V0IHNjcm9sbFZpZXcoKTogY2MuU2Nyb2xsVmlldyB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxWaWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFZpZXcgPSB0aGlzLmdldENvbXBvbmVudChjYy5TY3JvbGxWaWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfbGF5b3V0OiBWaXJ0dWFsTGF5b3V0PFQ+ID0gbnVsbDtcclxuICAgIHB1YmxpYyBnZXQgbGF5b3V0KCk6IFZpcnR1YWxMYXlvdXQ8VD4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IHRoaXMuc2Nyb2xsVmlldy5jb250ZW50LmdldENvbXBvbmVudChWaXJ0dWFsTGF5b3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9hcmdzQXJyOiBUW10gPSBbXTtcclxuICAgIC8qKiDliJfooajnvJPlrZjnmoTmiYDmnInmlbDmja4gKi9cclxuICAgIHB1YmxpYyBnZXQgYXJnc0FycigpOiBUW10geyByZXR1cm4gdGhpcy5fYXJnc0FycjsgfVxyXG4gICAgcHVibGljIHNldCBhcmdzQXJyKHY6IFRbXSkge1xyXG4gICAgICAgIHRoaXMuX2FyZ3NBcnIgPSB2O1xyXG4gICAgICAgIHRoaXMubGF5b3V0LnJlYXJyYW5nZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NhbGNJdGVtU2l6ZTogKGFyZ3M6IFQpID0+IGNjLlNpemUgPSBudWxsO1xyXG4gICAgLyoqIOagueaNruWPguaVsOiuoeeul+WFg+e0oOWkp+Wwj+eahOaOpeWPo++8iGlzRml4ZWRTaXpl5Li6ZmFsc2Xml7blv4Xpobvmj5DkvpvvvIkgKi9cclxuICAgIHB1YmxpYyBnZXQgY2FsY0l0ZW1TaXplKCk6IChhcmdzOiBUKSA9PiBjYy5TaXplIHsgcmV0dXJuIHRoaXMuX2NhbGNJdGVtU2l6ZTsgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChDQ19FRElUT1IpIHtcclxuICAgICAgICAgICAgdGhpcy5ydW5FZGl0b3IoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Lm9uSW5pdCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlc2V0SW5FZGl0b3IoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5ydW5FZGl0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Gb2N1c0luRWRpdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWFpbi5yZXNldE1haW5JdGVtQ2hpbGQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8lui+keWZqOaooeW8j+S4i+eahOS4gOS6m+iuvue9rlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJ1bkVkaXRvcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIUNDX0VESVRPUikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzY3JvbGxWaWV3ID0gdGhpcy5nZXRDb21wb25lbnQoY2MuU2Nyb2xsVmlldyk7XHJcbiAgICAgICAgbGV0IGxheW91dCA9IHNjcm9sbFZpZXcuY29udGVudC5nZXRDb21wb25lbnQoVmlydHVhbExheW91dCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1haW4uY29udGVudCkge1xyXG4gICAgICAgICAgICB0aGlzLm1haW4uY29udGVudCA9IHNjcm9sbFZpZXcuY29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFsYXlvdXQpIHtcclxuICAgICAgICAgICAgc2Nyb2xsVmlldy5jb250ZW50LmFkZENvbXBvbmVudChWaXJ0dWFsTGF5b3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYWluLmVkaXRvckNhbGwgPSAobWFpbkl0ZW1DaGlsZDogdW5rbm93biwgcmVmcmVzaDogYm9vbGVhbik6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGRUeXBlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdGhlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm90aGVyc1tpXS50ZW1wbGF0ZVR5cGUgPT09IE90aGVyVGVtcGxhdGVUeXBlLk1BSU5fSVRFTV9DSElMRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkVHlwZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgRWRpdG9yVG9vbC5zZXRDbGFzc0F0dHJQcm9wRW51bShPdGhlckxheW91dERhdGEsIFwidGVtcGxhdGVDaGlsZFwiLCBjYy5FbnVtW1wiZ2V0TGlzdFwiXShtYWluSXRlbUNoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEVkaXRvclRvb2wucmVmcmVzaFNlbGVjdGVkSW5zcGVjdG9yKHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubWFpbi5yZXNldE1haW5JdGVtQ2hpbGQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa7muWKqOWFg+e0oOiKgueCueWIsHZpZXfnmoTmjIflrprkvY3nva5cclxuICAgICAqIEBwYXJhbSBpZHgg5YWD57Sg5LiL5qCHXHJcbiAgICAgKiBAcGFyYW0gaXRlbUFuY2hvciDlhYPntKDnmoTplJrngrnkvY3nva7vvIjlt6bkuIvop5LkuLow54K577yJXHJcbiAgICAgKiBAcGFyYW0gdmlld0FuY2hvciB2aWV355qE6ZSa54K55L2N572u77yI5bem5LiL6KeS5Li6MOeCue+8iVxyXG4gICAgICogQHBhcmFtIHQg5pe26Ze0IHNcclxuICAgICAqIEBwYXJhbSBhIOWKoOmAn+W6puaYr+WQpuihsOWHj++8jOS4unRydWXkuJTmu5rliqjot53nprvlpKfml7bmu5rliqjkvJrkuI3lh4bnoa5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjcm9sbEl0ZW1Ub1ZpZXcoaWR4OiBudW1iZXIsIGl0ZW1BbmNob3I6IGNjLlZlYzIgPSBjYy52MigpLCB2aWV3QW5jaG9yOiBjYy5WZWMyID0gY2MudjIoKSwgdDogbnVtYmVyID0gMCwgYTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFZpZXcuc2Nyb2xsVG9PZmZzZXQodGhpcy5sYXlvdXQuZ2V0U2Nyb2xsT2Zmc2V0KGlkeCwgaXRlbUFuY2hvciwgdmlld0FuY2hvciksIHQsIGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rua5Yqo5Yiw6KeG5Zu+6aG26YOoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY3JvbGxUb1RvcCh0aW1lSW5TZWNvbmQ6IG51bWJlciA9IDAsIGF0dGVudWF0ZWQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxWaWV3LnNjcm9sbFRvVG9wKHRpbWVJblNlY29uZCwgYXR0ZW51YXRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmu5rliqjliLDop4blm77lupXpg6hcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjcm9sbFRvQm90dG9tKHRpbWVJblNlY29uZDogbnVtYmVyID0gMCwgYXR0ZW51YXRlZDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFZpZXcuc2Nyb2xsVG9Cb3R0b20odGltZUluU2Vjb25kLCBhdHRlbnVhdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa7muWKqOWIsOinhuWbvuW3pumDqFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2Nyb2xsVG9MZWZ0KHRpbWVJblNlY29uZDogbnVtYmVyID0gMCwgYXR0ZW51YXRlZDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFZpZXcuc2Nyb2xsVG9MZWZ0KHRpbWVJblNlY29uZCwgYXR0ZW51YXRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmu5rliqjliLDop4blm77lj7Ppg6hcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjcm9sbFRvUmlnaHQodGltZUluU2Vjb25kOiBudW1iZXIgPSAwLCBhdHRlbnVhdGVkOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVmlldy5zY3JvbGxUb1JpZ2h0KHRpbWVJblNlY29uZCwgYXR0ZW51YXRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7lj4LmlbDorqHnrpflhYPntKDlpKflsI/nmoTmjqXlj6PvvIhpc0ZpeGVkU2l6ZeS4umZhbHNl5pe25b+F6aG75o+Q5L6b77yJXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDYWxjSXRlbVNpemUoY2FsbDogKGFyZ3M6IFQpID0+IGNjLlNpemUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9jYWxjSXRlbVNpemUgPSBjYWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog56uL5Y2z5pu05paw5biD5bGAXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmb3JjZVVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxheW91dC5mb3JjZVVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yi35paw5omA5pyJ5r+A5rS755qEaXRlbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVmcmVzaEFsbEl0ZW1zKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubGF5b3V0LnJlZnJlc2hBbGxJdGVtcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YeN572u5p+Q5Liq5YWD57Sg5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggXHJcbiAgICAgKiBAcGFyYW0gYXJncyDlhYPntKDmiYDpnIDlj4LmlbBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KGluZGV4OiBudW1iZXIsIGFyZ3M6IFQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoVG9vbC5pblJhbmdlKDAsIHRoaXMuX2FyZ3NBcnIubGVuZ3RoIC0gMSwgaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FyZ3NBcnJbaW5kZXhdID0gYXJncztcclxuICAgICAgICAgICAgdGhpcy5sYXlvdXQucmVhcnJhbmdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg5YWD57Sg5pWw5o2u5Yiw5bC+6YOoXHJcbiAgICAgKiBAcGFyYW0gYXJncyDlhYPntKDmiYDpnIDlj4LmlbBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHB1c2goYXJnczogVCk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2FyZ3NBcnIucHVzaChhcmdzKTtcclxuICAgICAgICB0aGlzLmxheW91dC5yZWFycmFuZ2UoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTlsL7pg6jlhYPntKDmlbDmja5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvcCgpOiBUIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fYXJnc0Fyci5wb3AoKTtcclxuICAgICAgICB0aGlzLmxheW91dC5yZWFycmFuZ2UoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg5YWD57Sg5pWw5o2u5Yiw5aS06YOoXHJcbiAgICAgKiBAcGFyYW0gYXJncyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVuc2hpZnQoYXJnczogVCk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2FyZ3NBcnIudW5zaGlmdChhcmdzKTtcclxuICAgICAgICB0aGlzLmxheW91dC5yZWFycmFuZ2UoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5aS06YOo5YWD57Sg5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaGlmdCgpOiBUIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fYXJnc0Fyci5zaGlmdCgpO1xyXG4gICAgICAgIHRoaXMubGF5b3V0LnJlYXJyYW5nZSgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmj5LlhaXmiJbliKDpmaTlhYPntKAg55So5rOV5ZCM5pWw57uEc3BsaWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzcGxpY2Uoc3RhcnQ6IG51bWJlciwgZGVsZXRlQ291bnQ/OiBudW1iZXIsIC4uLmFyZ3NBcnI6IFRbXSk6IFRbXSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogVFtdO1xyXG4gICAgICAgIGlmIChkZWxldGVDb3VudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2FyZ3NBcnIuc3BsaWNlKHN0YXJ0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYXJnc0FyciA9PT0gdW5kZWZpbmVkIHx8IGFyZ3NBcnIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9hcmdzQXJyLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYXJnc0Fyci5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5hcmdzQXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5sYXlvdXQucmVhcnJhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaVsOaNruaOkuW6j1xyXG4gICAgICogQHBhcmFtIGNhbGwgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzb3J0KGNhbGw6IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9hcmdzQXJyLnNvcnQoY2FsbCk7XHJcbiAgICAgICAgdGhpcy5sYXlvdXQucmVhcnJhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaVsOaNrui/h+a7pFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsdGVyKGNhbGw6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgYXJyYXk6IFRbXSkgPT4gYm9vbGVhbik6IFRbXSB7XHJcbiAgICAgICAgdGhpcy5fYXJnc0FyciA9IHRoaXMuX2FyZ3NBcnIuZmlsdGVyKGNhbGwpO1xyXG4gICAgICAgIHRoaXMubGF5b3V0LnJlYXJyYW5nZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcmdzQXJyO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/base/Layer.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a6e48AvPltFQqwiI4zAsMqx', 'Layer');
// scripts/common/cmpt/base/Layer.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Url_1 = require("../../const/Url");
var Res_1 = require("../../util/Res");
var Tool_1 = require("../../util/Tool");
var DialogBase_1 = require("./DialogBase");
var Tip_1 = require("./Tip");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/**
 * 全局弹窗管理器
 */
var Layer = /** @class */ (function (_super) {
    __extends(Layer, _super);
    function Layer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.mainLayer = null;
        _this.dialogLayer = null;
        _this.loadingLayer = null;
        _this.tipLayer = null;
        /** 打开Loading层计数，为0时关闭，防止某些情况同时触发打开关闭Loading */
        _this._loadingCount = 0;
        /** tip节点池 */
        _this._tipPool = [];
        /** 当前存在的tip文字数组 */
        _this._tipTexts = [];
        return _this;
    }
    Layer_1 = Layer;
    Layer.prototype.resetInEditor = function () {
        var _this = this;
        if (!CC_EDITOR) {
            return;
        }
        var checkNode = function () {
            var names = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                names[_i] = arguments[_i];
            }
            names.forEach(function (name) {
                if (!_this.node.getChildByName(name)) {
                    var node = new cc.Node(name);
                    _this.node.addChild(node);
                    var widget = node.addComponent(cc.Widget);
                    widget.top = 0;
                    widget.isAlignTop = true;
                    widget.bottom = 0;
                    widget.isAlignBottom = true;
                    widget.left = 0;
                    widget.isAlignLeft = true;
                    widget.right = 0;
                    widget.isAlignRight = true;
                    if (name === "LoadingLayer") {
                        node.addComponent(cc.BlockInputEvents);
                    }
                }
            });
        };
        checkNode("MainLayer", "DialogLayer", "LoadingLayer", "TipLayer");
        this.mainLayer = this.node.getChildByName("MainLayer");
        this.dialogLayer = this.node.getChildByName("DialogLayer");
        this.loadingLayer = this.node.getChildByName("LoadingLayer");
        this.tipLayer = this.node.getChildByName("TipLayer");
    };
    Layer.prototype.onLoad = function () {
        Layer_1.inst = this;
        this.hideLoading();
    };
    Layer.prototype.onDestroy = function () {
        Layer_1.inst = null;
    };
    /**
     * 获取文件名（截取url最后一个斜杠后的内容）
     */
    Layer.prototype.getNameByUrl = function (url) {
        return url.substring(url.lastIndexOf("/") + 1, url.length);
    };
    /**
     * 进入新场景
     * @async
     * @param sceneName 场景名
     */
    Layer.prototype.enterScene = function (sceneName) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.showLoading();
                cc.director.preloadScene(sceneName, function (err) {
                    if (err) {
                        cc.error("[Layer.enterScene] failed to preload scene: " + sceneName);
                        return;
                    }
                    _this.hideLoading();
                    cc.director.loadScene(sceneName);
                });
                return [2 /*return*/];
            });
        });
    };
    /**
     * 进入常驻界面，并清空dialog与tip（不同于dialog，常驻界面始终显示在最底层，且同时只会存在一个）
     */
    Layer.prototype.enterMain = function (url) {
        return __awaiter(this, void 0, Promise, function () {
            var prefab, _a, node;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.showLoading();
                        _a = Res_1.default.get(url, cc.Prefab);
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, Res_1.default.load(url, cc.Prefab)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        prefab = _a;
                        this.hideLoading();
                        if (!prefab) {
                            cc.error("[Layer.enterMain] can not find prefab: " + url);
                            return [2 /*return*/, null];
                        }
                        this.mainLayer.destroyAllChildren();
                        this.closeDialogs();
                        this.clearTips();
                        node = Res_1.default.instantiate(prefab);
                        node.setPosition(0, 0);
                        this.mainLayer.addChild(node);
                        return [2 /*return*/, node];
                }
            });
        });
    };
    /**
     * 获取弹窗组件（返回遍历到的第一个）
     * @param url prefab路径，规则同Res加载路径
     */
    Layer.prototype.getDialog = function (url) {
        for (var i = 0; i < this.dialogLayer.childrenCount; i++) {
            var node = this.dialogLayer.children[i];
            var cmpt = node.getComponent(DialogBase_1.default);
            if (!cmpt) {
                continue;
            }
            if (cmpt.prefabUrl === url) {
                return cmpt;
            }
        }
        return null;
    };
    /**
     * （同步方法，需确保事先已加载预制资源）打开弹窗
     * @param url prefab路径，规则同Res加载路径
     * @param args DialogBase.open调用参数
     */
    Layer.prototype.openDialog = function (url) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var prefab = Res_1.default.get(url, cc.Prefab);
        if (!prefab) {
            cc.error("[Layer.openDialog] can not find dialog prefab: " + url);
            return;
        }
        var node = Res_1.default.instantiate(prefab);
        this.dialogLayer.addChild(node);
        node.setPosition(0, 0);
        var cmpt = node.getComponent(DialogBase_1.default);
        if (cmpt) {
            //@ts-ignore
            cmpt._prefabUrl = url;
            cmpt.playOpen();
            cmpt.onOpen.apply(cmpt, args);
        }
    };
    /**
     * （同步方法，需确保事先已加载预制资源）打开唯一弹窗--同一弹窗节点只能同时存在一个
     * @param url prefab路径，规则同Res加载路径
     * @param args DialogBase.open调用参数
     */
    Layer.prototype.openUniDialog = function (url) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.getDialog(url)) {
            return;
        }
        this.openDialog.apply(this, __spreadArrays([url], args));
    };
    /**
     * 打开弹窗
     * @async
     * @param url prefab路径，规则同Res加载路径
     * @param args DialogBase.open调用参数
     */
    Layer.prototype.openDialogAsync = function (url) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise, function () {
            var prefab, node, cmpt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.showLoading();
                        return [4 /*yield*/, Res_1.default.load(url, cc.Prefab)];
                    case 1:
                        prefab = _a.sent();
                        this.hideLoading();
                        if (!prefab) {
                            cc.error("[Layer.openDialogAsync] can not find dialog prefab: " + url);
                            return [2 /*return*/];
                        }
                        node = Res_1.default.instantiate(prefab);
                        this.dialogLayer.addChild(node);
                        node.setPosition(0, 0);
                        cmpt = node.getComponent(DialogBase_1.default);
                        if (cmpt) {
                            //@ts-ignore
                            cmpt._prefabUrl = url;
                            cmpt.playOpen();
                            cmpt.onOpen.apply(cmpt, args);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 打开唯一弹窗--同一弹窗节点只能同时存在一个
     * @async
     * @param url prefab路径，规则同Res加载路径
     * @param args DialogBase.open调用参数
     */
    Layer.prototype.openUniDialogAsync = function (url) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.getDialog(url)) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.openDialogAsync.apply(this, __spreadArrays([url], args))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 关闭遍历到的第一个弹窗
     * @param url prefab路径，规则同Res加载路径
     * @param play true：调用playClose播放弹窗关闭动画；false：直接调用close关闭弹窗
     */
    Layer.prototype.closeDialog = function (url, play) {
        if (play === void 0) { play = false; }
        var cmpt = this.getDialog(url);
        if (!cmpt) {
            return;
        }
        play ? cmpt.playClose() : cmpt.close();
    };
    /**
     * 关闭所有同路径弹窗，不传参则关闭所有弹窗
     * @param url prefab路径，规则同Res加载路径
     * @param play true：调用playClose播放弹窗关闭动画；false：直接调用close关闭弹窗
     */
    Layer.prototype.closeDialogs = function (url, play) {
        if (url === void 0) { url = ""; }
        if (play === void 0) { play = false; }
        for (var i = this.dialogLayer.childrenCount - 1; i >= 0; i--) {
            var node = this.dialogLayer.children[i];
            var cmpt = node.getComponent(DialogBase_1.default);
            if (!cmpt) {
                continue;
            }
            if (!url || cmpt.prefabUrl === url) {
                play ? cmpt.playClose() : cmpt.close();
            }
        }
    };
    /**
     * 异步等待弹窗关闭（只等待遍历到的第一个）
     * @param url prefab路径，规则同Res加载路径
     */
    Layer.prototype.waitCloseDialog = function (url) {
        return __awaiter(this, void 0, Promise, function () {
            var cmpt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cmpt = this.getDialog(url);
                        if (!cmpt) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                cmpt.addResolve(resolve);
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * 异步等待所有同路径弹窗关闭
     * @param url prefab路径，规则同Res加载路径
     */
    Layer.prototype.waitCloseDialogs = function (url) {
        return __awaiter(this, void 0, Promise, function () {
            var arr, _loop_1, this_1, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        arr = [];
                        _loop_1 = function (i) {
                            var node = this_1.dialogLayer.children[i];
                            var cmpt = node.getComponent(DialogBase_1.default);
                            if (!cmpt) {
                                return "continue";
                            }
                            if (cmpt.prefabUrl === url) {
                                arr.push(new Promise(function (resolve, reject) {
                                    cmpt.addResolve(resolve);
                                }));
                            }
                        };
                        this_1 = this;
                        for (i = 0; i < this.dialogLayer.childrenCount; i++) {
                            _loop_1(i);
                        }
                        return [4 /*yield*/, Promise.all(arr)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * 弹出一条文字提示
     * @param data TipData | string 提示数据
     */
    Layer.prototype.showTip = function (data) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var tipData, tipNode, prefab, delay, fade, moveTo, call;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tipData = null;
                        if (typeof data === "string") {
                            tipData = {
                                text: data
                            };
                        }
                        else {
                            tipData = data;
                        }
                        if (!tipData.hasOwnProperty("unique")) {
                            tipData.unique = false;
                        }
                        if (!tipData.hasOwnProperty("duration")) {
                            tipData.duration = 1;
                        }
                        if (!tipData.hasOwnProperty("fade")) {
                            tipData.fade = 0.5;
                        }
                        if (!tipData.hasOwnProperty("start")) {
                            tipData.start = cc.v2(0, 0);
                        }
                        if (!tipData.hasOwnProperty("end")) {
                            tipData.end = cc.v2(0, 0);
                        }
                        // 唯一显示
                        if (tipData.unique && Tool_1.default.arrayHas(this._tipTexts, tipData.text)) {
                            return [2 /*return*/];
                        }
                        this._tipTexts.push(tipData.text);
                        tipNode = null;
                        if (!(this._tipPool.length > 0)) return [3 /*break*/, 1];
                        tipNode = this._tipPool.shift();
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, Res_1.default.load(Url_1.ResUrl.PREFAB.TIP, cc.Prefab)];
                    case 2:
                        prefab = _b.sent();
                        if (!prefab) {
                            cc.error("[Layer.showTip] can not load prefab: " + Url_1.ResUrl.PREFAB.TIP);
                            return [2 /*return*/];
                        }
                        tipNode = Res_1.default.instantiate(prefab);
                        this.tipLayer.addChild(tipNode);
                        _b.label = 3;
                    case 3:
                        delay = cc.delayTime(tipData.duration);
                        fade = cc.fadeOut(tipData.fade);
                        moveTo = cc.moveTo(tipData.fade, tipData.end);
                        call = cc.callFunc(function () {
                            tipNode.active = false;
                            _this._tipPool.push(tipNode);
                            Tool_1.default.arrayDelete(_this._tipTexts, tipData.text);
                        });
                        tipNode.active = true;
                        tipNode.opacity = 255;
                        tipNode.setPosition(tipData.start);
                        tipNode.setSiblingIndex(this.tipLayer.childrenCount - 1);
                        tipNode.runAction(cc.sequence(delay, cc.spawn(fade, moveTo), call));
                        // 数据
                        (_a = tipNode.getComponent(Tip_1.default)) === null || _a === void 0 ? void 0 : _a.init(tipData.text);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 清空所有提示
     */
    Layer.prototype.clearTips = function () {
        this._tipPool.length = 0;
        this._tipTexts.length = 0;
        this.tipLayer.destroyAllChildren();
    };
    /**
     * 打开全局loading遮罩（打开与关闭的调用必须一一对应）
     */
    Layer.prototype.showLoading = function () {
        this._loadingCount++;
        if (!this.loadingLayer.active) {
            this.loadingLayer.active = true;
            // 默认0.5s后才显示loading内容
            var content_1 = this.loadingLayer.getChildByName("content");
            if (content_1) {
                content_1.active = false;
                this.unscheduleAllCallbacks();
                Tool_1.default.waitCmpt(this, 0.5).then(function () {
                    content_1.active = true;
                });
            }
        }
    };
    /**
     * 关闭全局loading遮罩
     */
    Layer.prototype.hideLoading = function () {
        this._loadingCount--;
        if (this._loadingCount <= 0) {
            this._loadingCount = 0;
            this.loadingLayer.active = false;
            this.unscheduleAllCallbacks();
        }
    };
    var Layer_1;
    Layer.inst = null;
    __decorate([
        property(cc.Node)
    ], Layer.prototype, "mainLayer", void 0);
    __decorate([
        property(cc.Node)
    ], Layer.prototype, "dialogLayer", void 0);
    __decorate([
        property(cc.Node)
    ], Layer.prototype, "loadingLayer", void 0);
    __decorate([
        property(cc.Node)
    ], Layer.prototype, "tipLayer", void 0);
    Layer = Layer_1 = __decorate([
        ccclass,
        disallowMultiple,
        menu("Framework/基础组件/Layer")
    ], Layer);
    return Layer;
}(cc.Component));
exports.default = Layer;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxiYXNlXFxMYXllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUNBQXlDO0FBQ3pDLHNDQUFpQztBQUNqQyx3Q0FBbUM7QUFDbkMsMkNBQXNDO0FBQ3RDLDZCQUF3QjtBQUVsQixJQUFBLEtBQWdELEVBQUUsQ0FBQyxVQUFVLEVBQTNELE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLGdCQUFnQixzQkFBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQW9CcEU7O0dBRUc7QUFJSDtJQUFtQyx5QkFBWTtJQUEvQztRQUFBLHFFQWtYQztRQS9XOEIsZUFBUyxHQUFZLElBQUksQ0FBQztRQUMxQixpQkFBVyxHQUFZLElBQUksQ0FBQztRQUM1QixrQkFBWSxHQUFZLElBQUksQ0FBQztRQUM3QixjQUFRLEdBQVksSUFBSSxDQUFDO1FBRXBELCtDQUErQztRQUN2QyxtQkFBYSxHQUFXLENBQUMsQ0FBQztRQUNsQyxhQUFhO1FBQ0wsY0FBUSxHQUFjLEVBQUUsQ0FBQztRQUNqQyxtQkFBbUI7UUFDWCxlQUFTLEdBQWEsRUFBRSxDQUFDOztJQXFXckMsQ0FBQztjQWxYb0IsS0FBSztJQWVaLDZCQUFhLEdBQXZCO1FBQUEsaUJBNkJDO1FBNUJHLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDWixPQUFPO1NBQ1Y7UUFDRCxJQUFJLFNBQVMsR0FBRztZQUFDLGVBQWtCO2lCQUFsQixVQUFrQixFQUFsQixxQkFBa0IsRUFBbEIsSUFBa0I7Z0JBQWxCLDBCQUFrQjs7WUFDL0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUk7Z0JBQ2YsSUFBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUNqQyxJQUFJLElB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LEVBQUUsQ0FBQztnQkFDOUIsY0FBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO29CQUMxQixTQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDMUIsQ0FBQyxDQUFDLENBQUM7YUFDTjtTQUNKO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ksMkJBQVcsR0FBbEI7UUFDSSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztZQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7WUFDakMsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7U0FDakM7SUFDTCxDQUFDOztJQWhYYSxVQUFJLEdBQVUsSUFBSSxDQUFDO0lBRWQ7UUFBbEIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7NENBQW1DO0lBQ2xDO1FBQWxCLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDOzhDQUFxQztJQUNwQztRQUFsQixRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQzsrQ0FBc0M7SUFDckM7UUFBbEIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7MkNBQWtDO0lBTm5DLEtBQUs7UUFIekIsT0FBTztRQUNQLGdCQUFnQjtRQUNoQixJQUFJLENBQUMsc0JBQXNCLENBQUM7T0FDUixLQUFLLENBa1h6QjtJQUFELFlBQUM7Q0FsWEQsQUFrWEMsQ0FsWGtDLEVBQUUsQ0FBQyxTQUFTLEdBa1g5QztrQkFsWG9CLEtBQUsiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXNVcmwgfSBmcm9tIFwiLi4vLi4vY29uc3QvVXJsXCI7XHJcbmltcG9ydCBSZXMgZnJvbSBcIi4uLy4uL3V0aWwvUmVzXCI7XHJcbmltcG9ydCBUb29sIGZyb20gXCIuLi8uLi91dGlsL1Rvb2xcIjtcclxuaW1wb3J0IERpYWxvZ0Jhc2UgZnJvbSBcIi4vRGlhbG9nQmFzZVwiO1xyXG5pbXBvcnQgVGlwIGZyb20gXCIuL1RpcFwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgZGlzYWxsb3dNdWx0aXBsZSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiB0aXDmlbDmja5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGlwRGF0YSB7XHJcbiAgICAvKiog5paH5a2X5YaF5a65ICovXHJcbiAgICB0ZXh0OiBzdHJpbmc7XHJcbiAgICAvKiog5q2k5p2h5paH5a2X5piv5ZCm5ZSv5LiA5pi+56S6ICovXHJcbiAgICB1bmlxdWU/OiBib29sZWFuO1xyXG4gICAgLyoqIOWtmOWcqOaXtumXtCDljZXkvY1zICovXHJcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcclxuICAgIC8qKiDmtojlpLHml7bnmoTmuJDpmpDml7bpl7Qg5Y2V5L2NcyAqL1xyXG4gICAgZmFkZT86IG51bWJlcjtcclxuICAgIC8qKiDliJ3lp4vkvY3nva4gKi9cclxuICAgIHN0YXJ0PzogY2MuVmVjMjtcclxuICAgIC8qKiDmuJDpmpDov4fnqIvnu4jngrnkvY3nva4gKi9cclxuICAgIGVuZD86IGNjLlZlYzI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlhajlsYDlvLnnqpfnrqHnkIblmahcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkBtZW51KFwiRnJhbWV3b3JrL+WfuuehgOe7hOS7ti9MYXllclwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGluc3Q6IExheWVyID0gbnVsbDtcclxuXHJcbiAgICBAcHJvcGVydHkoY2MuTm9kZSkgcHJpdmF0ZSBtYWluTGF5ZXI6IGNjLk5vZGUgPSBudWxsO1xyXG4gICAgQHByb3BlcnR5KGNjLk5vZGUpIHByaXZhdGUgZGlhbG9nTGF5ZXI6IGNjLk5vZGUgPSBudWxsO1xyXG4gICAgQHByb3BlcnR5KGNjLk5vZGUpIHByaXZhdGUgbG9hZGluZ0xheWVyOiBjYy5Ob2RlID0gbnVsbDtcclxuICAgIEBwcm9wZXJ0eShjYy5Ob2RlKSBwcml2YXRlIHRpcExheWVyOiBjYy5Ob2RlID0gbnVsbDtcclxuXHJcbiAgICAvKiog5omT5byATG9hZGluZ+WxguiuoeaVsO+8jOS4ujDml7blhbPpl63vvIzpmLLmraLmn5Dkupvmg4XlhrXlkIzml7bop6blj5HmiZPlvIDlhbPpl61Mb2FkaW5nICovXHJcbiAgICBwcml2YXRlIF9sb2FkaW5nQ291bnQ6IG51bWJlciA9IDA7XHJcbiAgICAvKiogdGlw6IqC54K55rGgICovXHJcbiAgICBwcml2YXRlIF90aXBQb29sOiBjYy5Ob2RlW10gPSBbXTtcclxuICAgIC8qKiDlvZPliY3lrZjlnKjnmoR0aXDmloflrZfmlbDnu4QgKi9cclxuICAgIHByaXZhdGUgX3RpcFRleHRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCByZXNldEluRWRpdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghQ0NfRURJVE9SKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNoZWNrTm9kZSA9ICguLi5uYW1lczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICAgICAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBjYy5Ob2RlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hZGRDaGlsZChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gbm9kZS5hZGRDb21wb25lbnQoY2MuV2lkZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQudG9wID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuaXNBbGlnblRvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmJvdHRvbSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmlzQWxpZ25Cb3R0b20gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5sZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQuaXNBbGlnbkxlZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5yaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LmlzQWxpZ25SaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiTG9hZGluZ0xheWVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQoY2MuQmxvY2tJbnB1dEV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNoZWNrTm9kZShcIk1haW5MYXllclwiLCBcIkRpYWxvZ0xheWVyXCIsIFwiTG9hZGluZ0xheWVyXCIsIFwiVGlwTGF5ZXJcIik7XHJcbiAgICAgICAgdGhpcy5tYWluTGF5ZXIgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJNYWluTGF5ZXJcIik7XHJcbiAgICAgICAgdGhpcy5kaWFsb2dMYXllciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcIkRpYWxvZ0xheWVyXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0xheWVyID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiTG9hZGluZ0xheWVyXCIpO1xyXG4gICAgICAgIHRoaXMudGlwTGF5ZXIgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJUaXBMYXllclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIExheWVyLmluc3QgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIExheWVyLmluc3QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5paH5Lu25ZCN77yI5oiq5Y+WdXJs5pyA5ZCO5LiA5Liq5pac5p2g5ZCO55qE5YaF5a6577yJXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXROYW1lQnlVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxLCB1cmwubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/m+WFpeaWsOWcuuaZr1xyXG4gICAgICogQGFzeW5jXHJcbiAgICAgKiBAcGFyYW0gc2NlbmVOYW1lIOWcuuaZr+WQjVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZW50ZXJTY2VuZShzY2VuZU5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHRoaXMuc2hvd0xvYWRpbmcoKTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5wcmVsb2FkU2NlbmUoc2NlbmVOYW1lLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNjLmVycm9yKGBbTGF5ZXIuZW50ZXJTY2VuZV0gZmFpbGVkIHRvIHByZWxvYWQgc2NlbmU6ICR7c2NlbmVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKHNjZW5lTmFtZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5vlhaXluLjpqbvnlYzpnaLvvIzlubbmuIXnqbpkaWFsb2fkuI50aXDvvIjkuI3lkIzkuo5kaWFsb2fvvIzluLjpqbvnlYzpnaLlp4vnu4jmmL7npLrlnKjmnIDlupXlsYLvvIzkuJTlkIzml7blj6rkvJrlrZjlnKjkuIDkuKrvvIlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGVudGVyTWFpbih1cmw6IHN0cmluZyk6IFByb21pc2U8Y2MuTm9kZSB8IG51bGw+IHtcclxuICAgICAgICB0aGlzLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgbGV0IHByZWZhYjogY2MuUHJlZmFiID0gUmVzLmdldCh1cmwsIGNjLlByZWZhYikgfHwgYXdhaXQgUmVzLmxvYWQodXJsLCBjYy5QcmVmYWIpO1xyXG4gICAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICBpZiAoIXByZWZhYikge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW0xheWVyLmVudGVyTWFpbl0gY2FuIG5vdCBmaW5kIHByZWZhYjogJHt1cmx9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tYWluTGF5ZXIuZGVzdHJveUFsbENoaWxkcmVuKCk7XHJcbiAgICAgICAgdGhpcy5jbG9zZURpYWxvZ3MoKTtcclxuICAgICAgICB0aGlzLmNsZWFyVGlwcygpO1xyXG4gICAgICAgIGxldCBub2RlOiBjYy5Ob2RlID0gUmVzLmluc3RhbnRpYXRlKHByZWZhYik7XHJcbiAgICAgICAgbm9kZS5zZXRQb3NpdGlvbigwLCAwKTtcclxuICAgICAgICB0aGlzLm1haW5MYXllci5hZGRDaGlsZChub2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluW8ueeql+e7hOS7tu+8iOi/lOWbnumBjeWOhuWIsOeahOesrOS4gOS4qu+8iVxyXG4gICAgICogQHBhcmFtIHVybCBwcmVmYWLot6/lvoTvvIzop4TliJnlkIxSZXPliqDovb3ot6/lvoRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERpYWxvZyh1cmw6IHN0cmluZyk6IERpYWxvZ0Jhc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaWFsb2dMYXllci5jaGlsZHJlbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRpYWxvZ0xheWVyLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBsZXQgY21wdCA9IG5vZGUuZ2V0Q29tcG9uZW50KERpYWxvZ0Jhc2UpO1xyXG4gICAgICAgICAgICBpZiAoIWNtcHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbXB0LnByZWZhYlVybCA9PT0gdXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIO+8iOWQjOatpeaWueazle+8jOmcgOehruS/neS6i+WFiOW3suWKoOi9vemihOWItui1hOa6kO+8ieaJk+W8gOW8ueeql1xyXG4gICAgICogQHBhcmFtIHVybCBwcmVmYWLot6/lvoTvvIzop4TliJnlkIxSZXPliqDovb3ot6/lvoRcclxuICAgICAqIEBwYXJhbSBhcmdzIERpYWxvZ0Jhc2Uub3Blbuiwg+eUqOWPguaVsFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3BlbkRpYWxvZyh1cmw6IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBsZXQgcHJlZmFiOiBjYy5QcmVmYWIgPSBSZXMuZ2V0KHVybCwgY2MuUHJlZmFiKTtcclxuICAgICAgICBpZiAoIXByZWZhYikge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW0xheWVyLm9wZW5EaWFsb2ddIGNhbiBub3QgZmluZCBkaWFsb2cgcHJlZmFiOiAke3VybH1gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG5vZGUgPSBSZXMuaW5zdGFudGlhdGUocHJlZmFiKTtcclxuICAgICAgICB0aGlzLmRpYWxvZ0xheWVyLmFkZENoaWxkKG5vZGUpO1xyXG4gICAgICAgIG5vZGUuc2V0UG9zaXRpb24oMCwgMCk7XHJcbiAgICAgICAgbGV0IGNtcHQgPSBub2RlLmdldENvbXBvbmVudChEaWFsb2dCYXNlKTtcclxuICAgICAgICBpZiAoY21wdCkge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgY21wdC5fcHJlZmFiVXJsID0gdXJsO1xyXG4gICAgICAgICAgICBjbXB0LnBsYXlPcGVuKCk7XHJcbiAgICAgICAgICAgIGNtcHQub25PcGVuKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIO+8iOWQjOatpeaWueazle+8jOmcgOehruS/neS6i+WFiOW3suWKoOi9vemihOWItui1hOa6kO+8ieaJk+W8gOWUr+S4gOW8ueeqly0t5ZCM5LiA5by556qX6IqC54K55Y+q6IO95ZCM5pe25a2Y5Zyo5LiA5LiqXHJcbiAgICAgKiBAcGFyYW0gdXJsIHByZWZhYui3r+W+hO+8jOinhOWImeWQjFJlc+WKoOi9vei3r+W+hFxyXG4gICAgICogQHBhcmFtIGFyZ3MgRGlhbG9nQmFzZS5vcGVu6LCD55So5Y+C5pWwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvcGVuVW5pRGlhbG9nKHVybDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmdldERpYWxvZyh1cmwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3BlbkRpYWxvZyh1cmwsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5by556qXXHJcbiAgICAgKiBAYXN5bmNcclxuICAgICAqIEBwYXJhbSB1cmwgcHJlZmFi6Lev5b6E77yM6KeE5YiZ5ZCMUmVz5Yqg6L296Lev5b6EXHJcbiAgICAgKiBAcGFyYW0gYXJncyBEaWFsb2dCYXNlLm9wZW7osIPnlKjlj4LmlbBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIG9wZW5EaWFsb2dBc3luYyh1cmw6IHN0cmluZywgLi4uYXJnczogYW55W10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLnNob3dMb2FkaW5nKCk7XHJcbiAgICAgICAgbGV0IHByZWZhYjogY2MuUHJlZmFiID0gYXdhaXQgUmVzLmxvYWQodXJsLCBjYy5QcmVmYWIpO1xyXG4gICAgICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcclxuICAgICAgICBpZiAoIXByZWZhYikge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW0xheWVyLm9wZW5EaWFsb2dBc3luY10gY2FuIG5vdCBmaW5kIGRpYWxvZyBwcmVmYWI6ICR7dXJsfWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbm9kZSA9IFJlcy5pbnN0YW50aWF0ZShwcmVmYWIpO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nTGF5ZXIuYWRkQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgbm9kZS5zZXRQb3NpdGlvbigwLCAwKTtcclxuICAgICAgICBsZXQgY21wdCA9IG5vZGUuZ2V0Q29tcG9uZW50KERpYWxvZ0Jhc2UpO1xyXG4gICAgICAgIGlmIChjbXB0KSB7XHJcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBjbXB0Ll9wcmVmYWJVcmwgPSB1cmw7XHJcbiAgICAgICAgICAgIGNtcHQucGxheU9wZW4oKTtcclxuICAgICAgICAgICAgY21wdC5vbk9wZW4oLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5ZSv5LiA5by556qXLS3lkIzkuIDlvLnnqpfoioLngrnlj6rog73lkIzml7blrZjlnKjkuIDkuKpcclxuICAgICAqIEBhc3luY1xyXG4gICAgICogQHBhcmFtIHVybCBwcmVmYWLot6/lvoTvvIzop4TliJnlkIxSZXPliqDovb3ot6/lvoRcclxuICAgICAqIEBwYXJhbSBhcmdzIERpYWxvZ0Jhc2Uub3Blbuiwg+eUqOWPguaVsFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgb3BlblVuaURpYWxvZ0FzeW5jKHVybDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICh0aGlzLmdldERpYWxvZyh1cmwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMub3BlbkRpYWxvZ0FzeW5jKHVybCwgLi4uYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63pgY3ljobliLDnmoTnrKzkuIDkuKrlvLnnqpdcclxuICAgICAqIEBwYXJhbSB1cmwgcHJlZmFi6Lev5b6E77yM6KeE5YiZ5ZCMUmVz5Yqg6L296Lev5b6EXHJcbiAgICAgKiBAcGFyYW0gcGxheSB0cnVl77ya6LCD55SocGxheUNsb3Nl5pKt5pS+5by556qX5YWz6Zet5Yqo55S777ybZmFsc2XvvJrnm7TmjqXosIPnlKhjbG9zZeWFs+mXreW8ueeql1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xvc2VEaWFsb2codXJsOiBzdHJpbmcsIHBsYXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjbXB0ID0gdGhpcy5nZXREaWFsb2codXJsKTtcclxuICAgICAgICBpZiAoIWNtcHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwbGF5ID8gY21wdC5wbGF5Q2xvc2UoKSA6IGNtcHQuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWFs+mXreaJgOacieWQjOi3r+W+hOW8ueeql++8jOS4jeS8oOWPguWImeWFs+mXreaJgOacieW8ueeql1xyXG4gICAgICogQHBhcmFtIHVybCBwcmVmYWLot6/lvoTvvIzop4TliJnlkIxSZXPliqDovb3ot6/lvoRcclxuICAgICAqIEBwYXJhbSBwbGF5IHRydWXvvJrosIPnlKhwbGF5Q2xvc2Xmkq3mlL7lvLnnqpflhbPpl63liqjnlLvvvJtmYWxzZe+8muebtOaOpeiwg+eUqGNsb3Nl5YWz6Zet5by556qXXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbG9zZURpYWxvZ3ModXJsOiBzdHJpbmcgPSBcIlwiLCBwbGF5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kaWFsb2dMYXllci5jaGlsZHJlbkNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRpYWxvZ0xheWVyLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBsZXQgY21wdCA9IG5vZGUuZ2V0Q29tcG9uZW50KERpYWxvZ0Jhc2UpO1xyXG4gICAgICAgICAgICBpZiAoIWNtcHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXJsIHx8IGNtcHQucHJlZmFiVXJsID09PSB1cmwpIHtcclxuICAgICAgICAgICAgICAgIHBsYXkgPyBjbXB0LnBsYXlDbG9zZSgpIDogY21wdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5byC5q2l562J5b6F5by556qX5YWz6Zet77yI5Y+q562J5b6F6YGN5Y6G5Yiw55qE56ys5LiA5Liq77yJXHJcbiAgICAgKiBAcGFyYW0gdXJsIHByZWZhYui3r+W+hO+8jOinhOWImeWQjFJlc+WKoOi9vei3r+W+hFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgd2FpdENsb3NlRGlhbG9nKHVybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgbGV0IGNtcHQgPSB0aGlzLmdldERpYWxvZyh1cmwpO1xyXG4gICAgICAgIGlmICghY21wdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNtcHQuYWRkUmVzb2x2ZShyZXNvbHZlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOW8guatpeetieW+heaJgOacieWQjOi3r+W+hOW8ueeql+WFs+mXrVxyXG4gICAgICogQHBhcmFtIHVybCBwcmVmYWLot6/lvoTvvIzop4TliJnlkIxSZXPliqDovb3ot6/lvoRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHdhaXRDbG9zZURpYWxvZ3ModXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWRbXT4ge1xyXG4gICAgICAgIGxldCBhcnI6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpYWxvZ0xheWVyLmNoaWxkcmVuQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZGlhbG9nTGF5ZXIuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGxldCBjbXB0ID0gbm9kZS5nZXRDb21wb25lbnQoRGlhbG9nQmFzZSk7XHJcbiAgICAgICAgICAgIGlmICghY21wdCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNtcHQucHJlZmFiVXJsID09PSB1cmwpIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjbXB0LmFkZFJlc29sdmUocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGFycik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvLnlh7rkuIDmnaHmloflrZfmj5DnpLpcclxuICAgICAqIEBwYXJhbSBkYXRhIFRpcERhdGEgfCBzdHJpbmcg5o+Q56S65pWw5o2uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzaG93VGlwKGRhdGE6IFRpcERhdGEgfCBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyDlpITnkIZ0aXBEYXRh6buY6K6k5YC8XHJcbiAgICAgICAgbGV0IHRpcERhdGE6IFRpcERhdGEgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aXBEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogZGF0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRpcERhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRpcERhdGEuaGFzT3duUHJvcGVydHkoXCJ1bmlxdWVcIikpIHtcclxuICAgICAgICAgICAgdGlwRGF0YS51bmlxdWUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aXBEYXRhLmhhc093blByb3BlcnR5KFwiZHVyYXRpb25cIikpIHtcclxuICAgICAgICAgICAgdGlwRGF0YS5kdXJhdGlvbiA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGlwRGF0YS5oYXNPd25Qcm9wZXJ0eShcImZhZGVcIikpIHtcclxuICAgICAgICAgICAgdGlwRGF0YS5mYWRlID0gMC41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRpcERhdGEuaGFzT3duUHJvcGVydHkoXCJzdGFydFwiKSkge1xyXG4gICAgICAgICAgICB0aXBEYXRhLnN0YXJ0ID0gY2MudjIoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGlwRGF0YS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSkge1xyXG4gICAgICAgICAgICB0aXBEYXRhLmVuZCA9IGNjLnYyKDAsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5ZSv5LiA5pi+56S6XHJcbiAgICAgICAgaWYgKHRpcERhdGEudW5pcXVlICYmIFRvb2wuYXJyYXlIYXModGhpcy5fdGlwVGV4dHMsIHRpcERhdGEudGV4dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aXBUZXh0cy5wdXNoKHRpcERhdGEudGV4dCk7XHJcblxyXG4gICAgICAgIC8vIOiOt+WPluiKgueCuVxyXG4gICAgICAgIGxldCB0aXBOb2RlOiBjYy5Ob2RlID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5fdGlwUG9vbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRpcE5vZGUgPSB0aGlzLl90aXBQb29sLnNoaWZ0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHByZWZhYjogY2MuUHJlZmFiID0gYXdhaXQgUmVzLmxvYWQoUmVzVXJsLlBSRUZBQi5USVAsIGNjLlByZWZhYik7XHJcbiAgICAgICAgICAgIGlmICghcHJlZmFiKSB7XHJcbiAgICAgICAgICAgICAgICBjYy5lcnJvcihgW0xheWVyLnNob3dUaXBdIGNhbiBub3QgbG9hZCBwcmVmYWI6ICR7UmVzVXJsLlBSRUZBQi5USVB9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGlwTm9kZSA9IFJlcy5pbnN0YW50aWF0ZShwcmVmYWIpO1xyXG4gICAgICAgICAgICB0aGlzLnRpcExheWVyLmFkZENoaWxkKHRpcE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Yqo55S7XHJcbiAgICAgICAgbGV0IGRlbGF5ID0gY2MuZGVsYXlUaW1lKHRpcERhdGEuZHVyYXRpb24pO1xyXG4gICAgICAgIGxldCBmYWRlID0gY2MuZmFkZU91dCh0aXBEYXRhLmZhZGUpO1xyXG4gICAgICAgIGxldCBtb3ZlVG8gPSBjYy5tb3ZlVG8odGlwRGF0YS5mYWRlLCB0aXBEYXRhLmVuZCk7XHJcbiAgICAgICAgbGV0IGNhbGwgPSBjYy5jYWxsRnVuYygoKSA9PiB7XHJcbiAgICAgICAgICAgIHRpcE5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpcFBvb2wucHVzaCh0aXBOb2RlKTtcclxuICAgICAgICAgICAgVG9vbC5hcnJheURlbGV0ZSh0aGlzLl90aXBUZXh0cywgdGlwRGF0YS50ZXh0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aXBOb2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGlwTm9kZS5vcGFjaXR5ID0gMjU1O1xyXG4gICAgICAgIHRpcE5vZGUuc2V0UG9zaXRpb24odGlwRGF0YS5zdGFydCk7XHJcbiAgICAgICAgdGlwTm9kZS5zZXRTaWJsaW5nSW5kZXgodGhpcy50aXBMYXllci5jaGlsZHJlbkNvdW50IC0gMSk7XHJcbiAgICAgICAgdGlwTm9kZS5ydW5BY3Rpb24oY2Muc2VxdWVuY2UoZGVsYXksIGNjLnNwYXduKGZhZGUsIG1vdmVUbyksIGNhbGwpKTtcclxuXHJcbiAgICAgICAgLy8g5pWw5o2uXHJcbiAgICAgICAgdGlwTm9kZS5nZXRDb21wb25lbnQoVGlwKT8uaW5pdCh0aXBEYXRhLnRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65omA5pyJ5o+Q56S6XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhclRpcHMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fdGlwUG9vbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3RpcFRleHRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy50aXBMYXllci5kZXN0cm95QWxsQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gOWFqOWxgGxvYWRpbmfpga7nvanvvIjmiZPlvIDkuI7lhbPpl63nmoTosIPnlKjlv4XpobvkuIDkuIDlr7nlupTvvIlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dMb2FkaW5nKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCsrO1xyXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nTGF5ZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ0xheWVyLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIOm7mOiupDAuNXPlkI7miY3mmL7npLpsb2FkaW5n5YaF5a65XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5sb2FkaW5nTGF5ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJjb250ZW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zY2hlZHVsZUFsbENhbGxiYWNrcygpO1xyXG4gICAgICAgICAgICAgICAgVG9vbC53YWl0Q21wdCh0aGlzLCAwLjUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YWz6Zet5YWo5bGAbG9hZGluZ+mBrue9qVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGlkZUxvYWRpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ0NvdW50LS07XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdDb3VudCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ0xheWVyLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2NoZWR1bGVBbGxDYWxsYmFja3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/scrollList/LoopList.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '47957NchK9M3pnXr5DdUH/B', 'LoopList');
// scripts/common/cmpt/ui/scrollList/LoopList.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Res_1 = require("../../../util/Res");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, requireComponent = _a.requireComponent, disallowMultiple = _a.disallowMultiple, menu = _a.menu;
/** 列表元素模板类型 */
var TemplateType;
(function (TemplateType) {
    TemplateType[TemplateType["NODE"] = 0] = "NODE";
    TemplateType[TemplateType["PREFAB"] = 1] = "PREFAB";
})(TemplateType || (TemplateType = {}));
/**
 * 无限循环列表(轮播图)
 */
var LoopList = /** @class */ (function (_super) {
    __extends(LoopList, _super);
    function LoopList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.templateType = TemplateType.PREFAB;
        _this.templatePrefab = null;
        _this.templateNode = null;
        _this._firstDirty = false;
        _this._refreshDirty = false;
        /** 当前显示的数据下标 */
        _this._curIdx = 0;
        /** 所有item的中间节点下标 */
        _this._midIdx = 2;
        /** 实际需显示的数据长度 */
        _this._dataLen = 0;
        _this._refreshCall = null;
        _this._target = null;
        _this._pageView = null;
        return _this;
    }
    Object.defineProperty(LoopList.prototype, "pageView", {
        get: function () {
            if (!this._pageView) {
                this._pageView = this.getComponent(cc.PageView);
            }
            return this._pageView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LoopList.prototype, "view", {
        get: function () { return this.pageView.content.parent; },
        enumerable: false,
        configurable: true
    });
    LoopList.prototype.start = function () {
        // 注册事件
        this.node.on("scroll-ended", this.onScrollEnd, this);
    };
    LoopList.prototype.lateUpdate = function () {
        if (this.pageView.getPages().length === 0) {
            return;
        }
        if (this._firstDirty) {
            this._firstDirty = false;
            this.pageView.setContentPosition(cc.v2(-this.view.width / 2 - this._midIdx * this.view.width, 0));
            this.pageView.setCurrentPageIndex(this._midIdx);
        }
        if (this._refreshDirty) {
            this._refreshDirty = false;
            this.refresh();
        }
    };
    /**
     * 初始化循环列表
     * @param length 数据长度
     * @param curIdx 初始显示的数据
     * @param refreshCall 每个item刷新时的回调
     * @param target 调用refreshCall时的this
     */
    LoopList.prototype.onInit = function (length, curIdx, refreshCall, target) {
        if (target === void 0) { target = null; }
        this._dataLen = length;
        this._curIdx = cc.misc.clampf(curIdx, 0, this._dataLen - 1);
        this._refreshCall = refreshCall;
        this._target = target;
        this._firstDirty = true;
        this._refreshDirty = true;
        // 生成节点
        if (this.pageView.getPages().length === 0) {
            var tmp = this.templateType === TemplateType.PREFAB ? this.templatePrefab : this.templateNode;
            for (var i = 0; i < 5; i++) {
                var node = Res_1.default.instantiate(tmp, this.node);
                node.active = true;
                node.setPosition(0, 0);
                this.pageView.addPage(node);
            }
            this.pageView.content.getComponent(cc.Layout).updateLayout();
        }
    };
    /**
     * 重置数据长度与当前显示的数据下标
     */
    LoopList.prototype.resetData = function (length, curIdx) {
        if (curIdx === void 0) { curIdx = null; }
        this._dataLen = length;
        this._curIdx = cc.misc.clampf(curIdx === null ? this._curIdx : curIdx, 0, this._dataLen - 1);
        this._refreshDirty = true;
    };
    /**
     * 根据下标设置当前显示的数据
     */
    LoopList.prototype.setCurIdx = function (curIdx) {
        this._curIdx = curIdx;
        this._refreshDirty = true;
    };
    LoopList.prototype.onScrollEnd = function () {
        var cur = this.pageView.getCurrentPageIndex();
        if (cur === this._midIdx) {
            return;
        }
        this.pageView.setContentPosition(cc.v2(-this.view.width / 2 - this._midIdx * this.view.width, 0));
        this.pageView.setCurrentPageIndex(this._midIdx);
        this._curIdx += cur - this._midIdx;
        while (this._curIdx < 0) {
            this._curIdx += this._dataLen;
        }
        while (this._curIdx > this._dataLen - 1) {
            this._curIdx -= this._dataLen;
        }
        this._refreshDirty = true;
    };
    LoopList.prototype.refresh = function () {
        var _this = this;
        this.pageView.content.children.forEach(function (item, index) {
            var i = _this._curIdx - (_this._midIdx - index);
            while (i < 0) {
                i += _this._dataLen;
            }
            while (i > _this._dataLen - 1) {
                i -= _this._dataLen;
            }
            if (_this._refreshCall) {
                _this._refreshCall.call(_this._target, item, i, i === _this._curIdx);
            }
        });
    };
    /** item刷新事件 */
    LoopList.ITEM_REFRESH = "LoopList-itemRefresh";
    __decorate([
        property({
            type: cc.Enum(TemplateType),
            tooltip: CC_DEV && "列表元素模板类型"
        })
    ], LoopList.prototype, "templateType", void 0);
    __decorate([
        property({
            type: cc.Prefab,
            tooltip: CC_DEV && "列表元素模板预制体",
            visible: function () { return this.templateType === TemplateType.PREFAB; }
        })
    ], LoopList.prototype, "templatePrefab", void 0);
    __decorate([
        property({
            type: cc.Node,
            tooltip: CC_DEV && "列表元素模板节点",
            visible: function () { return this.templateType === TemplateType.NODE; }
        })
    ], LoopList.prototype, "templateNode", void 0);
    LoopList = __decorate([
        ccclass,
        disallowMultiple,
        requireComponent(cc.PageView),
        menu("Framework/UI组件/LoopList")
    ], LoopList);
    return LoopList;
}(cc.Component));
exports.default = LoopList;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcc2Nyb2xsTGlzdFxcTG9vcExpc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQW9DO0FBRTlCLElBQUEsS0FBa0UsRUFBRSxDQUFDLFVBQVUsRUFBN0UsT0FBTyxhQUFBLEVBQUUsUUFBUSxjQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsZ0JBQWdCLHNCQUFBLEVBQUUsSUFBSSxVQUFrQixDQUFDO0FBRXRGLGVBQWU7QUFDZixJQUFLLFlBR0o7QUFIRCxXQUFLLFlBQVk7SUFDYiwrQ0FBSSxDQUFBO0lBQ0osbURBQU0sQ0FBQTtBQUNWLENBQUMsRUFISSxZQUFZLEtBQVosWUFBWSxRQUdoQjtBQUVEOztHQUVHO0FBS0g7SUFBc0MsNEJBQVk7SUFBbEQ7UUFBQSxxRUE4SUM7UUF0SVUsa0JBQVksR0FBaUIsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQU9qRCxvQkFBYyxHQUFjLElBQUksQ0FBQztRQU9qQyxrQkFBWSxHQUFZLElBQUksQ0FBQztRQUU1QixpQkFBVyxHQUFZLEtBQUssQ0FBQztRQUM3QixtQkFBYSxHQUFZLEtBQUssQ0FBQztRQUN2QyxnQkFBZ0I7UUFDUixhQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLG9CQUFvQjtRQUNaLGFBQU8sR0FBRyxDQUFDLENBQUM7UUFDcEIsaUJBQWlCO1FBQ1QsY0FBUSxHQUFHLENBQUMsQ0FBQztRQUNiLGtCQUFZLEdBQXlELElBQUksQ0FBQztRQUMxRSxhQUFPLEdBQVEsSUFBSSxDQUFDO1FBRXBCLGVBQVMsR0FBZ0IsSUFBSSxDQUFDOztJQTJHMUMsQ0FBQztJQTFHRyxzQkFBVyw4QkFBUTthQUFuQjtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNqQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFD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O1lBQ04sSUFBSSxFQUFFLEVBQUUsQ0FBQyxNQUFNO1lBQ2YsT0FBTyxFQUFFLE1BQU0sSUFBSSxXQUFXO1lBQzlCLE9BQU8sZ0JBQUssT0FBTyxJQUFJLENBQUMsWUFBWSxLQUFLLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ2xFLENBQUM7b0RBQ3NDO0lBT3hDO1FBTEMsUUFBUSxDQUFDO1lBQ04sSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO1lBQ2IsT0FBTyxFQUFFLE1BQU0sSUFBSSxVQUFVO1lBQzdCLE9BQU8sZ0JBQUssT0FBTyxJQUFJLENBQUMsWUFBWSxLQUFLLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2hFLENBQUM7a0RBQ2tDO0lBdEJuQixRQUFRO1FBSjVCLE9BQU87UUFDUCxnQkFBZ0I7UUFDaEIsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztRQUM3QixJQUFJLENBQUMseUJBQXlCLENBQUM7T0FDWCxRQUFRLENBOEk1QjtJQUFELGVBQUM7Q0E5SUQsQUE4SUMsQ0E5SXFDLEVBQUUsQ0FBQyxTQUFTLEdBOElqRDtrQkE5SW9CLFFBQVEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVzIGZyb20gXCIuLi8uLi8uLi91dGlsL1Jlc1wiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSwgcmVxdWlyZUNvbXBvbmVudCwgZGlzYWxsb3dNdWx0aXBsZSwgbWVudSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKiDliJfooajlhYPntKDmqKHmnb/nsbvlnosgKi9cclxuZW51bSBUZW1wbGF0ZVR5cGUge1xyXG4gICAgTk9ERSxcclxuICAgIFBSRUZBQlxyXG59XHJcblxyXG4vKipcclxuICog5peg6ZmQ5b6q546v5YiX6KGoKOi9ruaSreWbvilcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbkByZXF1aXJlQ29tcG9uZW50KGNjLlBhZ2VWaWV3KVxyXG5AbWVudShcIkZyYW1ld29yay9VSee7hOS7ti9Mb29wTGlzdFwiKVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb29wTGlzdCBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcbiAgICAvKiogaXRlbeWIt+aWsOS6i+S7tiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJVEVNX1JFRlJFU0g6IHN0cmluZyA9IFwiTG9vcExpc3QtaXRlbVJlZnJlc2hcIjtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLkVudW0oVGVtcGxhdGVUeXBlKSxcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajlhYPntKDmqKHmnb/nsbvlnotcIlxyXG4gICAgfSlcclxuICAgIHB1YmxpYyB0ZW1wbGF0ZVR5cGU6IFRlbXBsYXRlVHlwZSA9IFRlbXBsYXRlVHlwZS5QUkVGQUI7XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBjYy5QcmVmYWIsXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwi5YiX6KGo5YWD57Sg5qih5p2/6aKE5Yi25L2TXCIsXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudGVtcGxhdGVUeXBlID09PSBUZW1wbGF0ZVR5cGUuUFJFRkFCOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIHRlbXBsYXRlUHJlZmFiOiBjYy5QcmVmYWIgPSBudWxsO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuTm9kZSxcclxuICAgICAgICB0b29sdGlwOiBDQ19ERVYgJiYgXCLliJfooajlhYPntKDmqKHmnb/oioLngrlcIixcclxuICAgICAgICB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50ZW1wbGF0ZVR5cGUgPT09IFRlbXBsYXRlVHlwZS5OT0RFOyB9XHJcbiAgICB9KVxyXG4gICAgcHVibGljIHRlbXBsYXRlTm9kZTogY2MuTm9kZSA9IG51bGw7XHJcblxyXG4gICAgcHJpdmF0ZSBfZmlyc3REaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfcmVmcmVzaERpcnR5OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAvKiog5b2T5YmN5pi+56S655qE5pWw5o2u5LiL5qCHICovXHJcbiAgICBwcml2YXRlIF9jdXJJZHggPSAwO1xyXG4gICAgLyoqIOaJgOaciWl0ZW3nmoTkuK3pl7ToioLngrnkuIvmoIcgKi9cclxuICAgIHByaXZhdGUgX21pZElkeCA9IDI7XHJcbiAgICAvKiog5a6e6ZmF6ZyA5pi+56S655qE5pWw5o2u6ZW/5bqmICovXHJcbiAgICBwcml2YXRlIF9kYXRhTGVuID0gMDtcclxuICAgIHByaXZhdGUgX3JlZnJlc2hDYWxsOiAobm9kZTogY2MuTm9kZSwgaWR4OiBudW1iZXIsIGlzQ3VyOiBib29sZWFuKSA9PiB2b2lkID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3RhcmdldDogYW55ID0gbnVsbDtcclxuXHJcbiAgICBwcml2YXRlIF9wYWdlVmlldzogY2MuUGFnZVZpZXcgPSBudWxsO1xyXG4gICAgcHVibGljIGdldCBwYWdlVmlldygpOiBjYy5QYWdlVmlldyB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wYWdlVmlldykge1xyXG4gICAgICAgICAgICB0aGlzLl9wYWdlVmlldyA9IHRoaXMuZ2V0Q29tcG9uZW50KGNjLlBhZ2VWaWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VWaWV3O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdmlldygpOiBjYy5Ob2RlIHsgcmV0dXJuIHRoaXMucGFnZVZpZXcuY29udGVudC5wYXJlbnQ7IH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgLy8g5rOo5YaM5LqL5Lu2XHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKFwic2Nyb2xsLWVuZGVkXCIsIHRoaXMub25TY3JvbGxFbmQsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBsYXRlVXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnBhZ2VWaWV3LmdldFBhZ2VzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0RGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3REaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VWaWV3LnNldENvbnRlbnRQb3NpdGlvbihjYy52MigtdGhpcy52aWV3LndpZHRoIC8gMiAtIHRoaXMuX21pZElkeCAqIHRoaXMudmlldy53aWR0aCwgMCkpO1xyXG4gICAgICAgICAgICB0aGlzLnBhZ2VWaWV3LnNldEN1cnJlbnRQYWdlSW5kZXgodGhpcy5fbWlkSWR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZnJlc2hEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW5b6q546v5YiX6KGoXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIOaVsOaNrumVv+W6plxyXG4gICAgICogQHBhcmFtIGN1cklkeCDliJ3lp4vmmL7npLrnmoTmlbDmja5cclxuICAgICAqIEBwYXJhbSByZWZyZXNoQ2FsbCDmr4/kuKppdGVt5Yi35paw5pe255qE5Zue6LCDXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IOiwg+eUqHJlZnJlc2hDYWxs5pe255qEdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25Jbml0KGxlbmd0aDogbnVtYmVyLCBjdXJJZHg6IG51bWJlciwgcmVmcmVzaENhbGw6IChub2RlOiBjYy5Ob2RlLCBpZHg6IG51bWJlciwgaXNDdXI6IGJvb2xlYW4pID0+IHZvaWQsIHRhcmdldDogYW55ID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2RhdGFMZW4gPSBsZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fY3VySWR4ID0gY2MubWlzYy5jbGFtcGYoY3VySWR4LCAwLCB0aGlzLl9kYXRhTGVuIC0gMSk7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaENhbGwgPSByZWZyZXNoQ2FsbDtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fZmlyc3REaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaERpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8g55Sf5oiQ6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMucGFnZVZpZXcuZ2V0UGFnZXMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbGV0IHRtcDogYW55ID0gdGhpcy50ZW1wbGF0ZVR5cGUgPT09IFRlbXBsYXRlVHlwZS5QUkVGQUIgPyB0aGlzLnRlbXBsYXRlUHJlZmFiIDogdGhpcy50ZW1wbGF0ZU5vZGU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IFJlcy5pbnN0YW50aWF0ZSh0bXAsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldFBvc2l0aW9uKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlVmlldy5hZGRQYWdlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFnZVZpZXcuY29udGVudC5nZXRDb21wb25lbnQoY2MuTGF5b3V0KS51cGRhdGVMYXlvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDph43nva7mlbDmja7plb/luqbkuI7lvZPliY3mmL7npLrnmoTmlbDmja7kuIvmoIdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0RGF0YShsZW5ndGg6IG51bWJlciwgY3VySWR4OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fZGF0YUxlbiA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLl9jdXJJZHggPSBjYy5taXNjLmNsYW1wZihjdXJJZHggPT09IG51bGwgPyB0aGlzLl9jdXJJZHggOiBjdXJJZHgsIDAsIHRoaXMuX2RhdGFMZW4gLSAxKTtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5LiL5qCH6K6+572u5b2T5YmN5pi+56S655qE5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDdXJJZHgoY3VySWR4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9jdXJJZHggPSBjdXJJZHg7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uU2Nyb2xsRW5kKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjdXIgPSB0aGlzLnBhZ2VWaWV3LmdldEN1cnJlbnRQYWdlSW5kZXgoKTtcclxuICAgICAgICBpZiAoY3VyID09PSB0aGlzLl9taWRJZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhZ2VWaWV3LnNldENvbnRlbnRQb3NpdGlvbihjYy52MigtdGhpcy52aWV3LndpZHRoIC8gMiAtIHRoaXMuX21pZElkeCAqIHRoaXMudmlldy53aWR0aCwgMCkpO1xyXG4gICAgICAgIHRoaXMucGFnZVZpZXcuc2V0Q3VycmVudFBhZ2VJbmRleCh0aGlzLl9taWRJZHgpO1xyXG4gICAgICAgIHRoaXMuX2N1cklkeCArPSBjdXIgLSB0aGlzLl9taWRJZHg7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cklkeCA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VySWR4ICs9IHRoaXMuX2RhdGFMZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJJZHggPiB0aGlzLl9kYXRhTGVuIC0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJJZHggLT0gdGhpcy5fZGF0YUxlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlZnJlc2goKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYWdlVmlldy5jb250ZW50LmNoaWxkcmVuLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5fY3VySWR4IC0gKHRoaXMuX21pZElkeCAtIGluZGV4KTtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpICs9IHRoaXMuX2RhdGFMZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGkgPiB0aGlzLl9kYXRhTGVuIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaSAtPSB0aGlzLl9kYXRhTGVuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVmcmVzaENhbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hDYWxsLmNhbGwodGhpcy5fdGFyZ2V0LCBpdGVtLCBpLCBpID09PSB0aGlzLl9jdXJJZHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/config/En.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e1a79yRjpZFiZ8ShC5YIRcu', 'En');
// scripts/common/config/En.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    lang: "English",
    text1: "number: %{num}",
    text2: "param1: %{arg1}, param2: %{arg2}"
};

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjb25maWdcXEVuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0JBQWU7SUFDWCxJQUFJLEVBQUUsU0FBUztJQUNmLEtBQUssRUFBRSxnQkFBZ0I7SUFDdkIsS0FBSyxFQUFFLGtDQUFrQztDQUM1QyxDQUFDIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbGFuZzogXCJFbmdsaXNoXCIsXHJcbiAgICB0ZXh0MTogXCJudW1iZXI6ICV7bnVtfVwiLFxyXG4gICAgdGV4dDI6IFwicGFyYW0xOiAle2FyZzF9LCBwYXJhbTI6ICV7YXJnMn1cIlxyXG59O1xyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/scrollList/VirtualLayout.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '23c51D+ML1JI7Nz58WdBOmf', 'VirtualLayout');
// scripts/common/cmpt/ui/scrollList/VirtualLayout.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Res_1 = require("../../../util/Res");
var Tool_1 = require("../../../util/Tool");
var VirtualItem_1 = require("./VirtualItem");
var VirtualList_1 = require("./VirtualList");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, disallowMultiple = _a.disallowMultiple;
/**
 * 布局模式
 */
var LayoutType;
(function (LayoutType) {
    /** 横向 */
    LayoutType[LayoutType["HORIZONTAL"] = 0] = "HORIZONTAL";
    /** 纵向 */
    LayoutType[LayoutType["VERTICAL"] = 1] = "VERTICAL";
    /** 网格 */
    LayoutType[LayoutType["GRID"] = 2] = "GRID";
})(LayoutType || (LayoutType = {}));
/**
 * 布局轴向，只用于GRID布局。
 */
var AxisDirection;
(function (AxisDirection) {
    AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
    AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
})(AxisDirection || (AxisDirection = {}));
/**
 * 纵向排列方向
 */
var VerticalDirection;
(function (VerticalDirection) {
    VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 0] = "TOP_TO_BOTTOM";
    VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 1] = "BOTTOM_TO_TOP";
})(VerticalDirection || (VerticalDirection = {}));
/**
 * 横向排列方向
 */
var HorizontalDirection;
(function (HorizontalDirection) {
    HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
    HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
})(HorizontalDirection || (HorizontalDirection = {}));
/**
 * 虚拟列表所需的布局组件
 */
var VirtualLayout = /** @class */ (function (_super) {
    __extends(VirtualLayout, _super);
    function VirtualLayout() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = LayoutType.VERTICAL;
        _this.startAxis = AxisDirection.HORIZONTAL;
        _this.left = 0;
        _this.right = 0;
        _this.top = 0;
        _this.bottom = 0;
        _this.spacingX = 0;
        _this.spacingY = 0;
        _this.verticalDirection = VerticalDirection.TOP_TO_BOTTOM;
        _this.horizontalDirection = HorizontalDirection.LEFT_TO_RIGHT;
        /** 所属虚拟列表 */
        _this._list = null;
        /** mask节点（content父节点） */
        _this._view = null;
        /** view坐标系下view的边界矩形 */
        _this._viewEdge = null;
        /** 元素节点大小固定时的size */
        _this._fixedSize = null;
        /** 标记当前帧是否需要更新content size */
        _this._sizeDirty = false;
        /** 标记当前帧是否需要更新view区域数据显示 */
        _this._viewDirty = false;
        /** 标记当前帧是否需要同步others content的坐标 */
        _this._posDirty = false;
        /** main content激活状态的item */
        _this._items = [];
        /** main content被回收的item池（不移出节点树，只设置opacity） */
        _this._itemPool = [];
        /** others content激活状态的item，下标顺序与this.list.Others数组一致 */
        _this._otherItemsArr = [];
        /** others content被回收的item池数组（不移出节点树，只设置opacity），下标顺序与this.list.Others数组一致 */
        _this._otherItemPoolArr = [];
        return _this;
    }
    VirtualLayout.prototype.onInit = function (list) {
        var _this = this;
        this._list = list;
        this._view = this.node.parent;
        this._viewEdge = this.getNodeEdgeRect(this._view);
        // 初始化分层相关数据
        this._otherItemsArr = [];
        this._otherItemPoolArr = [];
        this._list.others.forEach(function (e) {
            _this._otherItemsArr.push([]);
            _this._otherItemPoolArr.push([]);
        });
        // 元素大小固定时初始化fixedSize
        if (this._fixedSize === null) {
            this.addItemNode(false);
            this._fixedSize = this._itemPool[0].getContentSize();
        }
        // 注册事件
        this.node.on(cc.Node.EventType.POSITION_CHANGED, this.onPositionChanged, this);
        this._view.on(cc.Node.EventType.SIZE_CHANGED, this.onViewSizeChanged, this);
    };
    VirtualLayout.prototype.onDestroy = function () {
        // 注销事件
        this.node.off(cc.Node.EventType.POSITION_CHANGED, this.onPositionChanged, this);
        this._view.off(cc.Node.EventType.SIZE_CHANGED, this.onViewSizeChanged, this);
    };
    /**
     * 立即更新布局
     */
    VirtualLayout.prototype.forceUpdate = function () {
        this.updatePos();
        this.updateSize();
        this.updateView();
    };
    VirtualLayout.prototype.lateUpdate = function () {
        this.forceUpdate();
    };
    /**
     * 同步others的坐标
     */
    VirtualLayout.prototype.updatePos = function () {
        var _this = this;
        if (!this._posDirty) {
            return;
        }
        this._posDirty = false;
        this._list.others.forEach(function (e) {
            e.content.position = _this.node.position;
        });
    };
    /**
     * 更新content size
     */
    VirtualLayout.prototype.updateSize = function () {
        if (!this._sizeDirty) {
            return;
        }
        this._sizeDirty = false;
        if (this._list.isFixedSize) {
            this.updateSizeFixed();
        }
        else {
            this.updateSizeUnfixed();
        }
    };
    VirtualLayout.prototype.updateSizeFixed = function () {
        if (this.type === LayoutType.VERTICAL) {
            if (this._list.argsArr.length <= 0) {
                this.node.height = 0;
                return;
            }
            this.node.height = this.top + this.bottom + (this._list.argsArr.length - 1) * this.spacingY + this._fixedSize.height * this._list.argsArr.length;
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            if (this._list.argsArr.length <= 0) {
                this.node.width = 0;
                return;
            }
            this.node.width = this.left + this.right + (this._list.argsArr.length - 1) * this.spacingX + this._fixedSize.width * this._list.argsArr.length;
        }
        else {
            if (this.startAxis === AxisDirection.HORIZONTAL) {
                if (this._list.argsArr.length <= 0) {
                    this.node.height = 0;
                    return;
                }
                // 计算一行可以排列几个，至少1个
                var num = Math.floor((this.node.width - this.left - this.right + this.spacingX) / (this._fixedSize.width + this.spacingX));
                num = Math.max(num, 1);
                // 计算可以排列几行
                var row = Math.ceil(this._list.argsArr.length / num);
                // 高度
                this.node.height = this.top + this.bottom + (row - 1) * this.spacingY + this._fixedSize.height * row;
            }
            else {
                if (this._list.argsArr.length <= 0) {
                    this.node.width = 0;
                    return;
                }
                // 计算一列可以排列几个，至少1个
                var num = Math.floor((this.node.height - this.top - this.bottom + this.spacingY) / (this._fixedSize.height + this.spacingY));
                num = Math.max(num, 1);
                // 计算可以排列几列
                var column = Math.ceil(this._list.argsArr.length / num);
                // 宽度
                this.node.width = this.left + this.right + (column - 1) * this.spacingX + this._fixedSize.width * column;
            }
        }
    };
    VirtualLayout.prototype.updateSizeUnfixed = function () {
        // 缓存宽高，最后赋值，是因为修改content size时会触发scrollview._calculateBoundary，改变content的坐标
        var result = 0;
        if (this.type === LayoutType.VERTICAL) {
            if (this._list.argsArr.length <= 0) {
                this.node.height = 0;
                return;
            }
            result = this.top + this.bottom + (this._list.argsArr.length - 1) * this.spacingY;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var size = this.calcItemSizeUnfixed(i);
                result += size.height;
            }
            this.node.height = result;
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            if (this._list.argsArr.length <= 0) {
                this.node.width = 0;
                return;
            }
            result = this.left + this.right + (this._list.argsArr.length - 1) * this.spacingX;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var size = this.calcItemSizeUnfixed(i);
                result += size.width;
            }
            this.node.width = result;
        }
    };
    /**
     * 更新view区域数据显示
     */
    VirtualLayout.prototype.updateView = function () {
        if (!this._viewDirty || this._list.argsArr.length <= 0) {
            return;
        }
        this._viewDirty = false;
        if (this._list.isFixedSize) {
            this.updateViewFixed();
        }
        else {
            this.updateViewUnfixed();
        }
    };
    VirtualLayout.prototype.updateViewFixed = function () {
        var _this = this;
        var viewResult = this.checkViewItem();
        var inView = viewResult.inView;
        var outView = viewResult.outView;
        var contentEdge = this.getNodeEdgeRect(this.node);
        var xMax, xMin, yMax, yMin;
        if (this.type === LayoutType.VERTICAL) {
            var _loop_1 = function (i) {
                if (this_1.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    yMax = contentEdge.yMax - (this_1.top + i * this_1.spacingY + this_1._fixedSize.height * i);
                    yMin = yMax - this_1._fixedSize.height;
                    if (yMax + this_1.node.y < this_1._viewEdge.yMin) {
                        return "break";
                    }
                    if (yMin + this_1.node.y > this_1._viewEdge.yMax) {
                        return "continue";
                    }
                }
                else {
                    yMin = contentEdge.yMin + this_1.bottom + i * this_1.spacingY + this_1._fixedSize.height * i;
                    yMax = yMin + this_1._fixedSize.height;
                    if (yMin + this_1.node.y > this_1._viewEdge.yMax) {
                        return "break";
                    }
                    if (yMax + this_1.node.y < this_1._viewEdge.yMin) {
                        return "continue";
                    }
                }
                // 判断显示区域内部是否有节点显示此条数据
                var found = inView.findIndex(function (e) { return _this._items[e].getComponent(VirtualItem_1.default).dataIdx === i; });
                if (found !== -1) {
                    return "continue";
                }
                // 没有节点显示此条数据，需使用显示区域外的节点显示此条数据
                var itemIdx = outView.length === 0 ? this_1.addItemNode() : outView.shift();
                var item = this_1._items[itemIdx];
                this_1.setItem(cc.v3(0, yMin + item.anchorY * item.height), i, itemIdx);
            };
            var this_1 = this;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var state_1 = _loop_1(i);
                if (state_1 === "break")
                    break;
            }
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            var _loop_2 = function (i) {
                if (this_2.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    xMax = contentEdge.xMax - (this_2.right + i * this_2.spacingX + this_2._fixedSize.width * i);
                    xMin = xMax - this_2._fixedSize.width;
                    if (xMax + this_2.node.x < this_2._viewEdge.xMin) {
                        return "break";
                    }
                    if (xMin + this_2.node.x > this_2._viewEdge.xMax) {
                        return "continue";
                    }
                }
                else {
                    xMin = contentEdge.xMin + this_2.left + i * this_2.spacingX + this_2._fixedSize.width * i;
                    xMax = xMin + this_2._fixedSize.width;
                    if (xMin + this_2.node.x > this_2._viewEdge.xMax) {
                        return "break";
                    }
                    if (xMax + this_2.node.x < this_2._viewEdge.xMin) {
                        return "continue";
                    }
                }
                // 判断显示区域内部是否有节点显示此条数据
                var found = inView.findIndex(function (e) { return _this._items[e].getComponent(VirtualItem_1.default).dataIdx === i; });
                if (found !== -1) {
                    return "continue";
                }
                // 没有节点显示此条数据，需使用显示区域外的节点显示此条数据
                var itemIdx = outView.length === 0 ? this_2.addItemNode() : outView.shift();
                var item = this_2._items[itemIdx];
                this_2.setItem(cc.v3(xMin + item.anchorX * item.width, 0), i, itemIdx);
            };
            var this_2 = this;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var state_2 = _loop_2(i);
                if (state_2 === "break")
                    break;
            }
        }
        else {
            var _loop_3 = function (i) {
                // 计算当前元素排在第几行第几列，从0开始
                var rowIndex = 0;
                var columnIndex = 0;
                if (this_3.startAxis === AxisDirection.HORIZONTAL) {
                    // 起始轴为横向
                    var num = Math.floor((this_3.node.width - this_3.left - this_3.right + this_3.spacingX) / (this_3._fixedSize.width + this_3.spacingX));
                    num = Math.max(num, 1);
                    rowIndex = Math.floor(i / num);
                    columnIndex = i % num;
                    // 计算纵向
                    if (this_3.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                        yMax = contentEdge.yMax - (this_3.top + rowIndex * this_3.spacingY + this_3._fixedSize.height * rowIndex);
                        yMin = yMax - this_3._fixedSize.height;
                        if (yMax + this_3.node.y < this_3._viewEdge.yMin) {
                            return "break";
                        }
                        if (yMin + this_3.node.y > this_3._viewEdge.yMax) {
                            return "continue";
                        }
                    }
                    else {
                        yMin = contentEdge.yMin + this_3.bottom + rowIndex * this_3.spacingY + this_3._fixedSize.height * rowIndex;
                        yMax = yMin + this_3._fixedSize.height;
                        if (yMin + this_3.node.y > this_3._viewEdge.yMax) {
                            return "break";
                        }
                        if (yMax + this_3.node.y < this_3._viewEdge.yMin) {
                            return "continue";
                        }
                    }
                    // 计算横向
                    if (this_3.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                        xMax = contentEdge.xMax - (this_3.right + columnIndex * this_3.spacingX + this_3._fixedSize.width * columnIndex);
                        xMin = xMax - this_3._fixedSize.width;
                    }
                    else {
                        xMin = contentEdge.xMin + this_3.left + columnIndex * this_3.spacingX + this_3._fixedSize.width * columnIndex;
                        xMax = xMin + this_3._fixedSize.width;
                    }
                    if (xMax + this_3.node.x < this_3._viewEdge.xMin || xMin + this_3.node.x > this_3._viewEdge.xMax) {
                        return "continue";
                    }
                }
                else {
                    // 起始轴为纵向
                    var num = Math.floor((this_3.node.height - this_3.top - this_3.bottom + this_3.spacingY) / (this_3._fixedSize.height + this_3.spacingY));
                    num = Math.max(num, 1);
                    rowIndex = i % num;
                    columnIndex = Math.floor(i / num);
                    // 计算横向
                    if (this_3.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                        xMax = contentEdge.xMax - (this_3.right + columnIndex * this_3.spacingX + this_3._fixedSize.width * columnIndex);
                        xMin = xMax - this_3._fixedSize.width;
                        if (xMax + this_3.node.x < this_3._viewEdge.xMin) {
                            return "break";
                        }
                        if (xMin + this_3.node.x > this_3._viewEdge.xMax) {
                            return "continue";
                        }
                    }
                    else {
                        xMin = contentEdge.xMin + this_3.left + columnIndex * this_3.spacingX + this_3._fixedSize.width * columnIndex;
                        xMax = xMin + this_3._fixedSize.width;
                        if (xMin + this_3.node.x > this_3._viewEdge.xMax) {
                            return "break";
                        }
                        if (xMax + this_3.node.x < this_3._viewEdge.xMin) {
                            return "continue";
                        }
                    }
                    // 计算纵向
                    if (this_3.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                        yMax = contentEdge.yMax - (this_3.top + rowIndex * this_3.spacingY + this_3._fixedSize.height * rowIndex);
                        yMin = yMax - this_3._fixedSize.height;
                    }
                    else {
                        yMin = contentEdge.yMin + this_3.bottom + rowIndex * this_3.spacingY + this_3._fixedSize.height * rowIndex;
                        yMax = yMin + this_3._fixedSize.height;
                    }
                    if (yMax + this_3.node.y < this_3._viewEdge.yMin || yMin + this_3.node.y > this_3._viewEdge.yMax) {
                        return "continue";
                    }
                }
                // 判断显示区域内部是否有节点显示此条数据
                var found = inView.findIndex(function (e) { return _this._items[e].getComponent(VirtualItem_1.default).dataIdx === i; });
                if (found !== -1) {
                    return "continue";
                }
                // 没有节点显示此条数据，需使用显示区域外的节点显示此条数据
                var itemIdx = outView.length === 0 ? this_3.addItemNode() : outView.shift();
                var item = this_3._items[itemIdx];
                this_3.setItem(cc.v3(xMin + item.anchorX * item.width, yMin + item.anchorY * item.height), i, itemIdx);
            };
            var this_3 = this;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var state_3 = _loop_3(i);
                if (state_3 === "break")
                    break;
            }
        }
        // 回收区域外的节点
        for (var i = outView.length - 1; i >= 0; i--) {
            this.putActivatedItemByIndex(outView[i]);
        }
    };
    VirtualLayout.prototype.updateViewUnfixed = function () {
        var _this = this;
        var viewResult = this.checkViewItem();
        var inView = viewResult.inView;
        var outView = viewResult.outView;
        var contentEdge = this.getNodeEdgeRect(this.node);
        var xMax, xMin, yMax, yMin;
        if (this.type === LayoutType.VERTICAL) {
            var totalHeight = 0;
            var _loop_4 = function (i) {
                var size = this_4.calcItemSizeUnfixed(i);
                totalHeight += size.height;
                if (this_4.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    yMax = contentEdge.yMax - (this_4.top + i * this_4.spacingY + (totalHeight - size.height));
                    yMin = yMax - size.height;
                    if (yMax + this_4.node.y < this_4._viewEdge.yMin) {
                        return "break";
                    }
                    if (yMin + this_4.node.y > this_4._viewEdge.yMax) {
                        return "continue";
                    }
                }
                else {
                    yMin = contentEdge.yMin + this_4.bottom + i * this_4.spacingY + (totalHeight - size.height);
                    yMax = yMin + size.height;
                    if (yMin + this_4.node.y > this_4._viewEdge.yMax) {
                        return "break";
                    }
                    if (yMax + this_4.node.y < this_4._viewEdge.yMin) {
                        return "continue";
                    }
                }
                // 判断显示区域内部是否有节点显示此条数据
                var found = inView.findIndex(function (e) { return _this._items[e].getComponent(VirtualItem_1.default).dataIdx === i; });
                if (found !== -1) {
                    return "continue";
                }
                // 没有节点显示此条数据，需使用显示区域外的节点显示此条数据
                var itemIdx = outView.length === 0 ? this_4.addItemNode() : outView.shift();
                var item = this_4._items[itemIdx];
                item.setContentSize(size);
                this_4.setItem(cc.v3(0, yMin + item.anchorY * size.height), i, itemIdx);
            };
            var this_4 = this;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var state_4 = _loop_4(i);
                if (state_4 === "break")
                    break;
            }
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            var totalWidth = 0;
            var _loop_5 = function (i) {
                var size = this_5.calcItemSizeUnfixed(i);
                totalWidth += size.width;
                if (this_5.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    xMax = contentEdge.xMax - (this_5.right + i * this_5.spacingX + (totalWidth - size.width));
                    xMin = xMax - size.width;
                    if (xMax + this_5.node.x < this_5._viewEdge.xMin) {
                        return "break";
                    }
                    if (xMin + this_5.node.x > this_5._viewEdge.xMax) {
                        return "continue";
                    }
                }
                else {
                    xMin = contentEdge.xMin + this_5.left + i * this_5.spacingX + (totalWidth - size.width);
                    xMax = xMin + size.width;
                    if (xMin + this_5.node.x > this_5._viewEdge.xMax) {
                        return "break";
                    }
                    if (xMax + this_5.node.x < this_5._viewEdge.xMin) {
                        return "continue";
                    }
                }
                // 判断显示区域内部是否有节点显示此条数据
                var found = inView.findIndex(function (e) { return _this._items[e].getComponent(VirtualItem_1.default).dataIdx === i; });
                if (found !== -1) {
                    return "continue";
                }
                // 没有节点显示此条数据，需使用显示区域外的节点显示此条数据
                var itemIdx = outView.length === 0 ? this_5.addItemNode() : outView.shift();
                var item = this_5._items[itemIdx];
                item.setContentSize(size);
                this_5.setItem(cc.v3(xMin + item.anchorX * size.width, 0), i, itemIdx);
            };
            var this_5 = this;
            for (var i = 0; i < this._list.argsArr.length; i++) {
                var state_5 = _loop_5(i);
                if (state_5 === "break")
                    break;
            }
        }
        // 回收区域外的节点
        for (var i = outView.length - 1; i >= 0; i--) {
            this.putActivatedItemByIndex(outView[i]);
        }
    };
    /**
     * 区分在view内部与外部的items数组下标（返回的下标数组会从小到大排序）
     */
    VirtualLayout.prototype.checkViewItem = function () {
        // 显示区域内部的下标
        var inView = [];
        // 显示区域外部的下标
        var outView = [];
        if (this.type === LayoutType.VERTICAL) {
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                var box = item.getBoundingBox();
                if (box.yMin + this.node.y <= this._viewEdge.yMax && box.yMax + this.node.y >= this._viewEdge.yMin) {
                    inView.push(i);
                }
                else {
                    outView.push(i);
                }
            }
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                var box = item.getBoundingBox();
                if (box.xMin + this.node.x <= this._viewEdge.xMax && box.xMax + this.node.x >= this._viewEdge.xMin) {
                    inView.push(i);
                }
                else {
                    outView.push(i);
                }
            }
        }
        else {
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                var box = item.getBoundingBox();
                if (box.xMin + this.node.x <= this._viewEdge.xMax && box.xMax + this.node.x >= this._viewEdge.xMin
                    && box.yMin + this.node.y <= this._viewEdge.yMax && box.yMax + this.node.y >= this._viewEdge.yMin) {
                    inView.push(i);
                }
                else {
                    outView.push(i);
                }
            }
        }
        return { inView: inView, outView: outView };
    };
    /**
     * 设置item数据与坐标
     * @param p 节点坐标
     * @param dataIdx this._dataArr的下标
     * @param itemIdx this._items的下标
     */
    VirtualLayout.prototype.setItem = function (p, dataIdx, itemIdx) {
        var item = this._items[itemIdx];
        item.position = p;
        var vi = item.getComponent(VirtualItem_1.default);
        vi.dataIdx = dataIdx;
        vi.args = this._list.argsArr[dataIdx];
        vi.onRefresh(vi.args);
        if (this._list.others.length > 0) {
            var nodes_1 = [];
            this._otherItemsArr.forEach(function (e) {
                e[itemIdx].position = p;
                nodes_1.push(e[itemIdx]);
            });
            vi.others = nodes_1;
            vi.onRefreshOthers.apply(vi, vi.others);
        }
    };
    /**
     * 激活新的节点，并添加到content下
     * @param show 默认为true。false时不激活节点并添加进节点池中（仅在onInit中使用）
     * @returns 激活的节点在this._items中的下标
     */
    VirtualLayout.prototype.addItemNode = function (show) {
        var _this = this;
        if (show === void 0) { show = true; }
        var node = null;
        if (this._itemPool.length > 0) {
            node = this._itemPool.pop();
            node.opacity = 255;
            this._items.push(node);
            this._otherItemPoolArr.forEach(function (e, i) {
                var otherNode = e.pop();
                otherNode.opacity = 255;
                _this._otherItemsArr[i].push(otherNode);
            });
        }
        else {
            var tmp = this._list.main.templateType === VirtualList_1.MainTemplateType.PREFAB ? this._list.main.templatePrefab : this._list.main.templateNode;
            node = Res_1.default.instantiate(tmp, this.node);
            if (!node.getComponent(VirtualItem_1.default)) {
                node.addComponent(VirtualItem_1.default);
            }
            this.node.addChild(node);
            if (show) {
                node.opacity = 255;
                this._items.push(node);
            }
            else {
                this.putItemNode(node);
            }
            // 拷贝一份子节点数组，防止子节点移除时改变下标
            var childrenCopy_1 = node.children.slice(0);
            this._list.others.forEach(function (e, i) {
                var otherNode = null;
                switch (e.templateType) {
                    case VirtualList_1.OtherTemplateType.NODE:
                        otherNode = Res_1.default.instantiate(e.templateNode, _this.node);
                        break;
                    case VirtualList_1.OtherTemplateType.PREFAB:
                        otherNode = Res_1.default.instantiate(e.templatePrefab, _this.node);
                        break;
                    case VirtualList_1.OtherTemplateType.MAIN_ITEM_CHILD:
                        if (!Tool_1.default.inRange(0, childrenCopy_1.length - 1, e.templateChild)) {
                            cc.error("[VirtualLayout.addItemNode] error e.templateChild: " + e.templateChild);
                            return;
                        }
                        otherNode = childrenCopy_1[e.templateChild];
                        otherNode.removeFromParent();
                        break;
                    default:
                        cc.error("[VirtualLayout.addItemNode] error e.templateType: " + e.templateType);
                        return;
                }
                e.content.addChild(otherNode);
                if (show) {
                    otherNode.opacity = 255;
                    _this._otherItemsArr[i].push(otherNode);
                }
                else {
                    _this.putItemNode(otherNode, true, i);
                }
            });
        }
        return this._items.length - 1;
    };
    /**
     * 将节点放入节点池
     * @param node
     * @param isOther 是否为Others下的节点
     * @param otherIdx Others的下标
     */
    VirtualLayout.prototype.putItemNode = function (node, isOther, otherIdx) {
        if (isOther === void 0) { isOther = false; }
        if (otherIdx === void 0) { otherIdx = 0; }
        node.opacity = 0;
        // 防止已回收的节点触发点击事件
        node.setPosition(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
        if (isOther) {
            this._otherItemPoolArr[otherIdx].push(node);
        }
        else {
            var vi = node.getComponent(VirtualItem_1.default);
            vi.onReset();
            this._itemPool.push(node);
        }
    };
    /**
     * 回收已激活的节点
     * @param index 节点在this._items中的下标
     */
    VirtualLayout.prototype.putActivatedItemByIndex = function (index) {
        var _this = this;
        this.putItemNode(this._items[index]);
        this._otherItemsArr.forEach(function (arr, otherIdx) { _this.putItemNode(arr[index], true, otherIdx); });
        this._items.splice(index, 1);
        this._otherItemsArr.forEach(function (arr) {
            arr.splice(index, 1);
        });
    };
    /**
     * 子节点坐标系下坐标转换为父节点坐标系下坐标
     */
    VirtualLayout.prototype.convertToParentPos = function (pos, child) {
        return pos.add(child.position);
    };
    /**
     * 父节点坐标系下坐标转换为子节点坐标系下坐标
     */
    VirtualLayout.prototype.convertToChildPos = function (pos, child) {
        return pos.sub(child.position);
    };
    /**
     * 获取节点自身坐标系下的节点边界矩形
     */
    VirtualLayout.prototype.getNodeEdgeRect = function (node) {
        return cc.rect(-node.width * node.anchorX, -node.height * node.anchorY, node.width, node.height);
    };
    /**
     * 根据元素下标计算对应元素大小，isFixedSize为false时使用
     * @param idx
     */
    VirtualLayout.prototype.calcItemSizeUnfixed = function (idx) {
        if (this._list.calcItemSize) {
            return this._list.calcItemSize(this._list.argsArr[idx]);
        }
        else {
            return this._fixedSize;
        }
    };
    /**
     * content位移监听回调
     */
    VirtualLayout.prototype.onPositionChanged = function () {
        // ScrollView源码的bug处理
        // 1.超出边界的差值会记录在_outOfBoundaryAmount里，但是这个_outOfBoundaryAmount不是每次检测边界时都更新的，它需要_outOfBoundaryAmountDirty为true才会更新
        // 2.在content size改变的时候，ScrollView会检测content有没有超出边界，此时会更新_outOfBoundaryAmount并直接修改content坐标。但是修改完content坐标之后_outOfBoundaryAmount记录的仍旧是旧值，此时_outOfBoundaryAmountDirty为false。
        // 3.ScrollView在touchend的时候会触发检测当前有没有超出边界，有的话自动回弹滚动。由于_outOfBoundaryAmountDirty为false，所以并未更新_outOfBoundaryAmount，而是直接取错误的_outOfBoundaryAmount作为超出边界的值，然后进行错误的自动回弹。
        this._list.scrollView["_outOfBoundaryAmountDirty"] = true;
        // 更新标记
        this._viewDirty = true;
        this._posDirty = true;
    };
    /**
     * view size监听回调
     */
    VirtualLayout.prototype.onViewSizeChanged = function () {
        this._viewEdge = this.getNodeEdgeRect(this._view);
    };
    /**
     * 获取content相对view左上角原点位置的偏移值
     * @param idx 元素下标
     * @param itemAnchor 元素的锚点位置（左下角为0点）
     * @param viewAnchor view的锚点位置（左下角为0点）
     */
    VirtualLayout.prototype.getScrollOffset = function (idx, itemAnchor, viewAnchor) {
        idx = Math.min(idx, this._list.argsArr.length - 1);
        return this._list.isFixedSize ? this.getScrollOffsetFixed(idx, itemAnchor, viewAnchor) : this.getScrollOffsetUnfixed(idx, itemAnchor, viewAnchor);
    };
    VirtualLayout.prototype.getScrollOffsetFixed = function (idx, itemAnchor, viewAnchor) {
        var contentEdge = this.getNodeEdgeRect(this.node);
        var xMax, xMin, yMax, yMin;
        if (this.type === LayoutType.VERTICAL) {
            if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                yMax = contentEdge.yMax - (this.top + idx * this.spacingY + this._fixedSize.height * idx);
                yMin = yMax - this._fixedSize.height;
            }
            else {
                yMin = contentEdge.yMin + this.bottom + idx * this.spacingY + this._fixedSize.height * idx;
                yMax = yMin + this._fixedSize.height;
            }
            var x = this._viewEdge.xMin - (contentEdge.xMin + this.node.x);
            var y = contentEdge.yMax - (this._fixedSize.height * itemAnchor.y + yMin) - (1 - viewAnchor.y) * this._viewEdge.height;
            return cc.v2(x, y);
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                xMax = contentEdge.xMax - (this.right + idx * this.spacingX + this._fixedSize.width * idx);
                xMin = xMax - this._fixedSize.width;
            }
            else {
                xMin = contentEdge.xMin + this.left + idx * this.spacingX + this._fixedSize.width * idx;
                xMax = xMin + this._fixedSize.width;
            }
            var x = this._fixedSize.width * itemAnchor.x + xMin - contentEdge.xMin - viewAnchor.x * this._viewEdge.width;
            var y = contentEdge.yMax - (this._viewEdge.yMax - this.node.y);
            return cc.v2(x, y);
        }
        else {
            // 计算当前元素排在第几行第几列，从0开始
            var rowIndex = 0;
            var columnIndex = 0;
            if (this.startAxis === AxisDirection.HORIZONTAL) {
                var num = Math.floor((this.node.width - this.left - this.right + this.spacingX) / (this._fixedSize.width + this.spacingX));
                num = Math.max(num, 1);
                rowIndex = Math.floor(idx / num);
                columnIndex = idx % num;
            }
            else {
                var num = Math.floor((this.node.height - this.top - this.bottom + this.spacingY) / (this._fixedSize.height + this.spacingY));
                num = Math.max(num, 1);
                rowIndex = idx % num;
                columnIndex = Math.floor(idx / num);
            }
            if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                yMax = contentEdge.yMax - (this.top + rowIndex * this.spacingY + this._fixedSize.height * rowIndex);
                yMin = yMax - this._fixedSize.height;
            }
            else {
                yMin = contentEdge.yMin + this.bottom + rowIndex * this.spacingY + this._fixedSize.height * rowIndex;
                yMax = yMin + this._fixedSize.height;
            }
            if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                xMax = contentEdge.xMax - (this.right + columnIndex * this.spacingX + this._fixedSize.width * columnIndex);
                xMin = xMax - this._fixedSize.width;
            }
            else {
                xMin = contentEdge.xMin + this.left + columnIndex * this.spacingX + this._fixedSize.width * columnIndex;
                xMax = xMin + this._fixedSize.width;
            }
            var x = this._fixedSize.width * itemAnchor.x + xMin - contentEdge.xMin - viewAnchor.x * this._viewEdge.width;
            var y = contentEdge.yMax - (this._fixedSize.height * itemAnchor.y + yMin) - (1 - viewAnchor.y) * this._viewEdge.height;
            return cc.v2(x, y);
        }
    };
    VirtualLayout.prototype.getScrollOffsetUnfixed = function (idx, itemAnchor, viewAnchor) {
        var contentEdge = this.getNodeEdgeRect(this.node);
        var xMax, xMin, yMax, yMin;
        var curSize = this.calcItemSizeUnfixed(idx);
        if (this.type === LayoutType.VERTICAL) {
            var totalHeight = 0;
            for (var i = 0; i < idx; i++) {
                var size = this.calcItemSizeUnfixed(i);
                totalHeight += size.height;
            }
            if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                yMax = contentEdge.yMax - (this.top + idx * this.spacingY + totalHeight);
                yMin = yMax - curSize.height;
            }
            else {
                yMin = contentEdge.yMin + this.bottom + idx * this.spacingY + totalHeight;
                yMax = yMin + curSize.height;
            }
            var x = this._viewEdge.xMin - (contentEdge.xMin + this.node.x);
            var y = contentEdge.yMax - (curSize.height * itemAnchor.y + yMin) - (1 - viewAnchor.y) * this._viewEdge.height;
            return cc.v2(x, y);
        }
        else if (this.type === LayoutType.HORIZONTAL) {
            var totalWidth = 0;
            for (var i = 0; i < idx; i++) {
                var size = this.calcItemSizeUnfixed(i);
                totalWidth += size.width;
            }
            if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                xMax = contentEdge.xMax - (this.right + idx * this.spacingX + totalWidth);
                xMin = xMax - curSize.width;
            }
            else {
                xMin = contentEdge.xMin + this.left + idx * this.spacingX + totalWidth;
                xMax = xMin + curSize.width;
            }
            var x = curSize.width * itemAnchor.x + xMin - contentEdge.xMin - viewAnchor.x * this._viewEdge.width;
            var y = contentEdge.yMax - (this._viewEdge.yMax - this.node.y);
            return cc.v2(x, y);
        }
        return null;
    };
    /**
     * 重新排列
     * @param clear 是否清空节点，默认true(仅当不会影响已有元素节点排列时才可传入false)
     */
    VirtualLayout.prototype.rearrange = function (clear) {
        var _this = this;
        if (clear === void 0) { clear = true; }
        this._sizeDirty = true;
        this._viewDirty = true;
        if (clear) {
            this._items.forEach(function (e, i) {
                _this.putItemNode(e);
                _this._otherItemsArr.forEach(function (arr, otherIdx) { _this.putItemNode(arr[i], true, otherIdx); });
            });
            this._items.length = 0;
            this._otherItemsArr.forEach(function (arr) { arr.length = 0; });
        }
    };
    /**
     * 刷新所有激活的item
     */
    VirtualLayout.prototype.refreshAllItems = function () {
        var _this = this;
        this._items.forEach(function (item) {
            var vi = item.getComponent(VirtualItem_1.default);
            vi.onRefresh(vi.args);
            if (_this._list.others.length > 0) {
                vi.onRefreshOthers.apply(vi, vi.others);
            }
        });
    };
    __decorate([
        property({ type: cc.Enum(LayoutType), tooltip: CC_DEV && "布局模式" })
    ], VirtualLayout.prototype, "type", void 0);
    __decorate([
        property({
            type: cc.Enum(AxisDirection),
            tooltip: CC_DEV && "GRID布局的起始轴方向\nHORIZONTAL：固定宽度，动态改变高度\nVERTICAL：固定高度，动态改变宽度",
            visible: function () { return this.type === LayoutType.GRID; }
        })
    ], VirtualLayout.prototype, "startAxis", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.HORIZONTAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "left", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.HORIZONTAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "right", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.VERTICAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "top", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.VERTICAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "bottom", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.HORIZONTAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "spacingX", void 0);
    __decorate([
        property({ visible: function () { return this.type === LayoutType.VERTICAL || this.type === LayoutType.GRID; } })
    ], VirtualLayout.prototype, "spacingY", void 0);
    __decorate([
        property({
            type: cc.Enum(VerticalDirection),
            visible: function () { return this.type === LayoutType.VERTICAL || this.type === LayoutType.GRID; }
        })
    ], VirtualLayout.prototype, "verticalDirection", void 0);
    __decorate([
        property({
            type: cc.Enum(HorizontalDirection),
            visible: function () { return this.type === LayoutType.HORIZONTAL || this.type === LayoutType.GRID; }
        })
    ], VirtualLayout.prototype, "horizontalDirection", void 0);
    VirtualLayout = __decorate([
        ccclass,
        disallowMultiple
    ], VirtualLayout);
    return VirtualLayout;
}(cc.Component));
exports.default = VirtualLayout;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcc2Nyb2xsTGlzdFxcVmlydHVhbExheW91dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBb0M7QUFDcEMsMkNBQXNDO0FBQ3RDLDZDQUF3QztBQUN4Qyw2Q0FBOEY7QUFFeEYsSUFBQSxLQUEwQyxFQUFFLENBQUMsVUFBVSxFQUFyRCxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFOUQ7O0dBRUc7QUFDSCxJQUFLLFVBT0o7QUFQRCxXQUFLLFVBQVU7SUFDWCxTQUFTO0lBQ1QsdURBQVUsQ0FBQTtJQUNWLFNBQVM7SUFDVCxtREFBUSxDQUFBO0lBQ1IsU0FBUztJQUNULDJDQUFJLENBQUE7QUFDUixDQUFDLEVBUEksVUFBVSxLQUFWLFVBQVUsUUFPZDtBQUVEOztHQUVHO0FBQ0gsSUFBSyxhQUdKO0FBSEQsV0FBSyxhQUFhO0lBQ2QsNkRBQVUsQ0FBQTtJQUNWLHlEQUFRLENBQUE7QUFDWixDQUFDLEVBSEksYUFBYSxLQUFiLGFBQWEsUUFHakI7QUFFRDs7R0FFRztBQUNILElBQUssaUJBR0o7QUFIRCxXQUFLLGlCQUFpQjtJQUNsQiwyRUFBYSxDQUFBO0lBQ2IsMkVBQWEsQ0FBQTtBQUNqQixDQUFDLEVBSEksaUJBQWlCLEtBQWpCLGlCQUFpQixRQUdyQjtBQUVEOztHQUVHO0FBQ0gsSUFBSyxtQkFHSjtBQUhELFdBQUssbUJBQW1CO0lBQ3BCLCtFQUFhLENBQUE7SUFDYiwrRUFBYSxDQUFBO0FBQ2pCLENBQUMsRUFISSxtQkFBbUIsS0FBbkIsbUJBQW1CLFFBR3ZCO0FBRUQ7O0dBRUc7QUFHSDtJQUFrRSxpQ0FBWTtJQUE5RTtRQUFBLHFFQXMxQkM7UUFwMUJVLFVBQUksR0FBZSxVQUFVLENBQUMsUUFBUSxDQUFDO1FBT3ZDLGVBQVMsR0FBa0IsYUFBYSxDQUFD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QUFRLENBQUM7WUFDTixJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztZQUNsQyxPQUFPLGdCQUFLLE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDN0YsQ0FBQzs4REFDa0Y7SUF2Q25FLGFBQWE7UUFGakMsT0FBTztRQUNQLGdCQUFnQjtPQUNJLGFBQWEsQ0FzMUJqQztJQUFELG9CQUFDO0NBdDFCRCxBQXMxQkMsQ0F0MUJpRSxFQUFFLENBQUMsU0FBUyxHQXMxQjdFO2tCQXQxQm9CLGFBQWEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVzIGZyb20gXCIuLi8uLi8uLi91dGlsL1Jlc1wiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Ub29sXCI7XHJcbmltcG9ydCBWaXJ0dWFsSXRlbSBmcm9tIFwiLi9WaXJ0dWFsSXRlbVwiO1xyXG5pbXBvcnQgVmlydHVhbExpc3QsIHsgTWFpblRlbXBsYXRlVHlwZSwgT3RoZXJUZW1wbGF0ZVR5cGUsIFZpcnR1YWxBcmdzIH0gZnJvbSBcIi4vVmlydHVhbExpc3RcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIGRpc2FsbG93TXVsdGlwbGUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG4vKipcclxuICog5biD5bGA5qih5byPXHJcbiAqL1xyXG5lbnVtIExheW91dFR5cGUge1xyXG4gICAgLyoqIOaoquWQkSAqL1xyXG4gICAgSE9SSVpPTlRBTCxcclxuICAgIC8qKiDnurXlkJEgKi9cclxuICAgIFZFUlRJQ0FMLFxyXG4gICAgLyoqIOe9keagvCAqL1xyXG4gICAgR1JJRFxyXG59XHJcblxyXG4vKipcclxuICog5biD5bGA6L205ZCR77yM5Y+q55So5LqOR1JJROW4g+WxgOOAglxyXG4gKi9cclxuZW51bSBBeGlzRGlyZWN0aW9uIHtcclxuICAgIEhPUklaT05UQUwsXHJcbiAgICBWRVJUSUNBTFxyXG59XHJcblxyXG4vKipcclxuICog57q15ZCR5o6S5YiX5pa55ZCRXHJcbiAqL1xyXG5lbnVtIFZlcnRpY2FsRGlyZWN0aW9uIHtcclxuICAgIFRPUF9UT19CT1RUT00sXHJcbiAgICBCT1RUT01fVE9fVE9QXHJcbn1cclxuXHJcbi8qKlxyXG4gKiDmqKrlkJHmjpLliJfmlrnlkJFcclxuICovXHJcbmVudW0gSG9yaXpvbnRhbERpcmVjdGlvbiB7XHJcbiAgICBMRUZUX1RPX1JJR0hULFxyXG4gICAgUklHSFRfVE9fTEVGVFxyXG59XHJcblxyXG4vKipcclxuICog6Jma5ouf5YiX6KGo5omA6ZyA55qE5biD5bGA57uE5Lu2XHJcbiAqL1xyXG5AY2NjbGFzc1xyXG5AZGlzYWxsb3dNdWx0aXBsZVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXJ0dWFsTGF5b3V0PFQgZXh0ZW5kcyBWaXJ0dWFsQXJncz4gZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogY2MuRW51bShMYXlvdXRUeXBlKSwgdG9vbHRpcDogQ0NfREVWICYmIFwi5biD5bGA5qih5byPXCIgfSlcclxuICAgIHB1YmxpYyB0eXBlOiBMYXlvdXRUeXBlID0gTGF5b3V0VHlwZS5WRVJUSUNBTDtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IGNjLkVudW0oQXhpc0RpcmVjdGlvbiksXHJcbiAgICAgICAgdG9vbHRpcDogQ0NfREVWICYmIFwiR1JJROW4g+WxgOeahOi1t+Wni+i9tOaWueWQkVxcbkhPUklaT05UQUzvvJrlm7rlrprlrr3luqbvvIzliqjmgIHmlLnlj5jpq5jluqZcXG5WRVJUSUNBTO+8muWbuuWumumrmOW6pu+8jOWKqOaAgeaUueWPmOWuveW6plwiLFxyXG4gICAgICAgIHZpc2libGUoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IExheW91dFR5cGUuR1JJRDsgfVxyXG4gICAgfSlcclxuICAgIHB1YmxpYyBzdGFydEF4aXM6IEF4aXNEaXJlY3Rpb24gPSBBeGlzRGlyZWN0aW9uLkhPUklaT05UQUw7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5IT1JJWk9OVEFMIHx8IHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5HUklEOyB9IH0pXHJcbiAgICBwdWJsaWMgbGVmdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBAcHJvcGVydHkoeyB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkhPUklaT05UQUwgfHwgdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkdSSUQ7IH0gfSlcclxuICAgIHB1YmxpYyByaWdodDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBAcHJvcGVydHkoeyB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLlZFUlRJQ0FMIHx8IHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5HUklEOyB9IH0pXHJcbiAgICBwdWJsaWMgdG9wOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHZpc2libGUoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IExheW91dFR5cGUuVkVSVElDQUwgfHwgdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkdSSUQ7IH0gfSlcclxuICAgIHB1YmxpYyBib3R0b206IG51bWJlciA9IDA7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5IT1JJWk9OVEFMIHx8IHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5HUklEOyB9IH0pXHJcbiAgICBwdWJsaWMgc3BhY2luZ1g6IG51bWJlciA9IDA7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5WRVJUSUNBTCB8fCB0aGlzLnR5cGUgPT09IExheW91dFR5cGUuR1JJRDsgfSB9KVxyXG4gICAgcHVibGljIHNwYWNpbmdZOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuRW51bShWZXJ0aWNhbERpcmVjdGlvbiksXHJcbiAgICAgICAgdmlzaWJsZSgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5WRVJUSUNBTCB8fCB0aGlzLnR5cGUgPT09IExheW91dFR5cGUuR1JJRDsgfVxyXG4gICAgfSlcclxuICAgIHB1YmxpYyB2ZXJ0aWNhbERpcmVjdGlvbjogVmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbERpcmVjdGlvbi5UT1BfVE9fQk9UVE9NO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogY2MuRW51bShIb3Jpem9udGFsRGlyZWN0aW9uKSxcclxuICAgICAgICB2aXNpYmxlKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkhPUklaT05UQUwgfHwgdGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkdSSUQ7IH1cclxuICAgIH0pXHJcbiAgICBwdWJsaWMgaG9yaXpvbnRhbERpcmVjdGlvbjogSG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxEaXJlY3Rpb24uTEVGVF9UT19SSUdIVDtcclxuXHJcbiAgICAvKiog5omA5bGe6Jma5ouf5YiX6KGoICovXHJcbiAgICBwcml2YXRlIF9saXN0OiBWaXJ0dWFsTGlzdDxUPiA9IG51bGw7XHJcbiAgICAvKiogbWFza+iKgueCue+8iGNvbnRlbnTniLboioLngrnvvIkgKi9cclxuICAgIHByaXZhdGUgX3ZpZXc6IGNjLk5vZGUgPSBudWxsO1xyXG4gICAgLyoqIHZpZXflnZDmoIfns7vkuIt2aWV355qE6L6555WM55+p5b2iICovXHJcbiAgICBwcml2YXRlIF92aWV3RWRnZTogY2MuUmVjdCA9IG51bGw7XHJcbiAgICAvKiog5YWD57Sg6IqC54K55aSn5bCP5Zu65a6a5pe255qEc2l6ZSAqL1xyXG4gICAgcHJpdmF0ZSBfZml4ZWRTaXplOiBjYy5TaXplID0gbnVsbDtcclxuICAgIC8qKiDmoIforrDlvZPliY3luKfmmK/lkKbpnIDopoHmm7TmlrBjb250ZW50IHNpemUgKi9cclxuICAgIHByaXZhdGUgX3NpemVEaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIOagh+iusOW9k+WJjeW4p+aYr+WQpumcgOimgeabtOaWsHZpZXfljLrln5/mlbDmja7mmL7npLogKi9cclxuICAgIHByaXZhdGUgX3ZpZXdEaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIOagh+iusOW9k+WJjeW4p+aYr+WQpumcgOimgeWQjOatpW90aGVycyBjb250ZW5055qE5Z2Q5qCHICovXHJcbiAgICBwcml2YXRlIF9wb3NEaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIG1haW4gY29udGVudOa/gOa0u+eKtuaAgeeahGl0ZW0gKi9cclxuICAgIHByaXZhdGUgX2l0ZW1zOiBjYy5Ob2RlW10gPSBbXTtcclxuICAgIC8qKiBtYWluIGNvbnRlbnTooqvlm57mlLbnmoRpdGVt5rGg77yI5LiN56e75Ye66IqC54K55qCR77yM5Y+q6K6+572ub3BhY2l0ee+8iSAqL1xyXG4gICAgcHJpdmF0ZSBfaXRlbVBvb2w6IGNjLk5vZGVbXSA9IFtdO1xyXG4gICAgLyoqIG90aGVycyBjb250ZW505r+A5rS754q25oCB55qEaXRlbe+8jOS4i+agh+mhuuW6j+S4jnRoaXMubGlzdC5PdGhlcnPmlbDnu4TkuIDoh7QgKi9cclxuICAgIHByaXZhdGUgX290aGVySXRlbXNBcnI6IGNjLk5vZGVbXVtdID0gW107XHJcbiAgICAvKiogb3RoZXJzIGNvbnRlbnTooqvlm57mlLbnmoRpdGVt5rGg5pWw57uE77yI5LiN56e75Ye66IqC54K55qCR77yM5Y+q6K6+572ub3BhY2l0ee+8ie+8jOS4i+agh+mhuuW6j+S4jnRoaXMubGlzdC5PdGhlcnPmlbDnu4TkuIDoh7QgKi9cclxuICAgIHByaXZhdGUgX290aGVySXRlbVBvb2xBcnI6IGNjLk5vZGVbXVtdID0gW107XHJcblxyXG4gICAgcHVibGljIG9uSW5pdChsaXN0OiBWaXJ0dWFsTGlzdDxUPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xpc3QgPSBsaXN0O1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSB0aGlzLm5vZGUucGFyZW50O1xyXG4gICAgICAgIHRoaXMuX3ZpZXdFZGdlID0gdGhpcy5nZXROb2RlRWRnZVJlY3QodGhpcy5fdmlldyk7XHJcblxyXG4gICAgICAgIC8vIOWIneWni+WMluWIhuWxguebuOWFs+aVsOaNrlxyXG4gICAgICAgIHRoaXMuX290aGVySXRlbXNBcnIgPSBbXTtcclxuICAgICAgICB0aGlzLl9vdGhlckl0ZW1Qb29sQXJyID0gW107XHJcbiAgICAgICAgdGhpcy5fbGlzdC5vdGhlcnMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1zQXJyLnB1c2goW10pO1xyXG4gICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1Qb29sQXJyLnB1c2goW10pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyDlhYPntKDlpKflsI/lm7rlrprml7bliJ3lp4vljJZmaXhlZFNpemVcclxuICAgICAgICBpZiAodGhpcy5fZml4ZWRTaXplID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbU5vZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9maXhlZFNpemUgPSB0aGlzLl9pdGVtUG9vbFswXS5nZXRDb250ZW50U2l6ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5rOo5YaM5LqL5Lu2XHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlBPU0lUSU9OX0NIQU5HRUQsIHRoaXMub25Qb3NpdGlvbkNoYW5nZWQsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3ZpZXcub24oY2MuTm9kZS5FdmVudFR5cGUuU0laRV9DSEFOR0VELCB0aGlzLm9uVmlld1NpemVDaGFuZ2VkLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIC8vIOazqOmUgOS6i+S7tlxyXG4gICAgICAgIHRoaXMubm9kZS5vZmYoY2MuTm9kZS5FdmVudFR5cGUuUE9TSVRJT05fQ0hBTkdFRCwgdGhpcy5vblBvc2l0aW9uQ2hhbmdlZCwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdmlldy5vZmYoY2MuTm9kZS5FdmVudFR5cGUuU0laRV9DSEFOR0VELCB0aGlzLm9uVmlld1NpemVDaGFuZ2VkLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeri+WNs+abtOaWsOW4g+WxgFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZm9yY2VVcGRhdGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQb3MoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbGF0ZVVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlkIzmraVvdGhlcnPnmoTlnZDmoIdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVQb3MoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wb3NEaXJ0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Bvc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGlzdC5vdGhlcnMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLmNvbnRlbnQucG9zaXRpb24gPSB0aGlzLm5vZGUucG9zaXRpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrBjb250ZW50IHNpemVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVTaXplKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2l6ZURpcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2l6ZURpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0LmlzRml4ZWRTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZUZpeGVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplVW5maXhlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZVNpemVGaXhlZCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBMYXlvdXRUeXBlLlZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuaGVpZ2h0ID0gdGhpcy50b3AgKyB0aGlzLmJvdHRvbSArICh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIC0gMSkgKiB0aGlzLnNwYWNpbmdZICsgdGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5hcmdzQXJyLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUud2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vZGUud2lkdGggPSB0aGlzLmxlZnQgKyB0aGlzLnJpZ2h0ICsgKHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGggLSAxKSAqIHRoaXMuc3BhY2luZ1ggKyB0aGlzLl9maXhlZFNpemUud2lkdGggKiB0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0QXhpcyA9PT0gQXhpc0RpcmVjdGlvbi5IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5hcmdzQXJyLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOiuoeeul+S4gOihjOWPr+S7peaOkuWIl+WHoOS4qu+8jOiHs+WwkTHkuKpcclxuICAgICAgICAgICAgICAgIGxldCBudW0gPSBNYXRoLmZsb29yKCh0aGlzLm5vZGUud2lkdGggLSB0aGlzLmxlZnQgLSB0aGlzLnJpZ2h0ICsgdGhpcy5zcGFjaW5nWCkgLyAodGhpcy5fZml4ZWRTaXplLndpZHRoICsgdGhpcy5zcGFjaW5nWCkpO1xyXG4gICAgICAgICAgICAgICAgbnVtID0gTWF0aC5tYXgobnVtLCAxKTtcclxuICAgICAgICAgICAgICAgIC8vIOiuoeeul+WPr+S7peaOkuWIl+WHoOihjFxyXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguY2VpbCh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIC8gbnVtKTtcclxuICAgICAgICAgICAgICAgIC8vIOmrmOW6plxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmhlaWdodCA9IHRoaXMudG9wICsgdGhpcy5ib3R0b20gKyAocm93IC0gMSkgKiB0aGlzLnNwYWNpbmdZICsgdGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIHJvdztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUud2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDorqHnrpfkuIDliJflj6/ku6XmjpLliJflh6DkuKrvvIzoh7PlsJEx5LiqXHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gTWF0aC5mbG9vcigodGhpcy5ub2RlLmhlaWdodCAtIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKyB0aGlzLnNwYWNpbmdZKSAvICh0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICsgdGhpcy5zcGFjaW5nWSkpO1xyXG4gICAgICAgICAgICAgICAgbnVtID0gTWF0aC5tYXgobnVtLCAxKTtcclxuICAgICAgICAgICAgICAgIC8vIOiuoeeul+WPr+S7peaOkuWIl+WHoOWIl1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IE1hdGguY2VpbCh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIC8gbnVtKTtcclxuICAgICAgICAgICAgICAgIC8vIOWuveW6plxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLndpZHRoID0gdGhpcy5sZWZ0ICsgdGhpcy5yaWdodCArIChjb2x1bW4gLSAxKSAqIHRoaXMuc3BhY2luZ1ggKyB0aGlzLl9maXhlZFNpemUud2lkdGggKiBjb2x1bW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVTaXplVW5maXhlZCgpOiB2b2lkIHtcclxuICAgICAgICAvLyDnvJPlrZjlrr3pq5jvvIzmnIDlkI7otYvlgLzvvIzmmK/lm6DkuLrkv67mlLljb250ZW50IHNpemXml7bkvJrop6blj5FzY3JvbGx2aWV3Ll9jYWxjdWxhdGVCb3VuZGFyee+8jOaUueWPmGNvbnRlbnTnmoTlnZDmoIdcclxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBMYXlvdXRUeXBlLlZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5oZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnRvcCArIHRoaXMuYm90dG9tICsgKHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGggLSAxKSAqIHRoaXMuc3BhY2luZ1k7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGlzdC5hcmdzQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuY2FsY0l0ZW1TaXplVW5maXhlZChpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaXplLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuaGVpZ2h0ID0gcmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkhPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLndpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5sZWZ0ICsgdGhpcy5yaWdodCArICh0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIC0gMSkgKiB0aGlzLnNwYWNpbmdYO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmNhbGNJdGVtU2l6ZVVuZml4ZWQoaSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUud2lkdGggPSByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5pu05pawdmlld+WMuuWfn+aVsOaNruaYvuekulxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVZpZXcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3RGlydHkgfHwgdGhpcy5fbGlzdC5hcmdzQXJyLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0LmlzRml4ZWRTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld0ZpeGVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3VW5maXhlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZVZpZXdGaXhlZCgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdmlld1Jlc3VsdCA9IHRoaXMuY2hlY2tWaWV3SXRlbSgpO1xyXG4gICAgICAgIGxldCBpblZpZXcgPSB2aWV3UmVzdWx0LmluVmlldztcclxuICAgICAgICBsZXQgb3V0VmlldyA9IHZpZXdSZXN1bHQub3V0VmlldztcclxuICAgICAgICBsZXQgY29udGVudEVkZ2UgPSB0aGlzLmdldE5vZGVFZGdlUmVjdCh0aGlzLm5vZGUpO1xyXG4gICAgICAgIGxldCB4TWF4OiBudW1iZXIsIHhNaW46IG51bWJlciwgeU1heDogbnVtYmVyLCB5TWluOiBudW1iZXI7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5WRVJUSUNBTCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsRGlyZWN0aW9uLlRPUF9UT19CT1RUT00pIHtcclxuICAgICAgICAgICAgICAgICAgICB5TWF4ID0gY29udGVudEVkZ2UueU1heCAtICh0aGlzLnRvcCArIGkgKiB0aGlzLnNwYWNpbmdZICsgdGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHlNaW4gPSB5TWF4IC0gdGhpcy5fZml4ZWRTaXplLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeU1heCArIHRoaXMubm9kZS55IDwgdGhpcy5fdmlld0VkZ2UueU1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlNaW4gKyB0aGlzLm5vZGUueSA+IHRoaXMuX3ZpZXdFZGdlLnlNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB5TWluID0gY29udGVudEVkZ2UueU1pbiArIHRoaXMuYm90dG9tICsgaSAqIHRoaXMuc3BhY2luZ1kgKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICogaTtcclxuICAgICAgICAgICAgICAgICAgICB5TWF4ID0geU1pbiArIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlNaW4gKyB0aGlzLm5vZGUueSA+IHRoaXMuX3ZpZXdFZGdlLnlNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5TWF4ICsgdGhpcy5ub2RlLnkgPCB0aGlzLl92aWV3RWRnZS55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3mmL7npLrljLrln5/lhoXpg6jmmK/lkKbmnInoioLngrnmmL7npLrmraTmnaHmlbDmja5cclxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGluVmlldy5maW5kSW5kZXgoKGUpID0+IHsgcmV0dXJuIHRoaXMuX2l0ZW1zW2VdLmdldENvbXBvbmVudChWaXJ0dWFsSXRlbSkuZGF0YUlkeCA9PT0gaTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5rKh5pyJ6IqC54K55pi+56S65q2k5p2h5pWw5o2u77yM6ZyA5L2/55So5pi+56S65Yy65Z+f5aSW55qE6IqC54K55pi+56S65q2k5p2h5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbUlkeDogbnVtYmVyID0gb3V0Vmlldy5sZW5ndGggPT09IDAgPyB0aGlzLmFkZEl0ZW1Ob2RlKCkgOiBvdXRWaWV3LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbTogY2MuTm9kZSA9IHRoaXMuX2l0ZW1zW2l0ZW1JZHhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGNjLnYzKDAsIHlNaW4gKyBpdGVtLmFuY2hvclkgKiBpdGVtLmhlaWdodCksIGksIGl0ZW1JZHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVF9UT19MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1heCA9IGNvbnRlbnRFZGdlLnhNYXggLSAodGhpcy5yaWdodCArIGkgKiB0aGlzLnNwYWNpbmdYICsgdGhpcy5fZml4ZWRTaXplLndpZHRoICogaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggLSB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhNYXggKyB0aGlzLm5vZGUueCA8IHRoaXMuX3ZpZXdFZGdlLnhNaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TWluICsgdGhpcy5ub2RlLnggPiB0aGlzLl92aWV3RWRnZS54TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1pbiA9IGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLmxlZnQgKyBpICogdGhpcy5zcGFjaW5nWCArIHRoaXMuX2ZpeGVkU2l6ZS53aWR0aCAqIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1heCA9IHhNaW4gKyB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhNaW4gKyB0aGlzLm5vZGUueCA+IHRoaXMuX3ZpZXdFZGdlLnhNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TWF4ICsgdGhpcy5ub2RlLnggPCB0aGlzLl92aWV3RWRnZS54TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3mmL7npLrljLrln5/lhoXpg6jmmK/lkKbmnInoioLngrnmmL7npLrmraTmnaHmlbDmja5cclxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGluVmlldy5maW5kSW5kZXgoKGUpID0+IHsgcmV0dXJuIHRoaXMuX2l0ZW1zW2VdLmdldENvbXBvbmVudChWaXJ0dWFsSXRlbSkuZGF0YUlkeCA9PT0gaTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5rKh5pyJ6IqC54K55pi+56S65q2k5p2h5pWw5o2u77yM6ZyA5L2/55So5pi+56S65Yy65Z+f5aSW55qE6IqC54K55pi+56S65q2k5p2h5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbUlkeDogbnVtYmVyID0gb3V0Vmlldy5sZW5ndGggPT09IDAgPyB0aGlzLmFkZEl0ZW1Ob2RlKCkgOiBvdXRWaWV3LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbTogY2MuTm9kZSA9IHRoaXMuX2l0ZW1zW2l0ZW1JZHhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGNjLnYzKHhNaW4gKyBpdGVtLmFuY2hvclggKiBpdGVtLndpZHRoLCAwKSwgaSwgaXRlbUlkeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8g6K6h566X5b2T5YmN5YWD57Sg5o6S5Zyo56ys5Yeg6KGM56ys5Yeg5YiX77yM5LuOMOW8gOWni1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvd0luZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbkluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRBeGlzID09PSBBeGlzRGlyZWN0aW9uLkhPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDotbflp4vovbTkuLrmqKrlkJFcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbnVtID0gTWF0aC5mbG9vcigodGhpcy5ub2RlLndpZHRoIC0gdGhpcy5sZWZ0IC0gdGhpcy5yaWdodCArIHRoaXMuc3BhY2luZ1gpIC8gKHRoaXMuX2ZpeGVkU2l6ZS53aWR0aCArIHRoaXMuc3BhY2luZ1gpKTtcclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBNYXRoLm1heChudW0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ID0gTWF0aC5mbG9vcihpIC8gbnVtKTtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IGkgJSBudW07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6h566X57q15ZCRXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsRGlyZWN0aW9uLlRPUF9UT19CT1RUT00pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU1heCA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy50b3AgKyByb3dJbmRleCAqIHRoaXMuc3BhY2luZ1kgKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICogcm93SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWluID0geU1heCAtIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5TWF4ICsgdGhpcy5ub2RlLnkgPCB0aGlzLl92aWV3RWRnZS55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeU1pbiArIHRoaXMubm9kZS55ID4gdGhpcy5fdmlld0VkZ2UueU1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWluID0gY29udGVudEVkZ2UueU1pbiArIHRoaXMuYm90dG9tICsgcm93SW5kZXggKiB0aGlzLnNwYWNpbmdZICsgdGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIHJvd0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWF4ID0geU1pbiArIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5TWluICsgdGhpcy5ub2RlLnkgPiB0aGlzLl92aWV3RWRnZS55TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeU1heCArIHRoaXMubm9kZS55IDwgdGhpcy5fdmlld0VkZ2UueU1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6h566X5qiq5ZCRXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVF9UT19MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNYXggPSBjb250ZW50RWRnZS54TWF4IC0gKHRoaXMucmlnaHQgKyBjb2x1bW5JbmRleCAqIHRoaXMuc3BhY2luZ1ggKyB0aGlzLl9maXhlZFNpemUud2lkdGggKiBjb2x1bW5JbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4IC0gdGhpcy5fZml4ZWRTaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNaW4gPSBjb250ZW50RWRnZS54TWluICsgdGhpcy5sZWZ0ICsgY29sdW1uSW5kZXggKiB0aGlzLnNwYWNpbmdYICsgdGhpcy5fZml4ZWRTaXplLndpZHRoICogY29sdW1uSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNYXggPSB4TWluICsgdGhpcy5fZml4ZWRTaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeE1heCArIHRoaXMubm9kZS54IDwgdGhpcy5fdmlld0VkZ2UueE1pbiB8fCB4TWluICsgdGhpcy5ub2RlLnggPiB0aGlzLl92aWV3RWRnZS54TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6LW35aeL6L205Li657q15ZCRXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG51bSA9IE1hdGguZmxvb3IoKHRoaXMubm9kZS5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICsgdGhpcy5zcGFjaW5nWSkgLyAodGhpcy5fZml4ZWRTaXplLmhlaWdodCArIHRoaXMuc3BhY2luZ1kpKTtcclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBNYXRoLm1heChudW0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ID0gaSAlIG51bTtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IE1hdGguZmxvb3IoaSAvIG51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6h566X5qiq5ZCRXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVF9UT19MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNYXggPSBjb250ZW50RWRnZS54TWF4IC0gKHRoaXMucmlnaHQgKyBjb2x1bW5JbmRleCAqIHRoaXMuc3BhY2luZ1ggKyB0aGlzLl9maXhlZFNpemUud2lkdGggKiBjb2x1bW5JbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4IC0gdGhpcy5fZml4ZWRTaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeE1heCArIHRoaXMubm9kZS54IDwgdGhpcy5fdmlld0VkZ2UueE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhNaW4gKyB0aGlzLm5vZGUueCA+IHRoaXMuX3ZpZXdFZGdlLnhNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE1pbiA9IGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLmxlZnQgKyBjb2x1bW5JbmRleCAqIHRoaXMuc3BhY2luZ1ggKyB0aGlzLl9maXhlZFNpemUud2lkdGggKiBjb2x1bW5JbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE1heCA9IHhNaW4gKyB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4TWluICsgdGhpcy5ub2RlLnggPiB0aGlzLl92aWV3RWRnZS54TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeE1heCArIHRoaXMubm9kZS54IDwgdGhpcy5fdmlld0VkZ2UueE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6h566X57q15ZCRXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsRGlyZWN0aW9uLlRPUF9UT19CT1RUT00pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU1heCA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy50b3AgKyByb3dJbmRleCAqIHRoaXMuc3BhY2luZ1kgKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICogcm93SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TWluID0geU1heCAtIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU1pbiA9IGNvbnRlbnRFZGdlLnlNaW4gKyB0aGlzLmJvdHRvbSArIHJvd0luZGV4ICogdGhpcy5zcGFjaW5nWSArIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQgKiByb3dJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeU1heCA9IHlNaW4gKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeU1heCArIHRoaXMubm9kZS55IDwgdGhpcy5fdmlld0VkZ2UueU1pbiB8fCB5TWluICsgdGhpcy5ub2RlLnkgPiB0aGlzLl92aWV3RWRnZS55TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyDliKTmlq3mmL7npLrljLrln5/lhoXpg6jmmK/lkKbmnInoioLngrnmmL7npLrmraTmnaHmlbDmja5cclxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGluVmlldy5maW5kSW5kZXgoKGUpID0+IHsgcmV0dXJuIHRoaXMuX2l0ZW1zW2VdLmdldENvbXBvbmVudChWaXJ0dWFsSXRlbSkuZGF0YUlkeCA9PT0gaTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5rKh5pyJ6IqC54K55pi+56S65q2k5p2h5pWw5o2u77yM6ZyA5L2/55So5pi+56S65Yy65Z+f5aSW55qE6IqC54K55pi+56S65q2k5p2h5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbUlkeDogbnVtYmVyID0gb3V0Vmlldy5sZW5ndGggPT09IDAgPyB0aGlzLmFkZEl0ZW1Ob2RlKCkgOiBvdXRWaWV3LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbTogY2MuTm9kZSA9IHRoaXMuX2l0ZW1zW2l0ZW1JZHhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKGNjLnYzKHhNaW4gKyBpdGVtLmFuY2hvclggKiBpdGVtLndpZHRoLCB5TWluICsgaXRlbS5hbmNob3JZICogaXRlbS5oZWlnaHQpLCBpLCBpdGVtSWR4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Zue5pS25Yy65Z+f5aSW55qE6IqC54K5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG91dFZpZXcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5wdXRBY3RpdmF0ZWRJdGVtQnlJbmRleChvdXRWaWV3W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVWaWV3VW5maXhlZCgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdmlld1Jlc3VsdCA9IHRoaXMuY2hlY2tWaWV3SXRlbSgpO1xyXG4gICAgICAgIGxldCBpblZpZXcgPSB2aWV3UmVzdWx0LmluVmlldztcclxuICAgICAgICBsZXQgb3V0VmlldyA9IHZpZXdSZXN1bHQub3V0VmlldztcclxuICAgICAgICBsZXQgY29udGVudEVkZ2UgPSB0aGlzLmdldE5vZGVFZGdlUmVjdCh0aGlzLm5vZGUpO1xyXG4gICAgICAgIGxldCB4TWF4OiBudW1iZXIsIHhNaW46IG51bWJlciwgeU1heDogbnVtYmVyLCB5TWluOiBudW1iZXI7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5WRVJUSUNBTCkge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxIZWlnaHQ6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGlzdC5hcmdzQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuY2FsY0l0ZW1TaXplVW5maXhlZChpKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IHNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsRGlyZWN0aW9uLlRPUF9UT19CT1RUT00pIHtcclxuICAgICAgICAgICAgICAgICAgICB5TWF4ID0gY29udGVudEVkZ2UueU1heCAtICh0aGlzLnRvcCArIGkgKiB0aGlzLnNwYWNpbmdZICsgKHRvdGFsSGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB5TWluID0geU1heCAtIHNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5TWF4ICsgdGhpcy5ub2RlLnkgPCB0aGlzLl92aWV3RWRnZS55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeU1pbiArIHRoaXMubm9kZS55ID4gdGhpcy5fdmlld0VkZ2UueU1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHlNaW4gPSBjb250ZW50RWRnZS55TWluICsgdGhpcy5ib3R0b20gKyBpICogdGhpcy5zcGFjaW5nWSArICh0b3RhbEhlaWdodCAtIHNpemUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB5TWF4ID0geU1pbiArIHNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5TWluICsgdGhpcy5ub2RlLnkgPiB0aGlzLl92aWV3RWRnZS55TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeU1heCArIHRoaXMubm9kZS55IDwgdGhpcy5fdmlld0VkZ2UueU1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5Yik5pat5pi+56S65Yy65Z+f5YaF6YOo5piv5ZCm5pyJ6IqC54K55pi+56S65q2k5p2h5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBpblZpZXcuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiB0aGlzLl9pdGVtc1tlXS5nZXRDb21wb25lbnQoVmlydHVhbEl0ZW0pLmRhdGFJZHggPT09IGk7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOayoeacieiKgueCueaYvuekuuatpOadoeaVsOaNru+8jOmcgOS9v+eUqOaYvuekuuWMuuWfn+WklueahOiKgueCueaYvuekuuatpOadoeaVsOaNrlxyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1JZHg6IG51bWJlciA9IG91dFZpZXcubGVuZ3RoID09PSAwID8gdGhpcy5hZGRJdGVtTm9kZSgpIDogb3V0Vmlldy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW06IGNjLk5vZGUgPSB0aGlzLl9pdGVtc1tpdGVtSWR4XTtcclxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0Q29udGVudFNpemUoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oY2MudjMoMCwgeU1pbiArIGl0ZW0uYW5jaG9yWSAqIHNpemUuaGVpZ2h0KSwgaSwgaXRlbUlkeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpc3QuYXJnc0Fyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmNhbGNJdGVtU2l6ZVVuZml4ZWQoaSk7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsRGlyZWN0aW9uID09PSBIb3Jpem9udGFsRGlyZWN0aW9uLlJJR0hUX1RPX0xFRlQpIHtcclxuICAgICAgICAgICAgICAgICAgICB4TWF4ID0gY29udGVudEVkZ2UueE1heCAtICh0aGlzLnJpZ2h0ICsgaSAqIHRoaXMuc3BhY2luZ1ggKyAodG90YWxXaWR0aCAtIHNpemUud2lkdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB4TWluID0geE1heCAtIHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhNYXggKyB0aGlzLm5vZGUueCA8IHRoaXMuX3ZpZXdFZGdlLnhNaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TWluICsgdGhpcy5ub2RlLnggPiB0aGlzLl92aWV3RWRnZS54TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1pbiA9IGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLmxlZnQgKyBpICogdGhpcy5zcGFjaW5nWCArICh0b3RhbFdpZHRoIC0gc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeE1heCA9IHhNaW4gKyBzaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TWluICsgdGhpcy5ub2RlLnggPiB0aGlzLl92aWV3RWRnZS54TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeE1heCArIHRoaXMubm9kZS54IDwgdGhpcy5fdmlld0VkZ2UueE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8g5Yik5pat5pi+56S65Yy65Z+f5YaF6YOo5piv5ZCm5pyJ6IqC54K55pi+56S65q2k5p2h5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBpblZpZXcuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiB0aGlzLl9pdGVtc1tlXS5nZXRDb21wb25lbnQoVmlydHVhbEl0ZW0pLmRhdGFJZHggPT09IGk7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOayoeacieiKgueCueaYvuekuuatpOadoeaVsOaNru+8jOmcgOS9v+eUqOaYvuekuuWMuuWfn+WklueahOiKgueCueaYvuekuuatpOadoeaVsOaNrlxyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1JZHg6IG51bWJlciA9IG91dFZpZXcubGVuZ3RoID09PSAwID8gdGhpcy5hZGRJdGVtTm9kZSgpIDogb3V0Vmlldy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW06IGNjLk5vZGUgPSB0aGlzLl9pdGVtc1tpdGVtSWR4XTtcclxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0Q29udGVudFNpemUoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEl0ZW0oY2MudjMoeE1pbiArIGl0ZW0uYW5jaG9yWCAqIHNpemUud2lkdGgsIDApLCBpLCBpdGVtSWR4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5Zue5pS25Yy65Z+f5aSW55qE6IqC54K5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG91dFZpZXcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5wdXRBY3RpdmF0ZWRJdGVtQnlJbmRleChvdXRWaWV3W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDljLrliIblnKh2aWV35YaF6YOo5LiO5aSW6YOo55qEaXRlbXPmlbDnu4TkuIvmoIfvvIjov5Tlm57nmoTkuIvmoIfmlbDnu4TkvJrku47lsI/liLDlpKfmjpLluo/vvIlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja1ZpZXdJdGVtKCk6IHsgaW5WaWV3OiBudW1iZXJbXSwgb3V0VmlldzogbnVtYmVyW10gfSB7XHJcbiAgICAgICAgLy8g5pi+56S65Yy65Z+f5YaF6YOo55qE5LiL5qCHXHJcbiAgICAgICAgbGV0IGluVmlldzogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICAvLyDmmL7npLrljLrln5/lpJbpg6jnmoTkuIvmoIdcclxuICAgICAgICBsZXQgb3V0VmlldzogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gTGF5b3V0VHlwZS5WRVJUSUNBTCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2l0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGl0ZW0uZ2V0Qm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3gueU1pbiArIHRoaXMubm9kZS55IDw9IHRoaXMuX3ZpZXdFZGdlLnlNYXggJiYgYm94LnlNYXggKyB0aGlzLm5vZGUueSA+PSB0aGlzLl92aWV3RWRnZS55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5WaWV3LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dFZpZXcucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBMYXlvdXRUeXBlLkhPUklaT05UQUwpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCBib3ggPSBpdGVtLmdldEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm94LnhNaW4gKyB0aGlzLm5vZGUueCA8PSB0aGlzLl92aWV3RWRnZS54TWF4ICYmIGJveC54TWF4ICsgdGhpcy5ub2RlLnggPj0gdGhpcy5fdmlld0VkZ2UueE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGluVmlldy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRWaWV3LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2l0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGl0ZW0uZ2V0Qm91bmRpbmdCb3goKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3gueE1pbiArIHRoaXMubm9kZS54IDw9IHRoaXMuX3ZpZXdFZGdlLnhNYXggJiYgYm94LnhNYXggKyB0aGlzLm5vZGUueCA+PSB0aGlzLl92aWV3RWRnZS54TWluXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgYm94LnlNaW4gKyB0aGlzLm5vZGUueSA8PSB0aGlzLl92aWV3RWRnZS55TWF4ICYmIGJveC55TWF4ICsgdGhpcy5ub2RlLnkgPj0gdGhpcy5fdmlld0VkZ2UueU1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGluVmlldy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRWaWV3LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IGluVmlldzogaW5WaWV3LCBvdXRWaWV3OiBvdXRWaWV3IH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5pdGVt5pWw5o2u5LiO5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0gcCDoioLngrnlnZDmoIdcclxuICAgICAqIEBwYXJhbSBkYXRhSWR4IHRoaXMuX2RhdGFBcnLnmoTkuIvmoIcgXHJcbiAgICAgKiBAcGFyYW0gaXRlbUlkeCB0aGlzLl9pdGVtc+eahOS4i+agh1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNldEl0ZW0ocDogY2MuVmVjMywgZGF0YUlkeDogbnVtYmVyLCBpdGVtSWR4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX2l0ZW1zW2l0ZW1JZHhdO1xyXG4gICAgICAgIGl0ZW0ucG9zaXRpb24gPSBwO1xyXG4gICAgICAgIGxldCB2aSA9IGl0ZW0uZ2V0Q29tcG9uZW50KFZpcnR1YWxJdGVtKTtcclxuICAgICAgICB2aS5kYXRhSWR4ID0gZGF0YUlkeDtcclxuICAgICAgICB2aS5hcmdzID0gdGhpcy5fbGlzdC5hcmdzQXJyW2RhdGFJZHhdO1xyXG4gICAgICAgIHZpLm9uUmVmcmVzaCh2aS5hcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xpc3Qub3RoZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IG5vZGVzOiBjYy5Ob2RlW10gPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fb3RoZXJJdGVtc0Fyci5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlW2l0ZW1JZHhdLnBvc2l0aW9uID0gcDtcclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZVtpdGVtSWR4XSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2aS5vdGhlcnMgPSBub2RlcztcclxuICAgICAgICAgICAgdmkub25SZWZyZXNoT3RoZXJzKC4uLnZpLm90aGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5r+A5rS75paw55qE6IqC54K577yM5bm25re75Yqg5YiwY29udGVudOS4i1xyXG4gICAgICogQHBhcmFtIHNob3cg6buY6K6k5Li6dHJ1ZeOAgmZhbHNl5pe25LiN5r+A5rS76IqC54K55bm25re75Yqg6L+b6IqC54K55rGg5Lit77yI5LuF5Zyob25Jbml05Lit5L2/55So77yJXHJcbiAgICAgKiBAcmV0dXJucyDmv4DmtLvnmoToioLngrnlnKh0aGlzLl9pdGVtc+S4reeahOS4i+agh1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZEl0ZW1Ob2RlKHNob3c6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbm9kZTogY2MuTm9kZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1Qb29sLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2l0ZW1Qb29sLnBvcCgpO1xyXG4gICAgICAgICAgICBub2RlLm9wYWNpdHkgPSAyNTU7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2gobm9kZSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1Qb29sQXJyLmZvckVhY2goKGUsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBvdGhlck5vZGUgPSBlLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgb3RoZXJOb2RlLm9wYWNpdHkgPSAyNTU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1zQXJyW2ldLnB1c2gob3RoZXJOb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRtcDogY2MuTm9kZSB8IGNjLlByZWZhYiA9IHRoaXMuX2xpc3QubWFpbi50ZW1wbGF0ZVR5cGUgPT09IE1haW5UZW1wbGF0ZVR5cGUuUFJFRkFCID8gdGhpcy5fbGlzdC5tYWluLnRlbXBsYXRlUHJlZmFiIDogdGhpcy5fbGlzdC5tYWluLnRlbXBsYXRlTm9kZTtcclxuICAgICAgICAgICAgbm9kZSA9IFJlcy5pbnN0YW50aWF0ZSh0bXAsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS5nZXRDb21wb25lbnQoVmlydHVhbEl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChWaXJ0dWFsSXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFkZENoaWxkKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5vcGFjaXR5ID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHV0SXRlbU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOaLt+i0neS4gOS7veWtkOiKgueCueaVsOe7hO+8jOmYsuatouWtkOiKgueCueenu+mZpOaXtuaUueWPmOS4i+agh1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5Db3B5ID0gbm9kZS5jaGlsZHJlbi5zbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdC5vdGhlcnMuZm9yRWFjaCgoZSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyTm9kZTogY2MuTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUudGVtcGxhdGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBPdGhlclRlbXBsYXRlVHlwZS5OT0RFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlck5vZGUgPSBSZXMuaW5zdGFudGlhdGUoZS50ZW1wbGF0ZU5vZGUsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgT3RoZXJUZW1wbGF0ZVR5cGUuUFJFRkFCOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlck5vZGUgPSBSZXMuaW5zdGFudGlhdGUoZS50ZW1wbGF0ZVByZWZhYiwgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBPdGhlclRlbXBsYXRlVHlwZS5NQUlOX0lURU1fQ0hJTEQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVG9vbC5pblJhbmdlKDAsIGNoaWxkcmVuQ29weS5sZW5ndGggLSAxLCBlLnRlbXBsYXRlQ2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5lcnJvcihgW1ZpcnR1YWxMYXlvdXQuYWRkSXRlbU5vZGVdIGVycm9yIGUudGVtcGxhdGVDaGlsZDogJHtlLnRlbXBsYXRlQ2hpbGR9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJOb2RlID0gY2hpbGRyZW5Db3B5W2UudGVtcGxhdGVDaGlsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTm9kZS5yZW1vdmVGcm9tUGFyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLmVycm9yKGBbVmlydHVhbExheW91dC5hZGRJdGVtTm9kZV0gZXJyb3IgZS50ZW1wbGF0ZVR5cGU6ICR7ZS50ZW1wbGF0ZVR5cGV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUuY29udGVudC5hZGRDaGlsZChvdGhlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdGhlck5vZGUub3BhY2l0eSA9IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1zQXJyW2ldLnB1c2gob3RoZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXRJdGVtTm9kZShvdGhlck5vZGUsIHRydWUsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCG6IqC54K55pS+5YWl6IqC54K55rGgXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBcclxuICAgICAqIEBwYXJhbSBpc090aGVyIOaYr+WQpuS4uk90aGVyc+S4i+eahOiKgueCuVxyXG4gICAgICogQHBhcmFtIG90aGVySWR4IE90aGVyc+eahOS4i+agh1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHB1dEl0ZW1Ob2RlKG5vZGU6IGNjLk5vZGUsIGlzT3RoZXI6IGJvb2xlYW4gPSBmYWxzZSwgb3RoZXJJZHg6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgICBub2RlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgIC8vIOmYsuatouW3suWbnuaUtueahOiKgueCueinpuWPkeeCueWHu+S6i+S7tlxyXG4gICAgICAgIG5vZGUuc2V0UG9zaXRpb24oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgICBpZiAoaXNPdGhlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9vdGhlckl0ZW1Qb29sQXJyW290aGVySWR4XS5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB2aSA9IG5vZGUuZ2V0Q29tcG9uZW50KFZpcnR1YWxJdGVtKTtcclxuICAgICAgICAgICAgdmkub25SZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pdGVtUG9vbC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWbnuaUtuW3sua/gOa0u+eahOiKgueCuVxyXG4gICAgICogQHBhcmFtIGluZGV4IOiKgueCueWcqHRoaXMuX2l0ZW1z5Lit55qE5LiL5qCHXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHV0QWN0aXZhdGVkSXRlbUJ5SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHV0SXRlbU5vZGUodGhpcy5faXRlbXNbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLl9vdGhlckl0ZW1zQXJyLmZvckVhY2goKGFyciwgb3RoZXJJZHgpID0+IHsgdGhpcy5wdXRJdGVtTm9kZShhcnJbaW5kZXhdLCB0cnVlLCBvdGhlcklkeCk7IH0pO1xyXG5cclxuICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHRoaXMuX290aGVySXRlbXNBcnIuZm9yRWFjaCgoYXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a2Q6IqC54K55Z2Q5qCH57O75LiL5Z2Q5qCH6L2s5o2i5Li654i26IqC54K55Z2Q5qCH57O75LiL5Z2Q5qCHXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29udmVydFRvUGFyZW50UG9zKHBvczogY2MuVmVjMywgY2hpbGQ6IGNjLk5vZGUpOiBjYy5WZWMzIHtcclxuICAgICAgICByZXR1cm4gcG9zLmFkZChjaGlsZC5wb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDniLboioLngrnlnZDmoIfns7vkuIvlnZDmoIfovazmjaLkuLrlrZDoioLngrnlnZDmoIfns7vkuIvlnZDmoIdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjb252ZXJ0VG9DaGlsZFBvcyhwb3M6IGNjLlZlYzMsIGNoaWxkOiBjYy5Ob2RlKTogY2MuVmVjMyB7XHJcbiAgICAgICAgcmV0dXJuIHBvcy5zdWIoY2hpbGQucG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IqC54K56Ieq6Lqr5Z2Q5qCH57O75LiL55qE6IqC54K56L6555WM55+p5b2iXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Tm9kZUVkZ2VSZWN0KG5vZGU6IGNjLk5vZGUpOiBjYy5SZWN0IHtcclxuICAgICAgICByZXR1cm4gY2MucmVjdCgtbm9kZS53aWR0aCAqIG5vZGUuYW5jaG9yWCwgLW5vZGUuaGVpZ2h0ICogbm9kZS5hbmNob3JZLCBub2RlLndpZHRoLCBub2RlLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7lhYPntKDkuIvmoIforqHnrpflr7nlupTlhYPntKDlpKflsI/vvIxpc0ZpeGVkU2l6ZeS4umZhbHNl5pe25L2/55SoXHJcbiAgICAgKiBAcGFyYW0gaWR4IFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGNJdGVtU2l6ZVVuZml4ZWQoaWR4OiBudW1iZXIpOiBjYy5TaXplIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdC5jYWxjSXRlbVNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuY2FsY0l0ZW1TaXplKHRoaXMuX2xpc3QuYXJnc0FycltpZHhdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZml4ZWRTaXplO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbnRlbnTkvY3np7vnm5HlkKzlm57osINcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvblBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcclxuICAgICAgICAvLyBTY3JvbGxWaWV35rqQ56CB55qEYnVn5aSE55CGXHJcbiAgICAgICAgLy8gMS7otoXlh7rovrnnlYznmoTlt67lgLzkvJrorrDlvZXlnKhfb3V0T2ZCb3VuZGFyeUFtb3VudOmHjO+8jOS9huaYr+i/meS4ql9vdXRPZkJvdW5kYXJ5QW1vdW505LiN5piv5q+P5qyh5qOA5rWL6L6555WM5pe26YO95pu05paw55qE77yM5a6D6ZyA6KaBX291dE9mQm91bmRhcnlBbW91bnREaXJ0eeS4unRydWXmiY3kvJrmm7TmlrBcclxuICAgICAgICAvLyAyLuWcqGNvbnRlbnQgc2l6ZeaUueWPmOeahOaXtuWAme+8jFNjcm9sbFZpZXfkvJrmo4DmtYtjb250ZW505pyJ5rKh5pyJ6LaF5Ye66L6555WM77yM5q2k5pe25Lya5pu05pawX291dE9mQm91bmRhcnlBbW91bnTlubbnm7TmjqXkv67mlLljb250ZW505Z2Q5qCH44CC5L2G5piv5L+u5pS55a6MY29udGVudOWdkOagh+S5i+WQjl9vdXRPZkJvdW5kYXJ5QW1vdW506K6w5b2V55qE5LuN5pen5piv5pen5YC877yM5q2k5pe2X291dE9mQm91bmRhcnlBbW91bnREaXJ0eeS4umZhbHNl44CCXHJcbiAgICAgICAgLy8gMy5TY3JvbGxWaWV35ZyodG91Y2hlbmTnmoTml7blgJnkvJrop6blj5Hmo4DmtYvlvZPliY3mnInmsqHmnInotoXlh7rovrnnlYzvvIzmnInnmoTor53oh6rliqjlm57lvLnmu5rliqjjgILnlLHkuo5fb3V0T2ZCb3VuZGFyeUFtb3VudERpcnR55Li6ZmFsc2XvvIzmiYDku6XlubbmnKrmm7TmlrBfb3V0T2ZCb3VuZGFyeUFtb3VudO+8jOiAjOaYr+ebtOaOpeWPlumUmeivr+eahF9vdXRPZkJvdW5kYXJ5QW1vdW505L2c5Li66LaF5Ye66L6555WM55qE5YC877yM54S25ZCO6L+b6KGM6ZSZ6K+v55qE6Ieq5Yqo5Zue5by544CCXHJcbiAgICAgICAgdGhpcy5fbGlzdC5zY3JvbGxWaWV3W1wiX291dE9mQm91bmRhcnlBbW91bnREaXJ0eVwiXSA9IHRydWU7XHJcbiAgICAgICAgLy8g5pu05paw5qCH6K6wXHJcbiAgICAgICAgdGhpcy5fdmlld0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9wb3NEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB2aWV3IHNpemXnm5HlkKzlm57osINcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvblZpZXdTaXplQ2hhbmdlZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl92aWV3RWRnZSA9IHRoaXMuZ2V0Tm9kZUVkZ2VSZWN0KHRoaXMuX3ZpZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WY29udGVudOebuOWvuXZpZXflt6bkuIrop5Lljp/ngrnkvY3nva7nmoTlgY/np7vlgLxcclxuICAgICAqIEBwYXJhbSBpZHgg5YWD57Sg5LiL5qCHXHJcbiAgICAgKiBAcGFyYW0gaXRlbUFuY2hvciDlhYPntKDnmoTplJrngrnkvY3nva7vvIjlt6bkuIvop5LkuLow54K577yJXHJcbiAgICAgKiBAcGFyYW0gdmlld0FuY2hvciB2aWV355qE6ZSa54K55L2N572u77yI5bem5LiL6KeS5Li6MOeCue+8iVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2Nyb2xsT2Zmc2V0KGlkeDogbnVtYmVyLCBpdGVtQW5jaG9yOiBjYy5WZWMyLCB2aWV3QW5jaG9yOiBjYy5WZWMyKTogY2MuVmVjMiB7XHJcbiAgICAgICAgaWR4ID0gTWF0aC5taW4oaWR4LCB0aGlzLl9saXN0LmFyZ3NBcnIubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuaXNGaXhlZFNpemUgPyB0aGlzLmdldFNjcm9sbE9mZnNldEZpeGVkKGlkeCwgaXRlbUFuY2hvciwgdmlld0FuY2hvcikgOiB0aGlzLmdldFNjcm9sbE9mZnNldFVuZml4ZWQoaWR4LCBpdGVtQW5jaG9yLCB2aWV3QW5jaG9yKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFNjcm9sbE9mZnNldEZpeGVkKGlkeDogbnVtYmVyLCBpdGVtQW5jaG9yOiBjYy5WZWMyLCB2aWV3QW5jaG9yOiBjYy5WZWMyKTogY2MuVmVjMiB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRFZGdlID0gdGhpcy5nZXROb2RlRWRnZVJlY3QodGhpcy5ub2RlKTtcclxuICAgICAgICBsZXQgeE1heDogbnVtYmVyLCB4TWluOiBudW1iZXIsIHlNYXg6IG51bWJlciwgeU1pbjogbnVtYmVyO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsRGlyZWN0aW9uLlRPUF9UT19CT1RUT00pIHtcclxuICAgICAgICAgICAgICAgIHlNYXggPSBjb250ZW50RWRnZS55TWF4IC0gKHRoaXMudG9wICsgaWR4ICogdGhpcy5zcGFjaW5nWSArIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQgKiBpZHgpO1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IHlNYXggLSB0aGlzLl9maXhlZFNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IGNvbnRlbnRFZGdlLnlNaW4gKyB0aGlzLmJvdHRvbSArIGlkeCAqIHRoaXMuc3BhY2luZ1kgKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICogaWR4O1xyXG4gICAgICAgICAgICAgICAgeU1heCA9IHlNaW4gKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5fdmlld0VkZ2UueE1pbiAtIChjb250ZW50RWRnZS54TWluICsgdGhpcy5ub2RlLngpO1xyXG4gICAgICAgICAgICBsZXQgeSA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIGl0ZW1BbmNob3IueSArIHlNaW4pIC0gKDEgLSB2aWV3QW5jaG9yLnkpICogdGhpcy5fdmlld0VkZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gY2MudjIoeCwgeSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsRGlyZWN0aW9uID09PSBIb3Jpem9udGFsRGlyZWN0aW9uLlJJR0hUX1RPX0xFRlQpIHtcclxuICAgICAgICAgICAgICAgIHhNYXggPSBjb250ZW50RWRnZS54TWF4IC0gKHRoaXMucmlnaHQgKyBpZHggKiB0aGlzLnNwYWNpbmdYICsgdGhpcy5fZml4ZWRTaXplLndpZHRoICogaWR4KTtcclxuICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4IC0gdGhpcy5fZml4ZWRTaXplLndpZHRoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLmxlZnQgKyBpZHggKiB0aGlzLnNwYWNpbmdYICsgdGhpcy5fZml4ZWRTaXplLndpZHRoICogaWR4O1xyXG4gICAgICAgICAgICAgICAgeE1heCA9IHhNaW4gKyB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLl9maXhlZFNpemUud2lkdGggKiBpdGVtQW5jaG9yLnggKyB4TWluIC0gY29udGVudEVkZ2UueE1pbiAtIHZpZXdBbmNob3IueCAqIHRoaXMuX3ZpZXdFZGdlLndpZHRoO1xyXG4gICAgICAgICAgICBsZXQgeSA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy5fdmlld0VkZ2UueU1heCAtIHRoaXMubm9kZS55KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNjLnYyKHgsIHkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOiuoeeul+W9k+WJjeWFg+e0oOaOkuWcqOesrOWHoOihjOesrOWHoOWIl++8jOS7jjDlvIDlp4tcclxuICAgICAgICAgICAgbGV0IHJvd0luZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgY29sdW1uSW5kZXg6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0QXhpcyA9PT0gQXhpc0RpcmVjdGlvbi5IT1JJWk9OVEFMKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gTWF0aC5mbG9vcigodGhpcy5ub2RlLndpZHRoIC0gdGhpcy5sZWZ0IC0gdGhpcy5yaWdodCArIHRoaXMuc3BhY2luZ1gpIC8gKHRoaXMuX2ZpeGVkU2l6ZS53aWR0aCArIHRoaXMuc3BhY2luZ1gpKTtcclxuICAgICAgICAgICAgICAgIG51bSA9IE1hdGgubWF4KG51bSwgMSk7XHJcbiAgICAgICAgICAgICAgICByb3dJbmRleCA9IE1hdGguZmxvb3IoaWR4IC8gbnVtKTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gaWR4ICUgbnVtO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bSA9IE1hdGguZmxvb3IoKHRoaXMubm9kZS5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICsgdGhpcy5zcGFjaW5nWSkgLyAodGhpcy5fZml4ZWRTaXplLmhlaWdodCArIHRoaXMuc3BhY2luZ1kpKTtcclxuICAgICAgICAgICAgICAgIG51bSA9IE1hdGgubWF4KG51bSwgMSk7XHJcbiAgICAgICAgICAgICAgICByb3dJbmRleCA9IGlkeCAlIG51bTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gTWF0aC5mbG9vcihpZHggLyBudW0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbERpcmVjdGlvbiA9PT0gVmVydGljYWxEaXJlY3Rpb24uVE9QX1RPX0JPVFRPTSkge1xyXG4gICAgICAgICAgICAgICAgeU1heCA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy50b3AgKyByb3dJbmRleCAqIHRoaXMuc3BhY2luZ1kgKyB0aGlzLl9maXhlZFNpemUuaGVpZ2h0ICogcm93SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IHlNYXggLSB0aGlzLl9maXhlZFNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IGNvbnRlbnRFZGdlLnlNaW4gKyB0aGlzLmJvdHRvbSArIHJvd0luZGV4ICogdGhpcy5zcGFjaW5nWSArIHRoaXMuX2ZpeGVkU2l6ZS5oZWlnaHQgKiByb3dJbmRleDtcclxuICAgICAgICAgICAgICAgIHlNYXggPSB5TWluICsgdGhpcy5fZml4ZWRTaXplLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVF9UT19MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICB4TWF4ID0gY29udGVudEVkZ2UueE1heCAtICh0aGlzLnJpZ2h0ICsgY29sdW1uSW5kZXggKiB0aGlzLnNwYWNpbmdYICsgdGhpcy5fZml4ZWRTaXplLndpZHRoICogY29sdW1uSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggLSB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4TWluID0gY29udGVudEVkZ2UueE1pbiArIHRoaXMubGVmdCArIGNvbHVtbkluZGV4ICogdGhpcy5zcGFjaW5nWCArIHRoaXMuX2ZpeGVkU2l6ZS53aWR0aCAqIGNvbHVtbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgeE1heCA9IHhNaW4gKyB0aGlzLl9maXhlZFNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLl9maXhlZFNpemUud2lkdGggKiBpdGVtQW5jaG9yLnggKyB4TWluIC0gY29udGVudEVkZ2UueE1pbiAtIHZpZXdBbmNob3IueCAqIHRoaXMuX3ZpZXdFZGdlLndpZHRoO1xyXG4gICAgICAgICAgICBsZXQgeSA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy5fZml4ZWRTaXplLmhlaWdodCAqIGl0ZW1BbmNob3IueSArIHlNaW4pIC0gKDEgLSB2aWV3QW5jaG9yLnkpICogdGhpcy5fdmlld0VkZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gY2MudjIoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0U2Nyb2xsT2Zmc2V0VW5maXhlZChpZHg6IG51bWJlciwgaXRlbUFuY2hvcjogY2MuVmVjMiwgdmlld0FuY2hvcjogY2MuVmVjMik6IGNjLlZlYzIge1xyXG4gICAgICAgIGxldCBjb250ZW50RWRnZSA9IHRoaXMuZ2V0Tm9kZUVkZ2VSZWN0KHRoaXMubm9kZSk7XHJcbiAgICAgICAgbGV0IHhNYXg6IG51bWJlciwgeE1pbjogbnVtYmVyLCB5TWF4OiBudW1iZXIsIHlNaW46IG51bWJlcjtcclxuICAgICAgICBsZXQgY3VyU2l6ZTogY2MuU2l6ZSA9IHRoaXMuY2FsY0l0ZW1TaXplVW5maXhlZChpZHgpO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuVkVSVElDQUwpIHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsSGVpZ2h0OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkeDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuY2FsY0l0ZW1TaXplVW5maXhlZChpKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IHNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsRGlyZWN0aW9uID09PSBWZXJ0aWNhbERpcmVjdGlvbi5UT1BfVE9fQk9UVE9NKSB7XHJcbiAgICAgICAgICAgICAgICB5TWF4ID0gY29udGVudEVkZ2UueU1heCAtICh0aGlzLnRvcCArIGlkeCAqIHRoaXMuc3BhY2luZ1kgKyB0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB5TWluID0geU1heCAtIGN1clNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IGNvbnRlbnRFZGdlLnlNaW4gKyB0aGlzLmJvdHRvbSArIGlkeCAqIHRoaXMuc3BhY2luZ1kgKyB0b3RhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHlNYXggPSB5TWluICsgY3VyU2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSB0aGlzLl92aWV3RWRnZS54TWluIC0gKGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLm5vZGUueCk7XHJcbiAgICAgICAgICAgIGxldCB5ID0gY29udGVudEVkZ2UueU1heCAtIChjdXJTaXplLmhlaWdodCAqIGl0ZW1BbmNob3IueSArIHlNaW4pIC0gKDEgLSB2aWV3QW5jaG9yLnkpICogdGhpcy5fdmlld0VkZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gY2MudjIoeCwgeSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IExheW91dFR5cGUuSE9SSVpPTlRBTCkge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxXaWR0aDogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0aGlzLmNhbGNJdGVtU2l6ZVVuZml4ZWQoaSk7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gSG9yaXpvbnRhbERpcmVjdGlvbi5SSUdIVF9UT19MRUZUKSB7XHJcbiAgICAgICAgICAgICAgICB4TWF4ID0gY29udGVudEVkZ2UueE1heCAtICh0aGlzLnJpZ2h0ICsgaWR4ICogdGhpcy5zcGFjaW5nWCArIHRvdGFsV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IHhNYXggLSBjdXJTaXplLndpZHRoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IGNvbnRlbnRFZGdlLnhNaW4gKyB0aGlzLmxlZnQgKyBpZHggKiB0aGlzLnNwYWNpbmdYICsgdG90YWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIHhNYXggPSB4TWluICsgY3VyU2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeCA9IGN1clNpemUud2lkdGggKiBpdGVtQW5jaG9yLnggKyB4TWluIC0gY29udGVudEVkZ2UueE1pbiAtIHZpZXdBbmNob3IueCAqIHRoaXMuX3ZpZXdFZGdlLndpZHRoO1xyXG4gICAgICAgICAgICBsZXQgeSA9IGNvbnRlbnRFZGdlLnlNYXggLSAodGhpcy5fdmlld0VkZ2UueU1heCAtIHRoaXMubm9kZS55KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNjLnYyKHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOaOkuWIl1xyXG4gICAgICogQHBhcmFtIGNsZWFyIOaYr+WQpua4heepuuiKgueCue+8jOm7mOiupHRydWUo5LuF5b2T5LiN5Lya5b2x5ZON5bey5pyJ5YWD57Sg6IqC54K55o6S5YiX5pe25omN5Y+v5Lyg5YWlZmFsc2UpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFycmFuZ2UoY2xlYXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmIChjbGVhcikge1xyXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKChlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1dEl0ZW1Ob2RlKGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3RoZXJJdGVtc0Fyci5mb3JFYWNoKChhcnIsIG90aGVySWR4KSA9PiB7IHRoaXMucHV0SXRlbU5vZGUoYXJyW2ldLCB0cnVlLCBvdGhlcklkeCk7IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fb3RoZXJJdGVtc0Fyci5mb3JFYWNoKChhcnIpID0+IHsgYXJyLmxlbmd0aCA9IDA7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIt+aWsOaJgOaciea/gOa0u+eahGl0ZW1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZnJlc2hBbGxJdGVtcygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2aSA9IGl0ZW0uZ2V0Q29tcG9uZW50KFZpcnR1YWxJdGVtKTtcclxuICAgICAgICAgICAgdmkub25SZWZyZXNoKHZpLmFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdC5vdGhlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmkub25SZWZyZXNoT3RoZXJzKC4uLnZpLm90aGVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/const/Url.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a8f33QbcWNMTZ0PfOQy5Uvh', 'Url');
// scripts/common/const/Url.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirUrl = exports.ResUrl = void 0;
/**
 * 单个资源路径
 */
exports.ResUrl = {
    PREFAB: {
        TIP: "prefab/tip/Tip",
        HOME: "prefab/home/Home",
        GAME: "prefab/game/Game",
    },
    ATLAS: {
        EN: "textures/localizedImage/en/AutoAtlas",
        ZH: "textures/localizedImage/zh/AutoAtlas"
    },
    AUDIO: {
        BGM1: "audio/bgm1",
        BGM2: "audio/bgm2",
        SFX1: "audio/sfx1",
        SFX2: "audio/sfx2",
        SFX_UI: "audio/sfxUi",
    }
};
/**
 * 文件夹路径
 */
exports.DirUrl = {
    PREFAB: "prefab/",
    PREFAB_DIALOG: "prefab/dialog/",
    ATLAS: "atlas/",
    TEXTURE: "textures/",
    AUDIO: "audio/",
    JSON: "json/",
    ANIMATION: "animation/",
};

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjb25zdFxcVXJsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ1UsUUFBQSxNQUFNLEdBQUc7SUFDbEIsTUFBTSxFQUFFO1FBQ0osR0FBRyxFQUFFLGdCQUFnQjtRQUNyQixJQUFJLEVBQUUsa0JBQWtCO1FBQ3hCLElBQUksRUFBRSxrQkFBa0I7S0FFM0I7SUFFRCxLQUFLLEVBQUU7UUFDSCxFQUFFLEVBQUUsc0NBQXNDO1FBQzFDLEVBQUUsRUFBRSxzQ0FBc0M7S0FDN0M7SUFFRCxLQUFLLEVBQUU7UUFDSCxJQUFJLEVBQUUsWUFBWTtRQUNsQixJQUFJLEVBQUUsWUFBWTtRQUVsQixJQUFJLEVBQUUsWUFBWTtRQUNsQixJQUFJLEVBQUUsWUFBWTtRQUNsQixNQUFNLEVBQUUsYUFBYTtLQUN4QjtDQUNKLENBQUE7QUFFRDs7R0FFRztBQUNVLFFBQUEsTUFBTSxHQUFHO0lBQ2xCLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGFBQWEsRUFBRSxnQkFBZ0I7SUFFL0IsS0FBSyxFQUFFLFFBQVE7SUFFZixPQUFPLEVBQUUsV0FBVztJQUVwQixLQUFLLEVBQUUsUUFBUTtJQUVmLElBQUksRUFBRSxPQUFPO0lBRWIsU0FBUyxFQUFFLFlBQVk7Q0FDMUIsQ0FBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiDljZXkuKrotYTmupDot6/lvoRcclxuICovXHJcbmV4cG9ydCBjb25zdCBSZXNVcmwgPSB7XHJcbiAgICBQUkVGQUI6IHtcclxuICAgICAgICBUSVA6IFwicHJlZmFiL3RpcC9UaXBcIixcclxuICAgICAgICBIT01FOiBcInByZWZhYi9ob21lL0hvbWVcIixcclxuICAgICAgICBHQU1FOiBcInByZWZhYi9nYW1lL0dhbWVcIixcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIEFUTEFTOiB7XHJcbiAgICAgICAgRU46IFwidGV4dHVyZXMvbG9jYWxpemVkSW1hZ2UvZW4vQXV0b0F0bGFzXCIsXHJcbiAgICAgICAgWkg6IFwidGV4dHVyZXMvbG9jYWxpemVkSW1hZ2UvemgvQXV0b0F0bGFzXCJcclxuICAgIH0sXHJcblxyXG4gICAgQVVESU86IHtcclxuICAgICAgICBCR00xOiBcImF1ZGlvL2JnbTFcIixcclxuICAgICAgICBCR00yOiBcImF1ZGlvL2JnbTJcIixcclxuXHJcbiAgICAgICAgU0ZYMTogXCJhdWRpby9zZngxXCIsXHJcbiAgICAgICAgU0ZYMjogXCJhdWRpby9zZngyXCIsXHJcbiAgICAgICAgU0ZYX1VJOiBcImF1ZGlvL3NmeFVpXCIsXHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDmlofku7blpLnot6/lvoRcclxuICovXHJcbmV4cG9ydCBjb25zdCBEaXJVcmwgPSB7XHJcbiAgICBQUkVGQUI6IFwicHJlZmFiL1wiLFxyXG4gICAgUFJFRkFCX0RJQUxPRzogXCJwcmVmYWIvZGlhbG9nL1wiLFxyXG5cclxuICAgIEFUTEFTOiBcImF0bGFzL1wiLFxyXG5cclxuICAgIFRFWFRVUkU6IFwidGV4dHVyZXMvXCIsXHJcblxyXG4gICAgQVVESU86IFwiYXVkaW8vXCIsXHJcblxyXG4gICAgSlNPTjogXCJqc29uL1wiLFxyXG5cclxuICAgIEFOSU1BVElPTjogXCJhbmltYXRpb24vXCIsXHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/ui/scrollList/VirtualItem.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '37390yL2g9Gx56ICLo3MK1K', 'VirtualItem');
// scripts/common/cmpt/ui/scrollList/VirtualItem.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, disallowMultiple = _a.disallowMultiple;
/**
 * 虚拟列表的元素组件
 */
var VirtualItem = /** @class */ (function (_super) {
    __extends(VirtualItem, _super);
    function VirtualItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** 列表数据索引 */
        _this.dataIdx = 0;
        /** 列表数据 */
        _this.args = null;
        /** 分层的其余节点，顺序为Others数组的顺序 */
        _this.others = [];
        return _this;
    }
    /**
     * 根据数据刷新item显示
     * @virtual
     */
    VirtualItem.prototype.onRefresh = function (args) {
    };
    /**
     * 在onRefresh之后调用，参数为分层显示的节点，参数顺序为Others数组的顺序
     * @virtual
     */
    VirtualItem.prototype.onRefreshOthers = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
    };
    /**
     * 回收item时重置内部状态
     * @virtual
     */
    VirtualItem.prototype.onReset = function () {
    };
    /**
     * 获取item显示当前数据所需的真实大小（若节点size会根据数据改变，请在此函数内返回准确的size）
     * @virtual
     */
    VirtualItem.prototype.getRealSize = function () {
        return this.node.getContentSize();
    };
    VirtualItem = __decorate([
        ccclass,
        disallowMultiple
    ], VirtualItem);
    return VirtualItem;
}(cc.Component));
exports.default = VirtualItem;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFx1aVxcc2Nyb2xsTGlzdFxcVmlydHVhbEl0ZW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU0sSUFBQSxLQUFnQyxFQUFFLENBQUMsVUFBVSxFQUEzQyxPQUFPLGFBQUEsRUFBRSxnQkFBZ0Isc0JBQWtCLENBQUM7QUFFcEQ7O0dBRUc7QUFHSDtJQUFnRSwrQkFBWTtJQUE1RTtRQUFBLHFFQW9DQztRQW5DRyxhQUFhO1FBQ04sYUFBTyxHQUFXLENBQUMsQ0FBQztRQUMzQixXQUFXO1FBQ0osVUFBSSxHQUFNLElBQUksQ0FBQztRQUN0Qiw2QkFBNkI7UUFDdEIsWUFBTSxHQUFjLEVBQUUsQ0FBQzs7SUE4QmxDLENBQUM7SUE1Qkc7OztPQUdHO0lBQ0ksK0JBQVMsR0FBaEIsVUFBaUIsSUFBTztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0kscUNBQWUsR0FBdEI7UUFBdUIsZUFBbUI7YUFBbkIsVUFBbUIsRUFBbkIscUJBQW1CLEVBQW5CLElBQW1CO1lBQW5CLDBCQUFtQjs7SUFDMUMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDZCQUFPLEdBQWQ7SUFDQSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksaUNBQVcsR0FBbEI7UUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDdEMsQ0FBQztJQW5DZ0IsV0FBVztRQUYvQixPQUFPO1FBQ1AsZ0JBQWdCO09BQ0ksV0FBVyxDQW9DL0I7SUFBRCxrQkFBQztDQXBDRCxBQW9DQyxDQXBDK0QsRUFBRSxDQUFDLFNBQVMsR0FvQzNFO2tCQXBDb0IsV0FBVyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZpcnR1YWxBcmdzIH0gZnJvbSBcIi4vVmlydHVhbExpc3RcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgZGlzYWxsb3dNdWx0aXBsZSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbi8qKlxyXG4gKiDomZrmi5/liJfooajnmoTlhYPntKDnu4Tku7ZcclxuICovXHJcbkBjY2NsYXNzXHJcbkBkaXNhbGxvd011bHRpcGxlXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpcnR1YWxJdGVtPFQgZXh0ZW5kcyBWaXJ0dWFsQXJncz4gZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgLyoqIOWIl+ihqOaVsOaNrue0ouW8lSAqL1xyXG4gICAgcHVibGljIGRhdGFJZHg6IG51bWJlciA9IDA7XHJcbiAgICAvKiog5YiX6KGo5pWw5o2uICovXHJcbiAgICBwdWJsaWMgYXJnczogVCA9IG51bGw7XHJcbiAgICAvKiog5YiG5bGC55qE5YW25L2Z6IqC54K577yM6aG65bqP5Li6T3RoZXJz5pWw57uE55qE6aG65bqPICovXHJcbiAgICBwdWJsaWMgb3RoZXJzOiBjYy5Ob2RlW10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruaVsOaNruWIt+aWsGl0ZW3mmL7npLpcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblJlZnJlc2goYXJnczogVCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Zyob25SZWZyZXNo5LmL5ZCO6LCD55So77yM5Y+C5pWw5Li65YiG5bGC5pi+56S655qE6IqC54K577yM5Y+C5pWw6aG65bqP5Li6T3RoZXJz5pWw57uE55qE6aG65bqPXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25SZWZyZXNoT3RoZXJzKC4uLm5vZGVzOiBjYy5Ob2RlW10pOiB2b2lkIHtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWbnuaUtml0ZW3ml7bph43nva7lhoXpg6jnirbmgIFcclxuICAgICAqIEB2aXJ0dWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblJlc2V0KCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WaXRlbeaYvuekuuW9k+WJjeaVsOaNruaJgOmcgOeahOecn+WunuWkp+Wwj++8iOiLpeiKgueCuXNpemXkvJrmoLnmja7mlbDmja7mlLnlj5jvvIzor7flnKjmraTlh73mlbDlhoXov5Tlm57lh4bnoa7nmoRzaXpl77yJXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmVhbFNpemUoKTogY2MuU2l6ZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb250ZW50U2l6ZSgpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/hack/EditorBoxHack.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '4a973xjr51JNIXUFY3Q2XsC', 'EditorBoxHack');
// scripts/common/hack/EditorBoxHack.ts

// 基于CocosCreator2.x EditBox组件hack代码
// 移动端web环境下，当EditBox会被弹出的软键盘遮挡时，视图向上滚动至EditBox在软键盘上方可见的位置。反之视图位置不变
if (!CC_PREVIEW && cc.sys.platform === cc.sys.MOBILE_BROWSER) {
    cc.EditBox["_ImplClass"].prototype._adjustWindowScroll = function () {
        var self = this;
        setTimeout(function () {
            if (window.scrollY < 100) {
                var editBox = self._delegate;
                if (editBox && editBox.node) {
                    var worldBox = editBox.node.getBoundingBoxToWorld();
                    var scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
                    var clientHeight = document.documentElement.clientHeight || document.body.clientHeight;
                    var ratio = cc.winSize.height / scrollHeight;
                    var keyboardDomHeight = scrollHeight - clientHeight;
                    var keyboardCocosHeight = keyboardDomHeight * ratio;
                    console.error("scrollHeight: " + scrollHeight + ", clientHeight: " + clientHeight + ", ratio: " + ratio);
                    console.error("keyboardDomHeight: " + keyboardDomHeight + ", keyboardCocosHeight: " + keyboardCocosHeight);
                    if (worldBox.yMin >= keyboardCocosHeight) {
                        console.error("return");
                        return;
                    }
                    // DOM坐标系下，EditBox底部与软键盘顶部的距离
                    var domDelta = (keyboardCocosHeight - worldBox.yMin) / ratio;
                    window.scroll({ top: domDelta, behavior: 'smooth' });
                    console.error("domDelta: " + domDelta);
                }
                else {
                    self._elem.scrollIntoView({ block: "start", inline: "nearest", behavior: "smooth" });
                    console.error("scrollIntoView");
                }
            }
        }, 500);
    };
}

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxoYWNrXFxFZGl0b3JCb3hIYWNrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9DQUFvQztBQUNwQyxtRUFBbUU7QUFDbkUsSUFBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRTtJQUMxRCxFQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsR0FBRztRQUNyRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsVUFBVSxDQUFDO1lBQ1AsSUFBSSxNQUFNLENBQUMsT0FBTyxHQUFHLEdBQUcsRUFBRTtnQkFDdEIsSUFBSSxPQUFPLEdBQWUsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFDekMsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksRUFBRTtvQkFDekIsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO29CQUNwRCxJQUFJLFlBQVksR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLFlBQVksSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDdkYsSUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxZQUFZLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7b0JBQ3ZGLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQztvQkFDN0MsSUFBSSxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsWUFBWSxDQUFDO29CQUNwRCxJQUFJLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLEtBQUssQ0FBQztvQkFDcEQsT0FBTyxDQUFDLEtBQUssQ0FBQyxtQkFBaUIsWUFBWSx3QkFBbUIsWUFBWSxpQkFBWSxLQUFPLENBQUMsQ0FBQztvQkFDL0YsT0FBTyxDQUFDLEtBQUssQ0FBQyx3QkFBc0IsaUJBQWlCLCtCQUEwQixtQkFBcUIsQ0FBQyxDQUFDO29CQUN0RyxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksbUJBQW1CLEVBQUU7d0JBQ3RDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQ3hCLE9BQU87cUJBQ1Y7b0JBRUQsNkJBQTZCO29CQUM3QixJQUFJLFFBQVEsR0FBRyxDQUFDLG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7b0JBQzdELE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUNyRCxPQUFPLENBQUMsS0FBSyxDQUFDLGVBQWEsUUFBVSxDQUFDLENBQUM7aUJBQzFDO3FCQUFNO29CQUNILElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO29CQUNyRixPQUFPLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7aUJBQ25DO2FBQ0o7UUFDTCxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDWixDQUFDLENBQUE7Q0FDSiIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8vIOWfuuS6jkNvY29zQ3JlYXRvcjIueCBFZGl0Qm9457uE5Lu2aGFja+S7o+eggVxyXG4vLyDnp7vliqjnq693ZWLnjq/looPkuIvvvIzlvZNFZGl0Qm945Lya6KKr5by55Ye655qE6L2v6ZSu55uY6YGu5oyh5pe277yM6KeG5Zu+5ZCR5LiK5rua5Yqo6IezRWRpdEJveOWcqOi9r+mUruebmOS4iuaWueWPr+ingeeahOS9jee9ruOAguWPjeS5i+inhuWbvuS9jee9ruS4jeWPmFxyXG5pZiAoIUNDX1BSRVZJRVcgJiYgY2Muc3lzLnBsYXRmb3JtID09PSBjYy5zeXMuTU9CSUxFX0JST1dTRVIpIHtcclxuICAgIGNjLkVkaXRCb3hbXCJfSW1wbENsYXNzXCJdLnByb3RvdHlwZS5fYWRqdXN0V2luZG93U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxZIDwgMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWRpdEJveDogY2MuRWRpdEJveCA9IHNlbGYuX2RlbGVnYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkaXRCb3ggJiYgZWRpdEJveC5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdvcmxkQm94ID0gZWRpdEJveC5ub2RlLmdldEJvdW5kaW5nQm94VG9Xb3JsZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzY3JvbGxIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGllbnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByYXRpbyA9IGNjLndpblNpemUuaGVpZ2h0IC8gc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXlib2FyZERvbUhlaWdodCA9IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2V5Ym9hcmRDb2Nvc0hlaWdodCA9IGtleWJvYXJkRG9tSGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgc2Nyb2xsSGVpZ2h0OiAke3Njcm9sbEhlaWdodH0sIGNsaWVudEhlaWdodDogJHtjbGllbnRIZWlnaHR9LCByYXRpbzogJHtyYXRpb31gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBrZXlib2FyZERvbUhlaWdodDogJHtrZXlib2FyZERvbUhlaWdodH0sIGtleWJvYXJkQ29jb3NIZWlnaHQ6ICR7a2V5Ym9hcmRDb2Nvc0hlaWdodH1gKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod29ybGRCb3gueU1pbiA+PSBrZXlib2FyZENvY29zSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJyZXR1cm5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERPTeWdkOagh+ezu+S4i++8jEVkaXRCb3jlupXpg6jkuI7ova/plK7nm5jpobbpg6jnmoTot53nprtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tRGVsdGEgPSAoa2V5Ym9hcmRDb2Nvc0hlaWdodCAtIHdvcmxkQm94LnlNaW4pIC8gcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbCh7IHRvcDogZG9tRGVsdGEsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBkb21EZWx0YTogJHtkb21EZWx0YX1gKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZWxlbS5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcInN0YXJ0XCIsIGlubGluZTogXCJuZWFyZXN0XCIsIGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHNjcm9sbEludG9WaWV3YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgfVxyXG59Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/runtime/GlobalInfo.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'da8e02iXl9PU5UpO9TdVHXv', 'GlobalInfo');
// scripts/common/runtime/GlobalInfo.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var GlobalInfo = /** @class */ (function () {
    function GlobalInfo() {
    }
    GlobalInfo.ON_COLLISION_ENTER = true;
    GlobalInfo.LEVEL_SELECT = 1;
    return GlobalInfo;
}());
exports.default = GlobalInfo;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxydW50aW1lXFxHbG9iYWxJbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7SUFBQTtJQU1BLENBQUM7SUFKaUIsNkJBQWtCLEdBQUcsSUFBSSxDQUFBO0lBRXpCLHVCQUFZLEdBQUcsQ0FBQyxDQUFBO0lBRWxDLGlCQUFDO0NBTkQsQUFNQyxJQUFBO2tCQU5vQixVQUFVIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbG9iYWxJbmZvIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIE9OX0NPTExJU0lPTl9FTlRFUiA9IHRydWVcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIExFVkVMX1NFTEVDVCA9IDFcclxuXHJcbn0iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Events.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'aae4cQnarlFE4m+zeU7vd7m', 'Events');
// scripts/common/util/Events.ts

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preloadEvent = exports.eventsOnEnable = exports.eventsOnLoad = void 0;
var EventName_1 = require("../const/EventName");
//#region 装饰器
/**
 * 重写类方法
 * @param constructor 构造函数
 * @param onKey 在该方法内部调用Events.targetOn
 * @param offKey 在该方法内部调用Events.targetOff
 * @param onSuper 是否注册父类成员方法上绑定的事件，默认true
 */
function rewrite(constructor, onKey, offKey, onSuper) {
    if (onSuper === void 0) { onSuper = true; }
    var onFunc = constructor.prototype[onKey];
    var offFunc = constructor.prototype[offKey];
    constructor.prototype[onKey] = function () {
        Events.targetOn(this, onSuper);
        onFunc && onFunc.call(this);
    };
    constructor.prototype[offKey] = function () {
        Events.targetOff(this);
        offFunc && offFunc.call(this);
    };
}
/**
 * 类装饰器。用于覆盖onLoad和onDestroy方法，在onLoad中注册preloadEvent绑定的所有事件，在onDestroy注销绑定的所有事件
 * @param onSuper 是否注册父类成员方法上绑定的事件，默认true
 */
function eventsOnLoad(onSuper) {
    if (onSuper === void 0) { onSuper = true; }
    return function (constructor) {
        rewrite(constructor, "onLoad", "onDestroy", onSuper);
    };
}
exports.eventsOnLoad = eventsOnLoad;
/**
 * 类装饰器。用于覆盖onEnable和onDisable方法，在onEnable中注册preloadEvent绑定的所有事件，在onDisable注销绑定的所有事件
 * @param onSuper 是否注册父类成员方法上绑定的事件，默认true
 */
function eventsOnEnable(onSuper) {
    if (onSuper === void 0) { onSuper = true; }
    return function (constructor) {
        rewrite(constructor, "onEnable", "onDisable", onSuper);
    };
}
exports.eventsOnEnable = eventsOnEnable;
/**
 * 非静态成员方法装饰器。用于预先载入待注册的事件，配合eventsOnLoad、eventsOnEnable、targetOn使用
 * @param event 事件名
 * @param once 事件是否只会触发一次，默认false
 */
function preloadEvent(event, once) {
    if (once === void 0) { once = false; }
    return function (target, funcName, desc) {
        var arr = Events.classMap.get(target.constructor);
        if (arr === undefined) {
            arr = [];
            Events.classMap.set(target.constructor, arr);
        }
        else {
            var find = arr.find(function (e) {
                return e.event === event && e.funcName === funcName;
            });
            if (find) {
                cc.error("event: " + EventName_1.EventName[event] + " \u91CD\u590D\u8F7D\u5165");
                return;
            }
        }
        arr.push({
            event: event,
            funcName: funcName,
            once: once
        });
    };
}
exports.preloadEvent = preloadEvent;
//#endregion
/**
 * 事件收发管理类
 */
var Events = /** @class */ (function () {
    function Events() {
    }
    /**
     * 注册与target构造函数预先绑定的所有事件
     * @param target 注册目标
     * @param onSuper 是否注册父类成员方法上绑定的事件，默认true
     */
    Events.targetOn = function (target, onSuper) {
        var _this = this;
        if (onSuper === void 0) { onSuper = true; }
        if (onSuper) {
            this.classMap.forEach(function (value, key) {
                if (target instanceof key) {
                    for (var i = 0; i < value.length; i++) {
                        var e = value[i];
                        _this.on(e.event, target[e.funcName], target, e.once);
                    }
                }
            });
        }
        else {
            var arr = this.classMap.get(target.constructor);
            if (arr) {
                for (var i = 0; i < arr.length; i++) {
                    var e = arr[i];
                    this.on(e.event, target[e.funcName], target, e.once);
                }
            }
        }
    };
    /**
     * 注册事件
     * @param event 事件名
     * @param cb 处理事件的监听函数
     * @param target 注册目标
     * @param once 事件是否只会触发一次，默认false
     */
    Events.on = function (event, cb, target, once) {
        if (once === void 0) { once = false; }
        if (!cb || !target) {
            cc.error("event: " + EventName_1.EventName[event] + " listener\u6216target\u4E0D\u80FD\u4E3A\u7A7A");
            return;
        }
        var map = this._eventsMap.get(event);
        var list = [];
        if (map === undefined) {
            map = new Map();
            map.set(target, list);
            this._eventsMap.set(event, map);
        }
        else {
            list = map.get(target);
            if (list === undefined) {
                list = [];
                map.set(target, list);
            }
            else {
                var result = list.find(function (e) { return e.cb === cb; });
                if (result) {
                    cc.error("event: " + EventName_1.EventName[event] + " \u91CD\u590D\u6CE8\u518C");
                    return;
                }
            }
        }
        var listener = {
            cb: cb,
            once: once
        };
        list.push(listener);
    };
    /**
     * 注册事件，触发一次后自动注销
     * @param event 事件名
     * @param cb 处理事件的监听函数
     * @param target 注册目标
     */
    Events.once = function (event, cb, target) {
        this.on(event, cb, target, true);
    };
    /**
     * 移除事件
     * @param event 事件名
     * @param cb 处理事件的监听函数
     * @param target 注册目标
     */
    Events.off = function (event, cb, target) {
        if (!cb || !target) {
            cc.error("event: " + EventName_1.EventName[event] + " listener\u6216target\u4E0D\u80FD\u4E3A\u7A7A");
            return;
        }
        var map = this._eventsMap.get(event);
        if (map === undefined) {
            cc.error("event: " + EventName_1.EventName[event] + " \u672A\u6CE8\u518C\u8BE5\u4E8B\u4EF6");
            return;
        }
        var list = map.get(target);
        if (list === undefined) {
            cc.error("event: " + EventName_1.EventName[event] + " target\u4E0A\u672A\u6CE8\u518C\u8BE5\u4E8B\u4EF6");
            return;
        }
        var index = list.findIndex(function (e) { return e.cb === cb; });
        if (index < 0) {
            cc.error("event: " + EventName_1.EventName[event] + " target\u4E0A\u672A\u4EE5\u8BE5listener\u6CE8\u518C\u8BE5\u4E8B\u4EF6");
            return;
        }
        list.splice(index, 1);
        if (list.length <= 0) {
            map.delete(target);
            map.size <= 0 && this._eventsMap.delete(event);
        }
    };
    /**
     * 移除target上注册的所有事件
     * @param target 注册目标
     */
    Events.targetOff = function (target) {
        var _this = this;
        if (!target) {
            cc.error("event: " + target + " target\u4E0D\u80FD\u4E3A\u7A7A");
            return;
        }
        this._eventsMap.forEach(function (map, event) {
            map.delete(target);
            map.size <= 0 && _this._eventsMap.delete(event);
        });
    };
    /**
     * 派发事件
     * @param event 事件名
     * @param args 事件参数
     */
    Events.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var map = this._eventsMap.get(event);
        if (map === undefined) {
            cc.warn("event: " + EventName_1.EventName[event] + " \u672A\u6CE8\u518C\u8BE5\u4E8B\u4EF6");
            return;
        }
        var i;
        var callArr = [];
        var onceArr = [];
        map.forEach(function (list, target) {
            for (i = 0; i < list.length; i++) {
                var listener = list[i];
                callArr.push({ cb: listener.cb, target: target });
                if (listener.once) {
                    onceArr.push({ cb: listener.cb, target: target });
                }
            }
        });
        // 移除所有once的监听
        for (i = 0; i < onceArr.length; i++) {
            var e = onceArr[i];
            this.off(event, e.cb, e.target);
        }
        // 延迟到此处调用事件回调，防止受到回调过程中的 注册/注销 影响
        for (i = 0; i < callArr.length; i++) {
            var e = callArr[i];
            e.cb.apply(e.target, args);
        }
    };
    /**
     * 派发事件--异步
     * @param event 事件名
     * @param args 事件参数
     */
    Events.emitAsync = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise, function () {
            var map, i, callArr, onceArr, e, arr, e;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        map = this._eventsMap.get(event);
                        if (map === undefined) {
                            cc.warn("event: " + EventName_1.EventName[event] + " \u672A\u6CE8\u518C\u8BE5\u4E8B\u4EF6");
                            return [2 /*return*/];
                        }
                        callArr = [];
                        onceArr = [];
                        map.forEach(function (list, target) {
                            for (i = 0; i < list.length; i++) {
                                var listener = list[i];
                                callArr.push({ cb: listener.cb, target: target });
                                if (listener.once) {
                                    onceArr.push({ cb: listener.cb, target: target });
                                }
                            }
                        });
                        // 移除所有once的监听
                        for (i = 0; i < onceArr.length; i++) {
                            e = onceArr[i];
                            this.off(event, e.cb, e.target);
                        }
                        arr = [];
                        for (i = 0; i < callArr.length; i++) {
                            e = callArr[i];
                            arr.push(e.cb.apply(e.target, args));
                        }
                        return [4 /*yield*/, Promise.all(arr)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 预加载数据，存储构造函数、监听事件、监听函数名，用于实例化时注册事件
     */
    Events.classMap = new Map();
    /**
     * 存储监听事件、监听函数与监听对象
     */
    Events._eventsMap = new Map();
    return Events;
}());
exports.default = Events;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxFdmVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQStDO0FBd0IvQyxhQUFhO0FBRWI7Ozs7OztHQU1HO0FBQ0gsU0FBUyxPQUFPLENBQUMsV0FBZ0IsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUFFLE9BQXVCO0lBQXZCLHdCQUFBLEVBQUEsY0FBdUI7SUFDckYsSUFBSSxNQUFNLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxJQUFJLE9BQU8sR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzVDLFdBQVcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUc7UUFDM0IsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDL0IsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQyxDQUFBO0lBQ0QsV0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRztRQUM1QixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixZQUFZLENBQUMsT0FBdUI7SUFBdkIsd0JBQUEsRUFBQSxjQUF1QjtJQUNoRCxPQUFPLFVBQVUsV0FBZ0I7UUFDN0IsT0FBTyxDQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pELENBQUMsQ0FBQztBQUNOLENBQUM7QUFKRCxvQ0FJQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLGNB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Qzt3QkFDSCxjQUFjO3dCQUNkLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDN0IsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7eUJBQ25DO3dCQUVHLEdBQUcsR0FBdUIsRUFBRSxDQUFDO3dCQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7NEJBQzdCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ25CLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO3lCQUN4Qzt3QkFDRCxxQkFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFBOzt3QkFBdEIsU0FBc0IsQ0FBQzs7Ozs7S0FDMUI7SUFuTkQ7O09BRUc7SUFDVyxlQUFRLEdBQWlDLElBQUksR0FBRyxFQUFFLENBQUM7SUFFakU7O09BRUc7SUFDWSxpQkFBVSxHQUE0QyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBNE1uRixhQUFDO0NBck5ELEFBcU5DLElBQUE7a0JBck5vQixNQUFNIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnROYW1lIH0gZnJvbSBcIi4uL2NvbnN0L0V2ZW50TmFtZVwiO1xyXG5cclxuLyoqXHJcbiAqIOijhemlsOWZqOmihOWKoOi9veaVsOaNrlxyXG4gKi9cclxuaW50ZXJmYWNlIFByZWxvYWREYXRhIHtcclxuICAgIC8qKiDkuovku7blkI0gKi9cclxuICAgIGV2ZW50OiBFdmVudE5hbWU7XHJcbiAgICAvKiog5LqL5Lu25Zue6LCD5Ye95pWw5ZCNICovXHJcbiAgICBmdW5jTmFtZTogc3RyaW5nO1xyXG4gICAgLyoqIOS6i+S7tuaYr+WQpuWPquS8muinpuWPkeS4gOasoSAqL1xyXG4gICAgb25jZTogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIOebkeWQrOWZqFxyXG4gKi9cclxuaW50ZXJmYWNlIExpc3RlbmVyIHtcclxuICAgIC8qKiDlm57osIMgKi9cclxuICAgIGNiOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkO1xyXG4gICAgLyoqIOaYr+WQpuWPquinpuWPkeS4gOasoSAqL1xyXG4gICAgb25jZTogYm9vbGVhbjtcclxufVxyXG5cclxuLy8jcmVnaW9uIOijhemlsOWZqFxyXG5cclxuLyoqXHJcbiAqIOmHjeWGmeexu+aWueazlVxyXG4gKiBAcGFyYW0gY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwXHJcbiAqIEBwYXJhbSBvbktleSDlnKjor6Xmlrnms5XlhoXpg6josIPnlKhFdmVudHMudGFyZ2V0T25cclxuICogQHBhcmFtIG9mZktleSDlnKjor6Xmlrnms5XlhoXpg6josIPnlKhFdmVudHMudGFyZ2V0T2ZmXHJcbiAqIEBwYXJhbSBvblN1cGVyIOaYr+WQpuazqOWGjOeItuexu+aIkOWRmOaWueazleS4iue7keWumueahOS6i+S7tu+8jOm7mOiupHRydWVcclxuICovXHJcbmZ1bmN0aW9uIHJld3JpdGUoY29uc3RydWN0b3I6IGFueSwgb25LZXk6IHN0cmluZywgb2ZmS2V5OiBzdHJpbmcsIG9uU3VwZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICBsZXQgb25GdW5jID0gY29uc3RydWN0b3IucHJvdG90eXBlW29uS2V5XTtcclxuICAgIGxldCBvZmZGdW5jID0gY29uc3RydWN0b3IucHJvdG90eXBlW29mZktleV07XHJcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbb25LZXldID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEV2ZW50cy50YXJnZXRPbih0aGlzLCBvblN1cGVyKTtcclxuICAgICAgICBvbkZ1bmMgJiYgb25GdW5jLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbb2ZmS2V5XSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T2ZmKHRoaXMpO1xyXG4gICAgICAgIG9mZkZ1bmMgJiYgb2ZmRnVuYy5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICog57G76KOF6aWw5Zmo44CC55So5LqO6KaG55uWb25Mb2Fk5ZKMb25EZXN0cm955pa55rOV77yM5Zyob25Mb2Fk5Lit5rOo5YaMcHJlbG9hZEV2ZW5057uR5a6a55qE5omA5pyJ5LqL5Lu277yM5Zyob25EZXN0cm955rOo6ZSA57uR5a6a55qE5omA5pyJ5LqL5Lu2XHJcbiAqIEBwYXJhbSBvblN1cGVyIOaYr+WQpuazqOWGjOeItuexu+aIkOWRmOaWueazleS4iue7keWumueahOS6i+S7tu+8jOm7mOiupHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBldmVudHNPbkxvYWQob25TdXBlcjogYm9vbGVhbiA9IHRydWUpOiAoY29uc3RydWN0b3I6IGFueSkgPT4gdm9pZCB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnN0cnVjdG9yOiBhbnkpIHtcclxuICAgICAgICByZXdyaXRlKGNvbnN0cnVjdG9yLCBcIm9uTG9hZFwiLCBcIm9uRGVzdHJveVwiLCBvblN1cGVyKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDnsbvoo4XppbDlmajjgILnlKjkuo7opobnm5ZvbkVuYWJsZeWSjG9uRGlzYWJsZeaWueazle+8jOWcqG9uRW5hYmxl5Lit5rOo5YaMcHJlbG9hZEV2ZW5057uR5a6a55qE5omA5pyJ5LqL5Lu277yM5Zyob25EaXNhYmxl5rOo6ZSA57uR5a6a55qE5omA5pyJ5LqL5Lu2XHJcbiAqIEBwYXJhbSBvblN1cGVyIOaYr+WQpuazqOWGjOeItuexu+aIkOWRmOaWueazleS4iue7keWumueahOS6i+S7tu+8jOm7mOiupHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBldmVudHNPbkVuYWJsZShvblN1cGVyOiBib29sZWFuID0gdHJ1ZSk6IChjb25zdHJ1Y3RvcjogYW55KSA9PiB2b2lkIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoY29uc3RydWN0b3I6IGFueSkge1xyXG4gICAgICAgIHJld3JpdGUoY29uc3RydWN0b3IsIFwib25FbmFibGVcIiwgXCJvbkRpc2FibGVcIiwgb25TdXBlcik7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICog6Z2e6Z2Z5oCB5oiQ5ZGY5pa55rOV6KOF6aWw5Zmo44CC55So5LqO6aKE5YWI6L295YWl5b6F5rOo5YaM55qE5LqL5Lu277yM6YWN5ZCIZXZlbnRzT25Mb2Fk44CBZXZlbnRzT25FbmFibGXjgIF0YXJnZXRPbuS9v+eUqFxyXG4gKiBAcGFyYW0gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSBvbmNlIOS6i+S7tuaYr+WQpuWPquS8muinpuWPkeS4gOasoe+8jOm7mOiupGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJlbG9hZEV2ZW50KGV2ZW50OiBFdmVudE5hbWUsIG9uY2U6IGJvb2xlYW4gPSBmYWxzZSk6ICh0YXJnZXQ6IGFueSwgZnVuY05hbWU6IHN0cmluZywgZGVzYzogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB2b2lkIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIGZ1bmNOYW1lOiBzdHJpbmcsIGRlc2M6IFByb3BlcnR5RGVzY3JpcHRvcikge1xyXG4gICAgICAgIGxldCBhcnIgPSBFdmVudHMuY2xhc3NNYXAuZ2V0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFyciA9IFtdO1xyXG4gICAgICAgICAgICBFdmVudHMuY2xhc3NNYXAuc2V0KHRhcmdldC5jb25zdHJ1Y3RvciwgYXJyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZmluZCA9IGFyci5maW5kKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5ldmVudCA9PT0gZXZlbnQgJiYgZS5mdW5jTmFtZSA9PT0gZnVuY05hbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZmluZCkge1xyXG4gICAgICAgICAgICAgICAgY2MuZXJyb3IoYGV2ZW50OiAke0V2ZW50TmFtZVtldmVudF19IOmHjeWkjei9veWFpWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhcnIucHVzaCh7XHJcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICAgICAgZnVuY05hbWU6IGZ1bmNOYW1lLFxyXG4gICAgICAgICAgICBvbmNlOiBvbmNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyNlbmRyZWdpb25cclxuXHJcbi8qKlxyXG4gKiDkuovku7bmlLblj5HnrqHnkIbnsbtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50cyB7XHJcbiAgICAvKipcclxuICAgICAqIOmihOWKoOi9veaVsOaNru+8jOWtmOWCqOaehOmAoOWHveaVsOOAgeebkeWQrOS6i+S7tuOAgeebkeWQrOWHveaVsOWQje+8jOeUqOS6juWunuS+i+WMluaXtuazqOWGjOS6i+S7tlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzTWFwOiBNYXA8RnVuY3Rpb24sIFByZWxvYWREYXRhW10+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a2Y5YKo55uR5ZCs5LqL5Lu244CB55uR5ZCs5Ye95pWw5LiO55uR5ZCs5a+56LGhXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9ldmVudHNNYXA6IE1hcDxFdmVudE5hbWUsIE1hcDxPYmplY3QsIExpc3RlbmVyW10+PiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOS4jnRhcmdldOaehOmAoOWHveaVsOmihOWFiOe7keWumueahOaJgOacieS6i+S7tlxyXG4gICAgICogQHBhcmFtIHRhcmdldCDms6jlhoznm67moIdcclxuICAgICAqIEBwYXJhbSBvblN1cGVyIOaYr+WQpuazqOWGjOeItuexu+aIkOWRmOaWueazleS4iue7keWumueahOS6i+S7tu+8jOm7mOiupHRydWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB0YXJnZXRPbih0YXJnZXQ6IE9iamVjdCwgb25TdXBlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgICBpZiAob25TdXBlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTWFwLmZvckVhY2goKHZhbHVlOiBQcmVsb2FkRGF0YVtdLCBrZXk6IEZ1bmN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2Yga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGUuZXZlbnQsIHRhcmdldFtlLmZ1bmNOYW1lXSwgdGFyZ2V0LCBlLm9uY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGFyciA9IHRoaXMuY2xhc3NNYXAuZ2V0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChhcnIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBhcnJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbihlLmV2ZW50LCB0YXJnZXRbZS5mdW5jTmFtZV0sIHRhcmdldCwgZS5vbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOS6i+S7tlxyXG4gICAgICogQHBhcmFtIGV2ZW50IOS6i+S7tuWQjVxyXG4gICAgICogQHBhcmFtIGNiIOWkhOeQhuS6i+S7tueahOebkeWQrOWHveaVsFxyXG4gICAgICogQHBhcmFtIHRhcmdldCDms6jlhoznm67moIdcclxuICAgICAqIEBwYXJhbSBvbmNlIOS6i+S7tuaYr+WQpuWPquS8muinpuWPkeS4gOasoe+8jOm7mOiupGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgb24oZXZlbnQ6IEV2ZW50TmFtZSwgY2I6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCwgdGFyZ2V0OiBPYmplY3QsIG9uY2U6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgIGlmICghY2IgfHwgIXRhcmdldCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgZXZlbnQ6ICR7RXZlbnROYW1lW2V2ZW50XX0gbGlzdGVuZXLmiJZ0YXJnZXTkuI3og73kuLrnqbpgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG1hcDogTWFwPE9iamVjdCwgTGlzdGVuZXJbXT4gPSB0aGlzLl9ldmVudHNNYXAuZ2V0KGV2ZW50KTtcclxuICAgICAgICBsZXQgbGlzdDogTGlzdGVuZXJbXSA9IFtdO1xyXG4gICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBtYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIG1hcC5zZXQodGFyZ2V0LCBsaXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzTWFwLnNldChldmVudCwgbWFwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaXN0ID0gbWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHRhcmdldCwgbGlzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gbGlzdC5maW5kKChlKSA9PiB7IHJldHVybiBlLmNiID09PSBjYjsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZXJyb3IoYGV2ZW50OiAke0V2ZW50TmFtZVtldmVudF19IOmHjeWkjeazqOWGjGApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxpc3RlbmVyOiBMaXN0ZW5lciA9IHtcclxuICAgICAgICAgICAgY2I6IGNiLFxyXG4gICAgICAgICAgICBvbmNlOiBvbmNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsaXN0LnB1c2gobGlzdGVuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaM5LqL5Lu277yM6Kem5Y+R5LiA5qyh5ZCO6Ieq5Yqo5rOo6ZSAXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQg5LqL5Lu25ZCNXHJcbiAgICAgKiBAcGFyYW0gY2Ig5aSE55CG5LqL5Lu255qE55uR5ZCs5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IOazqOWGjOebruagh1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2I6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCwgdGFyZ2V0OiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uKGV2ZW50LCBjYiwgdGFyZ2V0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOS6i+S7tlxyXG4gICAgICogQHBhcmFtIGV2ZW50IOS6i+S7tuWQjVxyXG4gICAgICogQHBhcmFtIGNiIOWkhOeQhuS6i+S7tueahOebkeWQrOWHveaVsFxyXG4gICAgICogQHBhcmFtIHRhcmdldCDms6jlhoznm67moIdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBvZmYoZXZlbnQ6IEV2ZW50TmFtZSwgY2I6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCwgdGFyZ2V0OiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIWNiIHx8ICF0YXJnZXQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoYGV2ZW50OiAke0V2ZW50TmFtZVtldmVudF19IGxpc3RlbmVy5oiWdGFyZ2V05LiN6IO95Li656m6YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtYXA6IE1hcDxPYmplY3QsIExpc3RlbmVyW10+ID0gdGhpcy5fZXZlbnRzTWFwLmdldChldmVudCk7XHJcbiAgICAgICAgaWYgKG1hcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBldmVudDogJHtFdmVudE5hbWVbZXZlbnRdfSDmnKrms6jlhozor6Xkuovku7ZgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxpc3Q6IExpc3RlbmVyW10gPSBtYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgZXZlbnQ6ICR7RXZlbnROYW1lW2V2ZW50XX0gdGFyZ2V05LiK5pyq5rOo5YaM6K+l5LqL5Lu2YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbmRleCA9IGxpc3QuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiBlLmNiID09PSBjYjsgfSk7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgZXZlbnQ6ICR7RXZlbnROYW1lW2V2ZW50XX0gdGFyZ2V05LiK5pyq5Lul6K+lbGlzdGVuZXLms6jlhozor6Xkuovku7ZgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIG1hcC5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgbWFwLnNpemUgPD0gMCAmJiB0aGlzLl9ldmVudHNNYXAuZGVsZXRlKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaR0YXJnZXTkuIrms6jlhoznmoTmiYDmnInkuovku7ZcclxuICAgICAqIEBwYXJhbSB0YXJnZXQg5rOo5YaM55uu5qCHXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdGFyZ2V0T2ZmKHRhcmdldDogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoYGV2ZW50OiAke3RhcmdldH0gdGFyZ2V05LiN6IO95Li656m6YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2V2ZW50c01hcC5mb3JFYWNoKChtYXAsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIG1hcC5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgbWFwLnNpemUgPD0gMCAmJiB0aGlzLl9ldmVudHNNYXAuZGVsZXRlKGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa0vuWPkeS6i+S7tlxyXG4gICAgICogQHBhcmFtIGV2ZW50IOS6i+S7tuWQjVxyXG4gICAgICogQHBhcmFtIGFyZ3Mg5LqL5Lu25Y+C5pWwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZW1pdChldmVudDogRXZlbnROYW1lLCAuLi5hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgICBsZXQgbWFwOiBNYXA8T2JqZWN0LCBMaXN0ZW5lcltdPiA9IHRoaXMuX2V2ZW50c01hcC5nZXQoZXZlbnQpO1xyXG4gICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYy53YXJuKGBldmVudDogJHtFdmVudE5hbWVbZXZlbnRdfSDmnKrms6jlhozor6Xkuovku7ZgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGk6IG51bWJlcjtcclxuICAgICAgICBsZXQgY2FsbEFycjogQXJyYXk8eyBjYjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZDsgdGFyZ2V0OiBPYmplY3QgfT4gPSBbXTtcclxuICAgICAgICBsZXQgb25jZUFycjogQXJyYXk8eyBjYjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZDsgdGFyZ2V0OiBPYmplY3QgfT4gPSBbXTtcclxuICAgICAgICBtYXAuZm9yRWFjaCgobGlzdCwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSBsaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbEFyci5wdXNoKHsgY2I6IGxpc3RlbmVyLmNiLCB0YXJnZXQ6IHRhcmdldCB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25jZUFyci5wdXNoKHsgY2I6IGxpc3RlbmVyLmNiLCB0YXJnZXQ6IHRhcmdldCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOenu+mZpOaJgOaciW9uY2XnmoTnm5HlkKxcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25jZUFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZSA9IG9uY2VBcnJbaV07XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBlLmNiLCBlLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW7tui/n+WIsOatpOWkhOiwg+eUqOS6i+S7tuWbnuiwg++8jOmYsuatouWPl+WIsOWbnuiwg+i/h+eoi+S4reeahCDms6jlhowv5rOo6ZSAIOW9seWTjVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gY2FsbEFycltpXTtcclxuICAgICAgICAgICAgZS5jYi5hcHBseShlLnRhcmdldCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5rS+5Y+R5LqL5Lu2LS3lvILmraVcclxuICAgICAqIEBwYXJhbSBldmVudCDkuovku7blkI1cclxuICAgICAqIEBwYXJhbSBhcmdzIOS6i+S7tuWPguaVsFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGVtaXRBc3luYyhldmVudDogRXZlbnROYW1lLCAuLi5hcmdzOiB1bmtub3duW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBsZXQgbWFwOiBNYXA8T2JqZWN0LCBMaXN0ZW5lcltdPiA9IHRoaXMuX2V2ZW50c01hcC5nZXQoZXZlbnQpO1xyXG4gICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYy53YXJuKGBldmVudDogJHtFdmVudE5hbWVbZXZlbnRdfSDmnKrms6jlhozor6Xkuovku7ZgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGk6IG51bWJlcjtcclxuICAgICAgICBsZXQgY2FsbEFycjogQXJyYXk8eyBjYjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZDsgdGFyZ2V0OiBPYmplY3QgfT4gPSBbXTtcclxuICAgICAgICBsZXQgb25jZUFycjogQXJyYXk8eyBjYjogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZDsgdGFyZ2V0OiBPYmplY3QgfT4gPSBbXTtcclxuICAgICAgICBtYXAuZm9yRWFjaCgobGlzdCwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSBsaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbEFyci5wdXNoKHsgY2I6IGxpc3RlbmVyLmNiLCB0YXJnZXQ6IHRhcmdldCB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25jZUFyci5wdXNoKHsgY2I6IGxpc3RlbmVyLmNiLCB0YXJnZXQ6IHRhcmdldCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOenu+mZpOaJgOaciW9uY2XnmoTnm5HlkKxcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25jZUFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZSA9IG9uY2VBcnJbaV07XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBlLmNiLCBlLnRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW7tui/n+WIsOatpOWkhOiwg+eUqOS6i+S7tuWbnuiwg++8jOmYsuatouWPl+WIsOWbnuiwg+i/h+eoi+S4reeahCDms6jlhowv5rOo6ZSAIOW9seWTjVxyXG4gICAgICAgIGxldCBhcnI6IFByb21pc2U8dW5rbm93bj5bXSA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gY2FsbEFycltpXTtcclxuICAgICAgICAgICAgYXJyLnB1c2goZS5jYi5hcHBseShlLnRhcmdldCwgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcnIpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/I18n.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a24383d1j1FRbXaBkcPctfn', 'I18n');
// scripts/common/util/I18n.ts

"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangType = void 0;
var En_1 = require("../config/En");
var Zh_1 = require("../config/Zh");
var EventName_1 = require("../const/EventName");
var Events_1 = require("./Events");
var Tool_1 = require("./Tool");
/**
 * 语言类型
 */
var LangType;
(function (LangType) {
    LangType["NONE"] = "";
    LangType["ZH"] = "zh";
    LangType["EN"] = "en";
})(LangType = exports.LangType || (exports.LangType = {}));
/**
 * 多语言控制类
 */
var I18n = /** @class */ (function () {
    function I18n() {
    }
    Object.defineProperty(I18n, "curLang", {
        /* 当前语言类型 */
        get: function () { return this._curLang; },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化语言
     * @param language
     */
    I18n.init = function (language) {
        if (language === void 0) { language = LangType.NONE; }
        if (this._init) {
            return;
        }
        this._init = true;
        var lang = language || cc.sys.language;
        this.switch(lang);
    };
    /**
     * 切换语言
     * @param language
     */
    I18n.switch = function (language) {
        if (this._curLang === language) {
            return;
        }
        this._curLang = language;
        switch (language) {
            case LangType.ZH:
                this._phrases = Zh_1.default;
                break;
            case LangType.EN:
                this._phrases = En_1.default;
                break;
            default:
                this._curLang = LangType.EN;
                this._phrases = En_1.default;
                break;
        }
        this.updateLocalizedCmpt();
    };
    /**
    * 更新所有多语言组件
    */
    I18n.updateLocalizedCmpt = function () {
        Events_1.default.emit(EventName_1.EventName.UPDATE_LOCALIZED_CMPT);
    };
    /**
     * 通过语言表value获取对应的key
     * @param value 语言表的value
     */
    I18n.getKeyByValue = function (value) {
        if (!this._phrases) {
            cc.error("[I18n.getKeyByValue] \u672A\u6B63\u786E\u521D\u59CB\u5316");
            return "";
        }
        for (var key in this._phrases) {
            if (this._phrases[key] === value) {
                return key;
            }
        }
        return "";
    };
    /**
     * 通过key获取语言表中的字符串
     * @param key 语言表中的key
     * @param option 用于替换的数据，可以传键值对，也可以按顺序传参
     * @example
     * // 语言表 {"test": "test %{arg1} %{arg2} !!!"}
     * I18n.getText("test", {arg1: "somthing", arg2: 2}); // "test somthing 2 !!!"
     * I18n.getText("test", "somthing", 2); // "test somthing 2 !!!"
     */
    I18n.getText = function (key) {
        var option = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            option[_i - 1] = arguments[_i];
        }
        if (!this._phrases) {
            cc.error("[I18n.getText] \u672A\u6B63\u786E\u521D\u59CB\u5316");
            return "";
        }
        if (!key) {
            return "";
        }
        var text = this._phrases.hasOwnProperty(key) ? this._phrases[key] : key;
        text = Tool_1.default.formatString.apply(Tool_1.default, __spreadArrays([text], option));
        return text;
    };
    I18n._init = false;
    /** 语言表 */
    I18n._phrases = null;
    I18n._curLang = LangType.NONE;
    return I18n;
}());
exports.default = I18n;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxJMThuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBOEI7QUFDOUIsbUNBQThCO0FBQzlCLGdEQUErQztBQUMvQyxtQ0FBOEI7QUFDOUIsK0JBQTBCO0FBRTFCOztHQUVHO0FBQ0gsSUFBWSxRQUlYO0FBSkQsV0FBWSxRQUFRO0lBQ2hCLHFCQUFTLENBQUE7SUFDVCxxQkFBUyxDQUFBO0lBQ1QscUJBQVMsQ0FBQTtBQUNiLENBQUMsRUFKVyxRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQUluQjtBQUVEOztHQUVHO0FBQ0g7SUFBQTtJQStGQSxDQUFDO0lBdkZHLHNCQUFrQixlQUFPO1FBRHpCLFlBQVk7YUFDWixjQUF3QyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzs7T0FBQTtJQUUvRDs7O09BR0c7SUFDVyxTQUFJLEdBQWxCLFVBQW1CLFFBQWtDO1FBQWxDLHlCQUFBLEVBQUEsV0FBcUIsUUFBUSxDQUFDLElBQUk7UUFDakQsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxJQUFJLEdBQUcsUUFBUSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBZ0IsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7O09BR0c7SUFDVyxXQUFNLEdBQXBCLFVBQXFCLFFBQWtCO1FBQ25DLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7WUFDNUIsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsUUFBUSxRQUFRLEVBQUU7WUFDZCxLQUFLLFFBQVEsQ0FBQyxFQUFFO2dCQUNaLElBQUksQ0FBQyxRQUFRLEdBQUcsWUFBRSxDQUFDO2dCQUNuQixNQUFNO1lBQ1YsS0FBSyxRQUFRLENBQUMsRUFBRTtnQkFDWixJQUFJLENBQUMsUUFBUSxHQUFHLFlBQUUsQ0FBQztnQkFDbkIsTUFBTTtZQUNWO2dCQUNJLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQztnQkFDNUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFFLENBQUM7Z0JBQ25CLE1BQU07U0FDYjtRQUNELElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7TUFFRTtJQUNZLHdCQUFtQixHQUFqQztRQUNJLGdCQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBR0Q7OztPQUdHO0lBQ1csa0JBQWEsR0FBM0IsVUFBNEIsS0FBYTtRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLDJEQUE2QixDQUFDLENBQUM7WUFDeEMsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMzQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssS0FBSyxFQUFFO2dCQUM5QixPQUFPLEdBQUcsQ0FBQzthQUNkO1NBQ0o7UUFDRCxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNXLFlBQU8sR0FBckIsVUFBc0IsR0FBVztRQUFFLGdCQUFxRTthQUFyRSxVQUFxRSxFQUFyRSxxQkFBcUUsRUFBckUsSUFBcUU7WUFBckUsK0JBQXFFOztRQUNwRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQixFQUFFLENBQUMsS0FBSyxDQUFDLHFEQUF1QixDQUFDLENBQUM7WUFDbEMsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDTixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBRUQsSUFBSSxJQUFJLEdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUNoRixJQUFJLEdBQUcsY0FBSSxDQUFDLFlBQVksT0FBakIsY0FBSSxrQkFBYyxJQUFJLEdBQUssTUFBTSxFQUFDLENBQUM7UUFDMUMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQTdGYyxVQUFLLEdBQVksS0FBSyxDQUFDO0lBRXRDLFVBQVU7SUFDSyxhQUFRLEdBQVEsSUFBSSxDQUFDO0lBRXJCLGFBQVEsR0FBYSxRQUFRLENBQUMsSUFBSSxDQUFDO0lBeUZ0RCxXQUFDO0NBL0ZELEFBK0ZDLElBQUE7a0JBL0ZvQixJQUFJIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVuIGZyb20gXCIuLi9jb25maWcvRW5cIjtcclxuaW1wb3J0IFpoIGZyb20gXCIuLi9jb25maWcvWmhcIjtcclxuaW1wb3J0IHsgRXZlbnROYW1lIH0gZnJvbSBcIi4uL2NvbnN0L0V2ZW50TmFtZVwiO1xyXG5pbXBvcnQgRXZlbnRzIGZyb20gXCIuL0V2ZW50c1wiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi9Ub29sXCI7XHJcblxyXG4vKipcclxuICog6K+t6KiA57G75Z6LXHJcbiAqL1xyXG5leHBvcnQgZW51bSBMYW5nVHlwZSB7XHJcbiAgICBOT05FID0gXCJcIixcclxuICAgIFpIID0gXCJ6aFwiLFxyXG4gICAgRU4gPSBcImVuXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIOWkmuivreiogOaOp+WItuexu1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSTE4biB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaW5pdDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiDor63oqIDooaggKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9waHJhc2VzOiBhbnkgPSBudWxsO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9jdXJMYW5nOiBMYW5nVHlwZSA9IExhbmdUeXBlLk5PTkU7XHJcbiAgICAvKiDlvZPliY3or63oqIDnsbvlnosgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGN1ckxhbmcoKTogTGFuZ1R5cGUgeyByZXR1cm4gdGhpcy5fY3VyTGFuZzsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW6K+t6KiAXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0KGxhbmd1YWdlOiBMYW5nVHlwZSA9IExhbmdUeXBlLk5PTkUpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5faW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBsYW5nID0gbGFuZ3VhZ2UgfHwgY2Muc3lzLmxhbmd1YWdlO1xyXG4gICAgICAgIHRoaXMuc3dpdGNoKGxhbmcgYXMgTGFuZ1R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YiH5o2i6K+t6KiAXHJcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzd2l0Y2gobGFuZ3VhZ2U6IExhbmdUeXBlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1ckxhbmcgPT09IGxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2N1ckxhbmcgPSBsYW5ndWFnZTtcclxuICAgICAgICBzd2l0Y2ggKGxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTGFuZ1R5cGUuWkg6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9waHJhc2VzID0gWmg7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBMYW5nVHlwZS5FTjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BocmFzZXMgPSBFbjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VyTGFuZyA9IExhbmdUeXBlLkVOO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGhyYXNlcyA9IEVuO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTG9jYWxpemVkQ21wdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiDmm7TmlrDmiYDmnInlpJror63oqIDnu4Tku7ZcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHVwZGF0ZUxvY2FsaXplZENtcHQoKTogdm9pZCB7XHJcbiAgICAgICAgRXZlbnRzLmVtaXQoRXZlbnROYW1lLlVQREFURV9MT0NBTElaRURfQ01QVCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YCa6L+H6K+t6KiA6KGodmFsdWXojrflj5blr7nlupTnmoRrZXlcclxuICAgICAqIEBwYXJhbSB2YWx1ZSDor63oqIDooajnmoR2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEtleUJ5VmFsdWUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9waHJhc2VzKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbSTE4bi5nZXRLZXlCeVZhbHVlXSDmnKrmraPnoa7liJ3lp4vljJZgKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9waHJhc2VzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9waHJhc2VzW2tleV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YCa6L+Ha2V56I635Y+W6K+t6KiA6KGo5Lit55qE5a2X56ym5LiyXHJcbiAgICAgKiBAcGFyYW0ga2V5IOivreiogOihqOS4reeahGtleVxyXG4gICAgICogQHBhcmFtIG9wdGlvbiDnlKjkuo7mm7/mjaLnmoTmlbDmja7vvIzlj6/ku6XkvKDplK7lgLzlr7nvvIzkuZ/lj6/ku6XmjInpobrluo/kvKDlj4JcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyDor63oqIDooagge1widGVzdFwiOiBcInRlc3QgJXthcmcxfSAle2FyZzJ9ICEhIVwifVxyXG4gICAgICogSTE4bi5nZXRUZXh0KFwidGVzdFwiLCB7YXJnMTogXCJzb210aGluZ1wiLCBhcmcyOiAyfSk7IC8vIFwidGVzdCBzb210aGluZyAyICEhIVwiXHJcbiAgICAgKiBJMThuLmdldFRleHQoXCJ0ZXN0XCIsIFwic29tdGhpbmdcIiwgMik7IC8vIFwidGVzdCBzb210aGluZyAyICEhIVwiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGV4dChrZXk6IHN0cmluZywgLi4ub3B0aW9uOiBbUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPl0gfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BocmFzZXMpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoYFtJMThuLmdldFRleHRdIOacquato+ehruWIneWni+WMlmApO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGV4dDogc3RyaW5nID0gdGhpcy5fcGhyYXNlcy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gdGhpcy5fcGhyYXNlc1trZXldIDoga2V5O1xyXG4gICAgICAgIHRleHQgPSBUb29sLmZvcm1hdFN0cmluZyh0ZXh0LCAuLi5vcHRpb24pO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Behavior3.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'de9bbKKaMZC1qbjY6eFDl/m', 'Behavior3');
// scripts/common/util/Behavior3.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.B3Wait = exports.B3Succeeder = exports.B3Runner = exports.B3Failer = exports.B3Error = exports.B3Repeater = exports.B3RepeatUntilSuccess = exports.B3RepeatUntilFailure = exports.B3MaxTime = exports.B3Limiter = exports.B3Inverter = exports.B3Sequence = exports.B3Priority = exports.B3MemSequence = exports.B3MemPriority = exports.B3Decorator = exports.B3Condition = exports.B3Composite = exports.B3Action = exports.B3BaseNode = exports.B3Blackboard = exports.B3Tick = exports.B3BehaviorTree = exports.B3State = void 0;
/**
 * 节点状态
 */
var B3State;
(function (B3State) {
    B3State[B3State["SUCCESS"] = 1] = "SUCCESS";
    B3State[B3State["FAILURE"] = 2] = "FAILURE";
    B3State[B3State["RUNNING"] = 3] = "RUNNING";
    B3State[B3State["ERROR"] = 4] = "ERROR";
})(B3State = exports.B3State || (exports.B3State = {}));
/**
 * The BehaviorTree class, as the name implies, represents the Behavior Tree
 * structure.
 *
 * There are two ways to construct a Behavior Tree: by manually setting the
 * root node, or by loading it from a data structure (which can be loaded
 * from a JSON). Both methods are shown in the examples below and better
 * explained in the user guide.
 *
 * The tick method must be called periodically, in order to send the tick
 * signal to all nodes in the tree, starting from the root. The method
 * `BehaviorTree.tick` receives a target object and a blackboard as
 * parameters. The target object can be anything: a game agent, a system, a
 * DOM object, etc. This target is not used by any piece of Behavior3JS,
 * i.e., the target object will only be used by custom nodes.
 *
 * The blackboard is obligatory and must be an instance of `Blackboard`. This
 * requirement is necessary due to the fact that neither `BehaviorTree` or
 * any node will store the execution variables in its own object (e.g., the
 * BT does not store the target, information about opened nodes or number of
 * times the tree was called). But because of this, you only need a single
 * tree instance to control multiple (maybe hundreds) objects.
 *
 * Manual construction of a Behavior Tree
 * --------------------------------------
 *
 *     var tree = new b3.BehaviorTree();
 *
 *     tree.root = new b3.Sequence({children:[
 *       new b3.Priority({children:[
 *         new MyCustomNode(),
 *         new MyCustomNode()
 *       ]}),
 *       ...
 *     ]});
 *
 *
 * Loading a Behavior Tree from data structure
 * -------------------------------------------
 *
 *     var tree = new b3.BehaviorTree();
 *
 *     tree.load({
 *       "title"       : "Behavior Tree title"
 *       "description" : "My description"
 *       "root"        : "node-id-1"
 *       "nodes"       : {
 *         "node-id-1" : {
 *           "name"        : "Priority", // this is the node type
 *           "title"       : "Root Node",
 *           "description" : "Description",
 *           "children"    : ["node-id-2", "node-id-3"],
 *         },
 *         ...
 *       }
 *     })
 *
 *
 * @module b3
 * @class BehaviorTree
 */
var B3BehaviorTree = /** @class */ (function () {
    /**
     * Initialization method.
     */
    function B3BehaviorTree() {
        /**
         * The tree id, must be unique. By default, created with `b3.createUUID`.
         * @readOnly
         */
        this.id = null;
        /**
         * The tree title.
         * @readonly
         */
        this.title = null;
        /**
         * Description of the tree.
         * @readonly
         */
        this.description = null;
        /**
         * A dictionary with (key-value) properties. Useful to define custom
         * variables in the visual editor.
         * @readonly
         */
        this.properties = null;
        /**
         * The reference to the root node. Must be an instance of `b3.BaseNode`.
         */
        this.root = null;
        /**
         * The reference to the debug instance.
         */
        this.debug = null;
        this.id = b3.createUUID();
        this.title = "The behavior tree";
        this.description = "Default description";
        this.properties = {};
        this.root = null;
        this.debug = null;
    }
    /**
     * This method loads a Behavior Tree from a data structure, populating this
     * object with the provided data. Notice that, the data structure must
     * follow the format specified by Behavior3JS. Consult the guide to know
     * more about this format.
     *
     * You probably want to use custom nodes in your BTs, thus, you need to
     * provide the `names` object, in which this method can find the nodes by
     * `names[NODE_NAME]`. This variable can be a namespace or a dictionary,
     * as long as this method can find the node by its name, for example:
     *
     *     //json
     *     ...
     *     "node1": {
     *       "name": MyCustomNode,
     *       "title": ...
     *     }
     *     ...
     *
     *     //code
     *     var bt = new b3.BehaviorTree();
     *     bt.load(data, {"MyCustomNode":MyCustomNode})
     *
     *
     * @method load
     * @param data The data structure representing a Behavior Tree.
     * @param names A namespace or dict containing custom nodes.
     */
    B3BehaviorTree.prototype.load = function (data, names) {
        names = names || {};
        this.title = data.title || this.title;
        this.description = data.description || this.description;
        this.properties = data.properties || this.properties;
        var nodes = {};
        var id, spec, node;
        // Create the node list (without connection between them)
        for (id in data.nodes) {
            spec = data.nodes[id];
            var Cls;
            if (spec.name in names) {
                // Look for the name in custom nodes
                Cls = names[spec.name];
            }
            else if (spec.name in b3) {
                // Look for the name in default nodes
                Cls = b3[spec.name];
            }
            else {
                // Invalid node name
                throw new EvalError('BehaviorTree.load: Invalid node name + "' +
                    spec.name + '".');
            }
            node = new Cls(spec.properties);
            node.id = spec.id || node.id;
            node.title = spec.title || node.title;
            node.description = spec.description || node.description;
            node.properties = spec.properties || node.properties;
            nodes[id] = node;
        }
        // Connect the nodes
        for (id in data.nodes) {
            spec = data.nodes[id];
            node = nodes[id];
            if (node.category === b3.COMPOSITE && spec.children) {
                for (var i = 0; i < spec.children.length; i++) {
                    var cid = spec.children[i];
                    node.children.push(nodes[cid]);
                }
            }
            else if (node.category === b3.DECORATOR && spec.child) {
                node.child = nodes[spec.child];
            }
        }
        this.root = nodes[data.root];
    };
    /**
     * This method dump the current BT into a data structure.
     *
     * Note: This method does not record the current node parameters. Thus,
     * it may not be compatible with load for now.
     *
     * @method dump
     * @return {Object} A data object representing this tree.
     */
    B3BehaviorTree.prototype.dump = function () {
        var data = {};
        var customNames = [];
        data.title = this.title;
        data.description = this.description;
        data.root = (this.root) ? this.root.id : null;
        data.properties = this.properties;
        data.nodes = {};
        data.custom_nodes = [];
        if (!this.root)
            return data;
        var stack = [this.root];
        while (stack.length > 0) {
            var node = stack.pop();
            var spec = {};
            spec.id = node.id;
            spec.name = node.name;
            spec.title = node.title;
            spec.description = node.description;
            spec.properties = node.properties;
            spec.parameters = node.parameters;
            // verify custom node
            var proto = (node.constructor && node.constructor.prototype);
            var nodeName = (proto && proto.name) || node.name;
            if (!b3[nodeName] && customNames.indexOf(nodeName) < 0) {
                var subdata = {};
                subdata.name = nodeName;
                subdata.title = (proto && proto.title) || node.title;
                subdata.category = node.category;
                customNames.push(nodeName);
                data.custom_nodes.push(subdata);
            }
            // store children/child
            if (node.category === b3.COMPOSITE && node.children) {
                var children = [];
                for (var i = node.children.length - 1; i >= 0; i--) {
                    children.push(node.children[i].id);
                    stack.push(node.children[i]);
                }
                spec.children = children;
            }
            else if (node.category === b3.DECORATOR && node.child) {
                stack.push(node.child);
                spec.child = node.child.id;
            }
            data.nodes[node.id] = spec;
        }
        return data;
    };
    /**
     * Propagates the tick signal through the tree, starting from the root.
     *
     * This method receives a target object of any type (Object, Array,
     * DOMElement, whatever) and a `Blackboard` instance. The target object has
     * no use at all for all Behavior3JS components, but surely is important
     * for custom nodes. The blackboard instance is used by the tree and nodes
     * to store execution variables (e.g., last node running) and is obligatory
     * to be a `Blackboard` instance (or an object with the same interface).
     *
     * Internally, this method creates a Tick object, which will store the
     * target and the blackboard objects.
     *
     * Note: BehaviorTree stores a list of open nodes from last tick, if these
     * nodes weren"t called after the current tick, this method will close them
     * automatically.
     *
     * @method tick
     * @param target A target object.
     * @param blackboard An instance of blackboard object.
     * @return {Constant} The tick signal state.
     */
    B3BehaviorTree.prototype.tick = function (target, blackboard) {
        if (!blackboard) {
            throw "The blackboard parameter is obligatory and must be an " +
                "instance of b3.Blackboard";
        }
        /* CREATE A TICK OBJECT */
        var tick = new B3Tick();
        tick.debug = this.debug;
        tick.target = target;
        tick.blackboard = blackboard;
        tick.tree = this;
        /* TICK NODE */
        var state = this.root._execute(tick);
        /* CLOSE NODES FROM LAST TICK, IF NEEDED */
        var lastOpenNodes = blackboard.get("openNodes", this.id);
        var currOpenNodes = tick._openNodes.slice(0);
        // does not close if it is still open in this tick
        var start = 0;
        var i;
        for (i = 0; i < Math.min(lastOpenNodes.length, currOpenNodes.length); i++) {
            start = i + 1;
            if (lastOpenNodes[i] !== currOpenNodes[i]) {
                break;
            }
        }
        // close the nodes
        for (i = lastOpenNodes.length - 1; i >= start; i--) {
            lastOpenNodes[i]._close(tick);
        }
        /* POPULATE BLACKBOARD */
        blackboard.set("openNodes", currOpenNodes, this.id);
        blackboard.set("nodeCount", tick._nodeCount, this.id);
        return state;
    };
    return B3BehaviorTree;
}());
exports.B3BehaviorTree = B3BehaviorTree;
/**
 * A new Tick object is instantiated every tick by BehaviorTree. It is passed
 * as parameter to the nodes through the tree during the traversal.
 *
 * The role of the Tick class is to store the instances of tree, debug,
 * target and blackboard. So, all nodes can access these informations.
 *
 * For internal uses, the Tick also is useful to store the open node after
 * the tick signal, in order to let `BehaviorTree` to keep track and close
 * them when necessary.
 *
 * This class also makes a bridge between nodes and the debug, passing the
 * node state to the debug if the last is provided.
 *
 * @module b3
 * @class Tick
 */
var B3Tick = /** @class */ (function () {
    /**
     * Initialization method.
     * @constructor
     */
    function B3Tick() {
        /**
         * The tree reference.
         * @readOnly
         */
        this.tree = null;
        /**
         * The debug reference.
         * @readOnly
         */
        this.debug = null;
        /**
         * The target object reference.
         * @readOnly
         */
        this.target = null;
        /**
         * The blackboard reference.
         * @readOnly
         */
        this.blackboard = null;
        /**
         * The list of open nodes. Update during the tree traversal.
         * @protected
         * @readOnly
         */
        this._openNodes = [];
        /**
         * The number of nodes entered during the tick. Update during the tree
         * traversal.
         *
         * @property {Integer} _nodeCount
         * @protected
         * @readOnly
         */
        this._nodeCount = 0;
        // set by BehaviorTree
        this.tree = null;
        this.debug = null;
        this.target = null;
        this.blackboard = null;
        // updated during the tick signal
        this._openNodes = [];
        this._nodeCount = 0;
    }
    /**
     * Called when entering a node (called by BaseNode).
     * @method _enterNode
     * @param node The node that called this method.
     * @protected
     */
    B3Tick.prototype._enterNode = function (node) {
        this._nodeCount++;
        this._openNodes.push(node);
        // TODO: call debug here
    };
    /**
     * Callback when opening a node (called by BaseNode).
     * @method _openNode
     * @param node The node that called this method.
     * @protected
     */
    B3Tick.prototype._openNode = function (node) {
        // TODO: call debug here
    };
    /**
     * Callback when ticking a node (called by BaseNode).
     * @method _tickNode
     * @param node The node that called this method.
     * @protected
     */
    B3Tick.prototype._tickNode = function (node) {
        // TODO: call debug here
    };
    /**
     * Callback when closing a node (called by BaseNode).
     * @method _closeNode
     * @param node The node that called this method.
     * @protected
     */
    B3Tick.prototype._closeNode = function (node) {
        // TODO: call debug here
        this._openNodes.pop();
    };
    /**
     * Callback when exiting a node (called by BaseNode).
     * @method _exitNode
     * @param node The node that called this method.
     * @protected
     */
    B3Tick.prototype._exitNode = function (node) {
        // TODO: call debug here
    };
    return B3Tick;
}());
exports.B3Tick = B3Tick;
/**
 * The Blackboard is the memory structure required by `BehaviorTree` and its
 * nodes. It only have 2 public methods: `set` and `get`. These methods works
 * in 3 different contexts: global, per tree, and per node per tree.
 *
 * Suppose you have two different trees controlling a single object with a
 * single blackboard, then:
 *
 * - In the global context, all nodes will access the stored information.
 * - In per tree context, only nodes sharing the same tree share the stored
 *   information.
 * - In per node per tree context, the information stored in the blackboard
 *   can only be accessed by the same node that wrote the data.
 *
 * The context is selected indirectly by the parameters provided to these
 * methods, for example:
 *
 *     // getting/setting variable in global context
 *     blackboard.set("testKey", "value");
 *     var value = blackboard.get("testKey");
 *
 *     // getting/setting variable in per tree context
 *     blackboard.set("testKey", "value", tree.id);
 *     var value = blackboard.get("testKey", tree.id);
 *
 *     // getting/setting variable in per node per tree context
 *     blackboard.set("testKey", "value", tree.id, node.id);
 *     var value = blackboard.get("testKey", tree.id, node.id);
 *
 * Note: Internally, the blackboard store these memories in different
 * objects, being the global on `_baseMemory`, the per tree on `_treeMemory`
 * and the per node per tree dynamically create inside the per tree memory
 * (it is accessed via `_treeMemory[id].nodeMemory`). Avoid to use these
 * variables manually, use `get` and `set` instead.
 *
 * @module b3
 * @class Blackboard
 */
var B3Blackboard = /** @class */ (function () {
    /**
     * Initialization method.
     * @method initialize
     * @constructor
     */
    function B3Blackboard() {
        this._baseMemory = null;
        this._treeMemory = null;
        this._baseMemory = {};
        this._treeMemory = {};
    }
    /**
     * Internal method to retrieve the tree context memory. If the memory does
     * not exist, this method creates it.
     *
     * @method _getTreeMemory
     * @param treeScope The id of the tree in scope.
     * @return {Object} The tree memory.
     * @protected
     */
    B3Blackboard.prototype._getTreeMemory = function (treeScope) {
        if (!this._treeMemory[treeScope]) {
            this._treeMemory[treeScope] = {
                "nodeMemory": {},
                "openNodes": [],
                "traversalDepth": 0,
                "traversalCycle": 0,
            };
        }
        return this._treeMemory[treeScope];
    };
    /**
     * Internal method to retrieve the node context memory, given the tree
     * memory. If the memory does not exist, this method creates is.
     *
     * @method _getNodeMemory
     * @param treeMemory the tree memory.
     * @param nodeScope The id of the node in scope.
     * @return {Object} The node memory.
     * @protected
     */
    B3Blackboard.prototype._getNodeMemory = function (treeMemory, nodeScope) {
        var memory = treeMemory.nodeMemory;
        if (!memory[nodeScope]) {
            memory[nodeScope] = {};
        }
        return memory[nodeScope];
    };
    /**
     * Internal method to retrieve the context memory. If treeScope and
     * nodeScope are provided, this method returns the per node per tree
     * memory. If only the treeScope is provided, it returns the per tree
     * memory. If no parameter is provided, it returns the global memory.
     * Notice that, if only nodeScope is provided, this method will still
     * return the global memory.
     *
     * @method _getMemory
     * @param treeScope The id of the tree scope.
     * @param nodeScope The id of the node scope.
     * @return {Object} A memory object.
     * @protected
     */
    B3Blackboard.prototype._getMemory = function (treeScope, nodeScope) {
        var memory = this._baseMemory;
        if (treeScope) {
            memory = this._getTreeMemory(treeScope);
            if (nodeScope) {
                memory = this._getNodeMemory(memory, nodeScope);
            }
        }
        return memory;
    };
    /**
     * Stores a value in the blackboard. If treeScope and nodeScope are
     * provided, this method will save the value into the per node per tree
     * memory. If only the treeScope is provided, it will save the value into
     * the per tree memory. If no parameter is provided, this method will save
     * the value into the global memory. Notice that, if only nodeScope is
     * provided (but treeScope not), this method will still save the value into
     * the global memory.
     *
     * @method set
     * @param key The key to be stored.
     * @param value The value to be stored.
     * @param treeScope The tree id if accessing the tree or node
     *                           memory.
     * @param nodeScope The node id if accessing the node memory.
     */
    B3Blackboard.prototype.set = function (key, value, treeScope, nodeScope) {
        var memory = this._getMemory(treeScope, nodeScope);
        memory[key] = value;
    };
    /**
     * Retrieves a value in the blackboard. If treeScope and nodeScope are
     * provided, this method will retrieve the value from the per node per tree
     * memory. If only the treeScope is provided, it will retrieve the value
     * from the per tree memory. If no parameter is provided, this method will
     * retrieve from the global memory. If only nodeScope is provided (but
     * treeScope not), this method will still try to retrieve from the global
     * memory.
     *
     * @method get
     * @param key The key to be retrieved.
     * @param treeScope The tree id if accessing the tree or node
     *                           memory.
     * @param nodeScope The node id if accessing the node memory.
     * @return {Object} The value stored or undefined.
     */
    B3Blackboard.prototype.get = function (key, treeScope, nodeScope) {
        var memory = this._getMemory(treeScope, nodeScope);
        return memory[key];
    };
    return B3Blackboard;
}());
exports.B3Blackboard = B3Blackboard;
/**
 * The BaseNode class is used as super class to all nodes in BehaviorJS. It
 * comprises all common variables and methods that a node must have to
 * execute.
 *
 * **IMPORTANT:** Do not inherit from this class, use `b3.Composite`,
 * `b3.Decorator`, `b3.Action` or `b3.Condition`, instead.
 *
 * The attributes are specially designed to serialization of the node in a
 * JSON format. In special, the `parameters` attribute can be set into the
 * visual editor (thus, in the JSON file), and it will be used as parameter
 * on the node initialization at `BehaviorTree.load`.
 *
 * BaseNode also provide 5 callback methods, which the node implementations
 * can override. They are `enter`, `open`, `tick`, `close` and `exit`. See
 * their documentation to know more. These callbacks are called inside the
 * `_execute` method, which is called in the tree traversal.
 *
 * @module b3
 * @class BaseNode
 */
var B3BaseNode = /** @class */ (function () {
    /**
     * Initialization method.
     * @constructor
     */
    function B3BaseNode(params) {
        /**
         * Node ID.
         * @readonly
         */
        this.id = null;
        /**
         * Node name. Must be a unique identifier, preferable the same name of the
         * class. You have to set the node name in the prototype.
         * @readonly
         */
        this.name = null;
        /**
         * Node category. Must be `b3.COMPOSITE`, `b3.DECORATOR`, `b3.ACTION` or
         * `b3.CONDITION`. This is defined automatically be inheriting the
         * correspondent class.
         * @readonly
         */
        this.category = null;
        /**
         * Node title.
         * @optional
         * @readonly
         */
        this.title = null;
        /**
         * Node description.
         * @optional
         * @readonly
         */
        this.description = null;
        /**
         * A dictionary (key, value) describing the node parameters. Useful for
         * defining parameter values in the visual editor. Note: this is only
         * useful for nodes when loading trees from JSON files.
         *
         * **Deprecated since 0.2.0. This is too similar to the properties
         * attribute, thus, this attribute is deprecated in favor to
         * `properties`.**
         *
         * @deprecated since 0.2.0.
         * @readonly
         */
        this.parameters = null;
        /**
         * A dictionary (key, value) describing the node properties. Useful for
         * defining custom variables inside the visual editor.
         *
         * @type {Object}
         * @readonly
         */
        this.properties = null;
        this.id = b3.createUUID();
        this.title = this.title || this.name;
        this.description = "";
        this.parameters = {};
        this.properties = {};
    }
    /**
     * This is the main method to propagate the tick signal to this node. This
     * method calls all callbacks: `enter`, `open`, `tick`, `close`, and
     * `exit`. It only opens a node if it is not already open. In the same
     * way, this method only close a node if the node  returned a status
     * different of `b3.RUNNING`.
     *
     * @method _execute
     * @param tick A tick instance.
     * @return {Constant} The tick state.
     * @protected
     */
    B3BaseNode.prototype._execute = function (tick) {
        // ENTER 
        this._enter(tick);
        // OPEN 
        if (!tick.blackboard.get("isOpen", tick.tree.id, this.id)) {
            this._open(tick);
        }
        // TICK 
        var status = this._tick(tick);
        // CLOSE 
        if (status !== b3.RUNNING) {
            this._close(tick);
        }
        // EXIT 
        this._exit(tick);
        return status;
    };
    /**
     * Wrapper for enter method.
     * @method _enter
     * @param tick A tick instance.
     * @protected
     */
    B3BaseNode.prototype._enter = function (tick) {
        tick._enterNode(this);
        this.enter(tick);
    };
    /**
     * Wrapper for open method.
     * @method _open
     * @param tick A tick instance.
     * @protected
     */
    B3BaseNode.prototype._open = function (tick) {
        tick._openNode(this);
        tick.blackboard.set("isOpen", true, tick.tree.id, this.id);
        this.open(tick);
    };
    /**
     * Wrapper for tick method.
     * @method _tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     * @protected
     */
    B3BaseNode.prototype._tick = function (tick) {
        tick._tickNode(this);
        return this.tick(tick);
    };
    /**
     * Wrapper for close method.
     * @method _close
     * @param tick A tick instance.
     * @protected
     */
    B3BaseNode.prototype._close = function (tick) {
        tick._closeNode(this);
        tick.blackboard.set("isOpen", false, tick.tree.id, this.id);
        this.close(tick);
    };
    /**
     * Wrapper for exit method.
     * @method _exit
     * @param tick A tick instance.
     * @protected
     */
    B3BaseNode.prototype._exit = function (tick) {
        tick._exitNode(this);
        this.exit(tick);
    };
    /**
     * Enter method, override this to use. It is called every time a node is
     * asked to execute, before the tick itself.
     *
     * @virtual
     * @method enter
     * @param tick A tick instance.
     */
    B3BaseNode.prototype.enter = function (tick) { };
    /**
     * Open method, override this to use. It is called only before the tick
     * callback and only if the not isn"t closed.
     *
     * Note: a node will be closed if it returned `b3.RUNNING` in the tick.
     *
     * @virtual
     * @method open
     * @param tick A tick instance.
     */
    B3BaseNode.prototype.open = function (tick) { };
    /**
     * Tick method, override this to use. This method must contain the real
     * execution of node (perform a task, call children, etc.). It is called
     * every time a node is asked to execute.
     *
     * @virtual
     * @method tick
     * @param tick A tick instance.
     */
    B3BaseNode.prototype.tick = function (tick) { return b3.SUCCESS; };
    /**
     * Close method, override this to use. This method is called after the tick
     * callback, and only if the tick return a state different from
     * `b3.RUNNING`.
     *
     * @virtual
     * @method close
     * @param tick A tick instance.
     */
    B3BaseNode.prototype.close = function (tick) { };
    /**
     * Exit method, override this to use. Called every time in the end of the
     * execution.
     *
     * @virtual
     * @method exit
     * @param tick A tick instance.
     */
    B3BaseNode.prototype.exit = function (tick) { };
    return B3BaseNode;
}());
exports.B3BaseNode = B3BaseNode;
/**
 * Action is the base class for all action nodes. Thus, if you want to create
 * new custom action nodes, you need to inherit from this class. For example,
 * take a look at the Runner action:
 *
 *     var Runner = b3.Class(b3.Action, {
 *       name: "Runner",
 *
 *       tick: function(tick) {
 *         return b3.RUNNING;
 *       }
 *     });
 *
 * @module b3
 * @class Action
 * @extends B3BaseNode
 */
var B3Action = /** @class */ (function (_super) {
    __extends(B3Action, _super);
    /**
     * Initialization method.
     * @constructor
     */
    function B3Action(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node category. Default to `b3.ACTION`.
         * @readonly
         */
        _this.category = b3.ACTION;
        return _this;
    }
    return B3Action;
}(B3BaseNode));
exports.B3Action = B3Action;
/**
 * Composite is the base class for all composite nodes. Thus, if you want to
 * create new custom composite nodes, you need to inherit from this class.
 *
 * When creating composite nodes, you will need to propagate the tick signal
 * to the children nodes manually. To do that, override the `tick` method and
 * call the `_execute` method on all nodes. For instance, take a look at how
 * the Sequence node inherit this class and how it call its children:
 *
 *     // Inherit from Composite, using the util function Class.
 *     var Sequence = b3.Class(b3.Composite, {
 *
 *       // Remember to set the name of the node.
 *       name: "Sequence",
 *
 *       // Override the tick function
 *       tick: function(tick) {
 *
 *         // Iterates over the children
 *         for (var i=0; i<this.children.length; i++) {
 *
 *           // Propagate the tick
 *           var status = this.children[i]._execute(tick);
 *
 *           if (status !== b3.SUCCESS) {
 *               return status;
 *           }
 *         }
 *
 *         return b3.SUCCESS;
 *       }
 *     });
 *
 * @module b3
 * @class Composite
 * @extends B3BaseNode
 */
var B3Composite = /** @class */ (function (_super) {
    __extends(B3Composite, _super);
    /**
     * Initialization method.
     * @constructor
     */
    function B3Composite(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node category. Default to `b3.COMPOSITE`.
         * @readonly
         */
        _this.category = b3.COMPOSITE;
        _this.children = (params.children || []).slice(0);
        return _this;
    }
    return B3Composite;
}(B3BaseNode));
exports.B3Composite = B3Composite;
/**
 * Condition is the base class for all condition nodes. Thus, if you want to
 * create new custom condition nodes, you need to inherit from this class.
 *
 * @class Condition
 * @extends B3BaseNode
 */
var B3Condition = /** @class */ (function (_super) {
    __extends(B3Condition, _super);
    /**
     * Initialization method.
     * @constructor
     */
    function B3Condition(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node category. Default to `b3.CONDITION`.
         * @readonly
         */
        _this.category = b3.CONDITION;
        return _this;
    }
    return B3Condition;
}(B3BaseNode));
exports.B3Condition = B3Condition;
/**
 * Decorator is the base class for all decorator nodes. Thus, if you want to
 * create new custom decorator nodes, you need to inherit from this class.
 *
 * When creating decorator nodes, you will need to propagate the tick signal
 * to the child node manually, just like the composite nodes. To do that,
 * override the `tick` method and call the `_execute` method on the child
 * node. For instance, take a look at how the Inverter node inherit this
 * class and how it call its children:
 *
 *     // Inherit from Decorator, using the util function Class.
 *     var Inverter = b3.Class(b3.Decorator, {
 *       name: "Inverter",
 *
 *       tick: function(tick) {
 *         if (!this.child) {
 *           return b3.ERROR;
 *         }
 *
 *         // Propagate the tick
 *         var status = this.child._execute(tick);
 *
 *         if (status == b3.SUCCESS) {
 *           status = b3.FAILURE;
 *         } else if (status == b3.FAILURE) {
 *           status = b3.SUCCESS;
 *         }
 *
 *         return status;
 *       }
 *     });
 *
 * @module b3
 * @class Decorator
 * @extends B3BaseNode
 */
var B3Decorator = /** @class */ (function (_super) {
    __extends(B3Decorator, _super);
    /**
     * Initialization method.
     * @constructor
     */
    function B3Decorator(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node category. Default to b3.DECORATOR.
         * @readonly
         */
        _this.category = b3.DECORATOR;
        _this.child = params.child || null;
        return _this;
    }
    return B3Decorator;
}(B3BaseNode));
exports.B3Decorator = B3Decorator;
/**
 * MemPriority is similar to Priority node, but when a child returns a
 * `RUNNING` state, its index is recorded and in the next tick the,
 * MemPriority calls the child recorded directly, without calling previous
 * children again.
 *
 * @module b3
 * @class MemPriority
 * @extends B3Composite
 */
var B3MemPriority = /** @class */ (function (_super) {
    __extends(B3MemPriority, _super);
    function B3MemPriority() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `MemPriority`.
         * @readonly
         */
        _this.name = "MemPriority";
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3MemPriority.prototype.open = function (tick) {
        tick.blackboard.set("runningChild", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3MemPriority.prototype.tick = function (tick) {
        var child = tick.blackboard.get("runningChild", tick.tree.id, this.id);
        for (var i = child; i < this.children.length; i++) {
            var status = this.children[i]._execute(tick);
            if (status !== b3.FAILURE) {
                if (status === b3.RUNNING) {
                    tick.blackboard.set("runningChild", i, tick.tree.id, this.id);
                }
                return status;
            }
        }
        return b3.FAILURE;
    };
    return B3MemPriority;
}(B3Composite));
exports.B3MemPriority = B3MemPriority;
/**
 * MemSequence is similar to Sequence node, but when a child returns a
 * `RUNNING` state, its index is recorded and in the next tick the
 * MemSequence call the child recorded directly, without calling previous
 * children again.
 *
 * @module b3
 * @class MemSequence
 * @extends B3Composite
 */
var B3MemSequence = /** @class */ (function (_super) {
    __extends(B3MemSequence, _super);
    function B3MemSequence() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `MemSequence`.
         * @readonly
         */
        _this.name = "MemSequence";
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3MemSequence.prototype.open = function (tick) {
        tick.blackboard.set("runningChild", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3MemSequence.prototype.tick = function (tick) {
        var child = tick.blackboard.get("runningChild", tick.tree.id, this.id);
        for (var i = child; i < this.children.length; i++) {
            var status = this.children[i]._execute(tick);
            if (status !== b3.SUCCESS) {
                if (status === b3.RUNNING) {
                    tick.blackboard.set("runningChild", i, tick.tree.id, this.id);
                }
                return status;
            }
        }
        return b3.SUCCESS;
    };
    return B3MemSequence;
}(B3Composite));
exports.B3MemSequence = B3MemSequence;
/**
 * Priority ticks its children sequentially until one of them returns
 * `SUCCESS`, `RUNNING` or `ERROR`. If all children return the failure state,
 * the priority also returns `FAILURE`.
 *
 * @module b3
 * @class Priority
 * @extends B3Composite
 */
var B3Priority = /** @class */ (function (_super) {
    __extends(B3Priority, _super);
    function B3Priority() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Priority`.
         * @readonly
         */
        _this.name = "Priority";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3Priority.prototype.tick = function (tick) {
        for (var i = 0; i < this.children.length; i++) {
            var status = this.children[i]._execute(tick);
            if (status !== b3.FAILURE) {
                return status;
            }
        }
        return b3.FAILURE;
    };
    return B3Priority;
}(B3Composite));
exports.B3Priority = B3Priority;
/**
 * The Sequence node ticks its children sequentially until one of them
 * returns `FAILURE`, `RUNNING` or `ERROR`. If all children return the
 * success state, the sequence also returns `SUCCESS`.
 *
 * @module b3
 * @class Sequence
 * @extends B3Composite
 */
var B3Sequence = /** @class */ (function (_super) {
    __extends(B3Sequence, _super);
    function B3Sequence() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Sequence`.
         * @readonly
         */
        _this.name = "Sequence";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3Sequence.prototype.tick = function (tick) {
        for (var i = 0; i < this.children.length; i++) {
            var status = this.children[i]._execute(tick);
            if (status !== b3.SUCCESS) {
                return status;
            }
        }
        return b3.SUCCESS;
    };
    return B3Sequence;
}(B3Composite));
exports.B3Sequence = B3Sequence;
/**
 * The Inverter decorator inverts the result of the child, returning `SUCCESS`
 * for `FAILURE` and `FAILURE` for `SUCCESS`.
 *
 * @module b3
 * @class Inverter
 * @extends B3Decorator
 */
var B3Inverter = /** @class */ (function (_super) {
    __extends(B3Inverter, _super);
    function B3Inverter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Inverter`.
         * @readonly
         */
        _this.name = "Inverter";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3Inverter.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var status = this.child._execute(tick);
        if (status == b3.SUCCESS) {
            status = b3.FAILURE;
        }
        else if (status == b3.FAILURE) {
            status = b3.SUCCESS;
        }
        return status;
    };
    return B3Inverter;
}(B3Decorator));
exports.B3Inverter = B3Inverter;
/**
 * This decorator limit the number of times its child can be called. After a
 * certain number of times, the Limiter decorator returns `FAILURE` without
 * executing the child.
 *
 * @module b3
 * @class Limiter
 * @extends B3Decorator
 */
var B3Limiter = /** @class */ (function (_super) {
    __extends(B3Limiter, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **maxLoop** (*Integer*) Maximum number of repetitions.
     * - **child** (*BaseNode*) The child node.
     *
     * @method initialize
     * @param params Object with parameters.
     * @constructor
     */
    function B3Limiter(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node name. Default to `Limiter`.
         * @readonly
         */
        _this.name = "Limiter";
        /**
         * Node title. Default to `Limit X Activations`. Used in Editor.
         * @readonly
         */
        _this.title = "Limit <maxLoop> Activations";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "maxLoop": 1 };
        if (!params.maxLoop) {
            throw "maxLoop parameter in Limiter decorator is an obligatory " +
                "parameter";
        }
        _this.maxLoop = params.maxLoop;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3Limiter.prototype.open = function (tick) {
        tick.blackboard.set("i", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3Limiter.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var i = tick.blackboard.get("i", tick.tree.id, this.id);
        if (i < this.maxLoop) {
            var status = this.child._execute(tick);
            if (status == b3.SUCCESS || status == b3.FAILURE)
                tick.blackboard.set("i", i + 1, tick.tree.id, this.id);
            return status;
        }
        return b3.FAILURE;
    };
    return B3Limiter;
}(B3Decorator));
exports.B3Limiter = B3Limiter;
/**
 * The MaxTime decorator limits the maximum time the node child can execute.
 * Notice that it does not interrupt the execution itself (i.e., the child
 * must be non-preemptive), it only interrupts the node after a `RUNNING`
 * status.
 *
 * @module b3
 * @class MaxTime
 * @extends B3Decorator
 */
var B3MaxTime = /** @class */ (function (_super) {
    __extends(B3MaxTime, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **maxTime** (*Integer*) Maximum time a child can execute.
     * - **child** (*BaseNode*) The child node.
     *
     * @method initialize
     * @param params Object with parameters.
     * @constructor
     */
    function B3MaxTime(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node name. Default to `MaxTime`.
         * @readonly
         */
        _this.name = "MaxTime";
        /**
         * Node title. Default to `Max XXms`. Used in Editor.
         * @readonly
         */
        _this.title = "Max <maxTime>ms";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "maxTime": 0 };
        if (!params.maxTime) {
            throw "maxTime parameter in MaxTime decorator is an obligatory " +
                "parameter";
        }
        _this.maxTime = params.maxTime;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3MaxTime.prototype.open = function (tick) {
        var startTime = (new Date()).getTime();
        tick.blackboard.set("startTime", startTime, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3MaxTime.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var currTime = (new Date()).getTime();
        var startTime = tick.blackboard.get("startTime", tick.tree.id, this.id);
        var status = this.child._execute(tick);
        if (currTime - startTime > this.maxTime) {
            return b3.FAILURE;
        }
        return status;
    };
    return B3MaxTime;
}(B3Decorator));
exports.B3MaxTime = B3MaxTime;
/**
 * RepeatUntilFailure is a decorator that repeats the tick signal until the
 * node child returns `FAILURE`, `RUNNING` or `ERROR`. Optionally, a maximum
 * number of repetitions can be defined.
 *
 * @module b3
 * @class RepeatUntilFailure
 * @extends B3Decorator
 */
var B3RepeatUntilFailure = /** @class */ (function (_super) {
    __extends(B3RepeatUntilFailure, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **maxLoop** (*Integer*) Maximum number of repetitions. Default to -1
     *                           (infinite).
     * - **child** (*BaseNode*) The child node.
     *
     * @method initialize
     * @param params Object with parameters.
     * @constructor
     */
    function B3RepeatUntilFailure(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node name. Default to `RepeatUntilFailure`.
         * @readonly
         */
        _this.name = "RepeatUntilFailure";
        /**
         * Node title. Default to `Repeat Until Failure`.
         * @readonly
         */
        _this.title = "Repeat Until Failure";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "maxLoop": -1 };
        _this.maxLoop = params.maxLoop || -1;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3RepeatUntilFailure.prototype.open = function (tick) {
        tick.blackboard.set("i", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3RepeatUntilFailure.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var i = tick.blackboard.get("i", tick.tree.id, this.id);
        var status = b3.ERROR;
        while (this.maxLoop < 0 || i < this.maxLoop) {
            status = this.child._execute(tick);
            if (status == b3.SUCCESS) {
                i++;
            }
            else {
                break;
            }
        }
        i = tick.blackboard.set("i", i, tick.tree.id, this.id);
        return status;
    };
    return B3RepeatUntilFailure;
}(B3Decorator));
exports.B3RepeatUntilFailure = B3RepeatUntilFailure;
/**
 * RepeatUntilSuccess is a decorator that repeats the tick signal until the
 * node child returns `SUCCESS`, `RUNNING` or `ERROR`. Optionally, a maximum
 * number of repetitions can be defined.
 *
 * @module b3
 * @class RepeatUntilSuccess
 * @extends B3Decorator
 */
var B3RepeatUntilSuccess = /** @class */ (function (_super) {
    __extends(B3RepeatUntilSuccess, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **maxLoop** (*Integer*) Maximum number of repetitions. Default to -1
     *                           (infinite).
     * - **child** (*BaseNode*) The child node.
     *
     * @method initialize
     * @param params Object with parameters.
     * @constructor
     */
    function B3RepeatUntilSuccess(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node name. Default to `RepeatUntilSuccess`.
         * @readonly
         */
        _this.name = "RepeatUntilSuccess";
        /**
         * Node title. Default to `Repeat Until Success`.
         * @readonly
         */
        _this.title = "Repeat Until Success";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "maxLoop": -1 };
        _this.maxLoop = params.maxLoop || -1;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3RepeatUntilSuccess.prototype.open = function (tick) {
        tick.blackboard.set("i", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3RepeatUntilSuccess.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var i = tick.blackboard.get("i", tick.tree.id, this.id);
        var status = b3.ERROR;
        while (this.maxLoop < 0 || i < this.maxLoop) {
            status = this.child._execute(tick);
            if (status == b3.FAILURE) {
                i++;
            }
            else {
                break;
            }
        }
        i = tick.blackboard.set("i", i, tick.tree.id, this.id);
        return status;
    };
    return B3RepeatUntilSuccess;
}(B3Decorator));
exports.B3RepeatUntilSuccess = B3RepeatUntilSuccess;
/**
 * Repeater is a decorator that repeats the tick signal until the child node
 * return `RUNNING` or `ERROR`. Optionally, a maximum number of repetitions
 * can be defined.
 *
 * @module b3
 * @class Repeater
 * @extends B3Decorator
 */
var B3Repeater = /** @class */ (function (_super) {
    __extends(B3Repeater, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **maxLoop** (*Integer*) Maximum number of repetitions. Default to -1
     *                           (infinite).
     * - **child** (*BaseNode*) The child node.
     *
     * @method initialize
     * @param params Object with parameters.
     * @constructor
     */
    function B3Repeater(params) {
        var _this = _super.call(this, params) || this;
        /**
         * Node name. Default to `Repeater`.
         * @readonly
         */
        _this.name = "Repeater";
        /**
         * Node title. Default to `Repeat XXx`. Used in Editor.
         * @readonly
         */
        _this.title = "Repeat <maxLoop>x";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "maxLoop": -1 };
        _this.maxLoop = params.maxLoop || -1;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3Repeater.prototype.open = function (tick) {
        tick.blackboard.set("i", 0, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     */
    B3Repeater.prototype.tick = function (tick) {
        if (!this.child) {
            return b3.ERROR;
        }
        var i = tick.blackboard.get("i", tick.tree.id, this.id);
        var status = b3.SUCCESS;
        while (this.maxLoop < 0 || i < this.maxLoop) {
            status = this.child._execute(tick);
            if (status == b3.SUCCESS || status == b3.FAILURE) {
                i++;
            }
            else {
                break;
            }
        }
        tick.blackboard.set("i", i, tick.tree.id, this.id);
        return status;
    };
    return B3Repeater;
}(B3Decorator));
exports.B3Repeater = B3Repeater;
/**
 * This action node returns `ERROR` always.
 *
 * @module b3
 * @class Error
 * @extends B3Action
 */
var B3Error = /** @class */ (function (_super) {
    __extends(B3Error, _super);
    function B3Error() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Error`.
         * @readonly
         */
        _this.name = "Error";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} Always return `b3.ERROR`.
     */
    B3Error.prototype.tick = function (tick) {
        return b3.ERROR;
    };
    return B3Error;
}(B3Action));
exports.B3Error = B3Error;
/**
 * This action node returns `FAILURE` always.
 *
 * @module b3
 * @class Failer
 * @extends B3Action
 */
var B3Failer = /** @class */ (function (_super) {
    __extends(B3Failer, _super);
    function B3Failer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Failer`.
         * @readonly
         */
        _this.name = "Failer";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} Always return `b3.FAILURE`.
     */
    B3Failer.prototype.tick = function (tick) {
        return b3.FAILURE;
    };
    return B3Failer;
}(B3Action));
exports.B3Failer = B3Failer;
/**
 * This action node returns RUNNING always.
 *
 * @module b3
 * @class Runner
 * @extends B3Action
 */
var B3Runner = /** @class */ (function (_super) {
    __extends(B3Runner, _super);
    function B3Runner() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Runner`.
         * @readonly
         */
        _this.name = "Runner";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} Always return `b3.RUNNING`.
     */
    B3Runner.prototype.tick = function (tick) {
        return b3.RUNNING;
    };
    return B3Runner;
}(B3Action));
exports.B3Runner = B3Runner;
/**
 * This action node returns `SUCCESS` always.
 *
 * @module b3
 * @class Succeeder
 * @extends B3Action
 */
var B3Succeeder = /** @class */ (function (_super) {
    __extends(B3Succeeder, _super);
    function B3Succeeder() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Node name. Default to `Succeeder`.
         * @readonly
         */
        _this.name = "Succeeder";
        return _this;
    }
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} Always return `b3.SUCCESS`.
     */
    B3Succeeder.prototype.tick = function (tick) {
        return b3.SUCCESS;
    };
    return B3Succeeder;
}(B3Action));
exports.B3Succeeder = B3Succeeder;
/**
 * Wait a few seconds.
 *
 * @module b3
 * @class Wait
 * @extends B3Action
 */
var B3Wait = /** @class */ (function (_super) {
    __extends(B3Wait, _super);
    /**
     * Initialization method.
     *
     * Settings parameters:
     *
     * - **milliseconds** (*Integer*) Maximum time, in milliseconds, a child
     *                                can execute.
     *
     * @method initialize
     * @param settings Object with parameters.
     * @constructor
     */
    function B3Wait(settings) {
        var _this = this;
        settings = settings || {};
        _this = _super.call(this, settings) || this;
        /**
         * Node name. Default to `Wait`.
         * @readonly
         */
        _this.name = "Wait";
        /**
         * Node title. Default to `Wait XXms`. Used in Editor.
         * @readonly
         */
        _this.title = "Wait <milliseconds>ms";
        /**
         * Node parameters.
         * @readonly
         */
        _this.parameters = { "milliseconds": 0 };
        _this.endTime = settings.milliseconds || 0;
        return _this;
    }
    /**
     * Open method.
     * @method open
     * @param tick A tick instance.
     */
    B3Wait.prototype.open = function (tick) {
        var startTime = (new Date()).getTime();
        tick.blackboard.set("startTime", startTime, tick.tree.id, this.id);
    };
    /**
     * Tick method.
     * @method tick
     * @param tick A tick instance.
     * @return {Constant} A state constant.
     */
    B3Wait.prototype.tick = function (tick) {
        var currTime = (new Date()).getTime();
        var startTime = tick.blackboard.get("startTime", tick.tree.id, this.id);
        if (currTime - startTime > this.endTime) {
            return b3.SUCCESS;
        }
        return b3.RUNNING;
    };
    return B3Wait;
}(B3Action));
exports.B3Wait = B3Wait;
/**
 * 行为树runtime
 * - https://github.com/behavior3/behavior3js
 */
var b3 = /** @class */ (function () {
    function b3() {
    }
    /**
     * This function is used to create unique IDs for trees and nodes.
     *
     * (consult http://www.ietf.org/rfc/rfc4122.txt).
     *
     * @class createUUID
     * @return {String} A unique ID.
     */
    b3.createUUID = function () {
        var s = [];
        var hexDigits = "0123456789abcdef";
        for (var i = 0; i < 36; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        }
        // bits 12-15 of the time_hi_and_version field to 0010
        s[14] = "4";
        // bits 6-7 of the clock_seq_hi_and_reserved to 01
        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
        s[8] = s[13] = s[18] = s[23] = "-";
        var uuid = s.join("");
        return uuid;
    };
    /**
     * Class is a meta-factory function to create classes in JavaScript. It is a
     * shortcut for the CreateJS syntax style. By default, the class created by
     * this function have an initialize function (the constructor). Optionally,
     * you can specify the inheritance by passing another class as parameter.
     *
     * By default, all classes created using this function, may receive only a
     * dictionary parameter as argument. This pattern is commonly used by jQuery
     * and its plugins.
     *
     * Since 0.2.0, Class also receives a `properties` parameter, a dictionary
     * which will be used to fill the new class prototype.
     *
     * Usage
     * -----
     *
     *     // Creating a simple class
     *     var BaseClass = b3.Class();
     *
     *     var ChildClass = b3.Class(BaseClass, {
     *       // constructor
     *       initialize(params) {
     *
     *         // call super initialize
     *         BaseClass.initialize.call(this, params);
     *         ...
     *       }
     *     });
     *
     * @class Class
     * @param {Object} baseClass The super class.
     * @param {Object} properties A dictionary with attributes and methods.
     * @return {Object} A new class.
     */
    b3.Class = function (baseClass, properties) {
        // create a new class
        var cls = function (params) {
            this.initialize(params || {});
        };
        // if base class is provided, inherit
        if (baseClass) {
            cls.prototype = Object.create(baseClass.prototype);
            cls.prototype.constructor = cls;
        }
        // create initialize if does not exist on baseClass
        if (!cls.prototype.initialize) {
            cls.prototype.initialize = function () { };
        }
        // copy properties
        if (properties) {
            for (var key in properties) {
                cls.prototype[key] = properties[key];
            }
        }
        return cls;
    };
    b3.VERSION = "0.2.0";
    // Returning status
    b3.SUCCESS = B3State.SUCCESS;
    b3.FAILURE = B3State.FAILURE;
    b3.RUNNING = B3State.RUNNING;
    b3.ERROR = B3State.ERROR;
    // Node categories
    b3.COMPOSITE = "composite";
    b3.DECORATOR = "decorator";
    b3.ACTION = "action";
    b3.CONDITION = "condition";
    b3.BehaviorTree = B3BehaviorTree;
    b3.Tick = B3Tick;
    b3.Blackboard = B3Blackboard;
    b3.BaseNode = B3BaseNode;
    b3.Action = B3Action;
    b3.Composite = B3Composite;
    b3.Condition = B3Condition;
    b3.Decorator = B3Decorator;
    b3.MemPriority = B3MemPriority;
    b3.MemSequence = B3MemSequence;
    b3.Priority = B3Priority;
    b3.Sequence = B3Sequence;
    b3.Inverter = B3Inverter;
    b3.Limiter = B3Limiter;
    b3.MaxTime = B3MaxTime;
    b3.RepeatUntilFailure = B3RepeatUntilFailure;
    b3.RepeatUntilSuccess = B3RepeatUntilSuccess;
    b3.Repeater = B3Repeater;
    b3.Error = B3Error;
    b3.Failer = B3Failer;
    b3.Runner = B3Runner;
    b3.Succeeder = B3Succeeder;
    b3.Wait = B3Wait;
    return b3;
}());
exports.default = b3;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxCZWhhdmlvcjMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsSUFBWSxPQUtYO0FBTEQsV0FBWSxPQUFPO0lBQ2YsMkNBQVcsQ0FBQTtJQUNYLDJDQUFXLENBQUE7SUFDWCwyQ0FBVyxDQUFBO0lBQ1gsdUNBQVMsQ0FBQTtBQUNiLENBQUMsRUFMVyxPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFLbEI7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNERHO0FBQ0g7SUFxQ0k7O09BRUc7SUFDSDtRQXRDQTs7O1dBR0c7UUFDSCxPQUFFLEdBQVcsSUFBSSxDQUFDO1FBRWxCOzs7V0FHRztRQUNILFVBQUssR0FBVyxJQUFJLENBQUM7UUFFckI7OztXQUdHO1FBQ0gsZ0JBQVcsR0FBVyxJQUFJLENBQUM7UUFFM0I7Ozs7V0FJRztRQUNILGVBQVUsR0FBd0IsSUFBSSxDQUFDO1FBRXZDOztXQUVHO1FBQ0gsU0FBSSxHQUFlLElBQUksQ0FBQztRQUV4Qjs7V0FFRztRQUNILFVBQUssR0FBUSxJQUFJLENBQUM7UUFNZCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLG1CQUFtQixDQUFDO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcscUJBQXFCLENBQUM7UUFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQkc7SUFDSCw2QkFBSSxHQUFKLFVBQUssSUFBUyxFQUFFLEtBQXlDO1FBQ3JELEtBQUssR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO1FBRXBCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3hELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO1FBRXJELElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNmLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7UUFDbkIseURBQXlEO1FBQ3pELEtBQUssRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDbkIsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdEIsSUFBSSxHQUFHLENBQUM7WUFFUixJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksS0FBSyxFQUFFO2dCQUNwQixvQ0FBb0M7Z0JBQ3BDLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzFCO2lCQUFNLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLEVBQUU7Z0JBQ3hCLHFDQUFxQztnQkFDckMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdkI7aUJBQU07Z0JBQ0gsb0JBQW9CO2dCQUNwQixNQUFNLElBQUksU0FBUyxDQUFDLDBDQUEwQztvQkFDMUQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQzthQUN6QjtZQUVELElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDN0IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUM7WUFDdEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDeEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUM7WUFFckQsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztTQUNwQjtRQUVELG9CQUFvQjtRQUNwQixLQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ25CLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3RCLElBQUksR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFakIsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEVBQUUsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUMzQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDbEM7YUFDSjtpQkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssRUFBRSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNyRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDbEM7U0FDSjtRQUVELElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCw2QkFBSSxHQUFKO1FBQ0ksSUFBSSxJQUFJLEdBQVEsRUFBRSxDQUFDO1FBQ25CLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUVyQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDOUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO1FBRXZCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSTtZQUFFLE9BQU8sSUFBSSxDQUFDO1FBRTVCLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hCLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRXZCLElBQUksSUFBSSxHQUFRLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUN4QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDcEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUVsQyxxQkFBcUI7WUFDckIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDN0QsSUFBSSxRQUFRLEdBQUcsQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDbEQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEQsSUFBSSxPQUFPLEdBQVEsRUFBRSxDQUFDO2dCQUN0QixPQUFPLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztnQkFDeEIsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDckQsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO2dCQUVqQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNuQztZQUVELHVCQUF1QjtZQUN2QixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssRUFBRSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNqRCxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2hELFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDbkMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2hDO2dCQUNELElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO2FBQzVCO2lCQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ3JELEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2FBQzlCO1lBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQzlCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FxQkc7SUFDSCw2QkFBSSxHQUFKLFVBQUssTUFBVyxFQUFFLFVBQXdCO1FBQ3RDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDYixNQUFNLHdEQUF3RDtnQkFDOUQsMkJBQTJCLENBQUM7U0FDL0I7UUFFRCwwQkFBMEI7UUFDMUIsSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFFakIsZUFBZTtRQUNmLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLDJDQUEyQztRQUMzQyxJQUFJLGFBQWEsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekQsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0Msa0RBQWtEO1FBQ2xELElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDO1FBQ04sS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZFLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2QsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUN2QyxNQUFNO2FBQ1Q7U0FDSjtRQUVELGtCQUFrQjtRQUNsQixLQUFLLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hELGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakM7UUFFRCx5QkFBeUI7UUFDekIsVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwRCxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV0RCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBQ0wscUJBQUM7QUFBRCxDQW5RQSxBQW1RQyxJQUFBO0FBblFZLHdDQUFjO0FBcVEzQjs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUNIO0lBMkNJOzs7T0FHRztJQUNIO1FBN0NBOzs7V0FHRztRQUNILFNBQUksR0FBbUIsSUFBSSxDQUFDO1FBRTVCOzs7V0FHRztRQUNILFVBQUssR0FBUSxJQUFJLENBQUM7UUFFbEI7OztXQUdHO1FBQ0gsV0FBTSxHQUFRLElBQUksQ0FBQztRQUVuQjs7O1dBR0c7UUFDSCxlQUFVLEdBQWlCLElBQUksQ0FBQztRQUVoQzs7OztXQUlHO1FBQ0gsZUFBVSxHQUFVLEVBQUUsQ0FBQztRQUV2Qjs7Ozs7OztXQU9HO1FBQ0gsZUFBVSxHQUFXLENBQUMsQ0FBQztRQU9uQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFFdkIsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDJCQUFVLEdBQVYsVUFBVyxJQUFnQjtRQUN2QixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFM0Isd0JBQXdCO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDBCQUFTLEdBQVQsVUFBVSxJQUFnQjtRQUN0Qix3QkFBd0I7SUFDNUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLElBQWdCO1FBQ3RCLHdCQUF3QjtJQUM1QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQkFBVSxHQUFWLFVBQVcsSUFBZ0I7UUFDdkIsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLElBQWdCO1FBQ3RCLHdCQUF3QjtJQUM1QixDQUFDO0lBQ0wsYUFBQztBQUFELENBaEhBLEFBZ0hDLElBQUE7QUFoSFksd0JBQU07QUFrSG5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUNHO0FBQ0g7SUFLSTs7OztPQUlHO0lBQ0g7UUFSUSxnQkFBVyxHQUF3QixJQUFJLENBQUM7UUFDeEMsZ0JBQVcsR0FBd0IsSUFBSSxDQUFDO1FBUTVDLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILHFDQUFjLEdBQWQsVUFBZSxTQUFpQjtRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUMxQixZQUFZLEVBQUUsRUFBRTtnQkFDaEIsV0FBVyxFQUFFLEVBQUU7Z0JBQ2YsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDbkIsZ0JBQWdCLEVBQUUsQ0FBQzthQUN0QixDQUFDO1NBQ0w7UUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILHFDQUFjLEdBQWQsVUFBZSxVQUFlLEVBQUUsU0FBaUI7UUFDN0MsSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQztRQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BCLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDMUI7UUFFRCxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILGlDQUFVLEdBQVYsVUFBVyxTQUFrQixFQUFFLFNBQWtCO1FBQzdDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFFOUIsSUFBSSxTQUFTLEVBQUU7WUFDWCxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUV4QyxJQUFJLFNBQVMsRUFBRTtnQkFDWCxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDbkQ7U0FDSjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCwwQkFBRyxHQUFILFVBQUksR0FBVyxFQUFFLEtBQVUsRUFBRSxTQUFrQixFQUFFLFNBQWtCO1FBQy9ELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNILDBCQUFHLEdBQUgsVUFBSSxHQUFXLEVBQUUsU0FBa0IsRUFBRSxTQUFrQjtRQUNuRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUNuRCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBQ0wsbUJBQUM7QUFBRCxDQTVIQSxBQTRIQyxJQUFBO0FBNUhZLG9DQUFZO0FBOEh6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSDtJQXNFSTs7O09BR0c7SUFDSCxvQkFBWSxNQUFXO1FBeEV2Qjs7O1dBR0c7UUFDSCxPQUFFLEdBQVcsSUFBSSxDQUFDO1FBRWxCOzs7O1dBSUc7UUFDSCxTQUFJLEdBQVcsSUFBSSxDQUFDO1FBRXBCOzs7OztXQUtHO1FBQ0gsYUFBUSxHQUFXLElBQUksQ0FBQztRQUV4Qjs7OztXQUlHO1FBQ0gsVUFBSyxHQUFXLElBQUksQ0FBQztRQUVyQjs7OztXQUlHO1FBQ0gsZ0JBQVcsR0FBVyxJQUFJLENBQUM7UUFFM0I7Ozs7Ozs7Ozs7O1dBV0c7UUFDSCxlQUFVLEdBQVEsSUFBSSxDQUFDO1FBRXZCOzs7Ozs7V0FNRztRQUNILGVBQVUsR0FBd0IsSUFBSSxDQUFDO1FBaUJuQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCw2QkFBUSxHQUFSLFVBQVMsSUFBWTtRQUNqQixTQUFTO1FBQ1QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVsQixRQUFRO1FBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNwQjtRQUVELFFBQVE7UUFDUixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTlCLFNBQVM7UUFDVCxJQUFJLE1BQU0sS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckI7UUFFRCxRQUFRO1FBQ1IsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVqQixPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQkFBTSxHQUFOLFVBQU8sSUFBWTtRQUNmLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwwQkFBSyxHQUFMLFVBQU0sSUFBWTtRQUNkLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsMEJBQUssR0FBTCxVQUFNLElBQVk7UUFDZCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQkFBTSxHQUFOLFVBQU8sSUFBWTtRQUNmLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwwQkFBSyxHQUFMLFVBQU0sSUFBWTtRQUNkLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDBCQUFLLEdBQUwsVUFBTSxJQUFZLElBQVUsQ0FBQztJQUU3Qjs7Ozs7Ozs7O09BU0c7SUFDSCx5QkFBSSxHQUFKLFVBQUssSUFBWSxJQUFVLENBQUM7SUFFNUI7Ozs7Ozs7O09BUUc7SUFDSCx5QkFBSSxHQUFKLFVBQUssSUFBWSxJQUFhLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFFbEQ7Ozs7Ozs7O09BUUc7SUFDSCwwQkFBSyxHQUFMLFVBQU0sSUFBWSxJQUFVLENBQUM7SUFFN0I7Ozs7Ozs7T0FPRztJQUNILHlCQUFJLEdBQUosVUFBSyxJQUFZLElBQVUsQ0FBQztJQUNoQyxpQkFBQztBQUFELENBcE9BLEFBb09DLElBQUE7QUFwT1ksZ0NBQVU7QUFzT3ZCOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0g7SUFBOEIsNEJBQVU7SUFRcEM7OztPQUdHO0lBQ0gsa0JBQVksTUFBVztRQUF2QixZQUNJLGtCQUFNLE1BQU0sQ0FBQyxTQUNoQjtRQVpEOzs7V0FHRztRQUNILGNBQVEsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDOztJQVFyQixDQUFDO0lBQ0wsZUFBQztBQUFELENBZkEsQUFlQyxDQWY2QixVQUFVLEdBZXZDO0FBZlksNEJBQVE7QUFpQnJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQ0c7QUFDSDtJQUFpQywrQkFBVTtJQVF2Qzs7O09BR0c7SUFDSCxxQkFBWSxNQUFXO1FBQXZCLFlBQ0ksa0JBQU0sTUFBTSxDQUFDLFNBRWhCO1FBYkQ7OztXQUdHO1FBQ0gsY0FBUSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUM7UUFRcEIsS0FBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUNyRCxDQUFDO0lBQ0wsa0JBQUM7QUFBRCxDQWhCQSxBQWdCQyxDQWhCZ0MsVUFBVSxHQWdCMUM7QUFoQlksa0NBQVc7QUFrQnhCOzs7Ozs7R0FNRztBQUNIO0lBQWlDLCtCQUFVO0lBUXZDOzs7T0FHRztJQUNILHFCQUFZLE1BQVc7UUFBdkIsWUFDSSxrQkFBTSxNQUFNLENBQUMsU0FDaEI7UUFaRDs7O1dBR0c7UUFDSCxjQUFRLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQzs7SUFReEIsQ0FBQztJQUVMLGtCQUFDO0FBQUQsQ0FoQkEsQUFnQkMsQ0FoQmdDLFVBQVUsR0FnQjFDO0FBaEJZLGtDQUFXO0FBa0J4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQ0c7QUFDSDtJQUFpQywrQkFBVTtJQVF2Qzs7O09BR0c7SUFDSCxxQkFBWSxNQUFXO1FBQXZCLFlBQ0ksa0JBQU0sTUFBTSxDQUFDLFNBRWhCO1FBYkQ7OztXQUdHO1FBQ0gsY0FBUSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUM7UUFRcEIsS0FBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQzs7SUFDdEMsQ0FBQztJQUNMLGtCQUFDO0FBQUQsQ0FoQkEsQUFnQkMsQ0FoQmdDLFVBQVUsR0FnQjFDO0FBaEJZLGtDQUFXO0FBa0J4Qjs7Ozs7Ozs7O0dBU0c7QUFDSDtJQUFtQyxpQ0FBVztJQUE5QztRQUFBLHFFQXVDQztRQXJDRzs7O1dBR0c7UUFDSCxVQUFJLEdBQUcsYUFBYSxDQUFDOztJQWlDekIsQ0FBQztJQS9CRzs7OztPQUlHO0lBQ0gsNEJBQUksR0FBSixVQUFLLElBQVk7UUFDYixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw0QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkUsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9DLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTdDLElBQUksTUFBTSxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUU7Z0JBQ3ZCLElBQUksTUFBTSxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUU7b0JBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2lCQUNqRTtnQkFFRCxPQUFPLE1BQU0sQ0FBQzthQUNqQjtTQUNKO1FBRUQsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFDTCxvQkFBQztBQUFELENBdkNBLEFBdUNDLENBdkNrQyxXQUFXLEdBdUM3QztBQXZDWSxzQ0FBYTtBQXlDMUI7Ozs7Ozs7OztHQVNHO0FBQ0g7SUFBbUMsaUNBQVc7SUFBOUM7UUFBQSxxRUFzQ0M7UUFwQ0c7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLGFBQWEsQ0FBQzs7SUFnQ3pCLENBQUM7SUE5Qkc7Ozs7T0FJRztJQUNILDRCQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsNEJBQUksR0FBSixVQUFLLElBQVk7UUFDYixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZFLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUU3QyxJQUFJLE1BQU0sS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFO2dCQUN2QixJQUFJLE1BQU0sS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFO29CQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztpQkFDakU7Z0JBQ0QsT0FBTyxNQUFNLENBQUM7YUFDakI7U0FDSjtRQUVELE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBQ0wsb0JBQUM7QUFBRCxDQXRDQSxBQXNDQyxDQXRDa0MsV0FBVyxHQXNDN0M7QUF0Q1ksc0NBQWE7QUF3QzFCOzs7Ozs7OztHQVFHO0FBQ0g7SUFBZ0MsOEJBQVc7SUFBM0M7UUFBQSxxRUF5QkM7UUF2Qkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLFVBQVUsQ0FBQzs7SUFtQnRCLENBQUM7SUFqQkc7Ozs7O09BS0c7SUFDSCx5QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMzQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUU3QyxJQUFJLE1BQU0sS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFO2dCQUN2QixPQUFPLE1BQU0sQ0FBQzthQUNqQjtTQUNKO1FBRUQsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFDTCxpQkFBQztBQUFELENBekJBLEFBeUJDLENBekIrQixXQUFXLEdBeUIxQztBQXpCWSxnQ0FBVTtBQTJCdkI7Ozs7Ozs7O0dBUUc7QUFDSDtJQUFnQyw4QkFBVztJQUEzQztRQUFBLHFFQXlCQztRQXZCRzs7O1dBR0c7UUFDSCxVQUFJLEdBQUcsVUFBVSxDQUFDOztJQW1CdEIsQ0FBQztJQWpCRzs7Ozs7T0FLRztJQUNILHlCQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTdDLElBQUksTUFBTSxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUU7Z0JBQ3ZCLE9BQU8sTUFBTSxDQUFDO2FBQ2pCO1NBQ0o7UUFFRCxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGlCQUFDO0FBQUQsQ0F6QkEsQUF5QkMsQ0F6QitCLFdBQVcsR0F5QjFDO0FBekJZLGdDQUFVO0FBMkJ2Qjs7Ozs7OztHQU9HO0FBQ0g7SUFBZ0MsOEJBQVc7SUFBM0M7UUFBQSxxRUE2QkM7UUEzQkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLFVBQVUsQ0FBQzs7SUF1QnRCLENBQUM7SUFyQkc7Ozs7O09BS0c7SUFDSCx5QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkMsSUFBSSxNQUFNLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtZQUN0QixNQUFNLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQztTQUN2QjthQUFNLElBQUksTUFBTSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUU7WUFDN0IsTUFBTSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUM7U0FDdkI7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBQ0wsaUJBQUM7QUFBRCxDQTdCQSxBQTZCQyxDQTdCK0IsV0FBVyxHQTZCMUM7QUE3QlksZ0NBQVU7QUErQnZCOzs7Ozs7OztHQVFHO0FBQ0g7SUFBK0IsNkJBQVc7SUFzQnRDOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsbUJBQVksTUFBVztRQUF2QixZQUNJLGtCQUFNLE1BQU0sQ0FBQyxTQVFoQjtRQXpDRDs7O1dBR0c7UUFDSCxVQUFJLEdBQUcsU0FBUyxDQUFDO1FBRWpCOzs7V0FHRztRQUNILFdBQUssR0FBRyw2QkFBNkIsQ0FBQztRQUV0Qzs7O1dBR0c7UUFDSCxnQkFBVSxHQUFHLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBbUIxQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRTtZQUNqQixNQUFNLDBEQUEwRDtnQkFDaEUsV0FBVyxDQUFDO1NBQ2Y7UUFFRCxLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7O0lBQ2xDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsd0JBQUksR0FBSixVQUFLLElBQVk7UUFDYixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCx3QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV4RCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2xCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXZDLElBQUksTUFBTSxJQUFJLEVBQUUsQ0FBQyxPQUFPLElBQUksTUFBTSxJQUFJLEVBQUUsQ0FBQyxPQUFPO2dCQUM1QyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFM0QsT0FBTyxNQUFNLENBQUM7U0FDakI7UUFFRCxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGdCQUFDO0FBQUQsQ0E5RUEsQUE4RUMsQ0E5RThCLFdBQVcsR0E4RXpDO0FBOUVZLDhCQUFTO0FBZ0Z0Qjs7Ozs7Ozs7O0dBU0c7QUFDSDtJQUErQiw2QkFBVztJQXNCdEM7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxtQkFBWSxNQUFXO1FBQXZCLFlBQ0ksa0JBQU0sTUFBTSxDQUFDLFNBUWhCO1FBekNEOzs7V0FHRztRQUNILFVBQUksR0FBRyxTQUFTLENBQUM7UUFFakI7OztXQUdHO1FBQ0gsV0FBSyxHQUFHLGlCQUFpQixDQUFDO1FBRTFCOzs7V0FHRztRQUNILGdCQUFVLEdBQUcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFtQjFCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2pCLE1BQU0sMERBQTBEO2dCQUNoRSxXQUFXLENBQUM7U0FDZjtRQUVELEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7SUFDbEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx3QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHdCQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDYixPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUM7U0FDbkI7UUFFRCxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhFLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLElBQUksUUFBUSxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3JDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQztTQUNyQjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFDTCxnQkFBQztBQUFELENBNUVBLEFBNEVDLENBNUU4QixXQUFXLEdBNEV6QztBQTVFWSw4QkFBUztBQThFdEI7Ozs7Ozs7O0dBUUc7QUFDSDtJQUEwQyx3Q0FBVztJQXNCakQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsOEJBQVksTUFBVztRQUF2QixZQUNJLGtCQUFNLE1BQU0sQ0FBQyxTQUVoQjtRQXBDRDs7O1dBR0c7UUFDSCxVQUFJLEdBQUcsb0JBQW9CLENBQUM7UUFFNUI7OztXQUdHO1FBQ0gsV0FBSyxHQUFHLHNCQUFzQixDQUFDO1FBRS9COzs7V0FHRztRQUNILGdCQUFVLEdBQUcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQW1CM0IsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDOztJQUN4QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILG1DQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsbUNBQUksR0FBSixVQUFLLElBQVk7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNiLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQztTQUNuQjtRQUVELElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEQsSUFBSSxNQUFNLEdBQVksRUFBRSxDQUFDLEtBQUssQ0FBQztRQUUvQixPQUFPLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3pDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVuQyxJQUFJLE1BQU0sSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFO2dCQUN0QixDQUFDLEVBQUUsQ0FBQzthQUNQO2lCQUFNO2dCQUNILE1BQU07YUFDVDtTQUNKO1FBRUQsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFDTCwyQkFBQztBQUFELENBNUVBLEFBNEVDLENBNUV5QyxXQUFXLEdBNEVwRDtBQTVFWSxvREFBb0I7QUE4RWpDOzs7Ozs7OztHQVFHO0FBQ0g7SUFBMEMsd0NBQVc7SUFzQmpEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILDhCQUFZLE1BQVc7UUFBdkIsWUFDSSxrQkFBTSxNQUFNLENBQUMsU0FFaEI7UUFwQ0Q7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLG9CQUFvQixDQUFDO1FBRTVCOzs7V0FHRztRQUNILFdBQUssR0FBRyxzQkFBc0IsQ0FBQztRQUUvQjs7O1dBR0c7UUFDSCxnQkFBVSxHQUFHLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFtQjNCLEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQzs7SUFDeEMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxtQ0FBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILG1DQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDYixPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUM7U0FDbkI7UUFFRCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELElBQUksTUFBTSxHQUFZLEVBQUUsQ0FBQyxLQUFLLENBQUM7UUFFL0IsT0FBTyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUN6QyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFbkMsSUFBSSxNQUFNLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtnQkFDdEIsQ0FBQyxFQUFFLENBQUM7YUFDUDtpQkFBTTtnQkFDSCxNQUFNO2FBQ1Q7U0FDSjtRQUVELENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN2RCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBQ0wsMkJBQUM7QUFBRCxDQTVFQSxBQTRFQyxDQTVFeUMsV0FBVyxHQTRFcEQ7QUE1RVksb0RBQW9CO0FBOEVqQzs7Ozs7Ozs7R0FRRztBQUNIO0lBQWdDLDhCQUFXO0lBc0J2Qzs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxvQkFBWSxNQUFXO1FBQXZCLFlBQ0ksa0JBQU0sTUFBTSxDQUFDLFNBRWhCO1FBcENEOzs7V0FHRztRQUNILFVBQUksR0FBRyxVQUFVLENBQUM7UUFFbEI7OztXQUdHO1FBQ0gsV0FBSyxHQUFHLG1CQUFtQixDQUFDO1FBRTVCOzs7V0FHRztRQUNILGdCQUFVLEdBQUcsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQW1CM0IsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDOztJQUN4QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHlCQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx5QkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDO1NBQ25CO1FBRUQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN4RCxJQUFJLE1BQU0sR0FBWSxFQUFFLENBQUMsT0FBTyxDQUFDO1FBRWpDLE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDekMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRW5DLElBQUksTUFBTSxJQUFJLEVBQUUsQ0FBQyxPQUFPLElBQUksTUFBTSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUU7Z0JBQzlDLENBQUMsRUFBRSxDQUFDO2FBQ1A7aUJBQU07Z0JBQ0gsTUFBTTthQUNUO1NBQ0o7UUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNuRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBQ0wsaUJBQUM7QUFBRCxDQTNFQSxBQTJFQyxDQTNFK0IsV0FBVyxHQTJFMUM7QUEzRVksZ0NBQVU7QUE2RXZCOzs7Ozs7R0FNRztBQUNIO0lBQTZCLDJCQUFRO0lBQXJDO1FBQUEscUVBaUJDO1FBZkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLE9BQU8sQ0FBQzs7SUFXbkIsQ0FBQztJQVRHOzs7OztPQUtHO0lBQ0gsc0JBQUksR0FBSixVQUFLLElBQVk7UUFDYixPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUNMLGNBQUM7QUFBRCxDQWpCQSxBQWlCQyxDQWpCNEIsUUFBUSxHQWlCcEM7QUFqQlksMEJBQU87QUFtQnBCOzs7Ozs7R0FNRztBQUNIO0lBQThCLDRCQUFRO0lBQXRDO1FBQUEscUVBaUJDO1FBZkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLFFBQVEsQ0FBQzs7SUFXcEIsQ0FBQztJQVRHOzs7OztPQUtHO0lBQ0gsdUJBQUksR0FBSixVQUFLLElBQVk7UUFDYixPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGVBQUM7QUFBRCxDQWpCQSxBQWlCQyxDQWpCNkIsUUFBUSxHQWlCckM7QUFqQlksNEJBQVE7QUFtQnJCOzs7Ozs7R0FNRztBQUNIO0lBQThCLDRCQUFRO0lBQXRDO1FBQUEscUVBaUJDO1FBZkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLFFBQVEsQ0FBQzs7SUFXcEIsQ0FBQztJQVRHOzs7OztPQUtHO0lBQ0gsdUJBQUksR0FBSixVQUFLLElBQVk7UUFDYixPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGVBQUM7QUFBRCxDQWpCQSxBQWlCQyxDQWpCNkIsUUFBUSxHQWlCckM7QUFqQlksNEJBQVE7QUFtQnJCOzs7Ozs7R0FNRztBQUNIO0lBQWlDLCtCQUFRO0lBQXpDO1FBQUEscUVBaUJDO1FBZkc7OztXQUdHO1FBQ0gsVUFBSSxHQUFHLFdBQVcsQ0FBQzs7SUFXdkIsQ0FBQztJQVRHOzs7OztPQUtHO0lBQ0gsMEJBQUksR0FBSixVQUFLLElBQVk7UUFDYixPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGtCQUFDO0FBQUQsQ0FqQkEsQUFpQkMsQ0FqQmdDLFFBQVEsR0FpQnhDO0FBakJZLGtDQUFXO0FBbUJ4Qjs7Ozs7O0dBTUc7QUFDSDtJQUE0QiwwQkFBUTtJQXNCaEM7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxnQkFBWSxRQUFxQztRQUFqRCxpQkFLQztRQUpHLFFBQVEsR0FBRyxRQUFRLElBQUksRUFBRSxDQUFDO1FBRTFCLFFBQUEsa0JBQU0sUUFBUSxDQUFDLFNBQUM7UUFuQ3BCOzs7V0FHRztRQUNILFVBQUksR0FBRyxNQUFNLENBQUM7UUFFZDs7O1dBR0c7UUFDSCxXQUFLLEdBQUcsdUJBQXVCLENBQUM7UUFFaEM7OztXQUdHO1FBQ0gsZ0JBQVUsR0FBRyxFQUFFLGNBQWMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQW9CL0IsS0FBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQzs7SUFDOUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxxQkFBSSxHQUFKLFVBQUssSUFBWTtRQUNiLElBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHFCQUFJLEdBQUosVUFBSyxJQUFZO1FBQ2IsSUFBSSxRQUFRLEdBQUcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV4RSxJQUFJLFFBQVEsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNyQyxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7U0FDckI7UUFFRCxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUNMLGFBQUM7QUFBRCxDQW5FQSxBQW1FQyxDQW5FMkIsUUFBUSxHQW1FbkM7QUFuRVksd0JBQU07QUFxRW5COzs7R0FHRztBQUNIO0lBQUE7SUE2SEEsQ0FBQztJQXRGRzs7Ozs7OztPQU9HO0lBQ1csYUFBVSxHQUF4QjtRQUNJLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLElBQUksU0FBUyxHQUFHLGtCQUFrQixDQUFDO1FBQ25DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDaEU7UUFDRCxzREFBc0Q7UUFDdEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUVaLGtEQUFrRDtRQUNsRCxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFakQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztRQUVuQyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUNHO0lBQ1csUUFBSyxHQUFuQixVQUFvQixTQUFTLEVBQUUsVUFBVztRQUN0QyxxQkFBcUI7UUFDckIsSUFBSSxHQUFHLEdBQUcsVUFBVSxNQUFNO1lBQ3RCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQztRQUVGLHFDQUFxQztRQUNyQyxJQUFJLFNBQVMsRUFBRTtZQUNYLEdBQUcsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbkQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFDO1NBQ25DO1FBRUQsbURBQW1EO1FBQ25ELElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtZQUMzQixHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxjQUFjLENBQUMsQ0FBQztTQUM5QztRQUVELGtCQUFrQjtRQUNsQixJQUFJLFVBQVUsRUFBRTtZQUNaLEtBQUssSUFBSSxHQUFHLElBQUksVUFBVSxFQUFFO2dCQUN4QixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN4QztTQUNKO1FBRUQsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBM0hzQixVQUFPLEdBQUcsT0FBTyxDQUFDO0lBRXpDLG1CQUFtQjtJQUNJLFVBQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzFCLFVBQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzFCLFVBQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQzFCLFFBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBRTdDLGtCQUFrQjtJQUNLLFlBQVMsR0FBRyxXQUFXLENBQUM7SUFDeEIsWUFBUyxHQUFHLFdBQVcsQ0FBQztJQUN4QixTQUFNLEdBQUcsUUFBUSxDQUFDO0lBQ2xCLFlBQVMsR0FBRyxXQUFXLENBQUM7SUFFeEIsZUFBWSxHQUFHLGNBQWMsQ0FBQztJQUM5QixPQUFJLEdBQUcsTUFBTSxDQUFDO0lBQ2QsYUFBVSxHQUFHLFlBQVksQ0FBQztJQUMxQixXQUFRLEdBQUcsVUFBVSxDQUFDO0lBQ3RCLFNBQU0sR0FBRyxRQUFRLENBQUM7SUFDbEIsWUFBUyxHQUFHLFdBQVcsQ0FBQztJQUN4QixZQUFTLEdBQUcsV0FBVyxDQUFDO0lBQ3hCLFlBQVMsR0FBRyxXQUFXLENBQUM7SUFDeEIsY0FBVyxHQUFHLGFBQWEsQ0FBQztJQUM1QixjQUFXLEdBQUcsYUFBYSxDQUFDO0lBQzVCLFdBQVEsR0FBRyxVQUFVLENBQUM7SUFDdEIsV0FBUSxHQUFHLFVBQVUsQ0FBQztJQUN0QixXQUFRLEdBQUcsVUFBVSxDQUFDO0lBQ3RCLFVBQU8sR0FBRyxTQUFTLENBQUM7SUFDcEIsVUFBTyxHQUFHLFNBQVMsQ0FBQztJQUNwQixxQkFBa0IsR0FBRyxvQkFBb0IsQ0FBQztJQUMxQyxxQkFBa0IsR0FBRyxvQkFBb0IsQ0FBQztJQUMxQyxXQUFRLEdBQUcsVUFBVSxDQUFDO0lBQ3RCLFFBQUssR0FBRyxPQUFPLENBQUM7SUFDaEIsU0FBTSxHQUFHLFFBQVEsQ0FBQztJQUNsQixTQUFNLEdBQUcsUUFBUSxDQUFDO0lBQ2xCLFlBQVMsR0FBRyxXQUFXLENBQUM7SUFDeEIsT0FBSSxHQUFHLE1BQU0sQ0FBQztJQXdGekMsU0FBQztDQTdIRCxBQTZIQyxJQUFBO2tCQTdIb0IsRUFBRSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiDoioLngrnnirbmgIFcclxuICovXHJcbmV4cG9ydCBlbnVtIEIzU3RhdGUge1xyXG4gICAgU1VDQ0VTUyA9IDEsXHJcbiAgICBGQUlMVVJFID0gMixcclxuICAgIFJVTk5JTkcgPSAzLFxyXG4gICAgRVJST1IgPSA0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQmVoYXZpb3JUcmVlIGNsYXNzLCBhcyB0aGUgbmFtZSBpbXBsaWVzLCByZXByZXNlbnRzIHRoZSBCZWhhdmlvciBUcmVlIFxyXG4gKiBzdHJ1Y3R1cmUuXHJcbiAqIFxyXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gY29uc3RydWN0IGEgQmVoYXZpb3IgVHJlZTogYnkgbWFudWFsbHkgc2V0dGluZyB0aGUgXHJcbiAqIHJvb3Qgbm9kZSwgb3IgYnkgbG9hZGluZyBpdCBmcm9tIGEgZGF0YSBzdHJ1Y3R1cmUgKHdoaWNoIGNhbiBiZSBsb2FkZWQgXHJcbiAqIGZyb20gYSBKU09OKS4gQm90aCBtZXRob2RzIGFyZSBzaG93biBpbiB0aGUgZXhhbXBsZXMgYmVsb3cgYW5kIGJldHRlciBcclxuICogZXhwbGFpbmVkIGluIHRoZSB1c2VyIGd1aWRlLlxyXG4gKlxyXG4gKiBUaGUgdGljayBtZXRob2QgbXVzdCBiZSBjYWxsZWQgcGVyaW9kaWNhbGx5LCBpbiBvcmRlciB0byBzZW5kIHRoZSB0aWNrIFxyXG4gKiBzaWduYWwgdG8gYWxsIG5vZGVzIGluIHRoZSB0cmVlLCBzdGFydGluZyBmcm9tIHRoZSByb290LiBUaGUgbWV0aG9kIFxyXG4gKiBgQmVoYXZpb3JUcmVlLnRpY2tgIHJlY2VpdmVzIGEgdGFyZ2V0IG9iamVjdCBhbmQgYSBibGFja2JvYXJkIGFzIFxyXG4gKiBwYXJhbWV0ZXJzLiBUaGUgdGFyZ2V0IG9iamVjdCBjYW4gYmUgYW55dGhpbmc6IGEgZ2FtZSBhZ2VudCwgYSBzeXN0ZW0sIGEgXHJcbiAqIERPTSBvYmplY3QsIGV0Yy4gVGhpcyB0YXJnZXQgaXMgbm90IHVzZWQgYnkgYW55IHBpZWNlIG9mIEJlaGF2aW9yM0pTLCBcclxuICogaS5lLiwgdGhlIHRhcmdldCBvYmplY3Qgd2lsbCBvbmx5IGJlIHVzZWQgYnkgY3VzdG9tIG5vZGVzLlxyXG4gKiBcclxuICogVGhlIGJsYWNrYm9hcmQgaXMgb2JsaWdhdG9yeSBhbmQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgQmxhY2tib2FyZGAuIFRoaXNcclxuICogcmVxdWlyZW1lbnQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgZmFjdCB0aGF0IG5laXRoZXIgYEJlaGF2aW9yVHJlZWAgb3IgXHJcbiAqIGFueSBub2RlIHdpbGwgc3RvcmUgdGhlIGV4ZWN1dGlvbiB2YXJpYWJsZXMgaW4gaXRzIG93biBvYmplY3QgKGUuZy4sIHRoZSBcclxuICogQlQgZG9lcyBub3Qgc3RvcmUgdGhlIHRhcmdldCwgaW5mb3JtYXRpb24gYWJvdXQgb3BlbmVkIG5vZGVzIG9yIG51bWJlciBvZiBcclxuICogdGltZXMgdGhlIHRyZWUgd2FzIGNhbGxlZCkuIEJ1dCBiZWNhdXNlIG9mIHRoaXMsIHlvdSBvbmx5IG5lZWQgYSBzaW5nbGUgXHJcbiAqIHRyZWUgaW5zdGFuY2UgdG8gY29udHJvbCBtdWx0aXBsZSAobWF5YmUgaHVuZHJlZHMpIG9iamVjdHMuXHJcbiAqIFxyXG4gKiBNYW51YWwgY29uc3RydWN0aW9uIG9mIGEgQmVoYXZpb3IgVHJlZVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBcclxuICogICAgIHZhciB0cmVlID0gbmV3IGIzLkJlaGF2aW9yVHJlZSgpO1xyXG4gKiAgXHJcbiAqICAgICB0cmVlLnJvb3QgPSBuZXcgYjMuU2VxdWVuY2Uoe2NoaWxkcmVuOltcclxuICogICAgICAgbmV3IGIzLlByaW9yaXR5KHtjaGlsZHJlbjpbXHJcbiAqICAgICAgICAgbmV3IE15Q3VzdG9tTm9kZSgpLFxyXG4gKiAgICAgICAgIG5ldyBNeUN1c3RvbU5vZGUoKVxyXG4gKiAgICAgICBdfSksXHJcbiAqICAgICAgIC4uLlxyXG4gKiAgICAgXX0pO1xyXG4gKiAgICAgXHJcbiAqIFxyXG4gKiBMb2FkaW5nIGEgQmVoYXZpb3IgVHJlZSBmcm9tIGRhdGEgc3RydWN0dXJlXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogXHJcbiAqICAgICB2YXIgdHJlZSA9IG5ldyBiMy5CZWhhdmlvclRyZWUoKTtcclxuICpcclxuICogICAgIHRyZWUubG9hZCh7XHJcbiAqICAgICAgIFwidGl0bGVcIiAgICAgICA6IFwiQmVoYXZpb3IgVHJlZSB0aXRsZVwiXHJcbiAqICAgICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiTXkgZGVzY3JpcHRpb25cIlxyXG4gKiAgICAgICBcInJvb3RcIiAgICAgICAgOiBcIm5vZGUtaWQtMVwiXHJcbiAqICAgICAgIFwibm9kZXNcIiAgICAgICA6IHtcclxuICogICAgICAgICBcIm5vZGUtaWQtMVwiIDoge1xyXG4gKiAgICAgICAgICAgXCJuYW1lXCIgICAgICAgIDogXCJQcmlvcml0eVwiLCAvLyB0aGlzIGlzIHRoZSBub2RlIHR5cGVcclxuICogICAgICAgICAgIFwidGl0bGVcIiAgICAgICA6IFwiUm9vdCBOb2RlXCIsIFxyXG4gKiAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiIDogXCJEZXNjcmlwdGlvblwiLCBcclxuICogICAgICAgICAgIFwiY2hpbGRyZW5cIiAgICA6IFtcIm5vZGUtaWQtMlwiLCBcIm5vZGUtaWQtM1wiXSwgXHJcbiAqICAgICAgICAgfSxcclxuICogICAgICAgICAuLi5cclxuICogICAgICAgfVxyXG4gKiAgICAgfSlcclxuICogICAgIFxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBCZWhhdmlvclRyZWVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM0JlaGF2aW9yVHJlZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHJlZSBpZCwgbXVzdCBiZSB1bmlxdWUuIEJ5IGRlZmF1bHQsIGNyZWF0ZWQgd2l0aCBgYjMuY3JlYXRlVVVJRGAuXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgaWQ6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHJlZSB0aXRsZS5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aXRsZTogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc2NyaXB0aW9uIG9mIHRoZSB0cmVlLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBkaWN0aW9uYXJ5IHdpdGggKGtleS12YWx1ZSkgcHJvcGVydGllcy4gVXNlZnVsIHRvIGRlZmluZSBjdXN0b20gXHJcbiAgICAgKiB2YXJpYWJsZXMgaW4gdGhlIHZpc3VhbCBlZGl0b3IuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSByb290IG5vZGUuIE11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYGIzLkJhc2VOb2RlYC5cclxuICAgICAqL1xyXG4gICAgcm9vdDogQjNCYXNlTm9kZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBkZWJ1ZyBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZGVidWc6IGFueSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbiBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBiMy5jcmVhdGVVVUlEKCk7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IFwiVGhlIGJlaGF2aW9yIHRyZWVcIjtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJEZWZhdWx0IGRlc2NyaXB0aW9uXCI7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGxvYWRzIGEgQmVoYXZpb3IgVHJlZSBmcm9tIGEgZGF0YSBzdHJ1Y3R1cmUsIHBvcHVsYXRpbmcgdGhpc1xyXG4gICAgICogb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuIE5vdGljZSB0aGF0LCB0aGUgZGF0YSBzdHJ1Y3R1cmUgbXVzdCBcclxuICAgICAqIGZvbGxvdyB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBCZWhhdmlvcjNKUy4gQ29uc3VsdCB0aGUgZ3VpZGUgdG8ga25vdyBcclxuICAgICAqIG1vcmUgYWJvdXQgdGhpcyBmb3JtYXQuXHJcbiAgICAgKlxyXG4gICAgICogWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIGN1c3RvbSBub2RlcyBpbiB5b3VyIEJUcywgdGh1cywgeW91IG5lZWQgdG8gXHJcbiAgICAgKiBwcm92aWRlIHRoZSBgbmFtZXNgIG9iamVjdCwgaW4gd2hpY2ggdGhpcyBtZXRob2QgY2FuIGZpbmQgdGhlIG5vZGVzIGJ5IFxyXG4gICAgICogYG5hbWVzW05PREVfTkFNRV1gLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBhIG5hbWVzcGFjZSBvciBhIGRpY3Rpb25hcnksIFxyXG4gICAgICogYXMgbG9uZyBhcyB0aGlzIG1ldGhvZCBjYW4gZmluZCB0aGUgbm9kZSBieSBpdHMgbmFtZSwgZm9yIGV4YW1wbGU6XHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vanNvblxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogICAgIFwibm9kZTFcIjoge1xyXG4gICAgICogICAgICAgXCJuYW1lXCI6IE15Q3VzdG9tTm9kZSxcclxuICAgICAqICAgICAgIFwidGl0bGVcIjogLi4uXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogICAgIFxyXG4gICAgICogICAgIC8vY29kZVxyXG4gICAgICogICAgIHZhciBidCA9IG5ldyBiMy5CZWhhdmlvclRyZWUoKTtcclxuICAgICAqICAgICBidC5sb2FkKGRhdGEsIHtcIk15Q3VzdG9tTm9kZVwiOk15Q3VzdG9tTm9kZX0pXHJcbiAgICAgKiAgICAgXHJcbiAgICAgKiBcclxuICAgICAqIEBtZXRob2QgbG9hZFxyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIEJlaGF2aW9yIFRyZWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZXMgQSBuYW1lc3BhY2Ugb3IgZGljdCBjb250YWluaW5nIGN1c3RvbSBub2Rlcy5cclxuICAgICAqL1xyXG4gICAgbG9hZChkYXRhOiBhbnksIG5hbWVzPzogUmVjb3JkPHN0cmluZywgdHlwZW9mIEIzQmFzZU5vZGU+KSB7XHJcbiAgICAgICAgbmFtZXMgPSBuYW1lcyB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IGRhdGEudGl0bGUgfHwgdGhpcy50aXRsZTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvbiB8fCB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IGRhdGEucHJvcGVydGllcyB8fCB0aGlzLnByb3BlcnRpZXM7XHJcblxyXG4gICAgICAgIHZhciBub2RlcyA9IHt9O1xyXG4gICAgICAgIHZhciBpZCwgc3BlYywgbm9kZTtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIG5vZGUgbGlzdCAod2l0aG91dCBjb25uZWN0aW9uIGJldHdlZW4gdGhlbSlcclxuICAgICAgICBmb3IgKGlkIGluIGRhdGEubm9kZXMpIHtcclxuICAgICAgICAgICAgc3BlYyA9IGRhdGEubm9kZXNbaWRdO1xyXG4gICAgICAgICAgICB2YXIgQ2xzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNwZWMubmFtZSBpbiBuYW1lcykge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhlIG5hbWUgaW4gY3VzdG9tIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBDbHMgPSBuYW1lc1tzcGVjLm5hbWVdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWMubmFtZSBpbiBiMykge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgdGhlIG5hbWUgaW4gZGVmYXVsdCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgQ2xzID0gYjNbc3BlYy5uYW1lXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEludmFsaWQgbm9kZSBuYW1lXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZhbEVycm9yKCdCZWhhdmlvclRyZWUubG9hZDogSW52YWxpZCBub2RlIG5hbWUgKyBcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWMubmFtZSArICdcIi4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm9kZSA9IG5ldyBDbHMoc3BlYy5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgbm9kZS5pZCA9IHNwZWMuaWQgfHwgbm9kZS5pZDtcclxuICAgICAgICAgICAgbm9kZS50aXRsZSA9IHNwZWMudGl0bGUgfHwgbm9kZS50aXRsZTtcclxuICAgICAgICAgICAgbm9kZS5kZXNjcmlwdGlvbiA9IHNwZWMuZGVzY3JpcHRpb24gfHwgbm9kZS5kZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0gc3BlYy5wcm9wZXJ0aWVzIHx8IG5vZGUucHJvcGVydGllcztcclxuXHJcbiAgICAgICAgICAgIG5vZGVzW2lkXSA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25uZWN0IHRoZSBub2Rlc1xyXG4gICAgICAgIGZvciAoaWQgaW4gZGF0YS5ub2Rlcykge1xyXG4gICAgICAgICAgICBzcGVjID0gZGF0YS5ub2Rlc1tpZF07XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpZF07XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5jYXRlZ29yeSA9PT0gYjMuQ09NUE9TSVRFICYmIHNwZWMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlYy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaWQgPSBzcGVjLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChub2Rlc1tjaWRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNhdGVnb3J5ID09PSBiMy5ERUNPUkFUT1IgJiYgc3BlYy5jaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZCA9IG5vZGVzW3NwZWMuY2hpbGRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJvb3QgPSBub2Rlc1tkYXRhLnJvb3RdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZHVtcCB0aGUgY3VycmVudCBCVCBpbnRvIGEgZGF0YSBzdHJ1Y3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3QgcmVjb3JkIHRoZSBjdXJyZW50IG5vZGUgcGFyYW1ldGVycy4gVGh1cywgXHJcbiAgICAgKiBpdCBtYXkgbm90IGJlIGNvbXBhdGlibGUgd2l0aCBsb2FkIGZvciBub3cuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZXRob2QgZHVtcFxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIGRhdGEgb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGR1bXAoKTogYW55IHtcclxuICAgICAgICB2YXIgZGF0YTogYW55ID0ge307XHJcbiAgICAgICAgdmFyIGN1c3RvbU5hbWVzID0gW107XHJcblxyXG4gICAgICAgIGRhdGEudGl0bGUgPSB0aGlzLnRpdGxlO1xyXG4gICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPSB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIGRhdGEucm9vdCA9ICh0aGlzLnJvb3QpID8gdGhpcy5yb290LmlkIDogbnVsbDtcclxuICAgICAgICBkYXRhLnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XHJcbiAgICAgICAgZGF0YS5ub2RlcyA9IHt9O1xyXG4gICAgICAgIGRhdGEuY3VzdG9tX25vZGVzID0gW107XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5yb290KSByZXR1cm4gZGF0YTtcclxuXHJcbiAgICAgICAgdmFyIHN0YWNrID0gW3RoaXMucm9vdF07XHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzcGVjOiBhbnkgPSB7fTtcclxuICAgICAgICAgICAgc3BlYy5pZCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgICAgIHNwZWMubmFtZSA9IG5vZGUubmFtZTtcclxuICAgICAgICAgICAgc3BlYy50aXRsZSA9IG5vZGUudGl0bGU7XHJcbiAgICAgICAgICAgIHNwZWMuZGVzY3JpcHRpb24gPSBub2RlLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBzcGVjLnByb3BlcnRpZXMgPSBub2RlLnByb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIHNwZWMucGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgICAgIC8vIHZlcmlmeSBjdXN0b20gbm9kZVxyXG4gICAgICAgICAgICB2YXIgcHJvdG8gPSAobm9kZS5jb25zdHJ1Y3RvciAmJiBub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IChwcm90byAmJiBwcm90by5uYW1lKSB8fCBub2RlLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICghYjNbbm9kZU5hbWVdICYmIGN1c3RvbU5hbWVzLmluZGV4T2Yobm9kZU5hbWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YmRhdGE6IGFueSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc3ViZGF0YS5uYW1lID0gbm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBzdWJkYXRhLnRpdGxlID0gKHByb3RvICYmIHByb3RvLnRpdGxlKSB8fCBub2RlLnRpdGxlO1xyXG4gICAgICAgICAgICAgICAgc3ViZGF0YS5jYXRlZ29yeSA9IG5vZGUuY2F0ZWdvcnk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VzdG9tTmFtZXMucHVzaChub2RlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmN1c3RvbV9ub2Rlcy5wdXNoKHN1YmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzdG9yZSBjaGlsZHJlbi9jaGlsZFxyXG4gICAgICAgICAgICBpZiAobm9kZS5jYXRlZ29yeSA9PT0gYjMuQ09NUE9TSVRFICYmIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUuY2hpbGRyZW5baV0uaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZHJlbltpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcGVjLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5jYXRlZ29yeSA9PT0gYjMuREVDT1JBVE9SICYmIG5vZGUuY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZS5jaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBzcGVjLmNoaWxkID0gbm9kZS5jaGlsZC5pZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGF0YS5ub2Rlc1tub2RlLmlkXSA9IHNwZWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BhZ2F0ZXMgdGhlIHRpY2sgc2lnbmFsIHRocm91Z2ggdGhlIHRyZWUsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgbWV0aG9kIHJlY2VpdmVzIGEgdGFyZ2V0IG9iamVjdCBvZiBhbnkgdHlwZSAoT2JqZWN0LCBBcnJheSwgXHJcbiAgICAgKiBET01FbGVtZW50LCB3aGF0ZXZlcikgYW5kIGEgYEJsYWNrYm9hcmRgIGluc3RhbmNlLiBUaGUgdGFyZ2V0IG9iamVjdCBoYXNcclxuICAgICAqIG5vIHVzZSBhdCBhbGwgZm9yIGFsbCBCZWhhdmlvcjNKUyBjb21wb25lbnRzLCBidXQgc3VyZWx5IGlzIGltcG9ydGFudCBcclxuICAgICAqIGZvciBjdXN0b20gbm9kZXMuIFRoZSBibGFja2JvYXJkIGluc3RhbmNlIGlzIHVzZWQgYnkgdGhlIHRyZWUgYW5kIG5vZGVzIFxyXG4gICAgICogdG8gc3RvcmUgZXhlY3V0aW9uIHZhcmlhYmxlcyAoZS5nLiwgbGFzdCBub2RlIHJ1bm5pbmcpIGFuZCBpcyBvYmxpZ2F0b3J5XHJcbiAgICAgKiB0byBiZSBhIGBCbGFja2JvYXJkYCBpbnN0YW5jZSAob3IgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgaW50ZXJmYWNlKS5cclxuICAgICAqIFxyXG4gICAgICogSW50ZXJuYWxseSwgdGhpcyBtZXRob2QgY3JlYXRlcyBhIFRpY2sgb2JqZWN0LCB3aGljaCB3aWxsIHN0b3JlIHRoZSBcclxuICAgICAqIHRhcmdldCBhbmQgdGhlIGJsYWNrYm9hcmQgb2JqZWN0cy5cclxuICAgICAqIFxyXG4gICAgICogTm90ZTogQmVoYXZpb3JUcmVlIHN0b3JlcyBhIGxpc3Qgb2Ygb3BlbiBub2RlcyBmcm9tIGxhc3QgdGljaywgaWYgdGhlc2UgXHJcbiAgICAgKiBub2RlcyB3ZXJlblwidCBjYWxsZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgdGljaywgdGhpcyBtZXRob2Qgd2lsbCBjbG9zZSB0aGVtXHJcbiAgICAgKiBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICogXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgQSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGJsYWNrYm9hcmQgQW4gaW5zdGFuY2Ugb2YgYmxhY2tib2FyZCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gVGhlIHRpY2sgc2lnbmFsIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICB0aWNrKHRhcmdldDogYW55LCBibGFja2JvYXJkOiBCM0JsYWNrYm9hcmQpOiBCM1N0YXRlIHtcclxuICAgICAgICBpZiAoIWJsYWNrYm9hcmQpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJUaGUgYmxhY2tib2FyZCBwYXJhbWV0ZXIgaXMgb2JsaWdhdG9yeSBhbmQgbXVzdCBiZSBhbiBcIiArXHJcbiAgICAgICAgICAgIFwiaW5zdGFuY2Ugb2YgYjMuQmxhY2tib2FyZFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogQ1JFQVRFIEEgVElDSyBPQkpFQ1QgKi9cclxuICAgICAgICB2YXIgdGljayA9IG5ldyBCM1RpY2soKTtcclxuICAgICAgICB0aWNrLmRlYnVnID0gdGhpcy5kZWJ1ZztcclxuICAgICAgICB0aWNrLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQgPSBibGFja2JvYXJkO1xyXG4gICAgICAgIHRpY2sudHJlZSA9IHRoaXM7XHJcblxyXG4gICAgICAgIC8qIFRJQ0sgTk9ERSAqL1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMucm9vdC5fZXhlY3V0ZSh0aWNrKTtcclxuXHJcbiAgICAgICAgLyogQ0xPU0UgTk9ERVMgRlJPTSBMQVNUIFRJQ0ssIElGIE5FRURFRCAqL1xyXG4gICAgICAgIHZhciBsYXN0T3Blbk5vZGVzID0gYmxhY2tib2FyZC5nZXQoXCJvcGVuTm9kZXNcIiwgdGhpcy5pZCk7XHJcbiAgICAgICAgdmFyIGN1cnJPcGVuTm9kZXMgPSB0aWNrLl9vcGVuTm9kZXMuc2xpY2UoMCk7XHJcblxyXG4gICAgICAgIC8vIGRvZXMgbm90IGNsb3NlIGlmIGl0IGlzIHN0aWxsIG9wZW4gaW4gdGhpcyB0aWNrXHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gMDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTWF0aC5taW4obGFzdE9wZW5Ob2Rlcy5sZW5ndGgsIGN1cnJPcGVuTm9kZXMubGVuZ3RoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0T3Blbk5vZGVzW2ldICE9PSBjdXJyT3Blbk5vZGVzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2xvc2UgdGhlIG5vZGVzXHJcbiAgICAgICAgZm9yIChpID0gbGFzdE9wZW5Ob2Rlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpLS0pIHtcclxuICAgICAgICAgICAgbGFzdE9wZW5Ob2Rlc1tpXS5fY2xvc2UodGljayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBQT1BVTEFURSBCTEFDS0JPQVJEICovXHJcbiAgICAgICAgYmxhY2tib2FyZC5zZXQoXCJvcGVuTm9kZXNcIiwgY3Vyck9wZW5Ob2RlcywgdGhpcy5pZCk7XHJcbiAgICAgICAgYmxhY2tib2FyZC5zZXQoXCJub2RlQ291bnRcIiwgdGljay5fbm9kZUNvdW50LCB0aGlzLmlkKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBuZXcgVGljayBvYmplY3QgaXMgaW5zdGFudGlhdGVkIGV2ZXJ5IHRpY2sgYnkgQmVoYXZpb3JUcmVlLiBJdCBpcyBwYXNzZWRcclxuICogYXMgcGFyYW1ldGVyIHRvIHRoZSBub2RlcyB0aHJvdWdoIHRoZSB0cmVlIGR1cmluZyB0aGUgdHJhdmVyc2FsLlxyXG4gKiBcclxuICogVGhlIHJvbGUgb2YgdGhlIFRpY2sgY2xhc3MgaXMgdG8gc3RvcmUgdGhlIGluc3RhbmNlcyBvZiB0cmVlLCBkZWJ1ZywgXHJcbiAqIHRhcmdldCBhbmQgYmxhY2tib2FyZC4gU28sIGFsbCBub2RlcyBjYW4gYWNjZXNzIHRoZXNlIGluZm9ybWF0aW9ucy5cclxuICogXHJcbiAqIEZvciBpbnRlcm5hbCB1c2VzLCB0aGUgVGljayBhbHNvIGlzIHVzZWZ1bCB0byBzdG9yZSB0aGUgb3BlbiBub2RlIGFmdGVyIFxyXG4gKiB0aGUgdGljayBzaWduYWwsIGluIG9yZGVyIHRvIGxldCBgQmVoYXZpb3JUcmVlYCB0byBrZWVwIHRyYWNrIGFuZCBjbG9zZSBcclxuICogdGhlbSB3aGVuIG5lY2Vzc2FyeS5cclxuICpcclxuICogVGhpcyBjbGFzcyBhbHNvIG1ha2VzIGEgYnJpZGdlIGJldHdlZW4gbm9kZXMgYW5kIHRoZSBkZWJ1ZywgcGFzc2luZyB0aGUgXHJcbiAqIG5vZGUgc3RhdGUgdG8gdGhlIGRlYnVnIGlmIHRoZSBsYXN0IGlzIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBUaWNrXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNUaWNrIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmVlIHJlZmVyZW5jZS5cclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcbiAgICB0cmVlOiBCM0JlaGF2aW9yVHJlZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVidWcgcmVmZXJlbmNlLlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIGRlYnVnOiBhbnkgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIHRhcmdldDogYW55ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBibGFja2JvYXJkIHJlZmVyZW5jZS5cclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcbiAgICBibGFja2JvYXJkOiBCM0JsYWNrYm9hcmQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpc3Qgb2Ygb3BlbiBub2Rlcy4gVXBkYXRlIGR1cmluZyB0aGUgdHJlZSB0cmF2ZXJzYWwuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgX29wZW5Ob2RlczogYW55W10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2Ygbm9kZXMgZW50ZXJlZCBkdXJpbmcgdGhlIHRpY2suIFVwZGF0ZSBkdXJpbmcgdGhlIHRyZWUgXHJcbiAgICAgKiB0cmF2ZXJzYWwuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gX25vZGVDb3VudFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKi9cclxuICAgIF9ub2RlQ291bnQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbiBtZXRob2QuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gc2V0IGJ5IEJlaGF2aW9yVHJlZVxyXG4gICAgICAgIHRoaXMudHJlZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYmxhY2tib2FyZCA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZWQgZHVyaW5nIHRoZSB0aWNrIHNpZ25hbFxyXG4gICAgICAgIHRoaXMuX29wZW5Ob2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25vZGVDb3VudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBlbnRlcmluZyBhIG5vZGUgKGNhbGxlZCBieSBCYXNlTm9kZSkuXHJcbiAgICAgKiBAbWV0aG9kIF9lbnRlck5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRoYXQgY2FsbGVkIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfZW50ZXJOb2RlKG5vZGU6IEIzQmFzZU5vZGUpIHtcclxuICAgICAgICB0aGlzLl9ub2RlQ291bnQrKztcclxuICAgICAgICB0aGlzLl9vcGVuTm9kZXMucHVzaChub2RlKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY2FsbCBkZWJ1ZyBoZXJlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayB3aGVuIG9wZW5pbmcgYSBub2RlIChjYWxsZWQgYnkgQmFzZU5vZGUpLlxyXG4gICAgICogQG1ldGhvZCBfb3Blbk5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRoYXQgY2FsbGVkIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfb3Blbk5vZGUobm9kZTogQjNCYXNlTm9kZSkge1xyXG4gICAgICAgIC8vIFRPRE86IGNhbGwgZGVidWcgaGVyZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgd2hlbiB0aWNraW5nIGEgbm9kZSAoY2FsbGVkIGJ5IEJhc2VOb2RlKS5cclxuICAgICAqIEBtZXRob2QgX3RpY2tOb2RlXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0aGF0IGNhbGxlZCB0aGlzIG1ldGhvZC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX3RpY2tOb2RlKG5vZGU6IEIzQmFzZU5vZGUpIHtcclxuICAgICAgICAvLyBUT0RPOiBjYWxsIGRlYnVnIGhlcmVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHdoZW4gY2xvc2luZyBhIG5vZGUgKGNhbGxlZCBieSBCYXNlTm9kZSkuXHJcbiAgICAgKiBAbWV0aG9kIF9jbG9zZU5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRoYXQgY2FsbGVkIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2xvc2VOb2RlKG5vZGU6IEIzQmFzZU5vZGUpIHtcclxuICAgICAgICAvLyBUT0RPOiBjYWxsIGRlYnVnIGhlcmVcclxuICAgICAgICB0aGlzLl9vcGVuTm9kZXMucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayB3aGVuIGV4aXRpbmcgYSBub2RlIChjYWxsZWQgYnkgQmFzZU5vZGUpLlxyXG4gICAgICogQG1ldGhvZCBfZXhpdE5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRoYXQgY2FsbGVkIHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfZXhpdE5vZGUobm9kZTogQjNCYXNlTm9kZSkge1xyXG4gICAgICAgIC8vIFRPRE86IGNhbGwgZGVidWcgaGVyZVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIEJsYWNrYm9hcmQgaXMgdGhlIG1lbW9yeSBzdHJ1Y3R1cmUgcmVxdWlyZWQgYnkgYEJlaGF2aW9yVHJlZWAgYW5kIGl0cyBcclxuICogbm9kZXMuIEl0IG9ubHkgaGF2ZSAyIHB1YmxpYyBtZXRob2RzOiBgc2V0YCBhbmQgYGdldGAuIFRoZXNlIG1ldGhvZHMgd29ya3NcclxuICogaW4gMyBkaWZmZXJlbnQgY29udGV4dHM6IGdsb2JhbCwgcGVyIHRyZWUsIGFuZCBwZXIgbm9kZSBwZXIgdHJlZS5cclxuICogXHJcbiAqIFN1cHBvc2UgeW91IGhhdmUgdHdvIGRpZmZlcmVudCB0cmVlcyBjb250cm9sbGluZyBhIHNpbmdsZSBvYmplY3Qgd2l0aCBhIFxyXG4gKiBzaW5nbGUgYmxhY2tib2FyZCwgdGhlbjpcclxuICpcclxuICogLSBJbiB0aGUgZ2xvYmFsIGNvbnRleHQsIGFsbCBub2RlcyB3aWxsIGFjY2VzcyB0aGUgc3RvcmVkIGluZm9ybWF0aW9uLiBcclxuICogLSBJbiBwZXIgdHJlZSBjb250ZXh0LCBvbmx5IG5vZGVzIHNoYXJpbmcgdGhlIHNhbWUgdHJlZSBzaGFyZSB0aGUgc3RvcmVkIFxyXG4gKiAgIGluZm9ybWF0aW9uLlxyXG4gKiAtIEluIHBlciBub2RlIHBlciB0cmVlIGNvbnRleHQsIHRoZSBpbmZvcm1hdGlvbiBzdG9yZWQgaW4gdGhlIGJsYWNrYm9hcmQgXHJcbiAqICAgY2FuIG9ubHkgYmUgYWNjZXNzZWQgYnkgdGhlIHNhbWUgbm9kZSB0aGF0IHdyb3RlIHRoZSBkYXRhLlxyXG4gKiAgIFxyXG4gKiBUaGUgY29udGV4dCBpcyBzZWxlY3RlZCBpbmRpcmVjdGx5IGJ5IHRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkIHRvIHRoZXNlIFxyXG4gKiBtZXRob2RzLCBmb3IgZXhhbXBsZTpcclxuICogXHJcbiAqICAgICAvLyBnZXR0aW5nL3NldHRpbmcgdmFyaWFibGUgaW4gZ2xvYmFsIGNvbnRleHRcclxuICogICAgIGJsYWNrYm9hcmQuc2V0KFwidGVzdEtleVwiLCBcInZhbHVlXCIpO1xyXG4gKiAgICAgdmFyIHZhbHVlID0gYmxhY2tib2FyZC5nZXQoXCJ0ZXN0S2V5XCIpO1xyXG4gKiAgICAgXHJcbiAqICAgICAvLyBnZXR0aW5nL3NldHRpbmcgdmFyaWFibGUgaW4gcGVyIHRyZWUgY29udGV4dFxyXG4gKiAgICAgYmxhY2tib2FyZC5zZXQoXCJ0ZXN0S2V5XCIsIFwidmFsdWVcIiwgdHJlZS5pZCk7XHJcbiAqICAgICB2YXIgdmFsdWUgPSBibGFja2JvYXJkLmdldChcInRlc3RLZXlcIiwgdHJlZS5pZCk7XHJcbiAqICAgICBcclxuICogICAgIC8vIGdldHRpbmcvc2V0dGluZyB2YXJpYWJsZSBpbiBwZXIgbm9kZSBwZXIgdHJlZSBjb250ZXh0XHJcbiAqICAgICBibGFja2JvYXJkLnNldChcInRlc3RLZXlcIiwgXCJ2YWx1ZVwiLCB0cmVlLmlkLCBub2RlLmlkKTtcclxuICogICAgIHZhciB2YWx1ZSA9IGJsYWNrYm9hcmQuZ2V0KFwidGVzdEtleVwiLCB0cmVlLmlkLCBub2RlLmlkKTtcclxuICogXHJcbiAqIE5vdGU6IEludGVybmFsbHksIHRoZSBibGFja2JvYXJkIHN0b3JlIHRoZXNlIG1lbW9yaWVzIGluIGRpZmZlcmVudCBcclxuICogb2JqZWN0cywgYmVpbmcgdGhlIGdsb2JhbCBvbiBgX2Jhc2VNZW1vcnlgLCB0aGUgcGVyIHRyZWUgb24gYF90cmVlTWVtb3J5YCBcclxuICogYW5kIHRoZSBwZXIgbm9kZSBwZXIgdHJlZSBkeW5hbWljYWxseSBjcmVhdGUgaW5zaWRlIHRoZSBwZXIgdHJlZSBtZW1vcnkgXHJcbiAqIChpdCBpcyBhY2Nlc3NlZCB2aWEgYF90cmVlTWVtb3J5W2lkXS5ub2RlTWVtb3J5YCkuIEF2b2lkIHRvIHVzZSB0aGVzZSBcclxuICogdmFyaWFibGVzIG1hbnVhbGx5LCB1c2UgYGdldGAgYW5kIGBzZXRgIGluc3RlYWQuXHJcbiAqICBcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgQmxhY2tib2FyZFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEIzQmxhY2tib2FyZCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfYmFzZU1lbW9yeTogUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF90cmVlTWVtb3J5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2Jhc2VNZW1vcnkgPSB7fTtcclxuICAgICAgICB0aGlzLl90cmVlTWVtb3J5ID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIHRyZWUgY29udGV4dCBtZW1vcnkuIElmIHRoZSBtZW1vcnkgZG9lc1xyXG4gICAgICogbm90IGV4aXN0LCB0aGlzIG1ldGhvZCBjcmVhdGVzIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgX2dldFRyZWVNZW1vcnlcclxuICAgICAqIEBwYXJhbSB0cmVlU2NvcGUgVGhlIGlkIG9mIHRoZSB0cmVlIGluIHNjb3BlLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJlZSBtZW1vcnkuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9nZXRUcmVlTWVtb3J5KHRyZWVTY29wZTogc3RyaW5nKTogYW55IHtcclxuICAgICAgICBpZiAoIXRoaXMuX3RyZWVNZW1vcnlbdHJlZVNjb3BlXSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmVlTWVtb3J5W3RyZWVTY29wZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBcIm5vZGVNZW1vcnlcIjoge30sXHJcbiAgICAgICAgICAgICAgICBcIm9wZW5Ob2Rlc1wiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwidHJhdmVyc2FsRGVwdGhcIjogMCxcclxuICAgICAgICAgICAgICAgIFwidHJhdmVyc2FsQ3ljbGVcIjogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVNZW1vcnlbdHJlZVNjb3BlXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgbm9kZSBjb250ZXh0IG1lbW9yeSwgZ2l2ZW4gdGhlIHRyZWUgXHJcbiAgICAgKiBtZW1vcnkuIElmIHRoZSBtZW1vcnkgZG9lcyBub3QgZXhpc3QsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgaXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBfZ2V0Tm9kZU1lbW9yeVxyXG4gICAgICogQHBhcmFtIHRyZWVNZW1vcnkgdGhlIHRyZWUgbWVtb3J5LlxyXG4gICAgICogQHBhcmFtIG5vZGVTY29wZSBUaGUgaWQgb2YgdGhlIG5vZGUgaW4gc2NvcGUuXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBub2RlIG1lbW9yeS5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX2dldE5vZGVNZW1vcnkodHJlZU1lbW9yeTogYW55LCBub2RlU2NvcGU6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgdmFyIG1lbW9yeSA9IHRyZWVNZW1vcnkubm9kZU1lbW9yeTtcclxuICAgICAgICBpZiAoIW1lbW9yeVtub2RlU2NvcGVdKSB7XHJcbiAgICAgICAgICAgIG1lbW9yeVtub2RlU2NvcGVdID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWVtb3J5W25vZGVTY29wZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRleHQgbWVtb3J5LiBJZiB0cmVlU2NvcGUgYW5kIFxyXG4gICAgICogbm9kZVNjb3BlIGFyZSBwcm92aWRlZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcGVyIG5vZGUgcGVyIHRyZWUgXHJcbiAgICAgKiBtZW1vcnkuIElmIG9ubHkgdGhlIHRyZWVTY29wZSBpcyBwcm92aWRlZCwgaXQgcmV0dXJucyB0aGUgcGVyIHRyZWUgXHJcbiAgICAgKiBtZW1vcnkuIElmIG5vIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgaXQgcmV0dXJucyB0aGUgZ2xvYmFsIG1lbW9yeS4gXHJcbiAgICAgKiBOb3RpY2UgdGhhdCwgaWYgb25seSBub2RlU2NvcGUgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHdpbGwgc3RpbGwgXHJcbiAgICAgKiByZXR1cm4gdGhlIGdsb2JhbCBtZW1vcnkuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBfZ2V0TWVtb3J5XHJcbiAgICAgKiBAcGFyYW0gdHJlZVNjb3BlIFRoZSBpZCBvZiB0aGUgdHJlZSBzY29wZS5cclxuICAgICAqIEBwYXJhbSBub2RlU2NvcGUgVGhlIGlkIG9mIHRoZSBub2RlIHNjb3BlLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBIG1lbW9yeSBvYmplY3QuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9nZXRNZW1vcnkodHJlZVNjb3BlPzogc3RyaW5nLCBub2RlU2NvcGU/OiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIHZhciBtZW1vcnkgPSB0aGlzLl9iYXNlTWVtb3J5O1xyXG5cclxuICAgICAgICBpZiAodHJlZVNjb3BlKSB7XHJcbiAgICAgICAgICAgIG1lbW9yeSA9IHRoaXMuX2dldFRyZWVNZW1vcnkodHJlZVNjb3BlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlU2NvcGUpIHtcclxuICAgICAgICAgICAgICAgIG1lbW9yeSA9IHRoaXMuX2dldE5vZGVNZW1vcnkobWVtb3J5LCBub2RlU2NvcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWVtb3J5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzIGEgdmFsdWUgaW4gdGhlIGJsYWNrYm9hcmQuIElmIHRyZWVTY29wZSBhbmQgbm9kZVNjb3BlIGFyZSBcclxuICAgICAqIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCB3aWxsIHNhdmUgdGhlIHZhbHVlIGludG8gdGhlIHBlciBub2RlIHBlciB0cmVlIFxyXG4gICAgICogbWVtb3J5LiBJZiBvbmx5IHRoZSB0cmVlU2NvcGUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgc2F2ZSB0aGUgdmFsdWUgaW50byBcclxuICAgICAqIHRoZSBwZXIgdHJlZSBtZW1vcnkuIElmIG5vIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdGhpcyBtZXRob2Qgd2lsbCBzYXZlIFxyXG4gICAgICogdGhlIHZhbHVlIGludG8gdGhlIGdsb2JhbCBtZW1vcnkuIE5vdGljZSB0aGF0LCBpZiBvbmx5IG5vZGVTY29wZSBpcyBcclxuICAgICAqIHByb3ZpZGVkIChidXQgdHJlZVNjb3BlIG5vdCksIHRoaXMgbWV0aG9kIHdpbGwgc3RpbGwgc2F2ZSB0aGUgdmFsdWUgaW50b1xyXG4gICAgICogdGhlIGdsb2JhbCBtZW1vcnkuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBzZXRcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBiZSBzdG9yZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHN0b3JlZC5cclxuICAgICAqIEBwYXJhbSB0cmVlU2NvcGUgVGhlIHRyZWUgaWQgaWYgYWNjZXNzaW5nIHRoZSB0cmVlIG9yIG5vZGUgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeS5cclxuICAgICAqIEBwYXJhbSBub2RlU2NvcGUgVGhlIG5vZGUgaWQgaWYgYWNjZXNzaW5nIHRoZSBub2RlIG1lbW9yeS5cclxuICAgICAqL1xyXG4gICAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55LCB0cmVlU2NvcGU/OiBzdHJpbmcsIG5vZGVTY29wZT86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHZhciBtZW1vcnkgPSB0aGlzLl9nZXRNZW1vcnkodHJlZVNjb3BlLCBub2RlU2NvcGUpO1xyXG4gICAgICAgIG1lbW9yeVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSB2YWx1ZSBpbiB0aGUgYmxhY2tib2FyZC4gSWYgdHJlZVNjb3BlIGFuZCBub2RlU2NvcGUgYXJlXHJcbiAgICAgKiBwcm92aWRlZCwgdGhpcyBtZXRob2Qgd2lsbCByZXRyaWV2ZSB0aGUgdmFsdWUgZnJvbSB0aGUgcGVyIG5vZGUgcGVyIHRyZWVcclxuICAgICAqIG1lbW9yeS4gSWYgb25seSB0aGUgdHJlZVNjb3BlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHJpZXZlIHRoZSB2YWx1ZVxyXG4gICAgICogZnJvbSB0aGUgcGVyIHRyZWUgbWVtb3J5LiBJZiBubyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHdpbGxcclxuICAgICAqIHJldHJpZXZlIGZyb20gdGhlIGdsb2JhbCBtZW1vcnkuIElmIG9ubHkgbm9kZVNjb3BlIGlzIHByb3ZpZGVkIChidXRcclxuICAgICAqIHRyZWVTY29wZSBub3QpLCB0aGlzIG1ldGhvZCB3aWxsIHN0aWxsIHRyeSB0byByZXRyaWV2ZSBmcm9tIHRoZSBnbG9iYWxcclxuICAgICAqIG1lbW9yeS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGJlIHJldHJpZXZlZC5cclxuICAgICAqIEBwYXJhbSB0cmVlU2NvcGUgVGhlIHRyZWUgaWQgaWYgYWNjZXNzaW5nIHRoZSB0cmVlIG9yIG5vZGUgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9yeS5cclxuICAgICAqIEBwYXJhbSBub2RlU2NvcGUgVGhlIG5vZGUgaWQgaWYgYWNjZXNzaW5nIHRoZSBub2RlIG1lbW9yeS5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHZhbHVlIHN0b3JlZCBvciB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXk6IHN0cmluZywgdHJlZVNjb3BlPzogc3RyaW5nLCBub2RlU2NvcGU/OiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIHZhciBtZW1vcnkgPSB0aGlzLl9nZXRNZW1vcnkodHJlZVNjb3BlLCBub2RlU2NvcGUpO1xyXG4gICAgICAgIHJldHVybiBtZW1vcnlba2V5XTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBCYXNlTm9kZSBjbGFzcyBpcyB1c2VkIGFzIHN1cGVyIGNsYXNzIHRvIGFsbCBub2RlcyBpbiBCZWhhdmlvckpTLiBJdCBcclxuICogY29tcHJpc2VzIGFsbCBjb21tb24gdmFyaWFibGVzIGFuZCBtZXRob2RzIHRoYXQgYSBub2RlIG11c3QgaGF2ZSB0byBcclxuICogZXhlY3V0ZS5cclxuICpcclxuICogKipJTVBPUlRBTlQ6KiogRG8gbm90IGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLCB1c2UgYGIzLkNvbXBvc2l0ZWAsIFxyXG4gKiBgYjMuRGVjb3JhdG9yYCwgYGIzLkFjdGlvbmAgb3IgYGIzLkNvbmRpdGlvbmAsIGluc3RlYWQuXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBzcGVjaWFsbHkgZGVzaWduZWQgdG8gc2VyaWFsaXphdGlvbiBvZiB0aGUgbm9kZSBpbiBhIFxyXG4gKiBKU09OIGZvcm1hdC4gSW4gc3BlY2lhbCwgdGhlIGBwYXJhbWV0ZXJzYCBhdHRyaWJ1dGUgY2FuIGJlIHNldCBpbnRvIHRoZSBcclxuICogdmlzdWFsIGVkaXRvciAodGh1cywgaW4gdGhlIEpTT04gZmlsZSksIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgcGFyYW1ldGVyIFxyXG4gKiBvbiB0aGUgbm9kZSBpbml0aWFsaXphdGlvbiBhdCBgQmVoYXZpb3JUcmVlLmxvYWRgLlxyXG4gKiBcclxuICogQmFzZU5vZGUgYWxzbyBwcm92aWRlIDUgY2FsbGJhY2sgbWV0aG9kcywgd2hpY2ggdGhlIG5vZGUgaW1wbGVtZW50YXRpb25zIFxyXG4gKiBjYW4gb3ZlcnJpZGUuIFRoZXkgYXJlIGBlbnRlcmAsIGBvcGVuYCwgYHRpY2tgLCBgY2xvc2VgIGFuZCBgZXhpdGAuIFNlZSBcclxuICogdGhlaXIgZG9jdW1lbnRhdGlvbiB0byBrbm93IG1vcmUuIFRoZXNlIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGluc2lkZSB0aGUgXHJcbiAqIGBfZXhlY3V0ZWAgbWV0aG9kLCB3aGljaCBpcyBjYWxsZWQgaW4gdGhlIHRyZWUgdHJhdmVyc2FsLlxyXG4gKiBcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgQmFzZU5vZGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM0Jhc2VOb2RlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgSUQuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgaWQ6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIE11c3QgYmUgYSB1bmlxdWUgaWRlbnRpZmllciwgcHJlZmVyYWJsZSB0aGUgc2FtZSBuYW1lIG9mIHRoZSBcclxuICAgICAqIGNsYXNzLiBZb3UgaGF2ZSB0byBzZXQgdGhlIG5vZGUgbmFtZSBpbiB0aGUgcHJvdG90eXBlLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWU6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIGNhdGVnb3J5LiBNdXN0IGJlIGBiMy5DT01QT1NJVEVgLCBgYjMuREVDT1JBVE9SYCwgYGIzLkFDVElPTmAgb3IgXHJcbiAgICAgKiBgYjMuQ09ORElUSU9OYC4gVGhpcyBpcyBkZWZpbmVkIGF1dG9tYXRpY2FsbHkgYmUgaW5oZXJpdGluZyB0aGUgXHJcbiAgICAgKiBjb3JyZXNwb25kZW50IGNsYXNzLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGNhdGVnb3J5OiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSB0aXRsZS5cclxuICAgICAqIEBvcHRpb25hbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHRpdGxlOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSBkZXNjcmlwdGlvbi5cclxuICAgICAqIEBvcHRpb25hbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBkaWN0aW9uYXJ5IChrZXksIHZhbHVlKSBkZXNjcmliaW5nIHRoZSBub2RlIHBhcmFtZXRlcnMuIFVzZWZ1bCBmb3IgXHJcbiAgICAgKiBkZWZpbmluZyBwYXJhbWV0ZXIgdmFsdWVzIGluIHRoZSB2aXN1YWwgZWRpdG9yLiBOb3RlOiB0aGlzIGlzIG9ubHkgXHJcbiAgICAgKiB1c2VmdWwgZm9yIG5vZGVzIHdoZW4gbG9hZGluZyB0cmVlcyBmcm9tIEpTT04gZmlsZXMuXHJcbiAgICAgKlxyXG4gICAgICogKipEZXByZWNhdGVkIHNpbmNlIDAuMi4wLiBUaGlzIGlzIHRvbyBzaW1pbGFyIHRvIHRoZSBwcm9wZXJ0aWVzIFxyXG4gICAgICogYXR0cmlidXRlLCB0aHVzLCB0aGlzIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIGluIGZhdm9yIHRvIFxyXG4gICAgICogYHByb3BlcnRpZXNgLioqXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgMC4yLjAuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcGFyYW1ldGVyczogYW55ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZGljdGlvbmFyeSAoa2V5LCB2YWx1ZSkgZGVzY3JpYmluZyB0aGUgbm9kZSBwcm9wZXJ0aWVzLiBVc2VmdWwgZm9yIFxyXG4gICAgICogZGVmaW5pbmcgY3VzdG9tIHZhcmlhYmxlcyBpbnNpZGUgdGhlIHZpc3VhbCBlZGl0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWtkOiKgueCue+8jOS7heeUqOS6jkRFQ09SQVRPUlxyXG4gICAgICovXHJcbiAgICBjaGlsZDogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a2Q6IqC54K577yM5LuF55So5LqOQ09NUE9TSVRFXHJcbiAgICAgKi9cclxuICAgIGNoaWxkcmVuOiBhbnlbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBiMy5jcmVhdGVVVUlEKCk7XHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGUgfHwgdGhpcy5uYW1lO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIlwiO1xyXG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBtZXRob2QgdG8gcHJvcGFnYXRlIHRoZSB0aWNrIHNpZ25hbCB0byB0aGlzIG5vZGUuIFRoaXMgXHJcbiAgICAgKiBtZXRob2QgY2FsbHMgYWxsIGNhbGxiYWNrczogYGVudGVyYCwgYG9wZW5gLCBgdGlja2AsIGBjbG9zZWAsIGFuZCBcclxuICAgICAqIGBleGl0YC4gSXQgb25seSBvcGVucyBhIG5vZGUgaWYgaXQgaXMgbm90IGFscmVhZHkgb3Blbi4gSW4gdGhlIHNhbWUgXHJcbiAgICAgKiB3YXksIHRoaXMgbWV0aG9kIG9ubHkgY2xvc2UgYSBub2RlIGlmIHRoZSBub2RlICByZXR1cm5lZCBhIHN0YXR1cyBcclxuICAgICAqIGRpZmZlcmVudCBvZiBgYjMuUlVOTklOR2AuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBfZXhlY3V0ZVxyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IFRoZSB0aWNrIHN0YXRlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfZXhlY3V0ZSh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICAvLyBFTlRFUiBcclxuICAgICAgICB0aGlzLl9lbnRlcih0aWNrKTtcclxuXHJcbiAgICAgICAgLy8gT1BFTiBcclxuICAgICAgICBpZiAoIXRpY2suYmxhY2tib2FyZC5nZXQoXCJpc09wZW5cIiwgdGljay50cmVlLmlkLCB0aGlzLmlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuKHRpY2spO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVElDSyBcclxuICAgICAgICB2YXIgc3RhdHVzID0gdGhpcy5fdGljayh0aWNrKTtcclxuXHJcbiAgICAgICAgLy8gQ0xPU0UgXHJcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gYjMuUlVOTklORykge1xyXG4gICAgICAgICAgICB0aGlzLl9jbG9zZSh0aWNrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYSVQgXHJcbiAgICAgICAgdGhpcy5fZXhpdCh0aWNrKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZm9yIGVudGVyIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgX2VudGVyXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9lbnRlcih0aWNrOiBCM1RpY2spOiB2b2lkIHtcclxuICAgICAgICB0aWNrLl9lbnRlck5vZGUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lbnRlcih0aWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZm9yIG9wZW4gbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCBfb3BlblxyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfb3Blbih0aWNrOiBCM1RpY2spOiB2b2lkIHtcclxuICAgICAgICB0aWNrLl9vcGVuTm9kZSh0aGlzKTtcclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwiaXNPcGVuXCIsIHRydWUsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy5vcGVuKHRpY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlciBmb3IgdGljayBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIF90aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gQSBzdGF0ZSBjb25zdGFudC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX3RpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgdGljay5fdGlja05vZGUodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGljayh0aWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZm9yIGNsb3NlIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgX2Nsb3NlXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9jbG9zZSh0aWNrOiBCM1RpY2spOiB2b2lkIHtcclxuICAgICAgICB0aWNrLl9jbG9zZU5vZGUodGhpcyk7XHJcbiAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcImlzT3BlblwiLCBmYWxzZSwgdGljay50cmVlLmlkLCB0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLmNsb3NlKHRpY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlciBmb3IgZXhpdCBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIF9leGl0XHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9leGl0KHRpY2s6IEIzVGljayk6IHZvaWQge1xyXG4gICAgICAgIHRpY2suX2V4aXROb2RlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZXhpdCh0aWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVudGVyIG1ldGhvZCwgb3ZlcnJpZGUgdGhpcyB0byB1c2UuIEl0IGlzIGNhbGxlZCBldmVyeSB0aW1lIGEgbm9kZSBpcyBcclxuICAgICAqIGFza2VkIHRvIGV4ZWN1dGUsIGJlZm9yZSB0aGUgdGljayBpdHNlbGYuXHJcbiAgICAgKlxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqIEBtZXRob2QgZW50ZXJcclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZW50ZXIodGljazogQjNUaWNrKTogdm9pZCB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW4gbWV0aG9kLCBvdmVycmlkZSB0aGlzIHRvIHVzZS4gSXQgaXMgY2FsbGVkIG9ubHkgYmVmb3JlIHRoZSB0aWNrIFxyXG4gICAgICogY2FsbGJhY2sgYW5kIG9ubHkgaWYgdGhlIG5vdCBpc25cInQgY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGEgbm9kZSB3aWxsIGJlIGNsb3NlZCBpZiBpdCByZXR1cm5lZCBgYjMuUlVOTklOR2AgaW4gdGhlIHRpY2suXHJcbiAgICAgKlxyXG4gICAgICogQHZpcnR1YWxcclxuICAgICAqIEBtZXRob2Qgb3BlblxyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBvcGVuKHRpY2s6IEIzVGljayk6IHZvaWQgeyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZCwgb3ZlcnJpZGUgdGhpcyB0byB1c2UuIFRoaXMgbWV0aG9kIG11c3QgY29udGFpbiB0aGUgcmVhbCBcclxuICAgICAqIGV4ZWN1dGlvbiBvZiBub2RlIChwZXJmb3JtIGEgdGFzaywgY2FsbCBjaGlsZHJlbiwgZXRjLikuIEl0IGlzIGNhbGxlZFxyXG4gICAgICogZXZlcnkgdGltZSBhIG5vZGUgaXMgYXNrZWQgdG8gZXhlY3V0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7IHJldHVybiBiMy5TVUNDRVNTOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZSBtZXRob2QsIG92ZXJyaWRlIHRoaXMgdG8gdXNlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRpY2tcclxuICAgICAqIGNhbGxiYWNrLCBhbmQgb25seSBpZiB0aGUgdGljayByZXR1cm4gYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSBcclxuICAgICAqIGBiMy5SVU5OSU5HYC5cclxuICAgICAqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQG1ldGhvZCBjbG9zZVxyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSh0aWNrOiBCM1RpY2spOiB2b2lkIHsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhpdCBtZXRob2QsIG92ZXJyaWRlIHRoaXMgdG8gdXNlLiBDYWxsZWQgZXZlcnkgdGltZSBpbiB0aGUgZW5kIG9mIHRoZSBcclxuICAgICAqIGV4ZWN1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAdmlydHVhbFxyXG4gICAgICogQG1ldGhvZCBleGl0XHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGV4aXQodGljazogQjNUaWNrKTogdm9pZCB7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFjdGlvbiBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGFjdGlvbiBub2Rlcy4gVGh1cywgaWYgeW91IHdhbnQgdG8gY3JlYXRlXHJcbiAqIG5ldyBjdXN0b20gYWN0aW9uIG5vZGVzLCB5b3UgbmVlZCB0byBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy4gRm9yIGV4YW1wbGUsXHJcbiAqIHRha2UgYSBsb29rIGF0IHRoZSBSdW5uZXIgYWN0aW9uOlxyXG4gKiBcclxuICogICAgIHZhciBSdW5uZXIgPSBiMy5DbGFzcyhiMy5BY3Rpb24sIHtcclxuICogICAgICAgbmFtZTogXCJSdW5uZXJcIixcclxuICpcclxuICogICAgICAgdGljazogZnVuY3Rpb24odGljaykge1xyXG4gKiAgICAgICAgIHJldHVybiBiMy5SVU5OSU5HO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9KTtcclxuICpcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgQWN0aW9uXHJcbiAqIEBleHRlbmRzIEIzQmFzZU5vZGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM0FjdGlvbiBleHRlbmRzIEIzQmFzZU5vZGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSBjYXRlZ29yeS4gRGVmYXVsdCB0byBgYjMuQUNUSU9OYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBjYXRlZ29yeSA9IGIzLkFDVElPTjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21wb3NpdGUgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBjb21wb3NpdGUgbm9kZXMuIFRodXMsIGlmIHlvdSB3YW50IHRvIFxyXG4gKiBjcmVhdGUgbmV3IGN1c3RvbSBjb21wb3NpdGUgbm9kZXMsIHlvdSBuZWVkIHRvIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLiBcclxuICogXHJcbiAqIFdoZW4gY3JlYXRpbmcgY29tcG9zaXRlIG5vZGVzLCB5b3Ugd2lsbCBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgdGljayBzaWduYWwgXHJcbiAqIHRvIHRoZSBjaGlsZHJlbiBub2RlcyBtYW51YWxseS4gVG8gZG8gdGhhdCwgb3ZlcnJpZGUgdGhlIGB0aWNrYCBtZXRob2QgYW5kXHJcbiAqIGNhbGwgdGhlIGBfZXhlY3V0ZWAgbWV0aG9kIG9uIGFsbCBub2Rlcy4gRm9yIGluc3RhbmNlLCB0YWtlIGEgbG9vayBhdCBob3cgXHJcbiAqIHRoZSBTZXF1ZW5jZSBub2RlIGluaGVyaXQgdGhpcyBjbGFzcyBhbmQgaG93IGl0IGNhbGwgaXRzIGNoaWxkcmVuOlxyXG4gKlxyXG4gKiAgICAgLy8gSW5oZXJpdCBmcm9tIENvbXBvc2l0ZSwgdXNpbmcgdGhlIHV0aWwgZnVuY3Rpb24gQ2xhc3MuXHJcbiAqICAgICB2YXIgU2VxdWVuY2UgPSBiMy5DbGFzcyhiMy5Db21wb3NpdGUsIHtcclxuICogICAgIFxyXG4gKiAgICAgICAvLyBSZW1lbWJlciB0byBzZXQgdGhlIG5hbWUgb2YgdGhlIG5vZGUuIFxyXG4gKiAgICAgICBuYW1lOiBcIlNlcXVlbmNlXCIsXHJcbiAqXHJcbiAqICAgICAgIC8vIE92ZXJyaWRlIHRoZSB0aWNrIGZ1bmN0aW9uXHJcbiAqICAgICAgIHRpY2s6IGZ1bmN0aW9uKHRpY2spIHtcclxuICogICAgICAgXHJcbiAqICAgICAgICAgLy8gSXRlcmF0ZXMgb3ZlciB0aGUgY2hpbGRyZW5cclxuICogICAgICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gKlxyXG4gKiAgICAgICAgICAgLy8gUHJvcGFnYXRlIHRoZSB0aWNrXHJcbiAqICAgICAgICAgICB2YXIgc3RhdHVzID0gdGhpcy5jaGlsZHJlbltpXS5fZXhlY3V0ZSh0aWNrKTtcclxuICogXHJcbiAqICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBiMy5TVUNDRVNTKSB7XHJcbiAqICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICogICAgICAgICAgIH1cclxuICogICAgICAgICB9XHJcbiAqXHJcbiAqICAgICAgICAgcmV0dXJuIGIzLlNVQ0NFU1M7XHJcbiAqICAgICAgIH1cclxuICogICAgIH0pO1xyXG4gKiBcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgQ29tcG9zaXRlXHJcbiAqIEBleHRlbmRzIEIzQmFzZU5vZGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM0NvbXBvc2l0ZSBleHRlbmRzIEIzQmFzZU5vZGUge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSBjYXRlZ29yeS4gRGVmYXVsdCB0byBgYjMuQ09NUE9TSVRFYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBjYXRlZ29yeSA9IGIzLkNPTVBPU0lURTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IChwYXJhbXMuY2hpbGRyZW4gfHwgW10pLnNsaWNlKDApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29uZGl0aW9uIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgY29uZGl0aW9uIG5vZGVzLiBUaHVzLCBpZiB5b3Ugd2FudCB0byBcclxuICogY3JlYXRlIG5ldyBjdXN0b20gY29uZGl0aW9uIG5vZGVzLCB5b3UgbmVlZCB0byBpbmhlcml0IGZyb20gdGhpcyBjbGFzcy4gXHJcbiAqXHJcbiAqIEBjbGFzcyBDb25kaXRpb25cclxuICogQGV4dGVuZHMgQjNCYXNlTm9kZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEIzQ29uZGl0aW9uIGV4dGVuZHMgQjNCYXNlTm9kZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIGNhdGVnb3J5LiBEZWZhdWx0IHRvIGBiMy5DT05ESVRJT05gLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGNhdGVnb3J5ID0gYjMuQ09ORElUSU9OO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24gbWV0aG9kLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtczogYW55KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBkZWNvcmF0b3Igbm9kZXMuIFRodXMsIGlmIHlvdSB3YW50IHRvIFxyXG4gKiBjcmVhdGUgbmV3IGN1c3RvbSBkZWNvcmF0b3Igbm9kZXMsIHlvdSBuZWVkIHRvIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLiBcclxuICogXHJcbiAqIFdoZW4gY3JlYXRpbmcgZGVjb3JhdG9yIG5vZGVzLCB5b3Ugd2lsbCBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgdGljayBzaWduYWxcclxuICogdG8gdGhlIGNoaWxkIG5vZGUgbWFudWFsbHksIGp1c3QgbGlrZSB0aGUgY29tcG9zaXRlIG5vZGVzLiBUbyBkbyB0aGF0LCBcclxuICogb3ZlcnJpZGUgdGhlIGB0aWNrYCBtZXRob2QgYW5kIGNhbGwgdGhlIGBfZXhlY3V0ZWAgbWV0aG9kIG9uIHRoZSBjaGlsZCBcclxuICogbm9kZS4gRm9yIGluc3RhbmNlLCB0YWtlIGEgbG9vayBhdCBob3cgdGhlIEludmVydGVyIG5vZGUgaW5oZXJpdCB0aGlzIFxyXG4gKiBjbGFzcyBhbmQgaG93IGl0IGNhbGwgaXRzIGNoaWxkcmVuOlxyXG4gKiBcclxuICogICAgIC8vIEluaGVyaXQgZnJvbSBEZWNvcmF0b3IsIHVzaW5nIHRoZSB1dGlsIGZ1bmN0aW9uIENsYXNzLlxyXG4gKiAgICAgdmFyIEludmVydGVyID0gYjMuQ2xhc3MoYjMuRGVjb3JhdG9yLCB7XHJcbiAqICAgICAgIG5hbWU6IFwiSW52ZXJ0ZXJcIixcclxuICpcclxuICogICAgICAgdGljazogZnVuY3Rpb24odGljaykge1xyXG4gKiAgICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xyXG4gKiAgICAgICAgICAgcmV0dXJuIGIzLkVSUk9SO1xyXG4gKiAgICAgICAgIH1cclxuICogICAgIFxyXG4gKiAgICAgICAgIC8vIFByb3BhZ2F0ZSB0aGUgdGlja1xyXG4gKiAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmNoaWxkLl9leGVjdXRlKHRpY2spO1xyXG4gKiAgICAgXHJcbiAqICAgICAgICAgaWYgKHN0YXR1cyA9PSBiMy5TVUNDRVNTKSB7XHJcbiAqICAgICAgICAgICBzdGF0dXMgPSBiMy5GQUlMVVJFO1xyXG4gKiAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09IGIzLkZBSUxVUkUpIHtcclxuICogICAgICAgICAgIHN0YXR1cyA9IGIzLlNVQ0NFU1M7XHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgXHJcbiAqICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICogICAgICAgfVxyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIERlY29yYXRvclxyXG4gKiBAZXh0ZW5kcyBCM0Jhc2VOb2RlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNEZWNvcmF0b3IgZXh0ZW5kcyBCM0Jhc2VOb2RlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgY2F0ZWdvcnkuIERlZmF1bHQgdG8gYjMuREVDT1JBVE9SLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGNhdGVnb3J5ID0gYjMuREVDT1JBVE9SO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24gbWV0aG9kLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtczogYW55KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmNoaWxkID0gcGFyYW1zLmNoaWxkIHx8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1Qcmlvcml0eSBpcyBzaW1pbGFyIHRvIFByaW9yaXR5IG5vZGUsIGJ1dCB3aGVuIGEgY2hpbGQgcmV0dXJucyBhIFxyXG4gKiBgUlVOTklOR2Agc3RhdGUsIGl0cyBpbmRleCBpcyByZWNvcmRlZCBhbmQgaW4gdGhlIG5leHQgdGljayB0aGUsIFxyXG4gKiBNZW1Qcmlvcml0eSBjYWxscyB0aGUgY2hpbGQgcmVjb3JkZWQgZGlyZWN0bHksIHdpdGhvdXQgY2FsbGluZyBwcmV2aW91cyBcclxuICogY2hpbGRyZW4gYWdhaW4uXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIE1lbVByaW9yaXR5XHJcbiAqIEBleHRlbmRzIEIzQ29tcG9zaXRlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNNZW1Qcmlvcml0eSBleHRlbmRzIEIzQ29tcG9zaXRlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgTWVtUHJpb3JpdHlgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIk1lbVByaW9yaXR5XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2Qgb3BlblxyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBvcGVuKHRpY2s6IEIzVGljayk6IHZvaWQge1xyXG4gICAgICAgIHRpY2suYmxhY2tib2FyZC5zZXQoXCJydW5uaW5nQ2hpbGRcIiwgMCwgdGljay50cmVlLmlkLCB0aGlzLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpY2sgbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gQSBzdGF0ZSBjb25zdGFudC5cclxuICAgICAqL1xyXG4gICAgdGljayh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSB0aWNrLmJsYWNrYm9hcmQuZ2V0KFwicnVubmluZ0NoaWxkXCIsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gdGhpcy5jaGlsZHJlbltpXS5fZXhlY3V0ZSh0aWNrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IGIzLkZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IGIzLlJVTk5JTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwicnVubmluZ0NoaWxkXCIsIGksIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGIzLkZBSUxVUkU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1TZXF1ZW5jZSBpcyBzaW1pbGFyIHRvIFNlcXVlbmNlIG5vZGUsIGJ1dCB3aGVuIGEgY2hpbGQgcmV0dXJucyBhIFxyXG4gKiBgUlVOTklOR2Agc3RhdGUsIGl0cyBpbmRleCBpcyByZWNvcmRlZCBhbmQgaW4gdGhlIG5leHQgdGljayB0aGUgXHJcbiAqIE1lbVNlcXVlbmNlIGNhbGwgdGhlIGNoaWxkIHJlY29yZGVkIGRpcmVjdGx5LCB3aXRob3V0IGNhbGxpbmcgcHJldmlvdXMgXHJcbiAqIGNoaWxkcmVuIGFnYWluLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBNZW1TZXF1ZW5jZVxyXG4gKiBAZXh0ZW5kcyBCM0NvbXBvc2l0ZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEIzTWVtU2VxdWVuY2UgZXh0ZW5kcyBCM0NvbXBvc2l0ZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIERlZmF1bHQgdG8gYE1lbVNlcXVlbmNlYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJNZW1TZXF1ZW5jZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbiBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIG9wZW5cclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgb3Blbih0aWNrOiBCM1RpY2spIHtcclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwicnVubmluZ0NoaWxkXCIsIDAsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEEgc3RhdGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGljay5ibGFja2JvYXJkLmdldChcInJ1bm5pbmdDaGlsZFwiLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjaGlsZDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuY2hpbGRyZW5baV0uX2V4ZWN1dGUodGljayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9PSBiMy5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBiMy5SVU5OSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcInJ1bm5pbmdDaGlsZFwiLCBpLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGIzLlNVQ0NFU1M7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0eSB0aWNrcyBpdHMgY2hpbGRyZW4gc2VxdWVudGlhbGx5IHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgXHJcbiAqIGBTVUNDRVNTYCwgYFJVTk5JTkdgIG9yIGBFUlJPUmAuIElmIGFsbCBjaGlsZHJlbiByZXR1cm4gdGhlIGZhaWx1cmUgc3RhdGUsXHJcbiAqIHRoZSBwcmlvcml0eSBhbHNvIHJldHVybnMgYEZBSUxVUkVgLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBQcmlvcml0eVxyXG4gKiBAZXh0ZW5kcyBCM0NvbXBvc2l0ZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEIzUHJpb3JpdHkgZXh0ZW5kcyBCM0NvbXBvc2l0ZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIERlZmF1bHQgdG8gYFByaW9yaXR5YC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJQcmlvcml0eVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGljayBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm4ge0NvbnN0YW50fSBBIHN0YXRlIGNvbnN0YW50LlxyXG4gICAgICovXHJcbiAgICB0aWNrKHRpY2s6IEIzVGljayk6IEIzU3RhdGUge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gdGhpcy5jaGlsZHJlbltpXS5fZXhlY3V0ZSh0aWNrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgIT09IGIzLkZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBiMy5GQUlMVVJFO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIFNlcXVlbmNlIG5vZGUgdGlja3MgaXRzIGNoaWxkcmVuIHNlcXVlbnRpYWxseSB1bnRpbCBvbmUgb2YgdGhlbSBcclxuICogcmV0dXJucyBgRkFJTFVSRWAsIGBSVU5OSU5HYCBvciBgRVJST1JgLiBJZiBhbGwgY2hpbGRyZW4gcmV0dXJuIHRoZSBcclxuICogc3VjY2VzcyBzdGF0ZSwgdGhlIHNlcXVlbmNlIGFsc28gcmV0dXJucyBgU1VDQ0VTU2AuXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIFNlcXVlbmNlXHJcbiAqIEBleHRlbmRzIEIzQ29tcG9zaXRlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNTZXF1ZW5jZSBleHRlbmRzIEIzQ29tcG9zaXRlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgU2VxdWVuY2VgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIlNlcXVlbmNlXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEEgc3RhdGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmNoaWxkcmVuW2ldLl9leGVjdXRlKHRpY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gYjMuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGIzLlNVQ0NFU1M7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgSW52ZXJ0ZXIgZGVjb3JhdG9yIGludmVydHMgdGhlIHJlc3VsdCBvZiB0aGUgY2hpbGQsIHJldHVybmluZyBgU1VDQ0VTU2BcclxuICogZm9yIGBGQUlMVVJFYCBhbmQgYEZBSUxVUkVgIGZvciBgU1VDQ0VTU2AuXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIEludmVydGVyXHJcbiAqIEBleHRlbmRzIEIzRGVjb3JhdG9yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNJbnZlcnRlciBleHRlbmRzIEIzRGVjb3JhdG9yIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgSW52ZXJ0ZXJgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIkludmVydGVyXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEEgc3RhdGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiMy5FUlJPUjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmNoaWxkLl9leGVjdXRlKHRpY2spO1xyXG5cclxuICAgICAgICBpZiAoc3RhdHVzID09IGIzLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgc3RhdHVzID0gYjMuRkFJTFVSRTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSBiMy5GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9IGIzLlNVQ0NFU1M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBkZWNvcmF0b3IgbGltaXQgdGhlIG51bWJlciBvZiB0aW1lcyBpdHMgY2hpbGQgY2FuIGJlIGNhbGxlZC4gQWZ0ZXIgYVxyXG4gKiBjZXJ0YWluIG51bWJlciBvZiB0aW1lcywgdGhlIExpbWl0ZXIgZGVjb3JhdG9yIHJldHVybnMgYEZBSUxVUkVgIHdpdGhvdXQgXHJcbiAqIGV4ZWN1dGluZyB0aGUgY2hpbGQuXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIExpbWl0ZXJcclxuICogQGV4dGVuZHMgQjNEZWNvcmF0b3JcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM0xpbWl0ZXIgZXh0ZW5kcyBCM0RlY29yYXRvciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIERlZmF1bHQgdG8gYExpbWl0ZXJgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIkxpbWl0ZXJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgdGl0bGUuIERlZmF1bHQgdG8gYExpbWl0IFggQWN0aXZhdGlvbnNgLiBVc2VkIGluIEVkaXRvci5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aXRsZSA9IFwiTGltaXQgPG1heExvb3A+IEFjdGl2YXRpb25zXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcGFyYW1ldGVycyA9IHsgXCJtYXhMb29wXCI6IDEgfTtcclxuXHJcbiAgICBtYXhMb29wOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbiBtZXRob2QuIFxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmdzIHBhcmFtZXRlcnM6XHJcbiAgICAgKlxyXG4gICAgICogLSAqKm1heExvb3AqKiAoKkludGVnZXIqKSBNYXhpbXVtIG51bWJlciBvZiByZXBldGl0aW9ucy5cclxuICAgICAqIC0gKipjaGlsZCoqICgqQmFzZU5vZGUqKSBUaGUgY2hpbGQgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgT2JqZWN0IHdpdGggcGFyYW1ldGVycy5cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XHJcblxyXG4gICAgICAgIGlmICghcGFyYW1zLm1heExvb3ApIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJtYXhMb29wIHBhcmFtZXRlciBpbiBMaW1pdGVyIGRlY29yYXRvciBpcyBhbiBvYmxpZ2F0b3J5IFwiICtcclxuICAgICAgICAgICAgXCJwYXJhbWV0ZXJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWF4TG9vcCA9IHBhcmFtcy5tYXhMb29wO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbiBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIG9wZW5cclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgb3Blbih0aWNrOiBCM1RpY2spOiB2b2lkIHtcclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwiaVwiLCAwLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGljayBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm4ge0NvbnN0YW50fSBBIHN0YXRlIGNvbnN0YW50LlxyXG4gICAgICovXHJcbiAgICB0aWNrKHRpY2s6IEIzVGljayk6IEIzU3RhdGUge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjMuRVJST1I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaSA9IHRpY2suYmxhY2tib2FyZC5nZXQoXCJpXCIsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcblxyXG4gICAgICAgIGlmIChpIDwgdGhpcy5tYXhMb29wKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB0aGlzLmNoaWxkLl9leGVjdXRlKHRpY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBiMy5TVUNDRVNTIHx8IHN0YXR1cyA9PSBiMy5GQUlMVVJFKVxyXG4gICAgICAgICAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcImlcIiwgaSArIDEsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGIzLkZBSUxVUkU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgTWF4VGltZSBkZWNvcmF0b3IgbGltaXRzIHRoZSBtYXhpbXVtIHRpbWUgdGhlIG5vZGUgY2hpbGQgY2FuIGV4ZWN1dGUuIFxyXG4gKiBOb3RpY2UgdGhhdCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIGV4ZWN1dGlvbiBpdHNlbGYgKGkuZS4sIHRoZSBjaGlsZCBcclxuICogbXVzdCBiZSBub24tcHJlZW1wdGl2ZSksIGl0IG9ubHkgaW50ZXJydXB0cyB0aGUgbm9kZSBhZnRlciBhIGBSVU5OSU5HYCBcclxuICogc3RhdHVzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBNYXhUaW1lXHJcbiAqIEBleHRlbmRzIEIzRGVjb3JhdG9yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNNYXhUaW1lIGV4dGVuZHMgQjNEZWNvcmF0b3Ige1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSBuYW1lLiBEZWZhdWx0IHRvIGBNYXhUaW1lYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJNYXhUaW1lXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHRpdGxlLiBEZWZhdWx0IHRvIGBNYXggWFhtc2AuIFVzZWQgaW4gRWRpdG9yLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHRpdGxlID0gXCJNYXggPG1heFRpbWU+bXNcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgcGFyYW1ldGVycy5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBwYXJhbWV0ZXJzID0geyBcIm1heFRpbWVcIjogMCB9O1xyXG5cclxuICAgIG1heFRpbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5ncyBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqIC0gKiptYXhUaW1lKiogKCpJbnRlZ2VyKikgTWF4aW11bSB0aW1lIGEgY2hpbGQgY2FuIGV4ZWN1dGUuXHJcbiAgICAgKiAtICoqY2hpbGQqKiAoKkJhc2VOb2RlKikgVGhlIGNoaWxkIG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBpbml0aWFsaXplXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIE9iamVjdCB3aXRoIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1zOiBhbnkpIHtcclxuICAgICAgICBzdXBlcihwYXJhbXMpO1xyXG5cclxuICAgICAgICBpZiAoIXBhcmFtcy5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibWF4VGltZSBwYXJhbWV0ZXIgaW4gTWF4VGltZSBkZWNvcmF0b3IgaXMgYW4gb2JsaWdhdG9yeSBcIiArXHJcbiAgICAgICAgICAgIFwicGFyYW1ldGVyXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1heFRpbWUgPSBwYXJhbXMubWF4VGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW4gbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCBvcGVuXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIG9wZW4odGljazogQjNUaWNrKTogdm9pZCB7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcInN0YXJ0VGltZVwiLCBzdGFydFRpbWUsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEEgc3RhdGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiMy5FUlJPUjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjdXJyVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHRpY2suYmxhY2tib2FyZC5nZXQoXCJzdGFydFRpbWVcIiwgdGljay50cmVlLmlkLCB0aGlzLmlkKTtcclxuXHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuY2hpbGQuX2V4ZWN1dGUodGljayk7XHJcbiAgICAgICAgaWYgKGN1cnJUaW1lIC0gc3RhcnRUaW1lID4gdGhpcy5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiMy5GQUlMVVJFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGVhdFVudGlsRmFpbHVyZSBpcyBhIGRlY29yYXRvciB0aGF0IHJlcGVhdHMgdGhlIHRpY2sgc2lnbmFsIHVudGlsIHRoZSBcclxuICogbm9kZSBjaGlsZCByZXR1cm5zIGBGQUlMVVJFYCwgYFJVTk5JTkdgIG9yIGBFUlJPUmAuIE9wdGlvbmFsbHksIGEgbWF4aW11bSBcclxuICogbnVtYmVyIG9mIHJlcGV0aXRpb25zIGNhbiBiZSBkZWZpbmVkLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBSZXBlYXRVbnRpbEZhaWx1cmVcclxuICogQGV4dGVuZHMgQjNEZWNvcmF0b3JcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM1JlcGVhdFVudGlsRmFpbHVyZSBleHRlbmRzIEIzRGVjb3JhdG9yIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgUmVwZWF0VW50aWxGYWlsdXJlYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJSZXBlYXRVbnRpbEZhaWx1cmVcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgdGl0bGUuIERlZmF1bHQgdG8gYFJlcGVhdCBVbnRpbCBGYWlsdXJlYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aXRsZSA9IFwiUmVwZWF0IFVudGlsIEZhaWx1cmVcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgcGFyYW1ldGVycy5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBwYXJhbWV0ZXJzID0geyBcIm1heExvb3BcIjogLTEgfTtcclxuXHJcbiAgICBtYXhMb29wOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbiBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZ3MgcGFyYW1ldGVyczpcclxuICAgICAqXHJcbiAgICAgKiAtICoqbWF4TG9vcCoqICgqSW50ZWdlciopIE1heGltdW0gbnVtYmVyIG9mIHJlcGV0aXRpb25zLiBEZWZhdWx0IHRvIC0xIFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5maW5pdGUpLlxyXG4gICAgICogLSAqKmNoaWxkKiogKCpCYXNlTm9kZSopIFRoZSBjaGlsZCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBPYmplY3Qgd2l0aCBwYXJhbWV0ZXJzLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtczogYW55KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcclxuICAgICAgICB0aGlzLm1heExvb3AgPSBwYXJhbXMubWF4TG9vcCB8fCAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW4gbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCBvcGVuXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIG9wZW4odGljazogQjNUaWNrKTogdm9pZCB7XHJcbiAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcImlcIiwgMCwgdGljay50cmVlLmlkLCB0aGlzLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpY2sgbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gQSBzdGF0ZSBjb25zdGFudC5cclxuICAgICAqL1xyXG4gICAgdGljayh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIzLkVSUk9SO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aWNrLmJsYWNrYm9hcmQuZ2V0KFwiaVwiLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIHZhciBzdGF0dXM6IEIzU3RhdGUgPSBiMy5FUlJPUjtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubWF4TG9vcCA8IDAgfHwgaSA8IHRoaXMubWF4TG9vcCkge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSB0aGlzLmNoaWxkLl9leGVjdXRlKHRpY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBiMy5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaSA9IHRpY2suYmxhY2tib2FyZC5zZXQoXCJpXCIsIGksIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGVhdFVudGlsU3VjY2VzcyBpcyBhIGRlY29yYXRvciB0aGF0IHJlcGVhdHMgdGhlIHRpY2sgc2lnbmFsIHVudGlsIHRoZSBcclxuICogbm9kZSBjaGlsZCByZXR1cm5zIGBTVUNDRVNTYCwgYFJVTk5JTkdgIG9yIGBFUlJPUmAuIE9wdGlvbmFsbHksIGEgbWF4aW11bSBcclxuICogbnVtYmVyIG9mIHJlcGV0aXRpb25zIGNhbiBiZSBkZWZpbmVkLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBSZXBlYXRVbnRpbFN1Y2Nlc3NcclxuICogQGV4dGVuZHMgQjNEZWNvcmF0b3JcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM1JlcGVhdFVudGlsU3VjY2VzcyBleHRlbmRzIEIzRGVjb3JhdG9yIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgUmVwZWF0VW50aWxTdWNjZXNzYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJSZXBlYXRVbnRpbFN1Y2Nlc3NcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgdGl0bGUuIERlZmF1bHQgdG8gYFJlcGVhdCBVbnRpbCBTdWNjZXNzYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aXRsZSA9IFwiUmVwZWF0IFVudGlsIFN1Y2Nlc3NcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgcGFyYW1ldGVycy5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBwYXJhbWV0ZXJzID0geyBcIm1heExvb3BcIjogLTEgfTtcclxuXHJcbiAgICBtYXhMb29wOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbiBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZ3MgcGFyYW1ldGVyczpcclxuICAgICAqXHJcbiAgICAgKiAtICoqbWF4TG9vcCoqICgqSW50ZWdlciopIE1heGltdW0gbnVtYmVyIG9mIHJlcGV0aXRpb25zLiBEZWZhdWx0IHRvIC0xIFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5maW5pdGUpLlxyXG4gICAgICogLSAqKmNoaWxkKiogKCpCYXNlTm9kZSopIFRoZSBjaGlsZCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBPYmplY3Qgd2l0aCBwYXJhbWV0ZXJzLlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtczogYW55KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcclxuICAgICAgICB0aGlzLm1heExvb3AgPSBwYXJhbXMubWF4TG9vcCB8fCAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW4gbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCBvcGVuXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIG9wZW4odGljazogQjNUaWNrKTogdm9pZCB7XHJcbiAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcImlcIiwgMCwgdGljay50cmVlLmlkLCB0aGlzLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpY2sgbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gQSBzdGF0ZSBjb25zdGFudC5cclxuICAgICAqL1xyXG4gICAgdGljayh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIzLkVSUk9SO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aWNrLmJsYWNrYm9hcmQuZ2V0KFwiaVwiLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIHZhciBzdGF0dXM6IEIzU3RhdGUgPSBiMy5FUlJPUjtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubWF4TG9vcCA8IDAgfHwgaSA8IHRoaXMubWF4TG9vcCkge1xyXG4gICAgICAgICAgICBzdGF0dXMgPSB0aGlzLmNoaWxkLl9leGVjdXRlKHRpY2spO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBiMy5GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaSA9IHRpY2suYmxhY2tib2FyZC5zZXQoXCJpXCIsIGksIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGVhdGVyIGlzIGEgZGVjb3JhdG9yIHRoYXQgcmVwZWF0cyB0aGUgdGljayBzaWduYWwgdW50aWwgdGhlIGNoaWxkIG5vZGUgXHJcbiAqIHJldHVybiBgUlVOTklOR2Agb3IgYEVSUk9SYC4gT3B0aW9uYWxseSwgYSBtYXhpbXVtIG51bWJlciBvZiByZXBldGl0aW9ucyBcclxuICogY2FuIGJlIGRlZmluZWQuXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIFJlcGVhdGVyXHJcbiAqIEBleHRlbmRzIEIzRGVjb3JhdG9yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNSZXBlYXRlciBleHRlbmRzIEIzRGVjb3JhdG9yIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgUmVwZWF0ZXJgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIlJlcGVhdGVyXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHRpdGxlLiBEZWZhdWx0IHRvIGBSZXBlYXQgWFh4YC4gVXNlZCBpbiBFZGl0b3IuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgdGl0bGUgPSBcIlJlcGVhdCA8bWF4TG9vcD54XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcGFyYW1ldGVycyA9IHsgXCJtYXhMb29wXCI6IC0xIH07XHJcblxyXG4gICAgbWF4TG9vcDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24gbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmdzIHBhcmFtZXRlcnM6XHJcbiAgICAgKlxyXG4gICAgICogLSAqKm1heExvb3AqKiAoKkludGVnZXIqKSBNYXhpbXVtIG51bWJlciBvZiByZXBldGl0aW9ucy4gRGVmYXVsdCB0byAtMSBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZmluaXRlKS5cclxuICAgICAqIC0gKipjaGlsZCoqICgqQmFzZU5vZGUqKSBUaGUgY2hpbGQgbm9kZS5cclxuICAgICAqIFxyXG4gICAgICogQG1ldGhvZCBpbml0aWFsaXplXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIE9iamVjdCB3aXRoIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1zOiBhbnkpIHtcclxuICAgICAgICBzdXBlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMubWF4TG9vcCA9IHBhcmFtcy5tYXhMb29wIHx8IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbiBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIG9wZW5cclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgb3Blbih0aWNrOiBCM1RpY2spOiB2b2lkIHtcclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwiaVwiLCAwLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGljayBtZXRob2QuXHJcbiAgICAgKiBAbWV0aG9kIHRpY2tcclxuICAgICAqIEBwYXJhbSB0aWNrIEEgdGljayBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGljayh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIzLkVSUk9SO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSB0aWNrLmJsYWNrYm9hcmQuZ2V0KFwiaVwiLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIHZhciBzdGF0dXM6IEIzU3RhdGUgPSBiMy5TVUNDRVNTO1xyXG5cclxuICAgICAgICB3aGlsZSAodGhpcy5tYXhMb29wIDwgMCB8fCBpIDwgdGhpcy5tYXhMb29wKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9IHRoaXMuY2hpbGQuX2V4ZWN1dGUodGljayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09IGIzLlNVQ0NFU1MgfHwgc3RhdHVzID09IGIzLkZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aWNrLmJsYWNrYm9hcmQuc2V0KFwiaVwiLCBpLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFjdGlvbiBub2RlIHJldHVybnMgYEVSUk9SYCBhbHdheXMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgYjNcclxuICogQGNsYXNzIEVycm9yXHJcbiAqIEBleHRlbmRzIEIzQWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNFcnJvciBleHRlbmRzIEIzQWN0aW9uIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgRXJyb3JgLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIG5hbWUgPSBcIkVycm9yXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEFsd2F5cyByZXR1cm4gYGIzLkVSUk9SYC5cclxuICAgICAqL1xyXG4gICAgdGljayh0aWNrOiBCM1RpY2spOiBCM1N0YXRlIHtcclxuICAgICAgICByZXR1cm4gYjMuRVJST1I7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFjdGlvbiBub2RlIHJldHVybnMgYEZBSUxVUkVgIGFsd2F5cy5cclxuICpcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgRmFpbGVyXHJcbiAqIEBleHRlbmRzIEIzQWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNGYWlsZXIgZXh0ZW5kcyBCM0FjdGlvbiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIERlZmF1bHQgdG8gYEZhaWxlcmAuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgbmFtZSA9IFwiRmFpbGVyXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEFsd2F5cyByZXR1cm4gYGIzLkZBSUxVUkVgLlxyXG4gICAgICovXHJcbiAgICB0aWNrKHRpY2s6IEIzVGljayk6IEIzU3RhdGUge1xyXG4gICAgICAgIHJldHVybiBiMy5GQUlMVVJFO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBhY3Rpb24gbm9kZSByZXR1cm5zIFJVTk5JTkcgYWx3YXlzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBSdW5uZXJcclxuICogQGV4dGVuZHMgQjNBY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCM1J1bm5lciBleHRlbmRzIEIzQWN0aW9uIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vZGUgbmFtZS4gRGVmYXVsdCB0byBgUnVubmVyYC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJSdW5uZXJcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpY2sgbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCB0aWNrXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtDb25zdGFudH0gQWx3YXlzIHJldHVybiBgYjMuUlVOTklOR2AuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgcmV0dXJuIGIzLlJVTk5JTkc7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFjdGlvbiBub2RlIHJldHVybnMgYFNVQ0NFU1NgIGFsd2F5cy5cclxuICpcclxuICogQG1vZHVsZSBiM1xyXG4gKiBAY2xhc3MgU3VjY2VlZGVyXHJcbiAqIEBleHRlbmRzIEIzQWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNTdWNjZWVkZXIgZXh0ZW5kcyBCM0FjdGlvbiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIG5hbWUuIERlZmF1bHQgdG8gYFN1Y2NlZWRlcmAuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgbmFtZSA9IFwiU3VjY2VlZGVyXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEFsd2F5cyByZXR1cm4gYGIzLlNVQ0NFU1NgLlxyXG4gICAgICovXHJcbiAgICB0aWNrKHRpY2s6IEIzVGljayk6IEIzU3RhdGUge1xyXG4gICAgICAgIHJldHVybiBiMy5TVUNDRVNTO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogV2FpdCBhIGZldyBzZWNvbmRzLlxyXG4gKlxyXG4gKiBAbW9kdWxlIGIzXHJcbiAqIEBjbGFzcyBXYWl0XHJcbiAqIEBleHRlbmRzIEIzQWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQjNXYWl0IGV4dGVuZHMgQjNBY3Rpb24ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9kZSBuYW1lLiBEZWZhdWx0IHRvIGBXYWl0YC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBuYW1lID0gXCJXYWl0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHRpdGxlLiBEZWZhdWx0IHRvIGBXYWl0IFhYbXNgLiBVc2VkIGluIEVkaXRvci5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICB0aXRsZSA9IFwiV2FpdCA8bWlsbGlzZWNvbmRzPm1zXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2RlIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgcGFyYW1ldGVycyA9IHsgXCJtaWxsaXNlY29uZHNcIjogMCB9O1xyXG5cclxuICAgIGVuZFRpbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5ncyBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqIC0gKiptaWxsaXNlY29uZHMqKiAoKkludGVnZXIqKSBNYXhpbXVtIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgYSBjaGlsZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbiBleGVjdXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIE9iamVjdCB3aXRoIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M/OiB7IG1pbGxpc2Vjb25kcz86IG51bWJlcjsgfSkge1xyXG4gICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XHJcblxyXG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBzZXR0aW5ncy5taWxsaXNlY29uZHMgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW4gbWV0aG9kLlxyXG4gICAgICogQG1ldGhvZCBvcGVuXHJcbiAgICAgKiBAcGFyYW0gdGljayBBIHRpY2sgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIG9wZW4odGljazogQjNUaWNrKTogdm9pZCB7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGljay5ibGFja2JvYXJkLnNldChcInN0YXJ0VGltZVwiLCBzdGFydFRpbWUsIHRpY2sudHJlZS5pZCwgdGhpcy5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWNrIG1ldGhvZC5cclxuICAgICAqIEBtZXRob2QgdGlja1xyXG4gICAgICogQHBhcmFtIHRpY2sgQSB0aWNrIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IEEgc3RhdGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIHRpY2sodGljazogQjNUaWNrKTogQjNTdGF0ZSB7XHJcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgc3RhcnRUaW1lID0gdGljay5ibGFja2JvYXJkLmdldChcInN0YXJ0VGltZVwiLCB0aWNrLnRyZWUuaWQsIHRoaXMuaWQpO1xyXG5cclxuICAgICAgICBpZiAoY3VyclRpbWUgLSBzdGFydFRpbWUgPiB0aGlzLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIzLlNVQ0NFU1M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYjMuUlVOTklORztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIOihjOS4uuagkXJ1bnRpbWVcclxuICogLSBodHRwczovL2dpdGh1Yi5jb20vYmVoYXZpb3IzL2JlaGF2aW9yM2pzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBiMyB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZFUlNJT04gPSBcIjAuMi4wXCI7XHJcblxyXG4gICAgLy8gUmV0dXJuaW5nIHN0YXR1c1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBTVUNDRVNTID0gQjNTdGF0ZS5TVUNDRVNTO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBGQUlMVVJFID0gQjNTdGF0ZS5GQUlMVVJFO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBSVU5OSU5HID0gQjNTdGF0ZS5SVU5OSU5HO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBFUlJPUiA9IEIzU3RhdGUuRVJST1I7XHJcblxyXG4gICAgLy8gTm9kZSBjYXRlZ29yaWVzXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTVBPU0lURSA9IFwiY29tcG9zaXRlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFQ09SQVRPUiA9IFwiZGVjb3JhdG9yXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFDVElPTiA9IFwiYWN0aW9uXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENPTkRJVElPTiA9IFwiY29uZGl0aW9uXCI7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBCZWhhdmlvclRyZWUgPSBCM0JlaGF2aW9yVHJlZTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgVGljayA9IEIzVGljaztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQmxhY2tib2FyZCA9IEIzQmxhY2tib2FyZDtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQmFzZU5vZGUgPSBCM0Jhc2VOb2RlO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBY3Rpb24gPSBCM0FjdGlvbjtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ29tcG9zaXRlID0gQjNDb21wb3NpdGU7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENvbmRpdGlvbiA9IEIzQ29uZGl0aW9uO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBEZWNvcmF0b3IgPSBCM0RlY29yYXRvcjtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTWVtUHJpb3JpdHkgPSBCM01lbVByaW9yaXR5O1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBNZW1TZXF1ZW5jZSA9IEIzTWVtU2VxdWVuY2U7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFByaW9yaXR5ID0gQjNQcmlvcml0eTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU2VxdWVuY2UgPSBCM1NlcXVlbmNlO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBJbnZlcnRlciA9IEIzSW52ZXJ0ZXI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IExpbWl0ZXIgPSBCM0xpbWl0ZXI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1heFRpbWUgPSBCM01heFRpbWU7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJlcGVhdFVudGlsRmFpbHVyZSA9IEIzUmVwZWF0VW50aWxGYWlsdXJlO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBSZXBlYXRVbnRpbFN1Y2Nlc3MgPSBCM1JlcGVhdFVudGlsU3VjY2VzcztcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUmVwZWF0ZXIgPSBCM1JlcGVhdGVyO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBFcnJvciA9IEIzRXJyb3I7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEZhaWxlciA9IEIzRmFpbGVyO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBSdW5uZXIgPSBCM1J1bm5lcjtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU3VjY2VlZGVyID0gQjNTdWNjZWVkZXI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFdhaXQgPSBCM1dhaXQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHVuaXF1ZSBJRHMgZm9yIHRyZWVzIGFuZCBub2Rlcy5cclxuICAgICAqIFxyXG4gICAgICogKGNvbnN1bHQgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQpLlxyXG4gICAgICpcclxuICAgICAqIEBjbGFzcyBjcmVhdGVVVUlEXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgdW5pcXVlIElELlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVVVSUQoKTogc3RyaW5nIHtcclxuICAgICAgICB2YXIgcyA9IFtdO1xyXG4gICAgICAgIHZhciBoZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM2OyBpKyspIHtcclxuICAgICAgICAgICAgc1tpXSA9IGhleERpZ2l0cy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMCksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBiaXRzIDEyLTE1IG9mIHRoZSB0aW1lX2hpX2FuZF92ZXJzaW9uIGZpZWxkIHRvIDAwMTBcclxuICAgICAgICBzWzE0XSA9IFwiNFwiO1xyXG5cclxuICAgICAgICAvLyBiaXRzIDYtNyBvZiB0aGUgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZCB0byAwMVxyXG4gICAgICAgIHNbMTldID0gaGV4RGlnaXRzLnN1YnN0cigoc1sxOV0gJiAweDMpIHwgMHg4LCAxKTtcclxuXHJcbiAgICAgICAgc1s4XSA9IHNbMTNdID0gc1sxOF0gPSBzWzIzXSA9IFwiLVwiO1xyXG5cclxuICAgICAgICB2YXIgdXVpZCA9IHMuam9pbihcIlwiKTtcclxuICAgICAgICByZXR1cm4gdXVpZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIGlzIGEgbWV0YS1mYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBjbGFzc2VzIGluIEphdmFTY3JpcHQuIEl0IGlzIGFcclxuICAgICAqIHNob3J0Y3V0IGZvciB0aGUgQ3JlYXRlSlMgc3ludGF4IHN0eWxlLiBCeSBkZWZhdWx0LCB0aGUgY2xhc3MgY3JlYXRlZCBieSBcclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaGF2ZSBhbiBpbml0aWFsaXplIGZ1bmN0aW9uICh0aGUgY29uc3RydWN0b3IpLiBPcHRpb25hbGx5LCBcclxuICAgICAqIHlvdSBjYW4gc3BlY2lmeSB0aGUgaW5oZXJpdGFuY2UgYnkgcGFzc2luZyBhbm90aGVyIGNsYXNzIGFzIHBhcmFtZXRlci5cclxuICAgICAqIFxyXG4gICAgICogQnkgZGVmYXVsdCwgYWxsIGNsYXNzZXMgY3JlYXRlZCB1c2luZyB0aGlzIGZ1bmN0aW9uLCBtYXkgcmVjZWl2ZSBvbmx5IGFcclxuICAgICAqIGRpY3Rpb25hcnkgcGFyYW1ldGVyIGFzIGFyZ3VtZW50LiBUaGlzIHBhdHRlcm4gaXMgY29tbW9ubHkgdXNlZCBieSBqUXVlcnkgXHJcbiAgICAgKiBhbmQgaXRzIHBsdWdpbnMuXHJcbiAgICAgKlxyXG4gICAgICogU2luY2UgMC4yLjAsIENsYXNzIGFsc28gcmVjZWl2ZXMgYSBgcHJvcGVydGllc2AgcGFyYW1ldGVyLCBhIGRpY3Rpb25hcnlcclxuICAgICAqIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBmaWxsIHRoZSBuZXcgY2xhc3MgcHJvdG90eXBlLlxyXG4gICAgICpcclxuICAgICAqIFVzYWdlXHJcbiAgICAgKiAtLS0tLVxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBDcmVhdGluZyBhIHNpbXBsZSBjbGFzc1xyXG4gICAgICogICAgIHZhciBCYXNlQ2xhc3MgPSBiMy5DbGFzcygpO1xyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgQ2hpbGRDbGFzcyA9IGIzLkNsYXNzKEJhc2VDbGFzcywge1xyXG4gICAgICogICAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAqICAgICAgIGluaXRpYWxpemUocGFyYW1zKSB7XHJcbiAgICAgKiAgICAgICBcclxuICAgICAqICAgICAgICAgLy8gY2FsbCBzdXBlciBpbml0aWFsaXplXHJcbiAgICAgKiAgICAgICAgIEJhc2VDbGFzcy5pbml0aWFsaXplLmNhbGwodGhpcywgcGFyYW1zKTtcclxuICAgICAqICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogQGNsYXNzIENsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYmFzZUNsYXNzIFRoZSBzdXBlciBjbGFzcy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEEgZGljdGlvbmFyeSB3aXRoIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMuXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENsYXNzKGJhc2VDbGFzcywgcHJvcGVydGllcz8pOiAocGFyYW1zOiBhbnkpID0+IHZvaWQge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBjbGFzc1xyXG4gICAgICAgIHZhciBjbHMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShwYXJhbXMgfHwge30pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGlmIGJhc2UgY2xhc3MgaXMgcHJvdmlkZWQsIGluaGVyaXRcclxuICAgICAgICBpZiAoYmFzZUNsYXNzKSB7XHJcbiAgICAgICAgICAgIGNscy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VDbGFzcy5wcm90b3R5cGUpO1xyXG4gICAgICAgICAgICBjbHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGluaXRpYWxpemUgaWYgZG9lcyBub3QgZXhpc3Qgb24gYmFzZUNsYXNzXHJcbiAgICAgICAgaWYgKCFjbHMucHJvdG90eXBlLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgY2xzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29weSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNscy5wcm90b3R5cGVba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNscztcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/runtime/EnumIndex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b97e7qLS85Nwpj6s7wRd8NN', 'EnumIndex');
// scripts/common/runtime/EnumIndex.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EGameStatus = void 0;
var EGameStatus;
(function (EGameStatus) {
    EGameStatus["START"] = "START";
    EGameStatus["END"] = "END";
})(EGameStatus = exports.EGameStatus || (exports.EGameStatus = {}));

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxydW50aW1lXFxFbnVtSW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBWSxXQUdYO0FBSEQsV0FBWSxXQUFXO0lBQ25CLDhCQUFlLENBQUE7SUFDZiwwQkFBVyxDQUFBO0FBQ2YsQ0FBQyxFQUhXLFdBQVcsR0FBWCxtQkFBVyxLQUFYLG1CQUFXLFFBR3RCIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiXHJcblxyXG5leHBvcnQgZW51bSBFR2FtZVN0YXR1cyB7XHJcbiAgICBTVEFSVCA9IFwiU1RBUlRcIixcclxuICAgIEVORCA9IFwiRU5EXCIsXHJcbn0iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/PhysicsController.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '017643KzK1BHIp4utqzkkFO', 'PhysicsController');
// scripts/common/util/PhysicsController.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var PhysicsController = /** @class */ (function (_super) {
    __extends(PhysicsController, _super);
    function PhysicsController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.enablePhysics = false;
        _this.enableCollision = false;
        _this.drawCollision = false;
        return _this;
    }
    PhysicsController.prototype.onLoad = function () {
        this.setPhysicsStatus(this.enablePhysics);
        this.setCollisionStatus(this.enableCollision);
        this.setCollisionDrawStatus(this.drawCollision);
    };
    /**
     * 设置物理引擎开启状态
     * @param enable {boolean} 是否开启物理引擎
     */
    PhysicsController.prototype.setPhysicsStatus = function (enable) {
        cc.director.getPhysicsManager().enabled = enable;
    };
    /**
     * 设置碰撞检测开启状态
     * @param enable {boolean} 是否开启碰撞检测
     */
    PhysicsController.prototype.setCollisionStatus = function (enable) {
        cc.director.getCollisionManager().enabled = enable;
    };
    /**
     * 设置碰撞绘制状态
     * @param enable {boolean} 是否绘制碰撞框
     */
    PhysicsController.prototype.setCollisionDrawStatus = function (enable) {
        cc.director.getCollisionManager().enabledDebugDraw = enable;
    };
    __decorate([
        property({ tooltip: "是否开启物理" })
    ], PhysicsController.prototype, "enablePhysics", void 0);
    __decorate([
        property({ tooltip: "是否开启碰撞检测" })
    ], PhysicsController.prototype, "enableCollision", void 0);
    __decorate([
        property({ tooltip: "是否绘制碰撞框" })
    ], PhysicsController.prototype, "drawCollision", void 0);
    PhysicsController = __decorate([
        ccclass
    ], PhysicsController);
    return PhysicsController;
}(cc.Component));
exports.default = PhysicsController;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxQaHlzaWNzQ29udHJvbGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTSxJQUFBLEtBQXdCLEVBQUUsQ0FBQyxVQUFVLEVBQW5DLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBa0IsQ0FBQztBQUc1QztJQUErQyxxQ0FBWTtJQUEzRDtRQUFBLHFFQXVDQztRQXJDRyxtQkFBYSxHQUFZLEtBQUssQ0FBQztRQUcvQixxQkFBZSxHQUFZLEtBQUssQ0FBQztRQUdqQyxtQkFBYSxHQUFZLEtBQUssQ0FBQzs7SUErQm5DLENBQUM7SUE3Qkcsa0NBQU0sR0FBTjtRQUNJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCw0Q0FBZ0IsR0FBaEIsVUFBaUIsTUFBZTtRQUM1QixFQUFFLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztJQUNyRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsOENBQWtCLEdBQWxCLFVBQW1CLE1BQWU7UUFDOUIsRUFBRSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7T0FHRztJQUNILGtEQUFzQixHQUF0QixVQUF1QixNQUFlO1FBQ2xDLEVBQUUsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7SUFDaEUsQ0FBQztJQXBDRDtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQzs0REFDRDtJQUcvQjtRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsQ0FBQzs4REFDRDtJQUdqQztRQURDLFFBQVEsQ0FBQyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQzs0REFDRjtJQVJkLGlCQUFpQjtRQURyQyxPQUFPO09BQ2EsaUJBQWlCLENBdUNyQztJQUFELHdCQUFDO0NBdkNELEFBdUNDLENBdkM4QyxFQUFFLENBQUMsU0FBUyxHQXVDMUQ7a0JBdkNvQixpQkFBaUIiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGh5c2ljc0NvbnRyb2xsZXIgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgQHByb3BlcnR5KHsgdG9vbHRpcDogXCLmmK/lkKblvIDlkK/niannkIZcIiB9KVxyXG4gICAgZW5hYmxlUGh5c2ljczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IFwi5piv5ZCm5byA5ZCv56Kw5pKe5qOA5rWLXCIgfSlcclxuICAgIGVuYWJsZUNvbGxpc2lvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIEBwcm9wZXJ0eSh7IHRvb2x0aXA6IFwi5piv5ZCm57uY5Yi256Kw5pKe5qGGXCIgfSlcclxuICAgIGRyYXdDb2xsaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBvbkxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRQaHlzaWNzU3RhdHVzKHRoaXMuZW5hYmxlUGh5c2ljcyk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xsaXNpb25TdGF0dXModGhpcy5lbmFibGVDb2xsaXNpb24pO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sbGlzaW9uRHJhd1N0YXR1cyh0aGlzLmRyYXdDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u54mp55CG5byV5pOO5byA5ZCv54q25oCBXHJcbiAgICAgKiBAcGFyYW0gZW5hYmxlIHtib29sZWFufSDmmK/lkKblvIDlkK/niannkIblvJXmk45cclxuICAgICAqL1xyXG4gICAgc2V0UGh5c2ljc1N0YXR1cyhlbmFibGU6IGJvb2xlYW4pIHtcclxuICAgICAgICBjYy5kaXJlY3Rvci5nZXRQaHlzaWNzTWFuYWdlcigpLmVuYWJsZWQgPSBlbmFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7norDmkp7mo4DmtYvlvIDlkK/nirbmgIFcclxuICAgICAqIEBwYXJhbSBlbmFibGUge2Jvb2xlYW59IOaYr+WQpuW8gOWQr+eisOaSnuajgOa1i1xyXG4gICAgICovXHJcbiAgICBzZXRDb2xsaXNpb25TdGF0dXMoZW5hYmxlOiBib29sZWFuKSB7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuZ2V0Q29sbGlzaW9uTWFuYWdlcigpLmVuYWJsZWQgPSBlbmFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7norDmkp7nu5jliLbnirbmgIFcclxuICAgICAqIEBwYXJhbSBlbmFibGUge2Jvb2xlYW59IOaYr+WQpue7mOWItueisOaSnuahhlxyXG4gICAgICovXHJcbiAgICBzZXRDb2xsaXNpb25EcmF3U3RhdHVzKGVuYWJsZTogYm9vbGVhbikge1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLmdldENvbGxpc2lvbk1hbmFnZXIoKS5lbmFibGVkRGVidWdEcmF3ID0gZW5hYmxlO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/EditorTool.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '50fe9qyZR5LgYuxXN3oK78x', 'EditorTool');
// scripts/common/util/EditorTool.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 编辑器工具类
 */
var EditorTool = /** @class */ (function () {
    function EditorTool() {
    }
    /**
     * 编辑器模式下加载资源
     * @param url db://assets/
     */
    EditorTool.load = function (url) {
        return new Promise(function (resolve, reject) {
            if (!CC_EDITOR) {
                resolve(null);
                return;
            }
            Editor.assetdb.queryUuidByUrl("db://assets/" + url, function (error, uuid) {
                if (error || !uuid) {
                    resolve(null);
                    cc.warn("[EditorTool.load] uuid\u67E5\u8BE2\u5931\u8D25 url: " + url);
                    return;
                }
                //@ts-ignore
                cc.resources.load({ type: "uuid", uuid: uuid }, function (error, result) {
                    if (error || !result) {
                        resolve(null);
                        cc.warn("[EditorTool.load] \u8D44\u6E90\u52A0\u8F7D\u5931\u8D25 url: " + url);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    };
    /**
     * 编辑器模式下设置ccclass的属性装饰器中的枚举值
     */
    EditorTool.setClassAttrPropEnum = function (ctor, propName, value) {
        if (!CC_EDITOR) {
            return;
        }
        cc.Class["Attr"].setClassAttr(ctor, propName, "enumList", value);
    };
    /**
     * 编辑器模式下刷新选中节点的属性检查器窗口
     * @param node 选中的节点
     */
    EditorTool.refreshSelectedInspector = function (node) {
        if (!CC_EDITOR) {
            return;
        }
        Editor.Utils.refreshSelectedInspector("node", node.uuid);
    };
    return EditorTool;
}());
exports.default = EditorTool;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxFZGl0b3JUb29sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSDtJQUFBO0lBa0RBLENBQUM7SUFqREc7OztPQUdHO0lBQ1csZUFBSSxHQUFsQixVQUFzQixHQUFXO1FBQzdCLE9BQU8sSUFBSSxPQUFPLENBQUksVUFBQyxPQUFPLEVBQUUsTUFBTTtZQUNsQyxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDZCxPQUFPO2FBQ1Y7WUFDRCxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxpQkFBZSxHQUFLLEVBQUUsVUFBQyxLQUFVLEVBQUUsSUFBWTtnQkFDekUsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQ2hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZCxFQUFFLENBQUMsSUFBSSxDQUFDLHlEQUFtQyxHQUFLLENBQUMsQ0FBQztvQkFDbEQsT0FBTztpQkFDVjtnQkFDRCxZQUFZO2dCQUNaLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsVUFBQyxLQUFVLEVBQUUsTUFBUztvQkFDbEUsSUFBSSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7d0JBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDZCxFQUFFLENBQUMsSUFBSSxDQUFDLGlFQUFpQyxHQUFLLENBQUMsQ0FBQzt3QkFDaEQsT0FBTztxQkFDVjtvQkFDRCxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3BCLENBQUMsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7T0FFRztJQUNXLCtCQUFvQixHQUFsQyxVQUFtQyxJQUFhLEVBQUUsUUFBZ0IsRUFBRSxLQUFjO1FBQzlFLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDWixPQUFPO1NBQ1Y7UUFDRCxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ1csbUNBQXdCLEdBQXRDLFVBQXVDLElBQWE7UUFDaEQsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNaLE9BQU87U0FDVjtRQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBQ0wsaUJBQUM7QUFBRCxDQWxEQSxBQWtEQyxJQUFBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIOe8lui+keWZqOW3peWFt+exu1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdG9yVG9vbCB7XHJcbiAgICAvKipcclxuICAgICAqIOe8lui+keWZqOaooeW8j+S4i+WKoOi9vei1hOa6kFxyXG4gICAgICogQHBhcmFtIHVybCBkYjovL2Fzc2V0cy9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2FkPFQ+KHVybDogc3RyaW5nKTogUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFDQ19FRElUT1IpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRWRpdG9yLmFzc2V0ZGIucXVlcnlVdWlkQnlVcmwoYGRiOi8vYXNzZXRzLyR7dXJsfWAsIChlcnJvcjogYW55LCB1dWlkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvciB8fCAhdXVpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2Mud2FybihgW0VkaXRvclRvb2wubG9hZF0gdXVpZOafpeivouWksei0pSB1cmw6ICR7dXJsfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgY2MucmVzb3VyY2VzLmxvYWQoeyB0eXBlOiBcInV1aWRcIiwgdXVpZDogdXVpZCB9LCAoZXJyb3I6IGFueSwgcmVzdWx0OiBUKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2Mud2FybihgW0VkaXRvclRvb2wubG9hZF0g6LWE5rqQ5Yqg6L295aSx6LSlIHVybDogJHt1cmx9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57yW6L6R5Zmo5qih5byP5LiL6K6+572uY2NjbGFzc+eahOWxnuaAp+ijhemlsOWZqOS4reeahOaemuS4vuWAvFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldENsYXNzQXR0clByb3BFbnVtKGN0b3I6IHVua25vd24sIHByb3BOYW1lOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFDQ19FRElUT1IpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy5DbGFzc1tcIkF0dHJcIl0uc2V0Q2xhc3NBdHRyKGN0b3IsIHByb3BOYW1lLCBcImVudW1MaXN0XCIsIHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8lui+keWZqOaooeW8j+S4i+WIt+aWsOmAieS4reiKgueCueeahOWxnuaAp+ajgOafpeWZqOeql+WPo1xyXG4gICAgICogQHBhcmFtIG5vZGUg6YCJ5Lit55qE6IqC54K5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVmcmVzaFNlbGVjdGVkSW5zcGVjdG9yKG5vZGU6IGNjLk5vZGUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIUNDX0VESVRPUikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEVkaXRvci5VdGlscy5yZWZyZXNoU2VsZWN0ZWRJbnNwZWN0b3IoXCJub2RlXCIsIG5vZGUudXVpZCk7XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/cmpt/base/Singleton.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '9fe50qokDpBJp9/BE0u0VTV', 'Singleton');
// scripts/common/cmpt/base/Singleton.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**单例 */
var Singleton = /** @class */ (function () {
    function Singleton() {
    }
    Singleton.getInstance = function () {
        if (this._instance === null) {
            this._instance = new this();
        }
        return this._instance;
    };
    Singleton._instance = null;
    return Singleton;
}());
exports.default = Singleton;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFxjbXB0XFxiYXNlXFxTaW5nbGV0b24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxRQUFRO0FBQ1I7SUFBQTtJQVNBLENBQUM7SUFOaUIscUJBQVcsR0FBekI7UUFDSSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssSUFBSSxFQUFFO1lBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQTtTQUM5QjtRQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQTtJQUN6QixDQUFDO0lBUGMsbUJBQVMsR0FBUSxJQUFJLENBQUE7SUFReEMsZ0JBQUM7Q0FURCxBQVNDLElBQUE7a0JBVG9CLFNBQVMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoq5Y2V5L6LICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbmdsZXRvbiB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2U6IGFueSA9IG51bGxcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlPFQ+KCk6IFQge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlXHJcbiAgICB9XHJcbn0iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Tween.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'c1812TWgDxL9rRQRBc+TfTK', 'Tween');
// scripts/common/util/Tween.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SCALE_TWEEN = exports.TWEEN = exports.VERSION = exports.Tween = exports.Sequence = exports.Interpolation = exports.Group = exports.Easing = void 0;
var Timer_1 = require("../cmpt/base/Timer");
/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
exports.Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - exports.Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return exports.Easing.Bounce.In(amount * 2) * 0.5;
            }
            return exports.Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};
var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
// if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
//     now = function () {
//         // eslint-disable-next-line
//         // @ts-ignore
//         var time = process.hrtime();
//         // Convert [seconds, nanoseconds] to milliseconds.
//         return time[0] * 1000 + time[1] / 1000000;
//     };
// }
// // In a browser, use self.performance.now if it is available.
// else 
if (typeof self !== "undefined" && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use "new Date().getTime()".
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.removeByCCObject = function (target) {
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return;
        }
        for (var i = 0; i < tweenIds.length; i++) {
            var tween = this._tweens[tweenIds[i]];
            if (tween && tween.ccObject === target) {
                tween.stop();
            }
        }
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) {
            time = now$1();
        }
        if (preserve === void 0) {
            preserve = false;
        }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // 检测tween绑定的cc.Object是否已经销毁，对应的tween也需销毁
        for (var i = 0; i < tweenIds.length; i++) {
            var tween = this._tweens[tweenIds[i]];
            if (tween && !tween.isCCObjectValid()) {
                tween.stop();
            }
        }
        tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());
exports.Group = Group;
/**
 * Tween.to中参数使用数组时应用
 */
exports.Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = exports.Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = exports.Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = exports.Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = exports.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};
/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());
exports.Sequence = Sequence;
var mainGroup = new Group();
/** 基于Timer.timeScale缩放速度 */
var scaleGroup = new Group();
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you"re awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) {
            _group = mainGroup;
        }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = exports.Easing.Linear.None;
        this._interpolationFunction = exports.Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Object.defineProperty(Tween.prototype, "ccObject", {
        get: function () { return this._ccObject; },
        enumerable: false,
        configurable: true
    });
    /**
     * 绑定cc.Object，则cc.Object销毁时，tween也会销毁
     */
    Tween.prototype.bindCCObject = function (obj) {
        this._ccObject = obj;
        return this;
    };
    /**
     * - 返回tween绑定的cc.Object是否可用
     * - 如果绑定了cc.Object，则检测tween绑定的cc.Object是否已经销毁，对应的tween也需销毁
     * - 如果没绑定则返回true
     */
    Tween.prototype.isCCObjectValid = function () {
        if (this._object instanceof cc.Object && !cc.isValid(this._object, true)) {
            return false;
        }
        if (this._ccObject instanceof cc.Object && !cc.isValid(this._ccObject, true)) {
            return false;
        }
        return true;
    };
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    /**
     * @param properties
     * @param duration ms
     */
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween"s to on each update. That way the behavior is opt-in (there"s
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    /**
     * @param time ms
     */
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // 对不同分组应用不同的默认参数
        if (time === void 0) {
            if (this._group === mainGroup) {
                time = Timer_1.default.gameMs;
            }
            else if (this._group === scaleGroup) {
                time = Timer_1.default.scaleGameMs;
            }
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === "string" ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? "array" : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn"t exist in the source object,
            // we should not set that property in the object
            if (propType === "undefined" || propType === "function") {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === "undefined") {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we"re using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) {
            time = now$1();
        }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) {
            time = now$1();
        }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    /**
     * tween结束之后额外的重复次数
     */
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _a = 0; _a < arguments.length; _a++) {
            tweens[_a] = arguments[_a];
        }
        //@ts-ignore
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) {
            time = now$1();
        }
        if (autoStart === void 0) {
            autoStart = true;
        }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === "string") {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don"t update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === "object" && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === "number") {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== "string") {
            return end;
        }
        if (end.charAt(0) === "+" || end.charAt(0) === "-") {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === "string") {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());
exports.Tween = Tween;
exports.VERSION = "18.6.4";
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
exports.TWEEN = mainGroup;
/**
 * 基于Timer.timeScale缩放速度的group
 */
exports.SCALE_TWEEN = scaleGroup;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxUd2Vlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0Q0FBdUM7QUFLdkM7O0dBRUc7QUFDUSxRQUFBLE1BQU0sR0FBRztJQUNoQixNQUFNLEVBQUU7UUFDSixJQUFJLEVBQUUsVUFBVSxNQUFNO1lBQ2xCLE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUM7S0FDSjtJQUNELFNBQVMsRUFBRTtRQUNQLEVBQUUsRUFBRSxVQUFVLE1BQU07WUFDaEIsT0FBTyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQzNCLENBQUM7UUFDRCxHQUFHLEVBQUUsVUFBVSxNQUFNO1lBQ2pCLE9BQU8sTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBQ2pDLENBQUM7UUFDRCxLQUFLLEVBQUUsVUFBVSxNQUFNO1lBQ25CLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNuQixPQUFPLEdBQUcsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO2FBQ2hDO1lBQ0QsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2hELENBQUM7S0FDSjtJQUNELEtBQUssRUFBRTtRQUNILEVBQUUsRUFBRSxVQUFVLE1BQU07WUFDaEIsT0FBTyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNwQyxDQUFDO1FBQ0QsR0FBRyxFQUFFLFVBQVUsTUFBTTtZQUNqQixPQUFPLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLENBQUM7UUFDRCxLQUFLLEVBQUUsVUFBVSxNQUFNO1lBQ25CLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNuQixPQUFP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dEQ7UUFDRCxPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFDRCxVQUFVLEVBQUUsVUFBVSxDQUFDLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0QixJQUFJLEVBQUUsR0FBRyxxQkFBYSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDeEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNQLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDckM7WUFDRCxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM5RTthQUNJO1lBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNQLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFB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LENBQUMsQ0FBQztTQUMxQjtJQUNMLENBQUM7SUFDRCx5Q0FBeUIsR0FBekIsVUFBMEIsUUFBUTtRQUM5QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6QyxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUM5QixJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNoRzthQUNJO1lBQ0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDakU7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNwQyxDQUFDO0lBQ0wsWUFBQztBQUFELENBdmNBLEFBdWNDLElBQUE7QUF2Y1ksc0JBQUs7QUF5Y1AsUUFBQSxPQUFPLEdBQUcsUUFBUSxDQUFDO0FBRTlCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFDN0I7Ozs7O0dBS0c7QUFDUSxRQUFBLEtBQUssR0FBRyxTQUFTLENBQUM7QUFDN0I7O0dBRUc7QUFDUSxRQUFBLFdBQVcsR0FBRyxVQUFVLENBQUMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGltZXIgZnJvbSBcIi4uL2NtcHQvYmFzZS9UaW1lclwiO1xyXG5cclxuZGVjbGFyZSB0eXBlIEVhc2luZ0Z1bmN0aW9uID0gKGFtb3VudDogbnVtYmVyKSA9PiBudW1iZXI7XHJcbmRlY2xhcmUgdHlwZSBJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAodjogbnVtYmVyW10sIGs6IG51bWJlcikgPT4gbnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCB0d2Vlbi5qcy5cclxuICovXHJcbmV4cG9ydCB2YXIgRWFzaW5nID0ge1xyXG4gICAgTGluZWFyOiB7XHJcbiAgICAgICAgTm9uZTogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgUXVhZHJhdGljOiB7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogKDIgLSBhbW91bnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tYW1vdW50ICogKGFtb3VudCAtIDIpIC0gMSk7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBDdWJpYzoge1xyXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKyAyKTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIFF1YXJ0aWM6IHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC0gLS1hbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGFtb3VudCAtPSAyKSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAtIDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgUXVpbnRpYzoge1xyXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0tYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICogYW1vdW50ICsgMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKiBhbW91bnQgKyAyKTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIFNpbnVzb2lkYWw6IHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKChhbW91bnQgKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbigoYW1vdW50ICogTWF0aC5QSSkgLyAyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEluT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBhbW91bnQpKTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxuICAgIEV4cG9uZW50aWFsOiB7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBhbW91bnQgLSAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBhbW91bnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChhbW91bnQgKj0gMikgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgYW1vdW50IC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGFtb3VudCAtIDEpKSArIDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgQ2lyY3VsYXI6IHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWFtb3VudCAqIGFtb3VudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoKGFtb3VudCAqPSAyKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gYW1vdW50ICogYW1vdW50KSAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoYW1vdW50IC09IDIpICogYW1vdW50KSArIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgRWxhc3RpYzoge1xyXG4gICAgICAgIEluOiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBPdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFtb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMCAqIGFtb3VudCkgKiBNYXRoLnNpbigoYW1vdW50IC0gMC4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBJbk91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbW91bnQgKj0gMjtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogTWF0aC5wb3coMiwgMTAgKiAoYW1vdW50IC0gMSkpICogTWF0aC5zaW4oKGFtb3VudCAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChhbW91bnQgLSAxKSkgKiBNYXRoLnNpbigoYW1vdW50IC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBCYWNrOiB7XHJcbiAgICAgICAgSW46IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xyXG4gICAgICAgICAgICByZXR1cm4gYW1vdW50ICogYW1vdW50ICogKChzICsgMSkgKiBhbW91bnQgLSBzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE91dDogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XHJcbiAgICAgICAgICAgIHJldHVybiAtLWFtb3VudCAqIGFtb3VudCAqICgocyArIDEpICogYW1vdW50ICsgcykgKyAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XHJcbiAgICAgICAgICAgIGlmICgoYW1vdW50ICo9IDIpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChhbW91bnQgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCAtIHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChhbW91bnQgLT0gMikgKiBhbW91bnQgKiAoKHMgKyAxKSAqIGFtb3VudCArIHMpICsgMik7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBCb3VuY2U6IHtcclxuICAgICAgICBJbjogZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMSAtIEVhc2luZy5Cb3VuY2UuT3V0KDEgLSBhbW91bnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgT3V0OiBmdW5jdGlvbiAoYW1vdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPCAxIC8gMi43NSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGFtb3VudCAqIGFtb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhbW91bnQgPCAyIC8gMi43NSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChhbW91bnQgLT0gMS41IC8gMi43NSkgKiBhbW91bnQgKyAwLjc1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFtb3VudCA8IDIuNSAvIDIuNzUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDIuMjUgLyAyLjc1KSAqIGFtb3VudCArIDAuOTM3NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoYW1vdW50IC09IDIuNjI1IC8gMi43NSkgKiBhbW91bnQgKyAwLjk4NDM3NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgSW5PdXQ6IGZ1bmN0aW9uIChhbW91bnQpIHtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA8IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuSW4oYW1vdW50ICogMikgKiAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEVhc2luZy5Cb3VuY2UuT3V0KGFtb3VudCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxufTtcclxuXHJcbnZhciBub3c7XHJcbi8vIEluY2x1ZGUgYSBwZXJmb3JtYW5jZS5ub3cgcG9seWZpbGwuXHJcbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbi8vIEB0cy1pZ25vcmVcclxuLy8gaWYgKHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuaHJ0aW1lKSB7XHJcbi8vICAgICBub3cgPSBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbi8vICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4vLyAgICAgICAgIHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcclxuLy8gICAgICAgICAvLyBDb252ZXJ0IFtzZWNvbmRzLCBuYW5vc2Vjb25kc10gdG8gbWlsbGlzZWNvbmRzLlxyXG4vLyAgICAgICAgIHJldHVybiB0aW1lWzBdICogMTAwMCArIHRpbWVbMV0gLyAxMDAwMDAwO1xyXG4vLyAgICAgfTtcclxuLy8gfVxyXG4vLyAvLyBJbiBhIGJyb3dzZXIsIHVzZSBzZWxmLnBlcmZvcm1hbmNlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXHJcbi8vIGVsc2UgXHJcbmlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gVGhpcyBtdXN0IGJlIGJvdW5kLCBiZWNhdXNlIGRpcmVjdGx5IGFzc2lnbmluZyB0aGlzIGZ1bmN0aW9uXHJcbiAgICAvLyBsZWFkcyB0byBhbiBpbnZvY2F0aW9uIGV4Y2VwdGlvbiBpbiBDaHJvbWUuXHJcbiAgICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xyXG59XHJcbi8vIFVzZSBEYXRlLm5vdyBpZiBpdCBpcyBhdmFpbGFibGUuXHJcbmVsc2UgaWYgKERhdGUubm93ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIG5vdyA9IERhdGUubm93O1xyXG59XHJcbi8vIE90aGVyd2lzZSwgdXNlIFwibmV3IERhdGUoKS5nZXRUaW1lKClcIi5cclxuZWxzZSB7XHJcbiAgICBub3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgfTtcclxufVxyXG52YXIgbm93JDEgPSBub3c7XHJcblxyXG5kZWNsYXJlIHR5cGUgVW5rbm93blByb3BzID0gUmVjb3JkPHN0cmluZywgYW55PjtcclxuLyoqXHJcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcclxuICpcclxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxyXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlblxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyb3VwIHtcclxuICAgIHByaXZhdGUgX3R3ZWVucyA9IHt9O1xyXG4gICAgcHJpdmF0ZSBfdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcclxuXHJcbiAgICBnZXRBbGwoKTogQXJyYXk8VHdlZW48VW5rbm93blByb3BzPj4ge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucykubWFwKGZ1bmN0aW9uICh0d2VlbklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdHdlZW5zW3R3ZWVuSWRdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xyXG4gICAgfVxyXG4gICAgYWRkKHR3ZWVuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldID0gdHdlZW47XHJcbiAgICAgICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcclxuICAgIH1cclxuICAgIHJlbW92ZSh0d2Vlbikge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQnlDQ09iamVjdCh0YXJnZXQ6IGNjLk9iamVjdCkge1xyXG4gICAgICAgIGxldCB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XHJcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR3ZWVuSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbjogVHdlZW48YW55PiA9IHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XHJcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiB0d2Vlbi5jY09iamVjdCA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodGltZT86IG51bWJlciwgcHJlc2VydmU/OiBib29sZWFuKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkgeyB0aW1lID0gbm93JDEoKTsgfVxyXG4gICAgICAgIGlmIChwcmVzZXJ2ZSA9PT0gdm9pZCAwKSB7IHByZXNlcnZlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgdHdlZW5JZHMgPSBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpO1xyXG4gICAgICAgIGlmICh0d2Vlbklkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5qOA5rWLdHdlZW7nu5HlrprnmoRjYy5PYmplY3TmmK/lkKblt7Lnu4/plIDmr4HvvIzlr7nlupTnmoR0d2VlbuS5n+mcgOmUgOavgVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHR3ZWVuOiBUd2Vlbjxhbnk+ID0gdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcclxuICAgICAgICAgICAgaWYgKHR3ZWVuICYmICF0d2Vlbi5pc0NDT2JqZWN0VmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgdHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XHJcbiAgICAgICAgaWYgKHR3ZWVuSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUd2VlbnMgYXJlIHVwZGF0ZWQgaW4gXCJiYXRjaGVzXCIuIElmIHlvdSBhZGQgYSBuZXcgdHdlZW4gZHVyaW5nIGFuXHJcbiAgICAgICAgLy8gdXBkYXRlLCB0aGVuIHRoZSBuZXcgdHdlZW4gd2lsbCBiZSB1cGRhdGVkIGluIHRoZSBuZXh0IGJhdGNoLlxyXG4gICAgICAgIC8vIElmIHlvdSByZW1vdmUgYSB0d2VlbiBkdXJpbmcgYW4gdXBkYXRlLCBpdCBtYXkgb3IgbWF5IG5vdCBiZSB1cGRhdGVkLlxyXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSByZW1vdmVkIHR3ZWVuIHdhcyBhZGRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2gsXHJcbiAgICAgICAgLy8gdGhlbiBpdCB3aWxsIG5vdCBiZSB1cGRhdGVkLlxyXG4gICAgICAgIHdoaWxlICh0d2Vlbklkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYXV0b1N0YXJ0ID0gIXByZXNlcnZlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuICYmIHR3ZWVuLnVwZGF0ZSh0aW1lLCBhdXRvU3RhcnQpID09PSBmYWxzZSAmJiAhcHJlc2VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUd2Vlbi50b+S4reWPguaVsOS9v+eUqOaVsOe7hOaXtuW6lOeUqFxyXG4gKi9cclxuZXhwb3J0IHZhciBJbnRlcnBvbGF0aW9uID0ge1xyXG4gICAgTGluZWFyOiBmdW5jdGlvbiAodiwgaykge1xyXG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xyXG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xyXG4gICAgICAgIGlmIChrIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4odlswXSwgdlsxXSwgZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4odlttXSwgdlttIC0gMV0sIG0gLSBmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xyXG4gICAgfSxcclxuICAgIEJlemllcjogZnVuY3Rpb24gKHYsIGspIHtcclxuICAgICAgICB2YXIgYiA9IDA7XHJcbiAgICAgICAgdmFyIG4gPSB2Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHB3ID0gTWF0aC5wb3c7XHJcbiAgICAgICAgdmFyIGJuID0gSW50ZXJwb2xhdGlvbi5VdGlscy5CZXJuc3RlaW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGIgKz0gcHcoMSAtIGssIG4gLSBpKSAqIHB3KGssIGkpICogdltpXSAqIGJuKG4sIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYjtcclxuICAgIH0sXHJcbiAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAodiwgaykge1xyXG4gICAgICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBmID0gbSAqIGs7XHJcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xyXG4gICAgICAgIHZhciBmbiA9IEludGVycG9sYXRpb24uVXRpbHMuQ2F0bXVsbFJvbTtcclxuICAgICAgICBpZiAodlswXSA9PT0gdlttXSkge1xyXG4gICAgICAgICAgICBpZiAoayA8IDApIHtcclxuICAgICAgICAgICAgICAgIGkgPSBNYXRoLmZsb29yKChmID0gbSAqICgxICsgaykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbMF0gLSAoZm4odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdlttXSAtIChmbih2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmbih2W2kgPyBpIC0gMSA6IDBdLCB2W2ldLCB2W20gPCBpICsgMSA/IG0gOiBpICsgMV0sIHZbbSA8IGkgKyAyID8gbSA6IGkgKyAyXSwgZiAtIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBVdGlsczoge1xyXG4gICAgICAgIExpbmVhcjogZnVuY3Rpb24gKHAwLCBwMSwgdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHAxIC0gcDApICogdCArIHAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQmVybnN0ZWluOiBmdW5jdGlvbiAobiwgaSkge1xyXG4gICAgICAgICAgICB2YXIgZmMgPSBJbnRlcnBvbGF0aW9uLlV0aWxzLkZhY3RvcmlhbDtcclxuICAgICAgICAgICAgcmV0dXJuIGZjKG4pIC8gZmMoaSkgLyBmYyhuIC0gaSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChhW25dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IDE7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgKj0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFbbl0gPSBzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkoKSxcclxuICAgICAgICBDYXRtdWxsUm9tOiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHQpIHtcclxuICAgICAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xyXG4gICAgICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XHJcbiAgICAgICAgICAgIHZhciB0MiA9IHQgKiB0O1xyXG4gICAgICAgICAgICB2YXIgdDMgPSB0ICogdDI7XHJcbiAgICAgICAgICAgIHJldHVybiAoMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSkgKiB0MyArICgtMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcclxuICAgICAgICB9LFxyXG4gICAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVdGlsc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlcXVlbmNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIF9uZXh0SWQgPSAwO1xyXG4gICAgc3RhdGljIG5leHRJZCgpIHtcclxuICAgICAgICByZXR1cm4gU2VxdWVuY2UuX25leHRJZCsrO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgbWFpbkdyb3VwID0gbmV3IEdyb3VwKCk7XHJcbi8qKiDln7rkuo5UaW1lci50aW1lU2NhbGXnvKnmlL7pgJ/luqYgKi9cclxudmFyIHNjYWxlR3JvdXAgPSBuZXcgR3JvdXAoKTtcclxuXHJcbi8qKlxyXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cclxuICogVGhhbmsgeW91IGFsbCwgeW91XCJyZSBhd2Vzb21lIVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFR3ZWVuPFQgZXh0ZW5kcyBVbmtub3duUHJvcHM+IHtcclxuICAgIC8qKiDnu5HlrprnmoRjYy5PYmplY3QgKi9cclxuICAgIHByaXZhdGUgX2NjT2JqZWN0O1xyXG4gICAgcHVibGljIGdldCBjY09iamVjdCgpIHsgcmV0dXJuIHRoaXMuX2NjT2JqZWN0OyB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb2JqZWN0O1xyXG4gICAgcHJpdmF0ZSBfZ3JvdXA7XHJcbiAgICBwcml2YXRlIF9pc1BhdXNlZDtcclxuICAgIHByaXZhdGUgX3BhdXNlU3RhcnQ7XHJcbiAgICBwcml2YXRlIF92YWx1ZXNTdGFydDtcclxuICAgIHByaXZhdGUgX3ZhbHVlc0VuZDtcclxuICAgIHByaXZhdGUgX3ZhbHVlc1N0YXJ0UmVwZWF0O1xyXG4gICAgcHJpdmF0ZSBfZHVyYXRpb247XHJcbiAgICBwcml2YXRlIF9pbml0aWFsUmVwZWF0O1xyXG4gICAgcHJpdmF0ZSBfcmVwZWF0O1xyXG4gICAgcHJpdmF0ZSBfcmVwZWF0RGVsYXlUaW1lPztcclxuICAgIHByaXZhdGUgX3lveW87XHJcbiAgICBwcml2YXRlIF9pc1BsYXlpbmc7XHJcbiAgICBwcml2YXRlIF9yZXZlcnNlZDtcclxuICAgIHByaXZhdGUgX2RlbGF5VGltZTtcclxuICAgIHByaXZhdGUgX3N0YXJ0VGltZTtcclxuICAgIHByaXZhdGUgX2Vhc2luZ0Z1bmN0aW9uO1xyXG4gICAgcHJpdmF0ZSBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uO1xyXG4gICAgcHJpdmF0ZSBfY2hhaW5lZFR3ZWVucztcclxuICAgIHByaXZhdGUgX29uU3RhcnRDYWxsYmFjaz87XHJcbiAgICBwcml2YXRlIF9vblN0YXJ0Q2FsbGJhY2tGaXJlZDtcclxuICAgIHByaXZhdGUgX29uVXBkYXRlQ2FsbGJhY2s/O1xyXG4gICAgcHJpdmF0ZSBfb25SZXBlYXRDYWxsYmFjaz87XHJcbiAgICBwcml2YXRlIF9vbkNvbXBsZXRlQ2FsbGJhY2s/O1xyXG4gICAgcHJpdmF0ZSBfb25TdG9wQ2FsbGJhY2s/O1xyXG4gICAgcHJpdmF0ZSBfaWQ7XHJcbiAgICBwcml2YXRlIF9pc0NoYWluU3RvcHBlZDtcclxuICAgIHByaXZhdGUgX2dvVG9FbmQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoX29iamVjdDogVCwgX2dyb3VwPzogR3JvdXAgfCBmYWxzZSkge1xyXG4gICAgICAgIGlmIChfZ3JvdXAgPT09IHZvaWQgMCkgeyBfZ3JvdXAgPSBtYWluR3JvdXA7IH1cclxuICAgICAgICB0aGlzLl9vYmplY3QgPSBfb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX2dyb3VwID0gX2dyb3VwO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnQgPSB7fTtcclxuICAgICAgICB0aGlzLl92YWx1ZXNFbmQgPSB7fTtcclxuICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMDtcclxuICAgICAgICB0aGlzLl9pbml0aWFsUmVwZWF0ID0gMDtcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3lveW8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlbGF5VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IEVhc2luZy5MaW5lYXIuTm9uZTtcclxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBJbnRlcnBvbGF0aW9uLkxpbmVhcjtcclxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gW107XHJcbiAgICAgICAgdGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pZCA9IFNlcXVlbmNlLm5leHRJZCgpO1xyXG4gICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57uR5a6aY2MuT2JqZWN077yM5YiZY2MuT2JqZWN06ZSA5q+B5pe277yMdHdlZW7kuZ/kvJrplIDmr4FcclxuICAgICAqL1xyXG4gICAgYmluZENDT2JqZWN0KG9iajogY2MuT2JqZWN0KTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fY2NPYmplY3QgPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAtIOi/lOWbnnR3ZWVu57uR5a6a55qEY2MuT2JqZWN05piv5ZCm5Y+v55SoXHJcbiAgICAgKiAtIOWmguaenOe7keWumuS6hmNjLk9iamVjdO+8jOWImeajgOa1i3R3ZWVu57uR5a6a55qEY2MuT2JqZWN05piv5ZCm5bey57uP6ZSA5q+B77yM5a+55bqU55qEdHdlZW7kuZ/pnIDplIDmr4FcclxuICAgICAqIC0g5aaC5p6c5rKh57uR5a6a5YiZ6L+U5ZuedHJ1ZVxyXG4gICAgICovXHJcbiAgICBpc0NDT2JqZWN0VmFsaWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdCBpbnN0YW5jZW9mIGNjLk9iamVjdCAmJiAhY2MuaXNWYWxpZCh0aGlzLl9vYmplY3QsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NjT2JqZWN0IGluc3RhbmNlb2YgY2MuT2JqZWN0ICYmICFjYy5pc1ZhbGlkKHRoaXMuX2NjT2JqZWN0LCB0cnVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldElkKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgfVxyXG4gICAgaXNQbGF5aW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1BsYXlpbmc7XHJcbiAgICB9XHJcbiAgICBpc1BhdXNlZCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0aWVzIFxyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIG1zXHJcbiAgICAgKi9cclxuICAgIHRvKHByb3BlcnRpZXM6IFVua25vd25Qcm9wcywgZHVyYXRpb24/OiBudW1iZXIpOiB0aGlzIHtcclxuICAgICAgICAvLyBUT0RPPyByZXN0b3JlIHRoaXMsIHRoZW4gdXBkYXRlIHRoZSAwN19keW5hbWljX3RvIGV4YW1wbGUgdG8gc2V0IGZveFxyXG4gICAgICAgIC8vIHR3ZWVuXCJzIHRvIG9uIGVhY2ggdXBkYXRlLiBUaGF0IHdheSB0aGUgYmVoYXZpb3IgaXMgb3B0LWluICh0aGVyZVwic1xyXG4gICAgICAgIC8vIGN1cnJlbnRseSBubyBvcHQtb3V0KS5cclxuICAgICAgICAvLyBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykgdGhpcy5fdmFsdWVzRW5kW3Byb3BdID0gcHJvcGVydGllc1twcm9wXVxyXG4gICAgICAgIHRoaXMuX3ZhbHVlc0VuZCA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcyk7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkdXJhdGlvbihkOiBudW1iZXIpOiB0aGlzIHtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB0aW1lIG1zXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KHRpbWU/OiBudW1iZXIpOiB0aGlzIHtcclxuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8g5a+55LiN5ZCM5YiG57uE5bqU55So5LiN5ZCM55qE6buY6K6k5Y+C5pWwXHJcbiAgICAgICAgaWYgKHRpbWUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZ3JvdXAgPT09IG1haW5Hcm91cCkge1xyXG4gICAgICAgICAgICAgICAgdGltZSA9IFRpbWVyLmdhbWVNcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ncm91cCA9PT0gc2NhbGVHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgdGltZSA9IFRpbWVyLnNjYWxlR2FtZU1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5hZGQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5faW5pdGlhbFJlcGVhdDtcclxuICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSByZXZlcnNlZCAoZi5lLiB1c2luZyB0aGUgeW95byBmZWF0dXJlKSB0aGVuIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgdHdlZW4gZGlyZWN0aW9uIGJhY2sgdG8gZm9yd2FyZC5cclxuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNDaGFpblN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyAodHlwZW9mIHRpbWUgPT09IFwic3RyaW5nXCIgPyBub3ckMSgpICsgcGFyc2VGbG9hdCh0aW1lKSA6IHRpbWUpIDogbm93JDEoKTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgKz0gdGhpcy5fZGVsYXlUaW1lO1xyXG4gICAgICAgIHRoaXMuX3NldHVwUHJvcGVydGllcyh0aGlzLl9vYmplY3QsIHRoaXMuX3ZhbHVlc1N0YXJ0LCB0aGlzLl92YWx1ZXNFbmQsIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIF9zZXR1cFByb3BlcnRpZXMoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCBfdmFsdWVzU3RhcnRSZXBlYXQpIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBfdmFsdWVzRW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlID0gX29iamVjdFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIHZhciBzdGFydFZhbHVlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciBwcm9wVHlwZSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gXCJhcnJheVwiIDogdHlwZW9mIHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBpc0ludGVycG9sYXRpb25MaXN0ID0gIXN0YXJ0VmFsdWVJc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICAvLyBJZiBgdG8oKWAgc3BlY2lmaWVzIGEgcHJvcGVydHkgdGhhdCBkb2VzblwidCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcclxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG5vdCBzZXQgdGhhdCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmIChwcm9wVHlwZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9wVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBBcnJheSB3YXMgcHJvdmlkZWQgYXMgcHJvcGVydHkgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRWYWx1ZXMgPSBfdmFsdWVzRW5kW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgYW4gYXJyYXkgb2YgcmVsYXRpdmUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZXMgPSBlbmRWYWx1ZXMubWFwKHRoaXMuX2hhbmRsZVJlbGF0aXZlVmFsdWUuYmluZCh0aGlzLCBzdGFydFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcclxuICAgICAgICAgICAgICAgIF92YWx1ZXNFbmRbcHJvcGVydHldID0gW3N0YXJ0VmFsdWVdLmNvbmNhdChlbmRWYWx1ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgZGVlcG5lc3Mgb2YgdGhlIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAoKHByb3BUeXBlID09PSBcIm9iamVjdFwiIHx8IHN0YXJ0VmFsdWVJc0FycmF5KSAmJiBzdGFydFZhbHVlICYmICFpc0ludGVycG9sYXRpb25MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldID0gc3RhcnRWYWx1ZUlzQXJyYXkgPyBbXSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xyXG4gICAgICAgICAgICAgICAgICAgIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV1bcHJvcF0gPSBzdGFydFZhbHVlW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWVJc0FycmF5ID8gW10gOiB7fTsgLy8gVE9ETz8gcmVwZWF0IG5lc3RlZCB2YWx1ZXM/IEFuZCB5b3lvPyBBbmQgYXJyYXkgdmFsdWVzP1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBQcm9wZXJ0aWVzKHN0YXJ0VmFsdWUsIF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0sIF92YWx1ZXNFbmRbcHJvcGVydHldLCBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHN0YXJ0aW5nIHZhbHVlLCBidXQgb25seSBvbmNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0VmFsdWVJc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cclxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRbcHJvcGVydHldICo9IDEuMDsgLy8gRW5zdXJlcyB3ZVwicmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0ludGVycG9sYXRpb25MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cclxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc0VuZFtwcm9wZXJ0eV0uc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RvcCgpOiB0aGlzIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhaW5TdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzQ2hhaW5TdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wQ2hhaW5lZFR3ZWVucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAgJiYgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uU3RvcENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uU3RvcENhbGxiYWNrKHRoaXMuX29iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZW5kKCk6IHRoaXMge1xyXG4gICAgICAgIHRoaXMuX2dvVG9FbmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKEluZmluaXR5KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHBhdXNlKHRpbWU/OiBudW1iZXIpOiB0aGlzIHtcclxuICAgICAgICBpZiAodGltZSA9PT0gdm9pZCAwKSB7IHRpbWUgPSBub3ckMSgpOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gdGltZTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICB0aGlzLl9ncm91cCAmJiB0aGlzLl9ncm91cC5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXN1bWUodGltZT86IG51bWJlcik6IHRoaXMge1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkIHx8ICF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lICs9IHRpbWUgLSB0aGlzLl9wYXVzZVN0YXJ0O1xyXG4gICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSAwO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHRoaXMuX2dyb3VwICYmIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHN0b3BDaGFpbmVkVHdlZW5zKCk6IHRoaXMge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ3JvdXAoZ3JvdXA6IEdyb3VwKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRlbGF5KGFtb3VudDogbnVtYmVyKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gYW1vdW50O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiB0d2Vlbue7k+adn+S5i+WQjumineWklueahOmHjeWkjeasoeaVsFxyXG4gICAgICovXHJcbiAgICByZXBlYXQodGltZXM6IG51bWJlcik6IHRoaXMge1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxSZXBlYXQgPSB0aW1lcztcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aW1lcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlcGVhdERlbGF5KGFtb3VudDogbnVtYmVyKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0RGVsYXlUaW1lID0gYW1vdW50O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgeW95byh5b3lvOiBib29sZWFuKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5feW95byA9IHlveW87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBlYXNpbmcoZWFzaW5nRnVuY3Rpb246IEVhc2luZ0Z1bmN0aW9uKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBlYXNpbmdGdW5jdGlvbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbkZ1bmN0aW9uOiBJbnRlcnBvbGF0aW9uRnVuY3Rpb24pOiB0aGlzIHtcclxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjaGFpbiguLi50d2VlbnM6IEFycmF5PFR3ZWVuPFVua25vd25Qcm9wcz4+KTogdGhpcyB7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgdmFyIHR3ZWVucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHR3ZWVuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gdHdlZW5zO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgb25TdGFydChjYWxsYmFjazogKG9iamVjdDogVCkgPT4gdm9pZCk6IHRoaXMge1xyXG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgb25VcGRhdGUoY2FsbGJhY2s6IChvYmplY3Q6IFQsIGVsYXBzZWQ6IG51bWJlcikgPT4gdm9pZCk6IHRoaXMge1xyXG4gICAgICAgIHRoaXMuX29uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG9uUmVwZWF0KGNhbGxiYWNrOiAob2JqZWN0OiBUKSA9PiB2b2lkKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fb25SZXBlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgb25Db21wbGV0ZShjYWxsYmFjazogKG9iamVjdDogVCkgPT4gdm9pZCk6IHRoaXMge1xyXG4gICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgb25TdG9wKGNhbGxiYWNrOiAob2JqZWN0OiBUKSA9PiB2b2lkKTogdGhpcyB7XHJcbiAgICAgICAgdGhpcy5fb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdlZW4gaXMgc3RpbGwgcGxheWluZyBhZnRlciB0aGUgdXBkYXRlLCBmYWxzZVxyXG4gICAgICogb3RoZXJ3aXNlIChjYWxsaW5nIHVwZGF0ZSBvbiBhIHBhdXNlZCB0d2VlbiBzdGlsbCByZXR1cm5zIHRydWUgYmVjYXVzZVxyXG4gICAgICogaXQgaXMgc3RpbGwgcGxheWluZywganVzdCBwYXVzZWQpLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUodGltZT86IG51bWJlciwgYXV0b1N0YXJ0PzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHsgdGltZSA9IG5vdyQxKCk7IH1cclxuICAgICAgICBpZiAoYXV0b1N0YXJ0ID09PSB2b2lkIDApIHsgYXV0b1N0YXJ0ID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5O1xyXG4gICAgICAgIHZhciBlbGFwc2VkO1xyXG4gICAgICAgIHZhciBlbmRUaW1lID0gdGhpcy5fc3RhcnRUaW1lICsgdGhpcy5fZHVyYXRpb247XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nb1RvRW5kICYmICF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWUgPiBlbmRUaW1lKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYXV0b1N0YXJ0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCh0aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ29Ub0VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vblN0YXJ0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFja0ZpcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgICAgIGVsYXBzZWQgPSB0aGlzLl9kdXJhdGlvbiA9PT0gMCB8fCBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Vhc2luZ0Z1bmN0aW9uKGVsYXBzZWQpO1xyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydGllcyh0aGlzLl9vYmplY3QsIHRoaXMuX3ZhbHVlc1N0YXJ0LCB0aGlzLl92YWx1ZXNFbmQsIHZhbHVlKTtcclxuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGVDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCwgZWxhcHNlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbGFwc2VkID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUodGhpcy5fcmVwZWF0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcclxuICAgICAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3lveW8gJiYgdHlwZW9mIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSArIHBhcnNlRmxvYXQodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXBFbmRTdGFydFJlcGVhdFZhbHVlcyhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl95b3lvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSAhdGhpcy5fcmV2ZXJzZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgdGhpcy5fcmVwZWF0RGVsYXlUaW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSArIHRoaXMuX2RlbGF5VGltZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vblJlcGVhdENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25SZXBlYXRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2hhaW5lZCB0d2VlbnMgc3RhcnQgZXhhY3RseSBhdCB0aGUgdGltZSB0aGV5IHNob3VsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZSBgdXBkYXRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIHdheSBwYXN0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdHdlZW5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0YXJ0KHRoaXMuX3N0YXJ0VGltZSArIHRoaXMuX2R1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVByb3BlcnRpZXMoX29iamVjdCwgX3ZhbHVlc1N0YXJ0LCBfdmFsdWVzRW5kLCB2YWx1ZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIF92YWx1ZXNFbmQpIHtcclxuICAgICAgICAgICAgLy8gRG9uXCJ0IHVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAgICAgICAgICAgIGlmIChfdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IF92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IF92YWx1ZXNFbmRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShfb2JqZWN0W3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIHZhciBlbmRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xyXG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uTGlzdCA9ICFzdGFydElzQXJyYXkgJiYgZW5kSXNBcnJheTtcclxuICAgICAgICAgICAgaWYgKGlzSW50ZXJwb2xhdGlvbkxpc3QpIHtcclxuICAgICAgICAgICAgICAgIF9vYmplY3RbcHJvcGVydHldID0gdGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGVuZCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09IFwib2JqZWN0XCIgJiYgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKF9vYmplY3RbcHJvcGVydHldLCBzdGFydCwgZW5kLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZXMgcmVsYXRpdmUgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IGFzIGJhc2UgKGUuZy46ICsxMCwgLTMpXHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLl9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUU/XHJcbiAgICAgICAgICAgICAgICAgICAgX29iamVjdFtwcm9wZXJ0eV0gPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVSZWxhdGl2ZVZhbHVlKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kLmNoYXJBdCgwKSA9PT0gXCIrXCIgfHwgZW5kLmNoYXJBdCgwKSA9PT0gXCItXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc3dhcEVuZFN0YXJ0UmVwZWF0VmFsdWVzKHByb3BlcnR5KSB7XHJcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcclxuICAgICAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdChlbmRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID0gdG1wO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIFZFUlNJT04gPSBcIjE4LjYuNFwiO1xyXG5cclxudmFyIG5leHRJZCA9IFNlcXVlbmNlLm5leHRJZDtcclxuLyoqXHJcbiAqIENvbnRyb2xsaW5nIGdyb3VwcyBvZiB0d2VlbnNcclxuICpcclxuICogVXNpbmcgdGhlIFRXRUVOIHNpbmdsZXRvbiB0byBtYW5hZ2UgeW91ciB0d2VlbnMgY2FuIGNhdXNlIGlzc3VlcyBpbiBsYXJnZSBhcHBzIHdpdGggbWFueSBjb21wb25lbnRzLlxyXG4gKiBJbiB0aGVzZSBjYXNlcywgeW91IG1heSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBzbWFsbGVyIGdyb3VwcyBvZiB0d2VlbnMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFRXRUVOID0gbWFpbkdyb3VwO1xyXG4vKiogXHJcbiAqIOWfuuS6jlRpbWVyLnRpbWVTY2FsZee8qeaUvumAn+W6pueahGdyb3VwXHJcbiAqL1xyXG5leHBvcnQgdmFyIFNDQUxFX1RXRUVOID0gc2NhbGVHcm91cDtcclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Random.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '67025YgSQdGQ6vst9yFrddx', 'Random');
// scripts/common/util/Random.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Tool_1 = require("./Tool");
var CHARS = [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
];
var BASE = 131;
var MOD = 19260817;
/**
 * 可设置随机种子的随机数生成器
 */
var Random = /** @class */ (function () {
    function Random() {
    }
    /**
     * 计算字符串的hash值 返回值>=0
     * @param str
     * @param initHash 计算的初始值
     */
    Random.hashCode = function (str, initHash) {
        if (initHash === void 0) { initHash = 0; }
        var hash = initHash;
        if (!str) {
            return hash;
        }
        for (var i = 0; i < str.length; i++) {
            hash = (BASE * hash + str.charCodeAt(i)) % MOD;
        }
        return hash;
    };
    /**
     * 随机生成一个种子编码
     * @param length 编码字节长度
     */
    Random.getSeed = function (length) {
        if (length === void 0) { length = 8; }
        var seed = "";
        for (var i = 0; i < length; i++) {
            seed += Tool_1.default.arrayRand(CHARS);
        }
        return seed;
    };
    /**
     * 获取区间[0, 1)的浮点数
     */
    Random.random = function (seed) {
        var seedCode = typeof seed === "string" ? this.hashCode(seed) : seed;
        return (seedCode * 9301 + 49297) % 233280 / 233280;
    };
    /**
     * 获取区间[min, max)的整数，传入1个参数则区间为[0, min)
     */
    Random.int = function (seed, min, max) {
        if (max === void 0) { max = undefined; }
        if (max === undefined) {
            max = min;
            min = 0;
        }
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(this.random(seed) * (max - min)) + min;
    };
    /**
     * 获取区间[min, max)的浮点数，传入1个参数则区间为[0, min)
     */
    Random.float = function (seed, min, max) {
        if (max === void 0) { max = undefined; }
        if (max === undefined) {
            max = min;
            min = 0;
        }
        return this.random(seed) * (max - min) + min;
    };
    /**
     * 根据权重数组进行随机，返回结果下标
     * @param weightArr 权重数组
     * @returns 随机到的权重数组下标
     */
    Random.randWeightIdx = function (seed, weightArr) {
        var sum = 0;
        for (var i = 0; i < weightArr.length; i++) {
            sum += weightArr[i];
        }
        var randNum = this.float(seed, 0, sum);
        var curValue = 0;
        for (var i = 0; i < weightArr.length; i++) {
            curValue += weightArr[i];
            if (randNum < curValue) {
                return i;
            }
        }
        return weightArr.length - 1;
    };
    /**
     * Fisher–Yates shuffle 数组随机乱序
     */
    Random.shuffle = function (seed, arr) {
        var _a;
        for (var i = arr.length - 1; i >= 0; i--) {
            var randomIndex = Math.floor(this.random(seed) * (i + 1));
            _a = [arr[i], arr[randomIndex]], arr[randomIndex] = _a[0], arr[i] = _a[1];
        }
        return arr;
    };
    /**
     * 随机返回数组中的一个元素
     */
    Random.arrayRand = function (seed, arr) {
        if (arr.length <= 0) {
            return null;
        }
        return arr[this.int(seed, 0, arr.length)];
    };
    return Random;
}());
exports.default = Random;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxSYW5kb20udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBMEI7QUFFMUIsSUFBTSxLQUFLLEdBQWE7SUFDcEIsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztJQUNoRCxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztJQUNoSSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztDQUNuSSxDQUFDO0FBRUYsSUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2pCLElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQztBQUVyQjs7R0FFRztBQUNIO0lBQUE7SUF3R0EsQ0FBQztJQXRHRzs7OztPQUlHO0lBQ1csZUFBUSxHQUF0QixV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QSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUb29sIGZyb20gXCIuL1Rvb2xcIjtcclxuXHJcbmNvbnN0IENIQVJTOiBzdHJpbmdbXSA9IFtcclxuICAgIFwiMFwiLCBcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLFxyXG4gICAgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZVwiLCBcImZcIiwgXCJnXCIsIFwiaFwiLCBcImlcIiwgXCJqXCIsIFwia1wiLCBcImxcIiwgXCJtXCIsIFwiblwiLCBcIm9cIiwgXCJwXCIsIFwicVwiLCBcInJcIiwgXCJzXCIsIFwidFwiLCBcInVcIiwgXCJ2XCIsIFwid1wiLCBcInhcIiwgXCJ5XCIsIFwielwiLFxyXG4gICAgXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIiwgXCJHXCIsIFwiSFwiLCBcIklcIiwgXCJKXCIsIFwiS1wiLCBcIkxcIiwgXCJNXCIsIFwiTlwiLCBcIk9cIiwgXCJQXCIsIFwiUVwiLCBcIlJcIiwgXCJTXCIsIFwiVFwiLCBcIlVcIiwgXCJWXCIsIFwiV1wiLCBcIlhcIiwgXCJZXCIsIFwiWlwiXHJcbl07XHJcblxyXG5jb25zdCBCQVNFID0gMTMxO1xyXG5jb25zdCBNT0QgPSAxOTI2MDgxNztcclxuXHJcbi8qKlxyXG4gKiDlj6/orr7nva7pmo/mnLrnp43lrZDnmoTpmo/mnLrmlbDnlJ/miJDlmahcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmRvbSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpflrZfnrKbkuLLnmoRoYXNo5YC8IOi/lOWbnuWAvD49MFxyXG4gICAgICogQHBhcmFtIHN0ciBcclxuICAgICAqIEBwYXJhbSBpbml0SGFzaCDorqHnrpfnmoTliJ3lp4vlgLxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBoYXNoQ29kZShzdHI6IHN0cmluZywgaW5pdEhhc2g6IG51bWJlciA9IDApOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBoYXNoID0gaW5pdEhhc2g7XHJcbiAgICAgICAgaWYgKCFzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBoYXNoID0gKEJBU0UgKiBoYXNoICsgc3RyLmNoYXJDb2RlQXQoaSkpICUgTU9EO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmaj+acuueUn+aIkOS4gOS4quenjeWtkOe8lueggVxyXG4gICAgICogQHBhcmFtIGxlbmd0aCDnvJbnoIHlrZfoioLplb/luqZcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRTZWVkKGxlbmd0aDogbnVtYmVyID0gOCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHNlZWQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZCArPSBUb29sLmFycmF5UmFuZChDSEFSUyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5Yy66Ze0WzAsIDEp55qE5rWu54K55pWwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmFuZG9tKHNlZWQ6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IHNlZWRDb2RlOiBudW1iZXIgPSB0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMuaGFzaENvZGUoc2VlZCkgOiBzZWVkO1xyXG4gICAgICAgIHJldHVybiAoc2VlZENvZGUgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwIC8gMjMzMjgwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5Yy66Ze0W21pbiwgbWF4KeeahOaVtOaVsO+8jOS8oOWFpTHkuKrlj4LmlbDliJnljLrpl7TkuLpbMCwgbWluKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGludChzZWVkOiBzdHJpbmcgfCBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciA9IHVuZGVmaW5lZCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1pbjtcclxuICAgICAgICAgICAgbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluID0gTWF0aC5jZWlsKG1pbik7XHJcbiAgICAgICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucmFuZG9tKHNlZWQpICogKG1heCAtIG1pbikpICsgbWluO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5Yy66Ze0W21pbiwgbWF4KeeahOa1rueCueaVsO+8jOS8oOWFpTHkuKrlj4LmlbDliJnljLrpl7TkuLpbMCwgbWluKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZsb2F0KHNlZWQ6IHN0cmluZyB8IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyID0gdW5kZWZpbmVkKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbWF4ID0gbWluO1xyXG4gICAgICAgICAgICBtaW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb20oc2VlZCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruadg+mHjeaVsOe7hOi/m+ihjOmaj+acuu+8jOi/lOWbnue7k+aenOS4i+agh1xyXG4gICAgICogQHBhcmFtIHdlaWdodEFyciDmnYPph43mlbDnu4RcclxuICAgICAqIEByZXR1cm5zIOmaj+acuuWIsOeahOadg+mHjeaVsOe7hOS4i+agh1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJhbmRXZWlnaHRJZHgoc2VlZDogc3RyaW5nIHwgbnVtYmVyLCB3ZWlnaHRBcnI6IG51bWJlcltdKSB7XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IHdlaWdodEFycltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJhbmROdW0gPSB0aGlzLmZsb2F0KHNlZWQsIDAsIHN1bSk7XHJcbiAgICAgICAgbGV0IGN1clZhbHVlID0gMFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0QXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1clZhbHVlICs9IHdlaWdodEFycltpXTtcclxuICAgICAgICAgICAgaWYgKHJhbmROdW0gPCBjdXJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdlaWdodEFyci5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlzaGVy4oCTWWF0ZXMgc2h1ZmZsZSDmlbDnu4Tpmo/mnLrkubHluo9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaHVmZmxlPFQ+KHNlZWQ6IHN0cmluZyB8IG51bWJlciwgYXJyOiBBcnJheTxUPik6IEFycmF5PFQ+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IodGhpcy5yYW5kb20oc2VlZCkgKiAoaSArIDEpKTtcclxuICAgICAgICAgICAgW2FycltyYW5kb21JbmRleF0sIGFycltpXV0gPSBbYXJyW2ldLCBhcnJbcmFuZG9tSW5kZXhdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmaj+acuui/lOWbnuaVsOe7hOS4reeahOS4gOS4quWFg+e0oFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFycmF5UmFuZDxUPihzZWVkOiBzdHJpbmcgfCBudW1iZXIsIGFycjogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyW3RoaXMuaW50KHNlZWQsIDAsIGFyci5sZW5ndGgpXTtcclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/RecyclePool.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a65467UylROdo6A5J2HqlLb', 'RecyclePool');
// scripts/common/util/RecyclePool.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 节点池
 */
var RecyclePool = /** @class */ (function () {
    function RecyclePool() {
    }
    /**
     * 获取节点池中节点数量
     */
    RecyclePool.size = function (key) {
        var list = typeof key === "string" ? this._urlMap.get(key) : this._cmptMap.get(key);
        if (list === undefined) {
            return 0;
        }
        return list.length;
    };
    /**
     * 清空节点
     */
    RecyclePool.clear = function (key) {
        if (typeof key === "string") {
            var list = this._urlMap.get(key);
            if (list === undefined) {
                return;
            }
            var count = list.length;
            for (var i = 0; i < count; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            this._urlMap.delete(key);
        }
        else {
            var list = this._cmptMap.get(key);
            if (list === undefined) {
                return;
            }
            var count = list.length;
            for (var i = 0; i < count; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            this._cmptMap.delete(key);
        }
    };
    /**
     * 清空全部节点
     */
    RecyclePool.clearAll = function () {
        this._urlMap.forEach(function (list) {
            var count = list.length;
            for (var i = 0; i < count; ++i) {
                list[i].destroy();
            }
        });
        this._urlMap.clear();
        this._cmptMap.forEach(function (list) {
            var count = list.length;
            for (var i = 0; i < count; ++i) {
                list[i].destroy();
            }
        });
        this._cmptMap.clear();
    };
    /**
     * 根据类型从节点池取出节点
     */
    RecyclePool.get = function (key) {
        if (typeof key === "string") {
            var list = this._urlMap.get(key);
            if (list === undefined || list.length <= 0) {
                return null;
            }
            var last = list.length - 1;
            var node = list[last];
            list.length = last;
            return node;
        }
        else {
            var list = this._cmptMap.get(key);
            if (list === undefined || list.length <= 0) {
                return null;
            }
            var last = list.length - 1;
            var node = list[last];
            list.length = last;
            // Invoke pool handler
            var handler = node.getComponent(key);
            if (handler && handler.reuse) {
                handler.reuse();
            }
            return node;
        }
    };
    /**
     * 根据类型将节点放入节点池
     */
    RecyclePool.put = function (key, node) {
        if (!node) {
            cc.error("[RecyclePool.put] error: \u4F20\u5165\u8282\u70B9\u4E3A\u7A7A");
            return;
        }
        if (typeof key === "string") {
            var list = this._urlMap.get(key);
            if (list === undefined) {
                list = [];
                this._urlMap.set(key, list);
            }
            else if (list.indexOf(node) !== -1) {
                cc.error("[RecyclePool.put] error: \u4E0D\u53EF\u5C06\u8282\u70B9\u91CD\u590D\u653E\u5165\u8282\u70B9\u6C60\u4E2D");
                return;
            }
            else if (list.length >= RecyclePool.limit) {
                node.destroy();
                cc.warn("[RecyclePool.put] warn: \u8282\u70B9\u6C60\u5230\u8FBE\u6700\u5927\u6570\u91CF key: " + key);
                return;
            }
            node.removeFromParent(false);
            list.push(node);
        }
        else {
            var list = this._cmptMap.get(key);
            if (list === undefined) {
                list = [];
                this._cmptMap.set(key, list);
            }
            else if (list.indexOf(node) !== -1) {
                cc.error("[RecyclePool.put] error: \u4E0D\u53EF\u5C06\u8282\u70B9\u91CD\u590D\u653E\u5165\u8282\u70B9\u6C60\u4E2D");
                return;
            }
            else if (list.length >= RecyclePool.limit) {
                node.destroy();
                cc.warn("[RecyclePool.put] warn: \u8282\u70B9\u6C60\u5230\u8FBE\u6700\u5927\u6570\u91CF key: " + key);
                return;
            }
            node.removeFromParent(false);
            // Invoke pool handler
            var handler = node.getComponent(key);
            if (handler && handler.unuse) {
                handler.unuse();
            }
            list.push(node);
        }
    };
    /** 以url标记的节点池 */
    RecyclePool._urlMap = new Map();
    /** 以cccomponent标记的节点池，需要实现接口RecycleNode */
    RecyclePool._cmptMap = new Map();
    /** 单个节点池的最大节点数量 */
    RecyclePool.limit = 512;
    return RecyclePool;
}());
exports.default = RecyclePool;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxSZWN5Y2xlUG9vbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQVVBOztHQUVHO0FBQ0g7SUFBQTtJQXlKQSxDQUFDO0lBaEpHOztPQUVHO0lBQ1csZ0JBQUksR0FBbEIsVUFBbUIsR0FBeUM7UUFDeEQsSUFBSSxJQUFJLEdBQUcsT0FBTyxHQUFHLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDcEYsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQ3BCLE9BQU8sQ0FBQyxDQUFDO1NBQ1o7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVEOztPQUVHO0lBQ1csaUJBQUssR0FBbkIsVUFBb0IsR0FBeUM7UUFDekQsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDekIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUNwQixPQUFPO2FBQ1Y7WUFFRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ3hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUNyQjtZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzVCO2FBQU07WUFDSCxJQUFJ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RSxJQUFJLENBQUMsQ0FBQzthQUNoQztpQkFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQ2xDLEVBQUUsQ0FBQyxLQUFLLENBQUMseUdBQXdDLENBQUMsQ0FBQztnQkFDbkQsT0FBTzthQUNWO2lCQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxXQUFXLENBQUMsS0FBSyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2YsRUFBRSxDQUFDLElBQUksQ0FBQyx5RkFBMEMsR0FBSyxDQUFDLENBQUM7Z0JBQ3pELE9BQU87YUFDVjtZQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM3QixzQkFBc0I7WUFDdEIsSUFBSSxPQUFPLEdBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxQyxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO2dCQUMxQixPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDbkI7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO0lBQ0wsQ0FBQztJQXZKRCxpQkFBaUI7SUFDRixtQkFBTyxHQUEyQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQzNELDJDQUEyQztJQUM1QixvQkFBUSxHQUFnRCxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBRWpGLG1CQUFtQjtJQUNMLGlCQUFLLEdBQVcsR0FBRyxDQUFDO0lBa0p0QyxrQkFBQztDQXpKRCxBQXlKQyxJQUFBO2tCQXpKb0IsV0FBVyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiDnlKjkuo7kvb/nlKjoioLngrnmsaDnmoToioLngrnmiYDnu5HlrprohJrmnKznu4Tku7blrp7njrBcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVjeWNsZU5vZGUge1xyXG4gICAgLyoqIOWbnuaUtuWJjeiwg+eUqCAqL1xyXG4gICAgdW51c2UoKTogdm9pZDtcclxuICAgIC8qKiDlj5blh7rliY3osIPnlKggKi9cclxuICAgIHJldXNlKCk6IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDoioLngrnmsaBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3ljbGVQb29sIHtcclxuICAgIC8qKiDku6V1cmzmoIforrDnmoToioLngrnmsaAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF91cmxNYXA6IE1hcDxzdHJpbmcsIGNjLk5vZGVbXT4gPSBuZXcgTWFwKCk7XHJcbiAgICAvKiog5LulY2Njb21wb25lbnTmoIforrDnmoToioLngrnmsaDvvIzpnIDopoHlrp7njrDmjqXlj6NSZWN5Y2xlTm9kZSAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX2NtcHRNYXA6IE1hcDx7IHByb3RvdHlwZTogY2MuQ29tcG9uZW50IH0sIGNjLk5vZGVbXT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgLyoqIOWNleS4quiKgueCueaxoOeahOacgOWkp+iKgueCueaVsOmHjyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsaW1pdDogbnVtYmVyID0gNTEyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6IqC54K55rGg5Lit6IqC54K55pWw6YePXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2l6ZShrZXk6IHN0cmluZyB8IHsgcHJvdG90eXBlOiBjYy5Db21wb25lbnQgfSk6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGxpc3QgPSB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiID8gdGhpcy5fdXJsTWFwLmdldChrZXkpIDogdGhpcy5fY21wdE1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpc3QubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m66IqC54K5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoa2V5OiBzdHJpbmcgfCB7IHByb3RvdHlwZTogY2MuQ29tcG9uZW50IH0pOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX3VybE1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgY291bnQgPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0W2ldLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3VybE1hcC5kZWxldGUoa2V5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX2NtcHRNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdFtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jbXB0TWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuWFqOmDqOiKgueCuVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3VybE1hcC5mb3JFYWNoKChsaXN0OiBjYy5Ob2RlW10pID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdFtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl91cmxNYXAuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fY21wdE1hcC5mb3JFYWNoKChsaXN0OiBjYy5Ob2RlW10pID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdFtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9jbXB0TWFwLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7nsbvlnovku47oioLngrnmsaDlj5blh7roioLngrlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQoa2V5OiBzdHJpbmcgfCB7IHByb3RvdHlwZTogY2MuQ29tcG9uZW50IH0pOiBjYy5Ob2RlIHtcclxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX3VybE1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCB8fCBsaXN0Lmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGxhc3QgPSBsaXN0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdFtsYXN0XTtcclxuICAgICAgICAgICAgbGlzdC5sZW5ndGggPSBsYXN0O1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX2NtcHRNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQgfHwgbGlzdC5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBsYXN0ID0gbGlzdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RbbGFzdF07XHJcbiAgICAgICAgICAgIGxpc3QubGVuZ3RoID0gbGFzdDtcclxuICAgICAgICAgICAgLy8gSW52b2tlIHBvb2wgaGFuZGxlclxyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcjogYW55ID0gbm9kZS5nZXRDb21wb25lbnQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5yZXVzZSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5yZXVzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruexu+Wei+WwhuiKgueCueaUvuWFpeiKgueCueaxoFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHB1dChrZXk6IHN0cmluZyB8IHsgcHJvdG90eXBlOiBjYy5Db21wb25lbnQgfSwgbm9kZTogY2MuTm9kZSk6IHZvaWQge1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcihgW1JlY3ljbGVQb29sLnB1dF0gZXJyb3I6IOS8oOWFpeiKgueCueS4uuepumApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX3VybE1hcC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXJsTWFwLnNldChrZXksIGxpc3QpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpc3QuaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNjLmVycm9yKGBbUmVjeWNsZVBvb2wucHV0XSBlcnJvcjog5LiN5Y+v5bCG6IqC54K56YeN5aSN5pS+5YWl6IqC54K55rGg5LitYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPj0gUmVjeWNsZVBvb2wubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgY2Mud2FybihgW1JlY3ljbGVQb29sLnB1dF0gd2Fybjog6IqC54K55rGg5Yiw6L6+5pyA5aSn5pWw6YePIGtleTogJHtrZXl9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRnJvbVBhcmVudChmYWxzZSk7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChub2RlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHRoaXMuX2NtcHRNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NtcHRNYXAuc2V0KGtleSwgbGlzdCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdC5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgY2MuZXJyb3IoYFtSZWN5Y2xlUG9vbC5wdXRdIGVycm9yOiDkuI3lj6/lsIboioLngrnph43lpI3mlL7lhaXoioLngrnmsaDkuK1gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA+PSBSZWN5Y2xlUG9vbC5saW1pdCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICBjYy53YXJuKGBbUmVjeWNsZVBvb2wucHV0XSB3YXJuOiDoioLngrnmsaDliLDovr7mnIDlpKfmlbDph48ga2V5OiAke2tleX1gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm9kZS5yZW1vdmVGcm9tUGFyZW50KGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gSW52b2tlIHBvb2wgaGFuZGxlclxyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcjogYW55ID0gbm9kZS5nZXRDb21wb25lbnQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci51bnVzZSkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci51bnVzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Res.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'e6bb4ug0+BII76RLebcZhXt', 'Res');
// scripts/common/util/Res.ts

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/** asset bundle路径校验 */
var BUNDLE_CHECK = "ab:";
/**
 * 资源管理类
 *
 * 资源加载:
 * 1. 如果加载resources内的资源，直接写明resources内的路径即可
 * 2. 如果加载路径以ab:开头，则会加载对应bundle内的资源。例：ab:bundleA/xxx/a表示bundle名为bundleA，资源路径为xxx/a
 *
 * 引用计数管理：
 * 1. 尽量使用此类的接口加载所有资源、instantiate节点实例，否则需要自行管理引用计数
 * 2. Res.instantiate不要对动态生成的节点使用，尽量只instantiate prefab上预设好的节点，否则有可能会导致引用计数的管理出错
 * 3. 调用load接口时如需传入release参数，则同一资源在全局调用load时release参数尽量保持一致，否则可能不符合预期
 * 4. 请使用ResSpine、ResSprite组件去动态加载spine、图片资源，否则需要自行管理这些资源的引用计数
 */
var Res = /** @class */ (function () {
    function Res() {
    }
    /**
     * 资源路径解析
     * @param url
     */
    Res.parseUrl = function (url) {
        if (url.startsWith(BUNDLE_CHECK)) {
            var loadUrl = url.substring(BUNDLE_CHECK.length);
            var idx = loadUrl.indexOf("/");
            var bundle = loadUrl.substring(0, idx);
            loadUrl = loadUrl.substring(idx + 1);
            return { bundle: bundle, loadUrl: loadUrl };
        }
        else {
            return { loadUrl: url };
        }
    };
    /**
     * 通过节点或预制查找已缓存prefab路径
     * @param target
     */
    Res.getCachePrefabUrl = function (target) {
        var url = "";
        if (target instanceof cc.Node) {
            var cur = target;
            while (cur) {
                if (cur["_prefab"] && cur["_prefab"]["root"]) {
                    url = this._nodePath.get(cur["_prefab"]["root"]) || "";
                    if (url) {
                        break;
                    }
                }
                cur = cur.parent;
            }
        }
        else if (target instanceof cc.Prefab) {
            url = this._prefabPath.get(target) || "";
        }
        return url;
    };
    /**
     * 缓存资源
     * @param url 资源路径
     * @param asset 资源
     * @param release 资源是否需要释放
     */
    Res.cacheAsset = function (url, asset, release) {
        var _this = this;
        if (release === void 0) { release = true; }
        if (!asset) {
            return;
        }
        var func = function (map) {
            if (map.has(url)) {
                return;
            }
            asset.addRef();
            if (asset instanceof cc.Prefab) {
                _this._prefabPath.set(asset, url);
            }
            var cacheData = {
                asset: asset,
                release: release,
                lastLoadTime: Date.now() / 1000
            };
            map.set(url, cacheData);
        };
        if (asset instanceof cc.Prefab) {
            func(this._prefabCache);
        }
        else if (asset instanceof cc.SpriteFrame) {
            func(this._spriteFrameCache);
        }
        else if (asset instanceof cc.SpriteAtlas) {
            func(this._spriteAtlasCache);
        }
        else if (asset instanceof sp.SkeletonData) {
            func(this._skeletonDataCache);
        }
        else {
            if (this._otherCache.has(url)) {
                return;
            }
            asset.addRef();
            this._otherCache.set(url, asset);
        }
    };
    /**
     * 获取缓存资源。通常不应直接调用此接口，除非调用前能确保资源已加载并且能自行管理引用计数
     * @param url 资源路径
     * @param type 资源类型
     */
    Res.get = function (url, type) {
        var asset = null;
        var func = function (map) {
            var data = map.get(url);
            if (data) {
                asset = data.asset;
                data.lastLoadTime = Date.now() / 1000;
            }
        };
        if (type === cc.Prefab) {
            func(this._prefabCache);
        }
        else if (type === cc.SpriteFrame) {
            func(this._spriteFrameCache);
        }
        else if (type === cc.SpriteAtlas) {
            func(this._spriteAtlasCache);
        }
        else if (type === sp.SkeletonData) {
            func(this._skeletonDataCache);
        }
        else {
            asset = this._otherCache.get(url);
        }
        return asset;
    };
    /**
     * 加载bundle
     * @param nameOrUrl bundle路径
     */
    Res.loadBundle = function (nameOrUrl) {
        return new Promise(function (resolve, reject) {
            cc.assetManager.loadBundle(nameOrUrl, function (error, bundle) {
                if (error) {
                    cc.error("[Res.loadBundle] error: " + error);
                    resolve(null);
                }
                else {
                    resolve(bundle);
                }
            });
        });
    };
    /**
     * 加载单个资源
     * @param url 资源路径
     * @param type 资源类型
     * @param release 资源是否需要释放
     */
    Res.load = function (url, type, release) {
        if (release === void 0) { release = true; }
        return __awaiter(this, void 0, Promise, function () {
            var asset, parseData;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!url) {
                            cc.error("[Res.load] url is empty");
                            return [2 /*return*/, null];
                        }
                        asset = this.get(url, type);
                        if (asset) {
                            return [2 /*return*/, asset];
                        }
                        parseData = this.parseUrl(url);
                        if (!(parseData.bundle && !cc.assetManager.getBundle(parseData.bundle))) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadBundle(parseData.bundle)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            var bundle = parseData.bundle ? cc.assetManager.getBundle(parseData.bundle) : cc.resources;
                            if (!bundle) {
                                cc.error("[Res.load] cant find bundle: " + url);
                                resolve(null);
                                return;
                            }
                            bundle.load(parseData.loadUrl, type, function (error, resource) {
                                if (error) {
                                    cc.error("[Res.load] load error: " + error);
                                    resolve(null);
                                }
                                else {
                                    _this.cacheAsset(url, resource, release);
                                    resolve(resource);
                                }
                            });
                        })];
                    case 3:
                        asset = _a.sent();
                        return [2 /*return*/, asset];
                }
            });
        });
    };
    /**
     * 加载某个文件夹内的某类资源
     * @param url 资源路径
     * @param type 资源类型
     * @param release 资源是否需要释放
     */
    Res.loadDir = function (url, type, release) {
        if (release === void 0) { release = true; }
        return __awaiter(this, void 0, Promise, function () {
            var parseData;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!url) {
                            cc.error("[Res.load] url is empty");
                            return [2 /*return*/, []];
                        }
                        parseData = this.parseUrl(url);
                        if (!(parseData.bundle && !cc.assetManager.getBundle(parseData.bundle))) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadBundle(parseData.bundle)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                            var bundle = parseData.bundle ? cc.assetManager.getBundle(parseData.bundle) : cc.resources;
                            if (!bundle) {
                                cc.error("[Res.loadDir] cant find bundle: " + url);
                                resolve([]);
                                return;
                            }
                            bundle.loadDir(parseData.loadUrl, type, function (error, resource) {
                                if (error) {
                                    cc.error("[Res.loadDir] load error: " + error);
                                    resolve([]);
                                }
                                else {
                                    var infos_1 = bundle.getDirWithPath(url, type);
                                    resource.forEach(function (asset, i) { _this.cacheAsset(infos_1[i].path, asset, release); });
                                    resolve(resource);
                                }
                            });
                        })];
                }
            });
        });
    };
    /**
     * 获取节点实例，并建立新节点与prefab资源的联系
     * @param original 用于实例化节点的prefab或node
     * @param related 如果original不是动态加载的prefab，则需传入与original相关联的动态加载的prefab或node，以便资源释放的管理
     * @example
     * // 1.original为动态加载的prefab，无需传related参数
     * Res.instantiate(original)
     *
     * // 2.aPrefab为动态加载的prefab，aNode为aPrefab的实例节点（aNode = Res.instantiate(aPrefab)），original为被aPrefab静态引用的prefab，则调用时需要用如下方式才能保证引用关系正确
     * Res.instantiate(original, aPrefab)
     * Res.instantiate(original, aNode)
     *
     * // 3.aPrefab为动态加载的prefab，aNode为aPrefab的实例节点（aNode = Res.instantiate(aPrefab)），original为aNode的某个子节点，则如下方式均可保证引用关系正确
     * Res.instantiate(original)
     * Res.instantiate(original, aPrefab)
     * Res.instantiate(original, aNode)
     */
    Res.instantiate = function (original, related) {
        if (!original) {
            cc.error("[Res.instantiate] original is null");
            return null;
        }
        var node = cc.instantiate(original);
        var url = this.getCachePrefabUrl(related) || this.getCachePrefabUrl(original);
        if (url) {
            var cacheData = this._prefabCache.get(url);
            // release为true才缓存关联节点
            if (cacheData && cacheData.release) {
                if (!Array.isArray(cacheData.nodes)) {
                    cacheData.nodes = [];
                }
                cacheData.nodes.push(node);
                this._nodePath.set(node, url);
            }
        }
        return node;
    };
    /**
     * 尝试释放所有缓存资源
     * - 只要遵守本文件的规则注释，此接口不会导致正在被使用的资源被引擎释放，可放心使用
     */
    Res.releaseAll = function () {
        var _this = this;
        var nowSec = Date.now() / 1000;
        // prefab
        this._prefabCache.forEach(function (cacheData, url) {
            if (!cacheData.release || nowSec - cacheData.lastLoadTime < _this.releaseSec) {
                return;
            }
            if (Array.isArray(cacheData.nodes)) {
                for (var i = cacheData.nodes.length - 1; i >= 0; i--) {
                    var node = cacheData.nodes[i];
                    if (node.isValid) {
                        continue;
                    }
                    _this._nodePath.delete(node);
                    cacheData.nodes.splice(i, 1);
                }
                if (cacheData.nodes.length === 0) {
                    delete cacheData.nodes;
                }
            }
            if (!Array.isArray(cacheData.nodes)) {
                cacheData.asset.decRef();
                _this._prefabPath.delete(cacheData.asset);
                _this._prefabCache.delete(url);
            }
        });
        // spriteFrame、spriteAtlas、skeletonData
        var arr = [this._spriteFrameCache, this._spriteAtlasCache, this._skeletonDataCache];
        arr.forEach(function (map) {
            map.forEach(function (cacheData, url) {
                if (!cacheData.release || nowSec - cacheData.lastLoadTime < _this.releaseSec) {
                    return;
                }
                cacheData.asset.decRef();
                map.delete(url);
            });
        });
        // other
    };
    /**
     * 获取resources包内资源打包后的真实路径
     * @param url resources下的资源路径
     * @param ext 资源的后缀名
     * @param isNative true:返回打包后native目录下的路径，false:返回打包后import目录下的路径
     */
    Res.getNativeUrlByResources = function (url, ext, isNative) {
        if (isNative === void 0) { isNative = true; }
        try {
            var nativeUrl = cc.assetManager["_transform"]({ path: url, bundle: cc.AssetManager.BuiltinBundleName.RESOURCES, __isNative__: isNative, ext: ext });
            return nativeUrl;
        }
        catch (error) {
            cc.error("[Res.getNativeUrlByResources] error url: " + url);
            return "";
        }
    };
    /** 节点与其关联的prefab路径 */
    Res._nodePath = new Map();
    /** prefab资源与路径 */
    Res._prefabPath = new Map();
    Res._prefabCache = new Map();
    Res._spriteFrameCache = new Map();
    Res._spriteAtlasCache = new Map();
    Res._skeletonDataCache = new Map();
    Res._otherCache = new Map();
    /** 资源释放的间隔时间（秒），资源超过此间隔未被load才可释放 */
    Res.releaseSec = 0;
    return Res;
}());
exports.default = Res;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxSZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSx1QkFBdUI7QUFDdkIsSUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDO0FBRTNCOzs7Ozs7Ozs7Ozs7R0FZRztBQUNIO0lBQUE7SUFzVUEsQ0FBQztJQXZURzs7O09BR0c7SUFDWSxZQUFRLEdBQXZCLFVBQXdCLEdBQVc7UUFDL0IsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQzlCLElBQUksT0FBTyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pELElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0IsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdkMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQztTQUMvQzthQUFNO1lBQ0gsT0FBTyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQztTQUMzQjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDWSxxQkFBaUIsR0FBaEMsVUFBaUMsTUFBMkI7UUFDeEQsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxNQUFNLFlBQVksRUFBRSxDQUFDLElBQUksRUFBRTtZQUMzQixJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUM7WUFDakIsT0FBTyxHQUFHLEVBQUU7Z0JBQ1IsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFO29CQUMxQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO29CQUN2RCxJQUFJLEdBQUcsRUFBRTt3QkFDTCxNQUFNO3FCQUNUO2lCQUNKO2dCQUNELEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO2FBQ3BCO1NBQ0o7YUFBTSxJQUFJLE1BQU0sWUFBWSxFQUFFLENBQUMsTUFBTSxFQUFFO1lBQ3BDLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDNUM7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNZLGNBQVUsR0FBekIsVUFBMEIsR0FBVyxFQUFFLEtBQWUsRUFBRSxPQUF1QjtRQUEvRSxpQkFvQ0M7UUFwQ3VELHdCQUFBLEVBQUEsY0FBdUI7UUFDM0UsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNSLE9BQU87U0FDVjtRQUVELElBQUksSUFBSSxHQUFHLFVBQUMsR0FBMkI7WUFDbkMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNkLE9BQU87YUFDVjtZQUNELEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNmLElBQUksS0FBSyxZQUFZLEVBQUUsQ0FBQyxNQUFNLEVBQUU7Z0JBQzVCLEtBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzthQUNwQztZQUNELElBQUksU0FBUyxHQUFjO2dCQUN2QixLQUFLLEVBQUUsS0FBSztnQkFDWixPQUFPLEVBQUUsT0FBTztnQkFDaEIsWUFBWSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJO2FBQ2xDLENBQUM7WUFDRixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUM7UUFFRixJQUFJLEtBQUssWUFBWSxFQUFFLENBQUMsTUFBTSxFQUFFO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDM0I7YUFBTSxJQUFJLEtBQUssWUFBWSxFQUFFLENBQUMsV0FBVyxFQUFFO1lBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNoQzthQUFNLElBQUksS0FBSyxZQUFZLEVBQUUsQ0FBQyxXQUFXLEVBQUU7WUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ2hDO2FBQU0sSUFBSSxLQUFLLFlBQVksRUFBRSxDQUFDLFlBQVksRUFBRTtZQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDakM7YUFBTTtZQUNILElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzNCLE9BQU87YUFDVjtZQUNELEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNmLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNwQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ1csT0FBRyxHQUFqQixVQUFzQyxHQUFXLEVBQUUsSUFBcUI7UUFDcEUsSUFBSSxLQUFLLEdBQVksSUFBSSxDQUFDO1FBQzFCLElBQUksSUFBSSxHQUFHLFVBQUMsR0FBMkI7WUFDbkMsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN4QixJQUFJLElBQUksRUFBRTtnQkFDTixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztnQkFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO2FBQ3pDO1FBQ0wsQ0FBQyxDQUFDO1FBRUYsSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLE1BQU0sRUFBRTtZQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzNCO2FBQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLFdBQVcsRUFBRTtZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDaEM7YUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUMsV0FBVyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNoQzthQUFNLElBQUksSUFBSSxLQUFLLEVBQUUsQ0FBQyxZQUFZLEVBQUU7WUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ2pDO2FBQU07WUFDSCxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDckM7UUFFRCxPQUFPLEtBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ1csY0FBVSxHQUF4QixVQUF5QixTQUFpQjtRQUN0QyxPQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDL0IsRUFBRSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLFVBQUMsS0FBWSxFQUFFLE1BQThCO2dCQUMvRSxJQUFJLEtBQUssRUFBRTtvQkFDUCxFQUFFLENBQUMsS0FBSyxDQUFDLDZCQUEyQixLQUFPLENBQUMsQ0FBQztvQkFDN0MsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNqQjtxQkFBTTtvQkFDSCxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ25CO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNpQixRQUFJLEdBQXhCLFVBQTZDLEdBQVcsRUFBRSxJQUFxQixFQUFFLE9BQXVCO1FBQXZCLHdCQUFBLEVBQUEsY0FBdUI7dUNBQUcsT0FBTzs7Ozs7O3dCQUM5RyxJQUFJLENBQUMsR0FBRyxFQUFFOzRCQUNOLEVBQUUsQ0FBQyxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQzs0QkFDcEMsc0JBQU8sSUFBSSxFQUFDO3lCQUNmO3dCQUVHLEtBQUssR0FBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDbkMsSUFBSSxLQUFLLEVBQUU7NEJBQ1Asc0JBQU8sS0FBSyxFQUFDO3lCQUNoQjt3QkFFRyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQzs2QkFDL0IsQ0FBQSxTQUFTLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBLEVBQWhFLHdCQUFnRTt3QkFDaEUscUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUE7O3dCQUF2QyxTQUF1QyxDQUFDOzs0QkFHcEMscUJBQU0sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTTs0QkFDdEMsSUFBSSxNQUFNLEdBQTJCLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQzs0QkFDbkgsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQ0FDVCxFQUFFLENBQUMsS0FBSyxDQUFDLGtDQUFnQyxHQUFLLENBQUMsQ0FBQztnQ0FDaEQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2dDQUNkLE9BQU87NkJBQ1Y7NEJBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFDLEtBQVksRUFBRSxRQUFXO2dDQUMzRCxJQUFJLEtBQUssRUFBRTtvQ0FDUCxFQUFFLENBQUMsS0FBSyxDQUFDLDRCQUEwQixLQUFPLENBQUMsQ0FBQztvQ0FDNUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lDQUNqQjtxQ0FBTTtvQ0FDSCxLQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7b0NBQ3hDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztpQ0FDckI7NEJBQ0wsQ0FBQyxDQUFDLENBQUM7d0JBQ1AsQ0FBQyxDQUFDLEVBQUE7O3dCQWpCRixLQUFLLEdBQUcsU0FpQk4sQ0FBQzt3QkFDSCxzQkFBTyxLQUFLLEVBQUM7Ozs7S0FDaEI7SUFFRDs7Ozs7T0FLRztJQUNpQixXQUFPLEdBQTNCLFVBQWdELEdBQVcsRUFBRSxJQUFxQixFQUFFLE9BQXVCO1FBQXZCLHdCQUFBLEVBQUEsY0FBdUI7dUNBQUcsT0FBTzs7Ozs7O3dCQUNqSCxJQUFJLENBQUMsR0FBRyxFQUFFOzRCQUNOLEVBQUUsQ0FBQyxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQzs0QkFDcEMsc0JBQU8sRUFBRSxFQUFDO3lCQUNiO3dCQUVHLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzZCQUMvQixDQUFBLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUEsRUFBaEUsd0JBQWdFO3dCQUNoRSxxQkFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXZDLFNBQXVDLENBQUM7OzRCQUc1QyxzQkFBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNOzRCQUMvQixJQUFJLE1BQU0sR0FBMkIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDOzRCQUNuSCxJQUFJLENBQUMsTUFBTSxFQUFFO2dDQUNULEVBQUUsQ0FBQyxLQUFLLENBQUMscUNBQW1DLEdBQUssQ0FBQyxDQUFDO2dDQUNuRCxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7Z0NBQ1osT0FBTzs2QkFDVjs0QkFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQUMsS0FBWSxFQUFFLFFBQWE7Z0NBQ2hFLElBQUksS0FBSyxFQUFFO29DQUNQLEVBQUUsQ0FBQyxLQUFLLENBQUMsK0JBQTZCLEtBQU8sQ0FBQyxDQUFDO29DQUMvQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7aUNBQ2Y7cUNBQU07b0NBQ0gsSUFBSSxPQUFLLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7b0NBQzdDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUUsQ0FBQyxJQUFPLEtBQUksQ0FBQyxVQUFVLENBQUMsT0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQ0FDcEYsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lDQUNyQjs0QkFDTCxDQUFDLENBQUMsQ0FBQzt3QkFDUCxDQUFDLENBQUMsRUFBQzs7OztLQUNOO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDVyxlQUFXLEdBQXpCLFVBQTBCLFFBQTZCLEVBQUUsT0FBNkI7UUFDbEYsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNYLEVBQUUsQ0FBQyxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztZQUMvQyxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQVksQ0FBQztRQUMvQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlFLElBQUksR0FBRyxFQUFFO1lBQ0wsSUFBSSxTQUFTLEdBQW9CLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzVELHNCQUFzQjtZQUN0QixJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsT0FBTyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ2pDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO2lCQUN4QjtnQkFDRCxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQ2pDO1NBQ0o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ1csY0FBVSxHQUF4QjtRQUFBLGlCQXdDQztRQXZDRyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQy9CLFNBQVM7UUFDVCxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFDLFNBQVMsRUFBRSxHQUFHO1lBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsWUFBWSxHQUFHLEtBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pFLE9BQU87YUFDVjtZQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ2hDLEtBQUssSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2xELElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzlCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTt3QkFDZCxTQUFTO3FCQUNaO29CQUNELEtBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUM1QixTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ2hDO2dCQUNELElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUM5QixPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUM7aUJBQzFCO2FBQ0o7WUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ2pDLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pCLEtBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFrQixDQUFDLENBQUM7Z0JBQ3RELEtBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2pDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCx1Q0FBdUM7UUFDdkMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3BGLEdBQUcsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHO1lBQ1osR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFDLFNBQVMsRUFBRSxHQUFHO2dCQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLFlBQVksR0FBRyxLQUFJLENBQUMsVUFBVSxFQUFFO29CQUN6RSxPQUFPO2lCQUNWO2dCQUNELFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pCLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEIsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUNILFFBQVE7SUFDWixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDVywyQkFBdUIsR0FBckMsVUFBc0MsR0FBVyxFQUFFLEdBQVcsRUFBRSxRQUF3QjtRQUF4Qix5QkFBQSxFQUFBLGVBQXdCO1FBQ3BGLElBQUk7WUFDQSxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUNwSixPQUFPLFNBQVMsQ0FBQztTQUNwQjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ1osRUFBRSxDQUFDLEtBQUssQ0FBQyw4Q0FBNEMsR0FBSyxDQUFDLENBQUM7WUFDNUQsT0FBTyxFQUFFLENBQUM7U0FDYjtJQUNMLENBQUM7SUFwVUQsc0JBQXNCO0lBQ1AsYUFBUyxHQUF5QixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQzNELGtCQUFrQjtJQUNILGVBQVcsR0FBMkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUVoRCxnQkFBWSxHQUFpQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3ZELHFCQUFpQixHQUEyQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3RELHFCQUFpQixHQUEyQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3RELHNCQUFrQixHQUEyQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ3ZELGVBQVcsR0FBMEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUU5RCxxQ0FBcUM7SUFDdkIsY0FBVSxHQUFXLENBQUMsQ0FBQztJQXlUekMsVUFBQztDQXRVRCxBQXNVQyxJQUFBO2tCQXRVb0IsR0FBRyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiDotYTmupDnvJPlrZjln7rnoYDmlbDmja7nu5PmnoQgKi9cclxuaW50ZXJmYWNlIENhY2hlRGF0YSB7XHJcbiAgICBhc3NldDogY2MuQXNzZXQsXHJcbiAgICAvKiog6LWE5rqQ5piv5ZCm6ZyA6KaB6YeK5pS+ICovXHJcbiAgICByZWxlYXNlOiBib29sZWFuLFxyXG4gICAgLyoqIOi1hOa6kOacgOWQjuS4gOasoeiiq+WKoOi9veeahOaXtumXtOeCue+8iOenku+8iSAqL1xyXG4gICAgbGFzdExvYWRUaW1lOiBudW1iZXIsXHJcbn1cclxuXHJcbi8qKiDpooTliLbkvZPotYTmupDnvJPlrZjmlbDmja4gKi9cclxuaW50ZXJmYWNlIFByZWZhYkNhY2hlRGF0YSBleHRlbmRzIENhY2hlRGF0YSB7XHJcbiAgICAvKiog5q2kcHJlZmFi5YWz6IGU55qE5a6e5L6L6IqC54K5ICovXHJcbiAgICBub2Rlcz86IGNjLk5vZGVbXSxcclxufVxyXG5cclxuLyoqIGFzc2V0IGJ1bmRsZei3r+W+hOagoemqjCAqL1xyXG5jb25zdCBCVU5ETEVfQ0hFQ0sgPSBcImFiOlwiO1xyXG5cclxuLyoqXHJcbiAqIOi1hOa6kOeuoeeQhuexu1xyXG4gKiBcclxuICog6LWE5rqQ5Yqg6L29OlxyXG4gKiAxLiDlpoLmnpzliqDovb1yZXNvdXJjZXPlhoXnmoTotYTmupDvvIznm7TmjqXlhpnmmI5yZXNvdXJjZXPlhoXnmoTot6/lvoTljbPlj69cclxuICogMi4g5aaC5p6c5Yqg6L296Lev5b6E5LulYWI65byA5aS077yM5YiZ5Lya5Yqg6L295a+55bqUYnVuZGxl5YaF55qE6LWE5rqQ44CC5L6L77yaYWI6YnVuZGxlQS94eHgvYeihqOekumJ1bmRsZeWQjeS4umJ1bmRsZUHvvIzotYTmupDot6/lvoTkuLp4eHgvYVxyXG4gKiBcclxuICog5byV55So6K6h5pWw566h55CG77yaXHJcbiAqIDEuIOWwvemHj+S9v+eUqOatpOexu+eahOaOpeWPo+WKoOi9veaJgOaciei1hOa6kOOAgWluc3RhbnRpYXRl6IqC54K55a6e5L6L77yM5ZCm5YiZ6ZyA6KaB6Ieq6KGM566h55CG5byV55So6K6h5pWwXHJcbiAqIDIuIFJlcy5pbnN0YW50aWF0ZeS4jeimgeWvueWKqOaAgeeUn+aIkOeahOiKgueCueS9v+eUqO+8jOWwvemHj+WPqmluc3RhbnRpYXRlIHByZWZhYuS4iumihOiuvuWlveeahOiKgueCue+8jOWQpuWImeacieWPr+iDveS8muWvvOiHtOW8leeUqOiuoeaVsOeahOeuoeeQhuWHuumUmVxyXG4gKiAzLiDosIPnlKhsb2Fk5o6l5Y+j5pe25aaC6ZyA5Lyg5YWlcmVsZWFzZeWPguaVsO+8jOWImeWQjOS4gOi1hOa6kOWcqOWFqOWxgOiwg+eUqGxvYWTml7ZyZWxlYXNl5Y+C5pWw5bC96YeP5L+d5oyB5LiA6Ie077yM5ZCm5YiZ5Y+v6IO95LiN56ym5ZCI6aKE5pyfXHJcbiAqIDQuIOivt+S9v+eUqFJlc1NwaW5l44CBUmVzU3ByaXRl57uE5Lu25Y675Yqo5oCB5Yqg6L29c3BpbmXjgIHlm77niYfotYTmupDvvIzlkKbliJnpnIDopoHoh6rooYznrqHnkIbov5nkupvotYTmupDnmoTlvJXnlKjorqHmlbBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcyB7XHJcbiAgICAvKiog6IqC54K55LiO5YW25YWz6IGU55qEcHJlZmFi6Lev5b6EICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbm9kZVBhdGg6IE1hcDxjYy5Ob2RlLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xyXG4gICAgLyoqIHByZWZhYui1hOa6kOS4jui3r+W+hCAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3ByZWZhYlBhdGg6IE1hcDxjYy5QcmVmYWIsIHN0cmluZz4gPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3ByZWZhYkNhY2hlOiBNYXA8c3RyaW5nLCBQcmVmYWJDYWNoZURhdGE+ID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3Nwcml0ZUZyYW1lQ2FjaGU6IE1hcDxzdHJpbmcsIENhY2hlRGF0YT4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBfc3ByaXRlQXRsYXNDYWNoZTogTWFwPHN0cmluZywgQ2FjaGVEYXRhPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIF9za2VsZXRvbkRhdGFDYWNoZTogTWFwPHN0cmluZywgQ2FjaGVEYXRhPiA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIF9vdGhlckNhY2hlOiBNYXA8c3RyaW5nLCBjYy5Bc3NldD4gPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgLyoqIOi1hOa6kOmHiuaUvueahOmXtOmalOaXtumXtO+8iOenku+8ie+8jOi1hOa6kOi2hei/h+atpOmXtOmalOacquiiq2xvYWTmiY3lj6/ph4rmlL4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVsZWFzZVNlYzogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi1hOa6kOi3r+W+hOino+aekFxyXG4gICAgICogQHBhcmFtIHVybCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VVcmwodXJsOiBzdHJpbmcpOiB7IGJ1bmRsZT86IHN0cmluZywgbG9hZFVybDogc3RyaW5nIH0ge1xyXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChCVU5ETEVfQ0hFQ0spKSB7XHJcbiAgICAgICAgICAgIGxldCBsb2FkVXJsID0gdXJsLnN1YnN0cmluZyhCVU5ETEVfQ0hFQ0subGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IGlkeCA9IGxvYWRVcmwuaW5kZXhPZihcIi9cIik7XHJcbiAgICAgICAgICAgIGxldCBidW5kbGUgPSBsb2FkVXJsLnN1YnN0cmluZygwLCBpZHgpO1xyXG4gICAgICAgICAgICBsb2FkVXJsID0gbG9hZFVybC5zdWJzdHJpbmcoaWR4ICsgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGJ1bmRsZTogYnVuZGxlLCBsb2FkVXJsOiBsb2FkVXJsIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbG9hZFVybDogdXJsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YCa6L+H6IqC54K55oiW6aKE5Yi25p+l5om+5bey57yT5a2YcHJlZmFi6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRDYWNoZVByZWZhYlVybCh0YXJnZXQ6IGNjLk5vZGUgfCBjYy5QcmVmYWIpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCB1cmwgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjYy5Ob2RlKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXIgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJbXCJfcHJlZmFiXCJdICYmIGN1cltcIl9wcmVmYWJcIl1bXCJyb290XCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fbm9kZVBhdGguZ2V0KGN1cltcIl9wcmVmYWJcIl1bXCJyb290XCJdKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgY2MuUHJlZmFiKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHRoaXMuX3ByZWZhYlBhdGguZ2V0KHRhcmdldCkgfHwgXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8k+WtmOi1hOa6kFxyXG4gICAgICogQHBhcmFtIHVybCDotYTmupDot6/lvoRcclxuICAgICAqIEBwYXJhbSBhc3NldCDotYTmupBcclxuICAgICAqIEBwYXJhbSByZWxlYXNlIOi1hOa6kOaYr+WQpumcgOimgemHiuaUvlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjYWNoZUFzc2V0KHVybDogc3RyaW5nLCBhc3NldDogY2MuQXNzZXQsIHJlbGVhc2U6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFhc3NldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZnVuYyA9IChtYXA6IE1hcDxzdHJpbmcsIENhY2hlRGF0YT4pID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hcC5oYXModXJsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzc2V0LmFkZFJlZigpO1xyXG4gICAgICAgICAgICBpZiAoYXNzZXQgaW5zdGFuY2VvZiBjYy5QcmVmYWIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWZhYlBhdGguc2V0KGFzc2V0LCB1cmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYWNoZURhdGE6IENhY2hlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGFzc2V0OiBhc3NldCxcclxuICAgICAgICAgICAgICAgIHJlbGVhc2U6IHJlbGVhc2UsXHJcbiAgICAgICAgICAgICAgICBsYXN0TG9hZFRpbWU6IERhdGUubm93KCkgLyAxMDAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1hcC5zZXQodXJsLCBjYWNoZURhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChhc3NldCBpbnN0YW5jZW9mIGNjLlByZWZhYikge1xyXG4gICAgICAgICAgICBmdW5jKHRoaXMuX3ByZWZhYkNhY2hlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFzc2V0IGluc3RhbmNlb2YgY2MuU3ByaXRlRnJhbWUpIHtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLl9zcHJpdGVGcmFtZUNhY2hlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFzc2V0IGluc3RhbmNlb2YgY2MuU3ByaXRlQXRsYXMpIHtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLl9zcHJpdGVBdGxhc0NhY2hlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFzc2V0IGluc3RhbmNlb2Ygc3AuU2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgIGZ1bmModGhpcy5fc2tlbGV0b25EYXRhQ2FjaGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdGhlckNhY2hlLmhhcyh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXNzZXQuYWRkUmVmKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX290aGVyQ2FjaGUuc2V0KHVybCwgYXNzZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue8k+WtmOi1hOa6kOOAgumAmuW4uOS4jeW6lOebtOaOpeiwg+eUqOatpOaOpeWPo++8jOmZpOmdnuiwg+eUqOWJjeiDveehruS/nei1hOa6kOW3suWKoOi9veW5tuS4lOiDveiHquihjOeuoeeQhuW8leeUqOiuoeaVsFxyXG4gICAgICogQHBhcmFtIHVybCDotYTmupDot6/lvoRcclxuICAgICAqIEBwYXJhbSB0eXBlIOi1hOa6kOexu+Wei1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldDxUIGV4dGVuZHMgY2MuQXNzZXQ+KHVybDogc3RyaW5nLCB0eXBlOiB0eXBlb2YgY2MuQXNzZXQpOiBUIHwgbnVsbCB7XHJcbiAgICAgICAgbGV0IGFzc2V0OiB1bmtub3duID0gbnVsbDtcclxuICAgICAgICBsZXQgZnVuYyA9IChtYXA6IE1hcDxzdHJpbmcsIENhY2hlRGF0YT4pID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBtYXAuZ2V0KHVybCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NldCA9IGRhdGEuYXNzZXQ7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmxhc3RMb2FkVGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IGNjLlByZWZhYikge1xyXG4gICAgICAgICAgICBmdW5jKHRoaXMuX3ByZWZhYkNhY2hlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGNjLlNwcml0ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgIGZ1bmModGhpcy5fc3ByaXRlRnJhbWVDYWNoZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBjYy5TcHJpdGVBdGxhcykge1xyXG4gICAgICAgICAgICBmdW5jKHRoaXMuX3Nwcml0ZUF0bGFzQ2FjaGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gc3AuU2tlbGV0b25EYXRhKSB7XHJcbiAgICAgICAgICAgIGZ1bmModGhpcy5fc2tlbGV0b25EYXRhQ2FjaGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2V0ID0gdGhpcy5fb3RoZXJDYWNoZS5nZXQodXJsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhc3NldCBhcyBUO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L29YnVuZGxlXHJcbiAgICAgKiBAcGFyYW0gbmFtZU9yVXJsIGJ1bmRsZei3r+W+hFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvYWRCdW5kbGUobmFtZU9yVXJsOiBzdHJpbmcpOiBQcm9taXNlPGNjLkFzc2V0TWFuYWdlci5CdW5kbGU+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjYy5hc3NldE1hbmFnZXIubG9hZEJ1bmRsZShuYW1lT3JVcmwsIChlcnJvcjogRXJyb3IsIGJ1bmRsZTogY2MuQXNzZXRNYW5hZ2VyLkJ1bmRsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZXJyb3IoYFtSZXMubG9hZEJ1bmRsZV0gZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShidW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWKoOi9veWNleS4qui1hOa6kFxyXG4gICAgICogQHBhcmFtIHVybCDotYTmupDot6/lvoRcclxuICAgICAqIEBwYXJhbSB0eXBlIOi1hOa6kOexu+Wei1xyXG4gICAgICogQHBhcmFtIHJlbGVhc2Ug6LWE5rqQ5piv5ZCm6ZyA6KaB6YeK5pS+XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZDxUIGV4dGVuZHMgY2MuQXNzZXQ+KHVybDogc3RyaW5nLCB0eXBlOiB0eXBlb2YgY2MuQXNzZXQsIHJlbGVhc2U6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xyXG4gICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbUmVzLmxvYWRdIHVybCBpcyBlbXB0eWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhc3NldDogVCA9IHRoaXMuZ2V0KHVybCwgdHlwZSk7XHJcbiAgICAgICAgaWYgKGFzc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3NldDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwYXJzZURhdGEgPSB0aGlzLnBhcnNlVXJsKHVybCk7XHJcbiAgICAgICAgaWYgKHBhcnNlRGF0YS5idW5kbGUgJiYgIWNjLmFzc2V0TWFuYWdlci5nZXRCdW5kbGUocGFyc2VEYXRhLmJ1bmRsZSkpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQnVuZGxlKHBhcnNlRGF0YS5idW5kbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXNzZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidW5kbGU6IGNjLkFzc2V0TWFuYWdlci5CdW5kbGUgPSBwYXJzZURhdGEuYnVuZGxlID8gY2MuYXNzZXRNYW5hZ2VyLmdldEJ1bmRsZShwYXJzZURhdGEuYnVuZGxlKSA6IGNjLnJlc291cmNlcztcclxuICAgICAgICAgICAgaWYgKCFidW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIGNjLmVycm9yKGBbUmVzLmxvYWRdIGNhbnQgZmluZCBidW5kbGU6ICR7dXJsfWApO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnVuZGxlLmxvYWQocGFyc2VEYXRhLmxvYWRVcmwsIHR5cGUsIChlcnJvcjogRXJyb3IsIHJlc291cmNlOiBUKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5lcnJvcihgW1Jlcy5sb2FkXSBsb2FkIGVycm9yOiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVBc3NldCh1cmwsIHJlc291cmNlLCByZWxlYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFzc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L295p+Q5Liq5paH5Lu25aS55YaF55qE5p+Q57G76LWE5rqQXHJcbiAgICAgKiBAcGFyYW0gdXJsIOi1hOa6kOi3r+W+hFxyXG4gICAgICogQHBhcmFtIHR5cGUg6LWE5rqQ57G75Z6LXHJcbiAgICAgKiBAcGFyYW0gcmVsZWFzZSDotYTmupDmmK/lkKbpnIDopoHph4rmlL5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkRGlyPFQgZXh0ZW5kcyBjYy5Bc3NldD4odXJsOiBzdHJpbmcsIHR5cGU6IHR5cGVvZiBjYy5Bc3NldCwgcmVsZWFzZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPFRbXT4ge1xyXG4gICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9yKGBbUmVzLmxvYWRdIHVybCBpcyBlbXB0eWApO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcGFyc2VEYXRhID0gdGhpcy5wYXJzZVVybCh1cmwpO1xyXG4gICAgICAgIGlmIChwYXJzZURhdGEuYnVuZGxlICYmICFjYy5hc3NldE1hbmFnZXIuZ2V0QnVuZGxlKHBhcnNlRGF0YS5idW5kbGUpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZEJ1bmRsZShwYXJzZURhdGEuYnVuZGxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidW5kbGU6IGNjLkFzc2V0TWFuYWdlci5CdW5kbGUgPSBwYXJzZURhdGEuYnVuZGxlID8gY2MuYXNzZXRNYW5hZ2VyLmdldEJ1bmRsZShwYXJzZURhdGEuYnVuZGxlKSA6IGNjLnJlc291cmNlcztcclxuICAgICAgICAgICAgaWYgKCFidW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIGNjLmVycm9yKGBbUmVzLmxvYWREaXJdIGNhbnQgZmluZCBidW5kbGU6ICR7dXJsfWApO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJ1bmRsZS5sb2FkRGlyKHBhcnNlRGF0YS5sb2FkVXJsLCB0eXBlLCAoZXJyb3I6IEVycm9yLCByZXNvdXJjZTogVFtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYy5lcnJvcihgW1Jlcy5sb2FkRGlyXSBsb2FkIGVycm9yOiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5mb3MgPSBidW5kbGUuZ2V0RGlyV2l0aFBhdGgodXJsLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5mb3JFYWNoKChhc3NldCwgaSkgPT4geyB0aGlzLmNhY2hlQXNzZXQoaW5mb3NbaV0ucGF0aCwgYXNzZXQsIHJlbGVhc2UpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5boioLngrnlrp7kvovvvIzlubblu7rnq4vmlrDoioLngrnkuI5wcmVmYWLotYTmupDnmoTogZTns7tcclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCDnlKjkuo7lrp7kvovljJboioLngrnnmoRwcmVmYWLmiJZub2RlXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRlZCDlpoLmnpxvcmlnaW5hbOS4jeaYr+WKqOaAgeWKoOi9veeahHByZWZhYu+8jOWImemcgOS8oOWFpeS4jm9yaWdpbmFs55u45YWz6IGU55qE5Yqo5oCB5Yqg6L2955qEcHJlZmFi5oiWbm9kZe+8jOS7peS+v+i1hOa6kOmHiuaUvueahOeuoeeQhlxyXG4gICAgICogQGV4YW1wbGUgXHJcbiAgICAgKiAvLyAxLm9yaWdpbmFs5Li65Yqo5oCB5Yqg6L2955qEcHJlZmFi77yM5peg6ZyA5LygcmVsYXRlZOWPguaVsFxyXG4gICAgICogUmVzLmluc3RhbnRpYXRlKG9yaWdpbmFsKVxyXG4gICAgICogXHJcbiAgICAgKiAvLyAyLmFQcmVmYWLkuLrliqjmgIHliqDovb3nmoRwcmVmYWLvvIxhTm9kZeS4umFQcmVmYWLnmoTlrp7kvovoioLngrnvvIhhTm9kZSA9IFJlcy5pbnN0YW50aWF0ZShhUHJlZmFiKe+8ie+8jG9yaWdpbmFs5Li66KKrYVByZWZhYumdmeaAgeW8leeUqOeahHByZWZhYu+8jOWImeiwg+eUqOaXtumcgOimgeeUqOWmguS4i+aWueW8j+aJjeiDveS/neivgeW8leeUqOWFs+ezu+ato+ehrlxyXG4gICAgICogUmVzLmluc3RhbnRpYXRlKG9yaWdpbmFsLCBhUHJlZmFiKVxyXG4gICAgICogUmVzLmluc3RhbnRpYXRlKG9yaWdpbmFsLCBhTm9kZSlcclxuICAgICAqIFxyXG4gICAgICogLy8gMy5hUHJlZmFi5Li65Yqo5oCB5Yqg6L2955qEcHJlZmFi77yMYU5vZGXkuLphUHJlZmFi55qE5a6e5L6L6IqC54K577yIYU5vZGUgPSBSZXMuaW5zdGFudGlhdGUoYVByZWZhYinvvInvvIxvcmlnaW5hbOS4umFOb2Rl55qE5p+Q5Liq5a2Q6IqC54K577yM5YiZ5aaC5LiL5pa55byP5Z2H5Y+v5L+d6K+B5byV55So5YWz57O75q2j56GuXHJcbiAgICAgKiBSZXMuaW5zdGFudGlhdGUob3JpZ2luYWwpXHJcbiAgICAgKiBSZXMuaW5zdGFudGlhdGUob3JpZ2luYWwsIGFQcmVmYWIpXHJcbiAgICAgKiBSZXMuaW5zdGFudGlhdGUob3JpZ2luYWwsIGFOb2RlKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluc3RhbnRpYXRlKG9yaWdpbmFsOiBjYy5Ob2RlIHwgY2MuUHJlZmFiLCByZWxhdGVkPzogY2MuTm9kZSB8IGNjLlByZWZhYik6IGNjLk5vZGUge1xyXG4gICAgICAgIGlmICghb3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoXCJbUmVzLmluc3RhbnRpYXRlXSBvcmlnaW5hbCBpcyBudWxsXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBub2RlID0gY2MuaW5zdGFudGlhdGUob3JpZ2luYWwpIGFzIGNjLk5vZGU7XHJcbiAgICAgICAgbGV0IHVybCA9IHRoaXMuZ2V0Q2FjaGVQcmVmYWJVcmwocmVsYXRlZCkgfHwgdGhpcy5nZXRDYWNoZVByZWZhYlVybChvcmlnaW5hbCk7XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICBsZXQgY2FjaGVEYXRhOiBQcmVmYWJDYWNoZURhdGEgPSB0aGlzLl9wcmVmYWJDYWNoZS5nZXQodXJsKTtcclxuICAgICAgICAgICAgLy8gcmVsZWFzZeS4unRydWXmiY3nvJPlrZjlhbPogZToioLngrlcclxuICAgICAgICAgICAgaWYgKGNhY2hlRGF0YSAmJiBjYWNoZURhdGEucmVsZWFzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNhY2hlRGF0YS5ub2RlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZURhdGEubm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhY2hlRGF0YS5ub2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZVBhdGguc2V0KG5vZGUsIHVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsJ3or5Xph4rmlL7miYDmnInnvJPlrZjotYTmupBcclxuICAgICAqIC0g5Y+q6KaB6YG15a6I5pys5paH5Lu255qE6KeE5YiZ5rOo6YeK77yM5q2k5o6l5Y+j5LiN5Lya5a+86Ie05q2j5Zyo6KKr5L2/55So55qE6LWE5rqQ6KKr5byV5pOO6YeK5pS+77yM5Y+v5pS+5b+D5L2/55SoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVsZWFzZUFsbCgpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbm93U2VjID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcbiAgICAgICAgLy8gcHJlZmFiXHJcbiAgICAgICAgdGhpcy5fcHJlZmFiQ2FjaGUuZm9yRWFjaCgoY2FjaGVEYXRhLCB1cmwpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjYWNoZURhdGEucmVsZWFzZSB8fCBub3dTZWMgLSBjYWNoZURhdGEubGFzdExvYWRUaW1lIDwgdGhpcy5yZWxlYXNlU2VjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhY2hlRGF0YS5ub2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjYWNoZURhdGEubm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IGNhY2hlRGF0YS5ub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlUGF0aC5kZWxldGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVEYXRhLm5vZGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZURhdGEubm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlRGF0YS5ub2RlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNhY2hlRGF0YS5ub2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlRGF0YS5hc3NldC5kZWNSZWYoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWZhYlBhdGguZGVsZXRlKGNhY2hlRGF0YS5hc3NldCBhcyBjYy5QcmVmYWIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlZmFiQ2FjaGUuZGVsZXRlKHVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzcHJpdGVGcmFtZeOAgXNwcml0ZUF0bGFz44CBc2tlbGV0b25EYXRhXHJcbiAgICAgICAgbGV0IGFyciA9IFt0aGlzLl9zcHJpdGVGcmFtZUNhY2hlLCB0aGlzLl9zcHJpdGVBdGxhc0NhY2hlLCB0aGlzLl9za2VsZXRvbkRhdGFDYWNoZV07XHJcbiAgICAgICAgYXJyLmZvckVhY2goKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICBtYXAuZm9yRWFjaCgoY2FjaGVEYXRhLCB1cmwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVEYXRhLnJlbGVhc2UgfHwgbm93U2VjIC0gY2FjaGVEYXRhLmxhc3RMb2FkVGltZSA8IHRoaXMucmVsZWFzZVNlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhY2hlRGF0YS5hc3NldC5kZWNSZWYoKTtcclxuICAgICAgICAgICAgICAgIG1hcC5kZWxldGUodXJsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gb3RoZXJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlnJlc291cmNlc+WMheWGhei1hOa6kOaJk+WMheWQjueahOecn+Wunui3r+W+hFxyXG4gICAgICogQHBhcmFtIHVybCByZXNvdXJjZXPkuIvnmoTotYTmupDot6/lvoRcclxuICAgICAqIEBwYXJhbSBleHQg6LWE5rqQ55qE5ZCO57yA5ZCNXHJcbiAgICAgKiBAcGFyYW0gaXNOYXRpdmUgdHJ1ZTrov5Tlm57miZPljIXlkI5uYXRpdmXnm67lvZXkuIvnmoTot6/lvoTvvIxmYWxzZTrov5Tlm57miZPljIXlkI5pbXBvcnTnm67lvZXkuIvnmoTot6/lvoRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXROYXRpdmVVcmxCeVJlc291cmNlcyh1cmw6IHN0cmluZywgZXh0OiBzdHJpbmcsIGlzTmF0aXZlOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IG5hdGl2ZVVybCA9IGNjLmFzc2V0TWFuYWdlcltcIl90cmFuc2Zvcm1cIl0oeyBwYXRoOiB1cmwsIGJ1bmRsZTogY2MuQXNzZXRNYW5hZ2VyLkJ1aWx0aW5CdW5kbGVOYW1lLlJFU09VUkNFUywgX19pc05hdGl2ZV9fOiBpc05hdGl2ZSwgZXh0OiBleHQgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVVcmw7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoYFtSZXMuZ2V0TmF0aXZlVXJsQnlSZXNvdXJjZXNdIGVycm9yIHVybDogJHt1cmx9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/Tool.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '8f0aaDZc6xBdrsOcvbGZFVC', 'Tool');
// scripts/common/util/Tool.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Tween_1 = require("./Tween");
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["S"] = 0] = "S";
    TimeUnit[TimeUnit["M"] = 1] = "M";
    TimeUnit[TimeUnit["H"] = 2] = "H";
    TimeUnit[TimeUnit["D"] = 3] = "D";
})(TimeUnit || (TimeUnit = {}));
/**
 * 工具类
 */
var Tool = /** @class */ (function () {
    function Tool() {
    }
    /**
     * 深拷贝
     * @param source 源数据
     */
    Tool.deepCopy = function (source) {
        if (typeof source !== "object" || source === null || source instanceof RegExp) {
            return source;
        }
        var result = null;
        if (Array.isArray(source)) {
            result = [];
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var item = source_1[_i];
                result.push(this.deepCopy(item));
            }
        }
        else {
            result = {};
            for (var key in source) {
                result[key] = this.deepCopy(source[key]);
            }
        }
        return result;
    };
    /**
     * 异步等待 - setTimeout
     * @param seconds
     */
    Tool.wait = function (seconds) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve();
            }, seconds * 1000);
        });
    };
    /**
     * 异步等待 - cc.Component.scheduleOnce
     */
    Tool.waitCmpt = function (cmpt, seconds) {
        return new Promise(function (resolve, reject) {
            cmpt.scheduleOnce(function () {
                resolve();
            }, seconds);
        });
    };
    /**
     * 异步等待 - tween 默认group为TWEEN
     */
    Tool.waitTween = function (cmpt, seconds, group) {
        if (group === void 0) { group = Tween_1.TWEEN; }
        return new Promise(function (resolve, reject) {
            new Tween_1.Tween({ k: 0 }, group)
                .to({ k: 1 }, seconds * 1000)
                .onComplete(function () {
                resolve();
            })
                .start()
                .bindCCObject(cmpt);
        });
    };
    /**
     * 以tween周期性执行回调，会随绑定的target销毁而销毁
     * @param callback
     * @param target
     * @param interval 回调间隔时间 秒
     * @param repeat 回调共会执行repeat+1次
     * @param group tween分组
     */
    Tool.scheduleByTween = function (callback, target, interval, repeat, group) {
        if (repeat === void 0) { repeat = 0; }
        if (group === void 0) { group = Tween_1.TWEEN; }
        var count = 0;
        var once = function () {
            var data = { arg: 0 };
            new Tween_1.Tween(data, group)
                .bindCCObject(target)
                .to({ arg: 1 }, interval * 1000)
                .onComplete(function () {
                callback();
                count++;
                if (count < repeat + 1) {
                    once();
                }
            })
                .start();
        };
        once();
    };
    /**
     * 线性插值
     * @param a 起始值
     * @param b 目标值
     * @param r ratio between 0 and 1
     * @param min 最小间隔值
     */
    Tool.lerp = function (a, b, r, min) {
        if (min === void 0) { min = 0; }
        min = Math.abs(min);
        var c = b - a;
        var delta = c * r;
        delta = delta < 0 ? Math.min(delta, -min) : Math.max(delta, min);
        if (Math.abs(delta) > Math.abs(c)) {
            delta = c;
        }
        return a + delta;
    };
    /**
     * 通过两点坐标(不平行于坐标轴)和x，计算两点式方程结果y
     */
    Tool.calcTwoPointForm = function (p1, p2, x) {
        if (p1.x === p2.x)
            return p1.y;
        return (p2.y - p1.y) * (x - p1.x) / (p2.x - p1.x) + p1.y;
    };
    /**
     * 返回两个矩形的重叠矩形，不重叠则返回null
     */
    Tool.overlapRect = function (r1, r2) {
        var xMin = Math.max(r1.xMin, r2.xMin);
        var xMax = Math.min(r1.xMax, r2.xMax);
        var yMin = Math.max(r1.yMin, r2.yMin);
        var yMax = Math.min(r1.yMax, r2.yMax);
        if (xMin > xMax || yMin > yMax) {
            return null;
        }
        return cc.rect(xMin, yMin, xMax - xMin, yMax - yMin);
    };
    /**
     * 将角度约束在 [0,360) 区间内
     */
    Tool.normalizeDegree = function (degree) {
        var result = degree % 360;
        if (result < 0) {
            result += 360;
        }
        return result;
    };
    /**
     * 圆心在坐标原点的椭圆，以与x轴逆时针方向的角度计算对应椭圆边上的坐标
     */
    Tool.getEllipsePoint = function (a, b, degree) {
        degree = this.normalizeDegree(degree);
        var k = Math.tan(cc.misc.degreesToRadians(degree));
        var x = Math.sqrt(b * b / (k * k + b * b / a / a));
        if (degree > 90 && degree < 270) {
            x = -x;
        }
        var y = Math.sqrt(b * b - b * b * x * x / a / a);
        if (degree > 180) {
            y = -y;
        }
        return cc.v2(x, y);
    };
    /**
     * 判断射线与圆是否相交
     * @param rayPoint 射线起点
     * @param rayDir 射线方向
     * @param circlrCenter 圆心
     * @param circleRadius 圆半径
     */
    Tool.isRayCircleIntersection = function (rayPoint, rayDir, circlrCenter, circleRadius) {
        var d = rayDir.magSqr();
        var t = ((circlrCenter.x - rayPoint.x) * rayDir.x + (circlrCenter.y - rayPoint.y) * rayDir.y) / d;
        var p;
        if (d <= 0) {
            p = rayPoint;
        }
        else {
            if (t < 0) {
                p = rayPoint;
            }
            else {
                p = cc.v2(rayPoint.x + t * rayDir.x, rayPoint.y + t * rayDir.y);
            }
        }
        var dx = circlrCenter.x - p.x;
        var dy = circlrCenter.y - p.y;
        return (dx * dx + dy * dy) <= circleRadius * circleRadius;
    };
    /**
     * 返回value是否在 [min, max] 区间内
     * @param min
     * @param max
     * @param value
     * @param includeEdge true(默认值): [min, max]; false: (min, max)
     */
    Tool.inRange = function (min, max, value, includeEdge) {
        if (includeEdge === void 0) { includeEdge = true; }
        return includeEdge ? value >= min && value <= max : value > min && value < max;
    };
    /**
     * 获取区间[min, max)的整数，传入1个参数则区间为[0, min)
     */
    Tool.randInt = function (min, max) {
        if (max === void 0) { max = undefined; }
        if (max === undefined) {
            max = min;
            min = 0;
        }
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min;
    };
    /**
     * 获取区间[min, max)的浮点数，传入1个参数则区间为[0, min)
     */
    Tool.randFloat = function (min, max) {
        if (max === void 0) { max = undefined; }
        if (max === undefined) {
            max = min;
            min = 0;
        }
        return Math.random() * (max - min) + min;
    };
    /**
     * 返回一个概率值(%)的随机结果是否在概率范围内
     * @param rate 概率值(%) [0,100]
     */
    Tool.randRateResult = function (rate) {
        return this.randFloat(100) < rate;
    };
    /**
     * 根据权重数组进行随机，返回结果下标
     * @param weightArr 权重数组
     * @returns 随机到的权重数组下标
     */
    Tool.randWeightIdx = function (weightArr) {
        var sum = 0;
        for (var i = 0; i < weightArr.length; i++) {
            sum += weightArr[i];
        }
        var randNum = this.randFloat(0, sum);
        var curValue = 0;
        for (var i = 0; i < weightArr.length; i++) {
            curValue += weightArr[i];
            if (randNum < curValue) {
                return i;
            }
        }
        return weightArr.length - 1;
    };
    /**
     * Fisher–Yates shuffle 字符串随机乱序
     */
    Tool.shuffleString = function (str) {
        var arr = [];
        for (var i = 0; i < str.length; i++) {
            arr.push(str[i]);
        }
        arr = this.shuffle(arr);
        str = "";
        arr.forEach(function (v) {
            str += v;
        });
        return str;
    };
    /**
     * Fisher–Yates shuffle 数组随机乱序
     */
    Tool.shuffle = function (arr) {
        var _a;
        for (var i = arr.length - 1; i >= 0; i--) {
            var randomIndex = Math.floor(Math.random() * (i + 1));
            _a = [arr[i], arr[randomIndex]], arr[randomIndex] = _a[0], arr[i] = _a[1];
        }
        return arr;
    };
    /**
     * 随机返回数组中的一个元素
     */
    Tool.arrayRand = function (arr) {
        if (arr.length <= 0) {
            return null;
        }
        return arr[this.randInt(0, arr.length)];
    };
    /**
     * 判断数组中是否有某个元素
     * @param arr 数组
     * @param param 元素值或表达元素值满足某种条件的函数
     */
    Tool.arrayHas = function (arr, param) {
        var idx = typeof param !== "function" ? arr.findIndex(function (e) { return e === param; }) : arr.findIndex(param);
        return idx >= 0;
    };
    /**
     * 根据下标交换数组两个元素位置
     */
    Tool.arraySwap = function (arr, idx1, idx2) {
        var _a;
        if (idx1 === idx2 || !this.inRange(0, arr.length - 1, idx1) || !this.inRange(0, arr.length - 1, idx2)) {
            return;
        }
        _a = [arr[idx2], arr[idx1]], arr[idx1] = _a[0], arr[idx2] = _a[1];
    };
    /**
     * 将元素从fromIdx位置移到toIdx位置，其余元素相对位置不变
     */
    Tool.arrayMove = function (arr, fromIdx, toIdx) {
        if (fromIdx === toIdx || !this.inRange(0, arr.length - 1, fromIdx) || !this.inRange(0, arr.length - 1, toIdx)) {
            return;
        }
        var from = arr.splice(fromIdx, 1);
        arr.splice(toIdx, 0, from[0]);
    };
    /**
     * 在数组中添加某个元素
     * @param canRepeat 是否可重复添加相同元素 默认false
     * @return 是否执行了添加行为
     */
    Tool.arrayAdd = function (arr, ele, canRepeat) {
        if (canRepeat === void 0) { canRepeat = false; }
        if (!canRepeat && this.arrayHas(arr, ele)) {
            return false;
        }
        arr.push(ele);
        return true;
    };
    /**
     * 在数组中删除某个元素(若有多个相同元素则只删除第一个)
     * @return 是否执行了删除行为
     */
    Tool.arrayDelete = function (arr, ele) {
        var index = arr.findIndex(function (e) { return e === ele; });
        if (index >= 0) {
            arr.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * 根据参数返回格式化字符串
     * @param text 源字符串
     * @param option 用于格式化源字符串的数据，可以是键值对，也可以按顺序传参
     * @example
     * // 可使用以下两种调用方式，返回结果都是"测试字符串111--abc..."
     * Tool.formatString("测试字符串%{a1}--%{a2}...", {a1: 111, a2: "abc"});
     * Tool.formatString("测试字符串%{a1}--%{a2}...", 111, "abc");
     */
    Tool.formatString = function (text) {
        var option = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            option[_i - 1] = arguments[_i];
        }
        var result = text;
        if (option.length === 1 && Object.prototype.toString.call(option[0]) === "[object Object]") {
            // 参数为键值对
            for (var arg in option[0]) {
                if (option[0].hasOwnProperty(arg)) {
                    var reg = new RegExp("%{" + arg + "}", "g");
                    result = result.replace(reg, "" + option[0][arg]);
                }
            }
        }
        else {
            // 参数为数组
            option.forEach(function (value) {
                result = result.replace(/%\{.*?\}/, "" + value);
            });
        }
        return result;
    };
    /**
     * 对一段时间返回格式化时间字符串
     * @param sec 时间s
     * @param format 格式化字符串
     * @example
     * // 当format为string时，会以format中的最大时间单位进行格式化
     * Tool.formatTimeString(3601, "%{m}:%{s}"); // 60:1
     * Tool.formatTimeString(3601, "%{mm}:%{ss}"); // 60:01
     * Tool.formatTimeString(3601, "%{hh}:%{mm}:%{ss}"); // 01:00:01
     *
     * // 当format为object时，会以传入的sec计算最大的时间单位，并选择format对应的字符串进行格式化
     * Tool.formatTimeString(100, {
     *     S: "%{s}秒",
     *     M: "%{m}分%{s}秒",
     *     H: "%{h}时%{m}分%{s}秒",
     *     D: "%{d}天%{h}时%{m}分%{s}秒"
     * }); // 1分40秒
     * Tool.formatTimeString(100000, {
     *     S: "%{s}秒",
     *     M: "%{m}分%{s}秒",
     *     H: "%{h}时%{m}分%{s}秒",
     *     D: "%{d}天%{h}时%{m}分%{s}秒"
     * }); // 1天3时46分40秒
     */
    Tool.formatTimeString = function (sec, format) {
        if (format === void 0) { format = "%{hh}:%{mm}:%{ss}"; }
        var seconds = Math.floor(sec);
        var minutes = Math.floor(seconds / 60);
        var hours = Math.floor(seconds / 3600);
        var days = Math.floor(seconds / 86400);
        var maxUnit = TimeUnit.S;
        var result = "";
        if (typeof format === "string") {
            // 查询格式化字符串中最大的单位
            result = format;
            if (/%\{d+\}/.test(format)) {
                maxUnit = TimeUnit.D;
            }
            else if (/%\{h+\}/.test(format)) {
                maxUnit = TimeUnit.H;
            }
            else if (/%\{m+\}/.test(format)) {
                maxUnit = TimeUnit.M;
            }
        }
        else {
            // 以传入的数值判断最大单位
            if (days > 0) {
                maxUnit = TimeUnit.D;
                result = format.D;
            }
            else if (hours > 0) {
                maxUnit = TimeUnit.H;
                result = format.H;
            }
            else if (minutes > 0) {
                maxUnit = TimeUnit.M;
                result = format.M;
            }
            else {
                maxUnit = TimeUnit.S;
                result = format.S;
            }
        }
        if (maxUnit > TimeUnit.S) {
            seconds %= 60;
        }
        if (maxUnit > TimeUnit.M) {
            minutes %= 60;
        }
        if (maxUnit > TimeUnit.H) {
            hours %= 24;
        }
        var data = {
            dd: days < 10 ? "0" + days : "" + days,
            d: "" + days,
            hh: hours < 10 ? "0" + hours : "" + hours,
            h: "" + hours,
            mm: minutes < 10 ? "0" + minutes : "" + minutes,
            m: "" + minutes,
            ss: seconds < 10 ? "0" + seconds : "" + seconds,
            s: "" + seconds
        };
        result = this.formatString(result, data);
        return result;
    };
    /**
     * 将一个Date对象或Date时间戳返回格式化日期字符串
     * @param date Date对象或Date时间戳
     * @param format 格式化字符串
     * @param isUTC true:UTC时间 false:本地时间
     * @example
     * Tool.formatDateString(0, "%{YYYY}-%{MM}-%{dd} %{hh}:%{mm}:%{ss}", true); // "1970-01-01 00:00:00"
     * Tool.formatDateString(0, "%{dd}/%{MM}/%{YY}", true); // "01/01/70"
     */
    Tool.formatDateString = function (date, format, isUTC) {
        if (format === void 0) { format = "%{YYYY}-%{MM}-%{dd} %{hh}:%{mm}:%{ss}"; }
        if (isUTC === void 0) { isUTC = false; }
        var src = date instanceof Date ? date : new Date(date);
        var year = isUTC ? src.getUTCFullYear() : src.getFullYear();
        var month = isUTC ? src.getUTCMonth() + 1 : src.getMonth() + 1;
        var days = isUTC ? src.getUTCDate() : src.getDate();
        var hours = isUTC ? src.getUTCHours() : src.getHours();
        var minutes = isUTC ? src.getUTCMinutes() : src.getMinutes();
        var seconds = isUTC ? src.getUTCSeconds() : src.getSeconds();
        var data = {
            YYYY: "" + year,
            YY: year % 100 < 10 ? "0" + year % 100 : "" + year % 100,
            MM: month < 10 ? "0" + month : "" + month,
            M: "" + month,
            dd: days < 10 ? "0" + days : "" + days,
            d: "" + days,
            hh: hours < 10 ? "0" + hours : "" + hours,
            h: "" + hours,
            mm: minutes < 10 ? "0" + minutes : "" + minutes,
            m: "" + minutes,
            ss: seconds < 10 ? "0" + seconds : "" + seconds,
            s: "" + seconds
        };
        var result = this.formatString(format, data);
        return result;
    };
    /**
     * 子节点递归处理
     * @param node 需要递归处理的节点或节点数组
     * @param cb 节点处理函数
     * @param thisArg cb绑定的this对象
     */
    Tool.nodeRecursive = function (node, cb, thisArg) {
        var _this = this;
        if (thisArg === void 0) { thisArg = undefined; }
        if (node instanceof cc.Node) {
            cb.call(thisArg, node);
            node.children.forEach(function (n) { _this.nodeRecursive(n, cb, thisArg); });
        }
        else if (Array.isArray(node)) {
            node.forEach(function (n) { _this.nodeRecursive(n, cb, thisArg); });
        }
    };
    /**
     * destroy并立即remove传入节点的所有子节点
     */
    Tool.clearChildren = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        nodes.forEach(function (e) {
            e.destroyAllChildren();
            e.removeAllChildren();
        });
    };
    /**
    * 为节点添加带参数的点击事件
    * @param node 添加点击事件的节点
    * @param component 组件名称 -- 脚本名称
    * @param callBack 点击事件函数 -- 需要在该component脚本内的方法
    * @param param 点击事件传入的参数
    * @param target 事件处理代码组件所属的节点 -- 该component脚本所挂载在的节点
    */
    Tool.addParamButtonClick = function (node, component, callBack, param, target, scale) {
        var clickEventHandler = new cc.Component.EventHandler();
        clickEventHandler.target = target; // 事件处理代码组件所属的节点 -- 该component脚本所挂载在的节点
        clickEventHandler.component = component; // 组件名称 -- 脚本名称
        clickEventHandler.handler = callBack; // 点击事件函数 -- 需要在该component脚本内的方法
        clickEventHandler.customEventData = param; // 点击事件传入的参数
        var button = node.getComponent(cc.Button);
        if (!button) {
            button = node.addComponent(cc.Button);
        }
        if (scale) {
            button.transition = cc.Button.Transition.SCALE;
        }
        button.clickEvents = [];
        button.clickEvents.push(clickEventHandler);
    };
    /**
    * 解绑带参数的点击事件
    * @param node 添加点击事件的节点
    * @param component 组件名称 -- 脚本名称
    * @param callBack 点击事件函数 -- 需要在该component脚本内的方法
    * @param target 事件处理代码组件所属的节点 -- 该component脚本所挂载在的节点
    */
    Tool.removeParamButtonClick = function (node, component, callBack, target) {
        var button = node.getComponent(cc.Button);
        if (button) {
            for (var i = button.clickEvents.length - 1; i >= 0; i--) {
                var eventHandler = button.clickEvents[i];
                if (eventHandler.target === target &&
                    eventHandler.component === component &&
                    eventHandler.handler === callBack) {
                    // 移除对应的点击事件
                    button.clickEvents.splice(i, 1);
                    break;
                }
            }
        }
    };
    return Tool;
}());
exports.default = Tool;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxUb29sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQThDO0FBRTlDLElBQUssUUFLSjtBQUxELFdBQUssUUFBUTtJQUNULGlDQUFDLENBQUE7SUFDRCxpQ0FBQyxDQUFBO0lBQ0QsaUNBQUMsQ0FBQTtJQUNELGlDQUFDLENBQUE7QUFDTCxDQUFDLEVBTEksUUFBUSxLQUFSLFFBQVEsUUFLWjtBQUVEOztHQUVHO0FBQ0g7SUFBQTtJQTBqQkEsQ0FBQztJQXpqQkc7OztPQUdHO0lBQ1csYUFBUSxHQUF0QixVQUEwQixNQUFTO1FBQy9CLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxZQUFZLE1BQU0sRUFBRTtZQUMzRSxPQUFPLE1BQU0sQ0FBQztTQUNqQjtRQUVELElBQUksTUFBTSxHQUFRLElBQUksQ0FBQztRQUN2QixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdkIsTUFBTSxHQUFHLEVBQUUsQ0FBQztZQUNaLEtBQWlCLFVBQU0sRUFBTixpQkFBTSxFQUFOLG9CQUFNLEVBQU4sSUFBTSxFQUFFO2dCQUFwQixJQUFJLElBQUksZUFBQTtnQkFDVCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNwQztTQUNKO2FBQU07WUFDSCxNQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ1osS0FBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUU7Z0JBQ3BCLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQzVDO1NBQ0o7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ1csU0FBSSxHQUFsQixVQUFt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QWEsRUFBRSxTQUFpQixFQUFFLFFBQWdCLEVBQUUsTUFBZTtRQUNwRyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxQyxJQUFJLE1BQU0sRUFBRTtZQUNSLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELElBQUksWUFBWSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pDLElBQ0ksWUFBWSxDQUFDLE1BQU0sS0FBSyxNQUFNO29CQUM5QixZQUFZLENBQUMsU0FBUyxLQUFLLFNBQVM7b0JBQ3BDLFlBQVksQ0FBQyxPQUFPLEtBQUssUUFBUSxFQUNuQztvQkFDRSxZQUFZO29CQUNaLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDaEMsTUFBTTtpQkFDVDthQUNKO1NBQ0o7SUFDTCxDQUFDO0lBRUwsV0FBQztBQUFELENBMWpCQSxBQTBqQkMsSUFBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3VwLCBUd2VlbiwgVFdFRU4gfSBmcm9tIFwiLi9Ud2VlblwiO1xyXG5cclxuZW51bSBUaW1lVW5pdCB7XHJcbiAgICBTLFxyXG4gICAgTSxcclxuICAgIEgsXHJcbiAgICBEXHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlt6XlhbfnsbtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2wge1xyXG4gICAgLyoqXHJcbiAgICAgKiDmt7Hmi7fotJ1cclxuICAgICAqIEBwYXJhbSBzb3VyY2Ug5rqQ5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVlcENvcHk8VD4oc291cmNlOiBUKTogVCB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIgfHwgc291cmNlID09PSBudWxsIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDogYW55ID0gbnVsbDtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kZWVwQ29weShpdGVtKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmRlZXBDb3B5KHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOW8guatpeetieW+hSAtIHNldFRpbWVvdXRcclxuICAgICAqIEBwYXJhbSBzZWNvbmRzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHdhaXQoc2Vjb25kczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIHNlY29uZHMgKiAxMDAwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOW8guatpeetieW+hSAtIGNjLkNvbXBvbmVudC5zY2hlZHVsZU9uY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB3YWl0Q21wdChjbXB0OiBjYy5Db21wb25lbnQsIHNlY29uZHM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNtcHQuc2NoZWR1bGVPbmNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgc2Vjb25kcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvILmraXnrYnlvoUgLSB0d2VlbiDpu5jorqRncm91cOS4ulRXRUVOXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgd2FpdFR3ZWVuKGNtcHQ6IGNjLkNvbXBvbmVudCwgc2Vjb25kczogbnVtYmVyLCBncm91cDogR3JvdXAgPSBUV0VFTik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIG5ldyBUd2Vlbih7IGs6IDAgfSwgZ3JvdXApXHJcbiAgICAgICAgICAgICAgICAudG8oeyBrOiAxIH0sIHNlY29uZHMgKiAxMDAwKVxyXG4gICAgICAgICAgICAgICAgLm9uQ29tcGxldGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoKVxyXG4gICAgICAgICAgICAgICAgLmJpbmRDQ09iamVjdChjbXB0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOS7pXR3ZWVu5ZGo5pyf5oCn5omn6KGM5Zue6LCD77yM5Lya6ZqP57uR5a6a55qEdGFyZ2V06ZSA5q+B6ICM6ZSA5q+BXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFxyXG4gICAgICogQHBhcmFtIGludGVydmFsIOWbnuiwg+mXtOmalOaXtumXtCDnp5JcclxuICAgICAqIEBwYXJhbSByZXBlYXQg5Zue6LCD5YWx5Lya5omn6KGMcmVwZWF0KzHmrKFcclxuICAgICAqIEBwYXJhbSBncm91cCB0d2VlbuWIhue7hFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNjaGVkdWxlQnlUd2VlbihjYWxsYmFjazogKCkgPT4gdm9pZCwgdGFyZ2V0OiBjYy5PYmplY3QsIGludGVydmFsOiBudW1iZXIsIHJlcGVhdDogbnVtYmVyID0gMCwgZ3JvdXA6IEdyb3VwID0gVFdFRU4pIHtcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGxldCBvbmNlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHsgYXJnOiAwIH07XHJcbiAgICAgICAgICAgIG5ldyBUd2VlbihkYXRhLCBncm91cClcclxuICAgICAgICAgICAgICAgIC5iaW5kQ0NPYmplY3QodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgLnRvKHsgYXJnOiAxIH0sIGludGVydmFsICogMTAwMClcclxuICAgICAgICAgICAgICAgIC5vbkNvbXBsZXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgcmVwZWF0ICsgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zdGFydCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb25jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog57q/5oCn5o+S5YC8XHJcbiAgICAgKiBAcGFyYW0gYSDotbflp4vlgLxcclxuICAgICAqIEBwYXJhbSBiIOebruagh+WAvFxyXG4gICAgICogQHBhcmFtIHIgcmF0aW8gYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgKiBAcGFyYW0gbWluIOacgOWwj+mXtOmalOWAvFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHI6IG51bWJlciwgbWluOiBudW1iZXIgPSAwKTogbnVtYmVyIHtcclxuICAgICAgICBtaW4gPSBNYXRoLmFicyhtaW4pO1xyXG4gICAgICAgIGxldCBjID0gYiAtIGE7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gYyAqIHI7XHJcbiAgICAgICAgZGVsdGEgPSBkZWx0YSA8IDAgPyBNYXRoLm1pbihkZWx0YSwgLW1pbikgOiBNYXRoLm1heChkZWx0YSwgbWluKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gTWF0aC5hYnMoYykpIHtcclxuICAgICAgICAgICAgZGVsdGEgPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSArIGRlbHRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YCa6L+H5Lik54K55Z2Q5qCHKOS4jeW5s+ihjOS6juWdkOagh+i9tCnlkox477yM6K6h566X5Lik54K55byP5pa556iL57uT5p6ceVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNhbGNUd29Qb2ludEZvcm0ocDE6IGNjLlZlYzIsIHAyOiBjYy5WZWMyLCB4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmIChwMS54ID09PSBwMi54KSByZXR1cm4gcDEueTtcclxuICAgICAgICByZXR1cm4gKHAyLnkgLSBwMS55KSAqICh4IC0gcDEueCkgLyAocDIueCAtIHAxLngpICsgcDEueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuS4pOS4quefqeW9oueahOmHjeWPoOefqeW9ou+8jOS4jemHjeWPoOWImei/lOWbnm51bGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBvdmVybGFwUmVjdChyMTogY2MuUmVjdCwgcjI6IGNjLlJlY3QpOiBjYy5SZWN0IHtcclxuICAgICAgICBsZXQgeE1pbiA9IE1hdGgubWF4KHIxLnhNaW4sIHIyLnhNaW4pO1xyXG4gICAgICAgIGxldCB4TWF4ID0gTWF0aC5taW4ocjEueE1heCwgcjIueE1heCk7XHJcbiAgICAgICAgbGV0IHlNaW4gPSBNYXRoLm1heChyMS55TWluLCByMi55TWluKTtcclxuICAgICAgICBsZXQgeU1heCA9IE1hdGgubWluKHIxLnlNYXgsIHIyLnlNYXgpO1xyXG5cclxuICAgICAgICBpZiAoeE1pbiA+IHhNYXggfHwgeU1pbiA+IHlNYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYy5yZWN0KHhNaW4sIHlNaW4sIHhNYXggLSB4TWluLCB5TWF4IC0geU1pbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIbop5LluqbnuqbmnZ/lnKggWzAsMzYwKSDljLrpl7TlhoVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBub3JtYWxpemVEZWdyZWUoZGVncmVlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBkZWdyZWUgJSAzNjA7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA8IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IDM2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWchuW/g+WcqOWdkOagh+WOn+eCueeahOakreWchu+8jOS7peS4jnjovbTpgIbml7bpkojmlrnlkJHnmoTop5LluqborqHnrpflr7nlupTmpK3lnIbovrnkuIrnmoTlnZDmoIdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRFbGxpcHNlUG9pbnQoYTogbnVtYmVyLCBiOiBudW1iZXIsIGRlZ3JlZTogbnVtYmVyKTogY2MuVmVjMiB7XHJcbiAgICAgICAgZGVncmVlID0gdGhpcy5ub3JtYWxpemVEZWdyZWUoZGVncmVlKTtcclxuICAgICAgICBsZXQgayA9IE1hdGgudGFuKGNjLm1pc2MuZGVncmVlc1RvUmFkaWFucyhkZWdyZWUpKTtcclxuICAgICAgICBsZXQgeCA9IE1hdGguc3FydChiICogYiAvIChrICogayArIGIgKiBiIC8gYSAvIGEpKTtcclxuICAgICAgICBpZiAoZGVncmVlID4gOTAgJiYgZGVncmVlIDwgMjcwKSB7XHJcbiAgICAgICAgICAgIHggPSAteDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHkgPSBNYXRoLnNxcnQoYiAqIGIgLSBiICogYiAqIHggKiB4IC8gYSAvIGEpO1xyXG4gICAgICAgIGlmIChkZWdyZWUgPiAxODApIHtcclxuICAgICAgICAgICAgeSA9IC15O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNjLnYyKHgsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5pat5bCE57q/5LiO5ZyG5piv5ZCm55u45LqkXHJcbiAgICAgKiBAcGFyYW0gcmF5UG9pbnQg5bCE57q/6LW354K5XHJcbiAgICAgKiBAcGFyYW0gcmF5RGlyIOWwhOe6v+aWueWQkVxyXG4gICAgICogQHBhcmFtIGNpcmNsckNlbnRlciDlnIblv4NcclxuICAgICAqIEBwYXJhbSBjaXJjbGVSYWRpdXMg5ZyG5Y2K5b6EXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNSYXlDaXJjbGVJbnRlcnNlY3Rpb24ocmF5UG9pbnQ6IGNjLlZlYzIgfCBjYy5WZWMzLCByYXlEaXI6IGNjLlZlYzIsIGNpcmNsckNlbnRlcjogY2MuVmVjMiB8IGNjLlZlYzMsIGNpcmNsZVJhZGl1czogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGQgPSByYXlEaXIubWFnU3FyKCk7XHJcbiAgICAgICAgbGV0IHQgPSAoKGNpcmNsckNlbnRlci54IC0gcmF5UG9pbnQueCkgKiByYXlEaXIueCArIChjaXJjbHJDZW50ZXIueSAtIHJheVBvaW50LnkpICogcmF5RGlyLnkpIC8gZDtcclxuICAgICAgICBsZXQgcDtcclxuICAgICAgICBpZiAoZCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHAgPSByYXlQb2ludDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHAgPSByYXlQb2ludDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBjYy52MihyYXlQb2ludC54ICsgdCAqIHJheURpci54LCByYXlQb2ludC55ICsgdCAqIHJheURpci55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZHggPSBjaXJjbHJDZW50ZXIueCAtIHAueDtcclxuICAgICAgICBsZXQgZHkgPSBjaXJjbHJDZW50ZXIueSAtIHAueTtcclxuICAgICAgICByZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8PSBjaXJjbGVSYWRpdXMgKiBjaXJjbGVSYWRpdXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm552YWx1ZeaYr+WQpuWcqCBbbWluLCBtYXhdIOWMuumXtOWGhVxyXG4gICAgICogQHBhcmFtIG1pbiBcclxuICAgICAqIEBwYXJhbSBtYXggXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEBwYXJhbSBpbmNsdWRlRWRnZSB0cnVlKOm7mOiupOWAvCk6IFttaW4sIG1heF07IGZhbHNlOiAobWluLCBtYXgpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5SYW5nZShtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGluY2x1ZGVFZGdlOiBib29sZWFuID0gdHJ1ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBpbmNsdWRlRWRnZSA/IHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXggOiB2YWx1ZSA+IG1pbiAmJiB2YWx1ZSA8IG1heDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWMuumXtFttaW4sIG1heCnnmoTmlbTmlbDvvIzkvKDlhaUx5Liq5Y+C5pWw5YiZ5Yy66Ze05Li6WzAsIG1pbilcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYW5kSW50KG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciA9IHVuZGVmaW5lZCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1pbjtcclxuICAgICAgICAgICAgbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluID0gTWF0aC5jZWlsKG1pbik7XHJcbiAgICAgICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bljLrpl7RbbWluLCBtYXgp55qE5rWu54K55pWw77yM5Lyg5YWlMeS4quWPguaVsOWImeWMuumXtOS4ulswLCBtaW4pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmFuZEZsb2F0KG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciA9IHVuZGVmaW5lZCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1pbjtcclxuICAgICAgICAgICAgbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuS4gOS4quamgueOh+WAvCglKeeahOmaj+acuue7k+aenOaYr+WQpuWcqOamgueOh+iMg+WbtOWGhVxyXG4gICAgICogQHBhcmFtIHJhdGUg5qaC546H5YC8KCUpIFswLDEwMF1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYW5kUmF0ZVJlc3VsdChyYXRlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5kRmxvYXQoMTAwKSA8IHJhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7mnYPph43mlbDnu4Tov5vooYzpmo/mnLrvvIzov5Tlm57nu5PmnpzkuIvmoIdcclxuICAgICAqIEBwYXJhbSB3ZWlnaHRBcnIg5p2D6YeN5pWw57uEXHJcbiAgICAgKiBAcmV0dXJucyDpmo/mnLrliLDnmoTmnYPph43mlbDnu4TkuIvmoIdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYW5kV2VpZ2h0SWR4KHdlaWdodEFycjogbnVtYmVyW10pIHtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodEFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gd2VpZ2h0QXJyW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmFuZE51bSA9IHRoaXMucmFuZEZsb2F0KDAsIHN1bSk7XHJcbiAgICAgICAgbGV0IGN1clZhbHVlID0gMFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0QXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1clZhbHVlICs9IHdlaWdodEFycltpXTtcclxuICAgICAgICAgICAgaWYgKHJhbmROdW0gPCBjdXJWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdlaWdodEFyci5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlzaGVy4oCTWWF0ZXMgc2h1ZmZsZSDlrZfnrKbkuLLpmo/mnLrkubHluo9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaHVmZmxlU3RyaW5nKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgYXJyOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHN0cltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyciA9IHRoaXMuc2h1ZmZsZShhcnIpO1xyXG4gICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcclxuICAgICAgICAgICAgc3RyICs9IHY7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpc2hlcuKAk1lhdGVzIHNodWZmbGUg5pWw57uE6ZqP5py65Lmx5bqPXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2h1ZmZsZTxUPihhcnI6IEFycmF5PFQ+KTogQXJyYXk8VD4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XHJcbiAgICAgICAgICAgIFthcnJbcmFuZG9tSW5kZXhdLCBhcnJbaV1dID0gW2FycltpXSwgYXJyW3JhbmRvbUluZGV4XV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpmo/mnLrov5Tlm57mlbDnu4TkuK3nmoTkuIDkuKrlhYPntKBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhcnJheVJhbmQ8VD4oYXJyOiBBcnJheTxUPik6IFQge1xyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJbdGhpcy5yYW5kSW50KDAsIGFyci5sZW5ndGgpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWreaVsOe7hOS4reaYr+WQpuacieafkOS4quWFg+e0oFxyXG4gICAgICogQHBhcmFtIGFyciDmlbDnu4RcclxuICAgICAqIEBwYXJhbSBwYXJhbSDlhYPntKDlgLzmiJbooajovr7lhYPntKDlgLzmu6HotrPmn5Dnp43mnaHku7bnmoTlh73mlbBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhcnJheUhhczxUPihhcnI6IFRbXSwgcGFyYW06IFQgfCAoKGVsZTogVCkgPT4gYm9vbGVhbikpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgaWR4ID0gdHlwZW9mIHBhcmFtICE9PSBcImZ1bmN0aW9uXCIgPyBhcnIuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiBlID09PSBwYXJhbTsgfSkgOiBhcnIuZmluZEluZGV4KHBhcmFtIGFzICgoZWxlOiBUKSA9PiBib29sZWFuKSk7XHJcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5LiL5qCH5Lqk5o2i5pWw57uE5Lik5Liq5YWD57Sg5L2N572uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXJyYXlTd2FwPFQ+KGFycjogVFtdLCBpZHgxOiBudW1iZXIsIGlkeDI6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChpZHgxID09PSBpZHgyIHx8ICF0aGlzLmluUmFuZ2UoMCwgYXJyLmxlbmd0aCAtIDEsIGlkeDEpIHx8ICF0aGlzLmluUmFuZ2UoMCwgYXJyLmxlbmd0aCAtIDEsIGlkeDIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgW2FycltpZHgxXSwgYXJyW2lkeDJdXSA9IFthcnJbaWR4Ml0sIGFycltpZHgxXV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIblhYPntKDku45mcm9tSWR45L2N572u56e75YiwdG9JZHjkvY3nva7vvIzlhbbkvZnlhYPntKDnm7jlr7nkvY3nva7kuI3lj5hcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhcnJheU1vdmU8VD4oYXJyOiBUW10sIGZyb21JZHg6IG51bWJlciwgdG9JZHg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChmcm9tSWR4ID09PSB0b0lkeCB8fCAhdGhpcy5pblJhbmdlKDAsIGFyci5sZW5ndGggLSAxLCBmcm9tSWR4KSB8fCAhdGhpcy5pblJhbmdlKDAsIGFyci5sZW5ndGggLSAxLCB0b0lkeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZnJvbTogVFtdID0gYXJyLnNwbGljZShmcm9tSWR4LCAxKTtcclxuICAgICAgICBhcnIuc3BsaWNlKHRvSWR4LCAwLCBmcm9tWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWcqOaVsOe7hOS4rea3u+WKoOafkOS4quWFg+e0oFxyXG4gICAgICogQHBhcmFtIGNhblJlcGVhdCDmmK/lkKblj6/ph43lpI3mt7vliqDnm7jlkIzlhYPntKAg6buY6K6kZmFsc2VcclxuICAgICAqIEByZXR1cm4g5piv5ZCm5omn6KGM5LqG5re75Yqg6KGM5Li6XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXJyYXlBZGQ8VD4oYXJyOiBUW10sIGVsZTogVCwgY2FuUmVwZWF0OiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoIWNhblJlcGVhdCAmJiB0aGlzLmFycmF5SGFzKGFyciwgZWxlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyci5wdXNoKGVsZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlnKjmlbDnu4TkuK3liKDpmaTmn5DkuKrlhYPntKAo6Iul5pyJ5aSa5Liq55u45ZCM5YWD57Sg5YiZ5Y+q5Yig6Zmk56ys5LiA5LiqKVxyXG4gICAgICogQHJldHVybiDmmK/lkKbmiafooYzkuobliKDpmaTooYzkuLpcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhcnJheURlbGV0ZTxUPihhcnI6IFRbXSwgZWxlOiBUKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBhcnIuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiBlID09PSBlbGU7IH0pO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5Y+C5pWw6L+U5Zue5qC85byP5YyW5a2X56ym5LiyXHJcbiAgICAgKiBAcGFyYW0gdGV4dCDmupDlrZfnrKbkuLJcclxuICAgICAqIEBwYXJhbSBvcHRpb24g55So5LqO5qC85byP5YyW5rqQ5a2X56ym5Liy55qE5pWw5o2u77yM5Y+v5Lul5piv6ZSu5YC85a+577yM5Lmf5Y+v5Lul5oyJ6aG65bqP5Lyg5Y+CXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8g5Y+v5L2/55So5Lul5LiL5Lik56eN6LCD55So5pa55byP77yM6L+U5Zue57uT5p6c6YO95pivXCLmtYvor5XlrZfnrKbkuLIxMTEtLWFiYy4uLlwiXHJcbiAgICAgKiBUb29sLmZvcm1hdFN0cmluZyhcIua1i+ivleWtl+espuS4siV7YTF9LS0le2EyfS4uLlwiLCB7YTE6IDExMSwgYTI6IFwiYWJjXCJ9KTtcclxuICAgICAqIFRvb2wuZm9ybWF0U3RyaW5nKFwi5rWL6K+V5a2X56ym5LiyJXthMX0tLSV7YTJ9Li4uXCIsIDExMSwgXCJhYmNcIik7XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZm9ybWF0U3RyaW5nKHRleHQ6IHN0cmluZywgLi4ub3B0aW9uOiBbUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPl0gfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+KTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGV4dDtcclxuICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCA9PT0gMSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9uWzBdKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xyXG4gICAgICAgICAgICAvLyDlj4LmlbDkuLrplK7lgLzlr7lcclxuICAgICAgICAgICAgZm9yIChsZXQgYXJnIGluIChvcHRpb25bMF0gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25bMF0uaGFzT3duUHJvcGVydHkoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKGAleyR7YXJnfX1gLCBcImdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocmVnLCBgJHtvcHRpb25bMF1bYXJnXX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOWPguaVsOS4uuaVsOe7hFxyXG4gICAgICAgICAgICBvcHRpb24uZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoLyVcXHsuKj9cXH0vLCBgJHt2YWx1ZX1gKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlr7nkuIDmrrXml7bpl7Tov5Tlm57moLzlvI/ljJbml7bpl7TlrZfnrKbkuLJcclxuICAgICAqIEBwYXJhbSBzZWMg5pe26Ze0c1xyXG4gICAgICogQHBhcmFtIGZvcm1hdCDmoLzlvI/ljJblrZfnrKbkuLJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyDlvZNmb3JtYXTkuLpzdHJpbmfml7bvvIzkvJrku6Vmb3JtYXTkuK3nmoTmnIDlpKfml7bpl7TljZXkvY3ov5vooYzmoLzlvI/ljJZcclxuICAgICAqIFRvb2wuZm9ybWF0VGltZVN0cmluZygzNjAxLCBcIiV7bX06JXtzfVwiKTsgLy8gNjA6MVxyXG4gICAgICogVG9vbC5mb3JtYXRUaW1lU3RyaW5nKDM2MDEsIFwiJXttbX06JXtzc31cIik7IC8vIDYwOjAxXHJcbiAgICAgKiBUb29sLmZvcm1hdFRpbWVTdHJpbmcoMzYwMSwgXCIle2hofTole21tfTole3NzfVwiKTsgLy8gMDE6MDA6MDFcclxuICAgICAqIFxyXG4gICAgICogLy8g5b2TZm9ybWF05Li6b2JqZWN05pe277yM5Lya5Lul5Lyg5YWl55qEc2Vj6K6h566X5pyA5aSn55qE5pe26Ze05Y2V5L2N77yM5bm26YCJ5oupZm9ybWF05a+55bqU55qE5a2X56ym5Liy6L+b6KGM5qC85byP5YyWXHJcbiAgICAgKiBUb29sLmZvcm1hdFRpbWVTdHJpbmcoMTAwLCB7XHJcbiAgICAgKiAgICAgUzogXCIle3N956eSXCIsXHJcbiAgICAgKiAgICAgTTogXCIle2195YiGJXtzfeenklwiLFxyXG4gICAgICogICAgIEg6IFwiJXtofeaXtiV7bX3liIYle3N956eSXCIsXHJcbiAgICAgKiAgICAgRDogXCIle2R95aSpJXtofeaXtiV7bX3liIYle3N956eSXCJcclxuICAgICAqIH0pOyAvLyAx5YiGNDDnp5JcclxuICAgICAqIFRvb2wuZm9ybWF0VGltZVN0cmluZygxMDAwMDAsIHtcclxuICAgICAqICAgICBTOiBcIiV7c33np5JcIixcclxuICAgICAqICAgICBNOiBcIiV7bX3liIYle3N956eSXCIsXHJcbiAgICAgKiAgICAgSDogXCIle2h95pe2JXttfeWIhiV7c33np5JcIixcclxuICAgICAqICAgICBEOiBcIiV7ZH3lpKkle2h95pe2JXttfeWIhiV7c33np5JcIlxyXG4gICAgICogfSk7IC8vIDHlpKkz5pe2NDbliIY0MOenklxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZvcm1hdFRpbWVTdHJpbmcoc2VjOiBudW1iZXIsIGZvcm1hdDogc3RyaW5nIHwgeyBcIlNcIjogc3RyaW5nOyBcIk1cIjogc3RyaW5nOyBcIkhcIjogc3RyaW5nOyBcIkRcIjogc3RyaW5nIH0gPSBcIiV7aGh9OiV7bW19OiV7c3N9XCIpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBzZWNvbmRzOiBudW1iZXIgPSBNYXRoLmZsb29yKHNlYyk7XHJcbiAgICAgICAgbGV0IG1pbnV0ZXM6IG51bWJlciA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcclxuICAgICAgICBsZXQgaG91cnM6IG51bWJlciA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xyXG4gICAgICAgIGxldCBkYXlzOiBudW1iZXIgPSBNYXRoLmZsb29yKHNlY29uZHMgLyA4NjQwMCk7XHJcblxyXG4gICAgICAgIGxldCBtYXhVbml0OiBUaW1lVW5pdCA9IFRpbWVVbml0LlM7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgLy8g5p+l6K+i5qC85byP5YyW5a2X56ym5Liy5Lit5pyA5aSn55qE5Y2V5L2NXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgaWYgKC8lXFx7ZCtcXH0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICAgICAgbWF4VW5pdCA9IFRpbWVVbml0LkQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLyVcXHtoK1xcfS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhVbml0ID0gVGltZVVuaXQuSDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgvJVxce20rXFx9Ly50ZXN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIG1heFVuaXQgPSBUaW1lVW5pdC5NO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5Lul5Lyg5YWl55qE5pWw5YC85Yik5pat5pyA5aSn5Y2V5L2NXHJcbiAgICAgICAgICAgIGlmIChkYXlzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbWF4VW5pdCA9IFRpbWVVbml0LkQ7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmb3JtYXQuRDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VycyA+IDApIHtcclxuICAgICAgICAgICAgICAgIG1heFVuaXQgPSBUaW1lVW5pdC5IO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9ybWF0Lkg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWludXRlcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIG1heFVuaXQgPSBUaW1lVW5pdC5NO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9ybWF0Lk07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXhVbml0ID0gVGltZVVuaXQuUztcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZvcm1hdC5TO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobWF4VW5pdCA+IFRpbWVVbml0LlMpIHtcclxuICAgICAgICAgICAgc2Vjb25kcyAlPSA2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heFVuaXQgPiBUaW1lVW5pdC5NKSB7XHJcbiAgICAgICAgICAgIG1pbnV0ZXMgJT0gNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhVbml0ID4gVGltZVVuaXQuSCkge1xyXG4gICAgICAgICAgICBob3VycyAlPSAyNDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkYXRhID0ge1xyXG4gICAgICAgICAgICBkZDogZGF5cyA8IDEwID8gYDAke2RheXN9YCA6IGAke2RheXN9YCxcclxuICAgICAgICAgICAgZDogYCR7ZGF5c31gLFxyXG4gICAgICAgICAgICBoaDogaG91cnMgPCAxMCA/IGAwJHtob3Vyc31gIDogYCR7aG91cnN9YCxcclxuICAgICAgICAgICAgaDogYCR7aG91cnN9YCxcclxuICAgICAgICAgICAgbW06IG1pbnV0ZXMgPCAxMCA/IGAwJHttaW51dGVzfWAgOiBgJHttaW51dGVzfWAsXHJcbiAgICAgICAgICAgIG06IGAke21pbnV0ZXN9YCxcclxuICAgICAgICAgICAgc3M6IHNlY29uZHMgPCAxMCA/IGAwJHtzZWNvbmRzfWAgOiBgJHtzZWNvbmRzfWAsXHJcbiAgICAgICAgICAgIHM6IGAke3NlY29uZHN9YFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRTdHJpbmcocmVzdWx0LCBkYXRhKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bCG5LiA5LiqRGF0ZeWvueixoeaIlkRhdGXml7bpl7TmiLPov5Tlm57moLzlvI/ljJbml6XmnJ/lrZfnrKbkuLJcclxuICAgICAqIEBwYXJhbSBkYXRlIERhdGXlr7nosaHmiJZEYXRl5pe26Ze05oizXHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IOagvOW8j+WMluWtl+espuS4slxyXG4gICAgICogQHBhcmFtIGlzVVRDIHRydWU6VVRD5pe26Ze0IGZhbHNlOuacrOWcsOaXtumXtFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIFRvb2wuZm9ybWF0RGF0ZVN0cmluZygwLCBcIiV7WVlZWX0tJXtNTX0tJXtkZH0gJXtoaH06JXttbX06JXtzc31cIiwgdHJ1ZSk7IC8vIFwiMTk3MC0wMS0wMSAwMDowMDowMFwiXHJcbiAgICAgKiBUb29sLmZvcm1hdERhdGVTdHJpbmcoMCwgXCIle2RkfS8le01NfS8le1lZfVwiLCB0cnVlKTsgLy8gXCIwMS8wMS83MFwiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZm9ybWF0RGF0ZVN0cmluZyhkYXRlOiBudW1iZXIgfCBEYXRlLCBmb3JtYXQ6IHN0cmluZyA9IFwiJXtZWVlZfS0le01NfS0le2RkfSAle2hofTole21tfTole3NzfVwiLCBpc1VUQzogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgc3JjID0gZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRlIDogbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgbGV0IHllYXIgPSBpc1VUQyA/IHNyYy5nZXRVVENGdWxsWWVhcigpIDogc3JjLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgbGV0IG1vbnRoID0gaXNVVEMgPyBzcmMuZ2V0VVRDTW9udGgoKSArIDEgOiBzcmMuZ2V0TW9udGgoKSArIDE7XHJcbiAgICAgICAgbGV0IGRheXMgPSBpc1VUQyA/IHNyYy5nZXRVVENEYXRlKCkgOiBzcmMuZ2V0RGF0ZSgpO1xyXG4gICAgICAgIGxldCBob3VycyA9IGlzVVRDID8gc3JjLmdldFVUQ0hvdXJzKCkgOiBzcmMuZ2V0SG91cnMoKTtcclxuICAgICAgICBsZXQgbWludXRlcyA9IGlzVVRDID8gc3JjLmdldFVUQ01pbnV0ZXMoKSA6IHNyYy5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgbGV0IHNlY29uZHMgPSBpc1VUQyA/IHNyYy5nZXRVVENTZWNvbmRzKCkgOiBzcmMuZ2V0U2Vjb25kcygpO1xyXG5cclxuICAgICAgICBsZXQgZGF0YSA9IHtcclxuICAgICAgICAgICAgWVlZWTogYCR7eWVhcn1gLFxyXG4gICAgICAgICAgICBZWTogeWVhciAlIDEwMCA8IDEwID8gYDAke3llYXIgJSAxMDB9YCA6IGAke3llYXIgJSAxMDB9YCxcclxuICAgICAgICAgICAgTU06IG1vbnRoIDwgMTAgPyBgMCR7bW9udGh9YCA6IGAke21vbnRofWAsXHJcbiAgICAgICAgICAgIE06IGAke21vbnRofWAsXHJcbiAgICAgICAgICAgIGRkOiBkYXlzIDwgMTAgPyBgMCR7ZGF5c31gIDogYCR7ZGF5c31gLFxyXG4gICAgICAgICAgICBkOiBgJHtkYXlzfWAsXHJcbiAgICAgICAgICAgIGhoOiBob3VycyA8IDEwID8gYDAke2hvdXJzfWAgOiBgJHtob3Vyc31gLFxyXG4gICAgICAgICAgICBoOiBgJHtob3Vyc31gLFxyXG4gICAgICAgICAgICBtbTogbWludXRlcyA8IDEwID8gYDAke21pbnV0ZXN9YCA6IGAke21pbnV0ZXN9YCxcclxuICAgICAgICAgICAgbTogYCR7bWludXRlc31gLFxyXG4gICAgICAgICAgICBzczogc2Vjb25kcyA8IDEwID8gYDAke3NlY29uZHN9YCA6IGAke3NlY29uZHN9YCxcclxuICAgICAgICAgICAgczogYCR7c2Vjb25kc31gXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmZvcm1hdFN0cmluZyhmb3JtYXQsIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlrZDoioLngrnpgJLlvZLlpITnkIZcclxuICAgICAqIEBwYXJhbSBub2RlIOmcgOimgemAkuW9kuWkhOeQhueahOiKgueCueaIluiKgueCueaVsOe7hFxyXG4gICAgICogQHBhcmFtIGNiIOiKgueCueWkhOeQhuWHveaVsFxyXG4gICAgICogQHBhcmFtIHRoaXNBcmcgY2Lnu5HlrprnmoR0aGlz5a+56LGhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbm9kZVJlY3Vyc2l2ZShub2RlOiBjYy5Ob2RlIHwgY2MuTm9kZVtdLCBjYjogKG46IGNjLk5vZGUpID0+IHZvaWQsIHRoaXNBcmc6IGFueSA9IHVuZGVmaW5lZCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgY2MuTm9kZSkge1xyXG4gICAgICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKG46IGNjLk5vZGUpID0+IHsgdGhpcy5ub2RlUmVjdXJzaXZlKG4sIGNiLCB0aGlzQXJnKTsgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuZm9yRWFjaCgobjogY2MuTm9kZSkgPT4geyB0aGlzLm5vZGVSZWN1cnNpdmUobiwgY2IsIHRoaXNBcmcpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkZXN0cm955bm256uL5Y2zcmVtb3Zl5Lyg5YWl6IqC54K555qE5omA5pyJ5a2Q6IqC54K5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXJDaGlsZHJlbiguLi5ub2RlczogY2MuTm9kZVtdKTogdm9pZCB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLmRlc3Ryb3lBbGxDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICBlLnJlbW92ZUFsbENoaWxkcmVuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIOS4uuiKgueCuea3u+WKoOW4puWPguaVsOeahOeCueWHu+S6i+S7tlxyXG4gICAgKiBAcGFyYW0gbm9kZSDmt7vliqDngrnlh7vkuovku7bnmoToioLngrlcclxuICAgICogQHBhcmFtIGNvbXBvbmVudCDnu4Tku7blkI3np7AgLS0g6ISa5pys5ZCN56ewXHJcbiAgICAqIEBwYXJhbSBjYWxsQmFjayDngrnlh7vkuovku7blh73mlbAgLS0g6ZyA6KaB5Zyo6K+lY29tcG9uZW506ISa5pys5YaF55qE5pa55rOVXHJcbiAgICAqIEBwYXJhbSBwYXJhbSDngrnlh7vkuovku7bkvKDlhaXnmoTlj4LmlbBcclxuICAgICogQHBhcmFtIHRhcmdldCDkuovku7blpITnkIbku6PnoIHnu4Tku7bmiYDlsZ7nmoToioLngrkgLS0g6K+lY29tcG9uZW506ISa5pys5omA5oyC6L295Zyo55qE6IqC54K5XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRQYXJhbUJ1dHRvbkNsaWNrKG5vZGU6IGNjLk5vZGUsIGNvbXBvbmVudDogc3RyaW5nLCBjYWxsQmFjazogc3RyaW5nLCBwYXJhbTogc3RyaW5nLCB0YXJnZXQ6IGNjLk5vZGUsIHNjYWxlPzogYm9vbGVhbikge1xyXG4gICAgICAgIGxldCBjbGlja0V2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKClcclxuICAgICAgICBjbGlja0V2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQgLy8g5LqL5Lu25aSE55CG5Luj56CB57uE5Lu25omA5bGe55qE6IqC54K5IC0tIOivpWNvbXBvbmVudOiEmuacrOaJgOaMgui9veWcqOeahOiKgueCuVxyXG4gICAgICAgIGNsaWNrRXZlbnRIYW5kbGVyLmNvbXBvbmVudCA9IGNvbXBvbmVudCAvLyDnu4Tku7blkI3np7AgLS0g6ISa5pys5ZCN56ewXHJcbiAgICAgICAgY2xpY2tFdmVudEhhbmRsZXIuaGFuZGxlciA9IGNhbGxCYWNrIC8vIOeCueWHu+S6i+S7tuWHveaVsCAtLSDpnIDopoHlnKjor6Vjb21wb25lbnTohJrmnKzlhoXnmoTmlrnms5VcclxuICAgICAgICBjbGlja0V2ZW50SGFuZGxlci5jdXN0b21FdmVudERhdGEgPSBwYXJhbSAvLyDngrnlh7vkuovku7bkvKDlhaXnmoTlj4LmlbBcclxuXHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IG5vZGUuZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbilcclxuICAgICAgICBpZiAoIWJ1dHRvbikge1xyXG4gICAgICAgICAgICBidXR0b24gPSBub2RlLmFkZENvbXBvbmVudChjYy5CdXR0b24pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2FsZSkge1xyXG4gICAgICAgICAgICBidXR0b24udHJhbnNpdGlvbiA9IGNjLkJ1dHRvbi5UcmFuc2l0aW9uLlNDQUxFXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBidXR0b24uY2xpY2tFdmVudHMgPSBbXVxyXG4gICAgICAgIGJ1dHRvbi5jbGlja0V2ZW50cy5wdXNoKGNsaWNrRXZlbnRIYW5kbGVyKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiDop6Pnu5HluKblj4LmlbDnmoTngrnlh7vkuovku7ZcclxuICAgICogQHBhcmFtIG5vZGUg5re75Yqg54K55Ye75LqL5Lu255qE6IqC54K5XHJcbiAgICAqIEBwYXJhbSBjb21wb25lbnQg57uE5Lu25ZCN56ewIC0tIOiEmuacrOWQjeensFxyXG4gICAgKiBAcGFyYW0gY2FsbEJhY2sg54K55Ye75LqL5Lu25Ye95pWwIC0tIOmcgOimgeWcqOivpWNvbXBvbmVudOiEmuacrOWGheeahOaWueazlVxyXG4gICAgKiBAcGFyYW0gdGFyZ2V0IOS6i+S7tuWkhOeQhuS7o+eggee7hOS7tuaJgOWxnueahOiKgueCuSAtLSDor6Vjb21wb25lbnTohJrmnKzmiYDmjILovb3lnKjnmoToioLngrlcclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZVBhcmFtQnV0dG9uQ2xpY2sobm9kZTogY2MuTm9kZSwgY29tcG9uZW50OiBzdHJpbmcsIGNhbGxCYWNrOiBzdHJpbmcsIHRhcmdldDogY2MuTm9kZSkge1xyXG4gICAgICAgIGxldCBidXR0b24gPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pO1xyXG4gICAgICAgIGlmIChidXR0b24pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJ1dHRvbi5jbGlja0V2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SGFuZGxlciA9IGJ1dHRvbi5jbGlja0V2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIudGFyZ2V0ID09PSB0YXJnZXQgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuY29tcG9uZW50ID09PSBjb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuaGFuZGxlciA9PT0gY2FsbEJhY2tcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOenu+mZpOWvueW6lOeahOeCueWHu+S6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGlja0V2ZW50cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/common/util/AudioManager.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ed9cbEOGDVGSIJOKhzlTwEi', 'AudioManager');
// scripts/common/util/AudioManager.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfxType = void 0;
var Tween_1 = require("./Tween");
/**
 * 音效类型
 */
var SfxType;
(function (SfxType) {
    SfxType[SfxType["NORMAL"] = 0] = "NORMAL";
    SfxType[SfxType["UI"] = 1] = "UI";
})(SfxType = exports.SfxType || (exports.SfxType = {}));
/**
 * 音频管理类
 */
var AudioManager = /** @class */ (function () {
    function AudioManager() {
    }
    Object.defineProperty(AudioManager, "bgmVolume", {
        /** 全局bgm音量 */
        get: function () { return this._bgmVolume; },
        set: function (volume) {
            var _this = this;
            if (this._bgmVolume === volume) {
                return;
            }
            this._bgmVolume = cc.misc.clampf(volume, 0, 1);
            this._bgmMap.forEach(function (audioData, clip) {
                cc.audioEngine.setVolume(audioData.id, _this._bgmVolume * audioData.volume);
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioManager, "sfxVolume", {
        /** 全局sfx音量 */
        get: function () { return this._sfxVolume; },
        set: function (volume) {
            var _this = this;
            if (this._sfxVolume === volume) {
                return;
            }
            this._sfxVolume = cc.misc.clampf(volume, 0, 1);
            this._normalSfxMap.forEach(function (data, clip) {
                data.audioList.forEach(function (audioData) {
                    cc.audioEngine.setVolume(audioData.id, _this._sfxVolume * audioData.volume);
                });
            });
            this._uiSfxMap.forEach(function (data, clip) {
                data.audioList.forEach(function (audioData) {
                    cc.audioEngine.setVolume(audioData.id, _this._sfxVolume * audioData.volume);
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioManager, "bgmOff", {
        /** bgm是否关闭 */
        get: function () { return this._bgmOff; },
        set: function (isOff) {
            var _this = this;
            if (this._bgmOff === isOff) {
                return;
            }
            this._bgmOff = isOff;
            if (this._bgmOff) {
                this._bgmMap.forEach(function (audioData, clip) {
                    _this.stop(audioData);
                });
                this._bgmMap.clear();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioManager, "sfxOff", {
        /** sfx是否关闭 */
        get: function () { return this._sfxOff; },
        set: function (isOff) {
            var _this = this;
            if (this._sfxOff === isOff) {
                return;
            }
            this._sfxOff = isOff;
            if (this._sfxOff) {
                this._normalSfxMap.forEach(function (data, clip) {
                    data.audioList.forEach(function (audioData) {
                        _this.stop(audioData);
                    });
                    data.audioList.length = 0;
                });
                this._uiSfxMap.forEach(function (data, clip) {
                    data.audioList.forEach(function (audioData) {
                        _this.stop(audioData);
                    });
                    data.audioList.length = 0;
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioManager, "bgmPause", {
        /** bgm是否暂停 */
        get: function () { return this._bgmPause; },
        set: function (isPause) {
            var _this = this;
            if (this.bgmOff || this._bgmPause === isPause) {
                return;
            }
            this._bgmPause = isPause;
            this._bgmMap.forEach(function (audioData, clip) {
                var _a, _b;
                if (_this._bgmPause) {
                    (_a = audioData.tween) === null || _a === void 0 ? void 0 : _a.pause();
                    cc.audioEngine.pause(audioData.id);
                }
                else {
                    (_b = audioData.tween) === null || _b === void 0 ? void 0 : _b.resume();
                    cc.audioEngine.resume(audioData.id);
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AudioManager, "sfxPause", {
        /** sfx是否暂停，暂停时不暂停ui音效 */
        get: function () { return this._sfxPause; },
        set: function (isPause) {
            if (this.sfxOff || this._sfxPause === isPause) {
                return;
            }
            this._sfxPause = isPause;
            if (this._sfxPause) {
                this._normalSfxMap.forEach(function (data, clip) {
                    data.audioList.forEach(function (audioData) {
                        var _a;
                        (_a = audioData.tween) === null || _a === void 0 ? void 0 : _a.pause();
                        cc.audioEngine.pause(audioData.id);
                    });
                });
            }
            else {
                this._normalSfxMap.forEach(function (data, clip) {
                    data.audioList.forEach(function (audioData) {
                        var _a;
                        (_a = audioData.tween) === null || _a === void 0 ? void 0 : _a.resume();
                        cc.audioEngine.resume(audioData.id);
                    });
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 音量渐变
     * @param data
     * @param duration 音量渐变时长 单位s
     * @param from 音量初始值
     * @param to 音量目标值
     * @param call 渐变结束的回调
     */
    AudioManager.volumeFade = function (data, duration, from, to, call) {
        var _this = this;
        var _a;
        (_a = data.tween) === null || _a === void 0 ? void 0 : _a.stop();
        data.volume = from;
        cc.audioEngine.setVolume(data.id, data.volume * this.bgmVolume);
        data.tween = new Tween_1.Tween(data)
            .to({ volume: to }, duration * 1000)
            .onUpdate(function () {
            cc.audioEngine.setVolume(data.id, data.volume * _this.bgmVolume);
        })
            .onComplete(function () {
            data.tween = null;
            if (call) {
                call();
            }
        })
            .start();
    };
    /**
     * 停止音频
     * @param audioData
     */
    AudioManager.stop = function (audioData) {
        if (audioData.tween) {
            audioData.tween.stop();
            audioData.tween = null;
        }
        cc.audioEngine.stop(audioData.id);
    };
    /**
     * 播放音频并返回AudioData
     */
    AudioManager.play = function (args, volume, audioData) {
        if (audioData === void 0) { audioData = null; }
        var data = args instanceof cc.AudioClip ? { clip: args } : args;
        if (!data.hasOwnProperty("loop")) {
            data.loop = false;
        }
        if (!data.hasOwnProperty("fadeDuration")) {
            data.fadeDuration = 0;
        }
        if (!data.hasOwnProperty("finishCall")) {
            data.finishCall = null;
        }
        if (audioData) {
            audioData.id = cc.audioEngine.play(data.clip, data.loop, volume);
            audioData.volume = 1;
            if (audioData.tween) {
                audioData.tween.stop();
                audioData.tween = null;
            }
        }
        else {
            audioData = {
                id: cc.audioEngine.play(data.clip, data.loop, volume),
                volume: 1,
                tween: null
            };
        }
        if (data.finishCall) {
            cc.audioEngine.setFinishCallback(audioData.id, data.finishCall);
        }
        if (data.fadeDuration > 0) {
            this.volumeFade(audioData, data.fadeDuration, 0, 1);
        }
        return audioData;
    };
    /**
     * 播放bgm
     */
    AudioManager.playBgm = function (args) {
        var clip = args instanceof cc.AudioClip ? args : args.clip;
        if (this.bgmOff || !clip) {
            return;
        }
        var audioData = this._bgmMap.get(clip);
        if (audioData === undefined) {
            audioData = this.play(args, this.bgmVolume);
            this._bgmMap.set(clip, audioData);
        }
        else {
            this.stop(audioData);
            this.play(args, this.bgmVolume, audioData);
        }
    };
    /**
     * 播放sfx
     */
    AudioManager.playSfx = function (args, type) {
        if (type === void 0) { type = SfxType.NORMAL; }
        var clip = args instanceof cc.AudioClip ? args : args.clip;
        if (this.sfxOff || !clip) {
            return;
        }
        var sfxData = type === SfxType.NORMAL ? this._normalSfxMap.get(clip) : this._uiSfxMap.get(clip);
        var audioData = null;
        if (sfxData === undefined) {
            sfxData = this.setSfxData(clip, type);
            audioData = this.play(args, this.sfxVolume);
            sfxData.audioList.push(audioData);
        }
        else {
            // 剔除不处于播放状态的音频
            while (sfxData.audioList.length > 0 && cc.audioEngine.getState(sfxData.audioList[0].id) !== cc.audioEngine.AudioState.PLAYING) {
                this.stop(sfxData.audioList.shift());
            }
            // 已达到最大数量则剔除最先(第一个)缓存的音频
            while (sfxData.overStop && sfxData.audioList.length >= sfxData.maxNum) {
                this.stop(sfxData.audioList.shift());
            }
            // 缓存新的音频
            if (sfxData.audioList.length < sfxData.maxNum) {
                audioData = this.play(args, this.sfxVolume);
                sfxData.audioList.push(audioData);
            }
        }
    };
    /**
     * 设置音效数据（用于限制某些短时间内同时大量播放的音效）
     * @param clip
     * @param type 音效类型
     * @param maxNum 此音效最大同时播放的数量
     * @param overStop 超过最大数量时是否stop未播完的音效并缓存新的音效
     */
    AudioManager.setSfxData = function (clip, type, maxNum, overStop) {
        if (type === void 0) { type = SfxType.NORMAL; }
        if (maxNum === void 0) { maxNum = 8; }
        if (overStop === void 0) { overStop = false; }
        if (!clip) {
            return;
        }
        maxNum = Math.max(maxNum, 1);
        var map = type === SfxType.NORMAL ? this._normalSfxMap : this._uiSfxMap;
        var sfxData = map.get(clip);
        if (sfxData === undefined) {
            sfxData = {
                audioList: [],
                maxNum: maxNum,
                overStop: overStop
            };
            map.set(clip, sfxData);
        }
        else {
            sfxData.maxNum = maxNum;
            sfxData.overStop = overStop;
        }
        return sfxData;
    };
    /**
     * 停止bgm
     * @param clip 需停止的音频，clip返回值为false则停止所有
     * @param fadeDuration 音量渐变时长 单位s
     */
    AudioManager.stopBgm = function (clip, fadeDuration) {
        var _this = this;
        if (clip === void 0) { clip = null; }
        if (fadeDuration === void 0) { fadeDuration = 0; }
        if (this.bgmOff) {
            return;
        }
        if (clip) {
            var audioData_1 = this._bgmMap.get(clip);
            if (audioData_1 === undefined) {
                return;
            }
            if (fadeDuration <= 0) {
                this.stop(audioData_1);
                this._bgmMap.delete(clip);
            }
            else {
                this.volumeFade(audioData_1, fadeDuration, 1, 0, function () {
                    _this.stop(audioData_1);
                    _this._bgmMap.delete(clip);
                });
            }
        }
        else {
            if (fadeDuration <= 0) {
                this._bgmMap.forEach(function (audioData, clip) {
                    _this.stop(audioData);
                });
                this._bgmMap.clear();
            }
            else {
                this._bgmMap.forEach(function (audioData, clip) {
                    _this.volumeFade(audioData, fadeDuration, 1, 0, function () {
                        _this.stop(audioData);
                        _this._bgmMap.delete(clip);
                    });
                });
            }
        }
    };
    /**
     * 停止sfx
     * @param clip 需停止的音频，clip返回值为false则停止所有
     * @param type 音效类型
     */
    AudioManager.stopSfx = function (clip, type) {
        var _this = this;
        if (clip === void 0) { clip = null; }
        if (type === void 0) { type = SfxType.NORMAL; }
        if (this.sfxOff) {
            return;
        }
        if (clip) {
            var data = type === SfxType.NORMAL ? this._normalSfxMap.get(clip) : this._uiSfxMap.get(clip);
            if (data === undefined || data.audioList.length <= 0) {
                return;
            }
            data.audioList.forEach(function (audioData) {
                _this.stop(audioData);
            });
            data.audioList.length = 0;
        }
        else {
            this._normalSfxMap.forEach(function (data, clip) {
                data.audioList.forEach(function (audioData) {
                    _this.stop(audioData);
                });
                data.audioList.length = 0;
            });
            this._uiSfxMap.forEach(function (data, clip) {
                data.audioList.forEach(function (audioData) {
                    _this.stop(audioData);
                });
                data.audioList.length = 0;
            });
        }
    };
    /**
     * 停止所有音频
     */
    AudioManager.stopAll = function () {
        this.stopBgm();
        this.stopSfx();
    };
    /**
     * 暂停所有音频
     */
    AudioManager.pauseAll = function () {
        this.bgmPause = true;
        this.sfxPause = true;
    };
    /**
     * 恢复所有音频
     */
    AudioManager.resumeAll = function () {
        this.bgmPause = false;
        this.sfxPause = false;
    };
    /**
     * 停止所有音频，清除所有音频缓存
     */
    AudioManager.uncacheAll = function () {
        this.stopAll();
        this._bgmMap.clear();
        this._normalSfxMap.clear();
        this._uiSfxMap.clear();
        cc.audioEngine.uncacheAll();
    };
    /** 缓存的bgm数据 */
    AudioManager._bgmMap = new Map();
    /** 缓存的普通音效数据 */
    AudioManager._normalSfxMap = new Map();
    /** 缓存的ui音效数据 */
    AudioManager._uiSfxMap = new Map();
    AudioManager._bgmVolume = 1;
    AudioManager._sfxVolume = 1;
    AudioManager._bgmOff = false;
    AudioManager._sfxOff = false;
    AudioManager._bgmPause = false;
    AudioManager._sfxPause = false;
    return AudioManager;
}());
exports.default = AudioManager;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcY29tbW9uXFx1dGlsXFxBdWRpb01hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQWdDO0FBRWhDOztHQUVHO0FBQ0gsSUFBWSxPQUdYO0FBSEQsV0FBWSxPQUFPO0lBQ2YseUNBQU0sQ0FBQTtJQUNOLGlDQUFFLENBQUE7QUFDTixDQUFDLEVBSFcsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBR2xCO0FBd0NEOztHQUVHO0FBQ0g7SUFBQTtJQW1aQSxDQUFDO0lBellHLHNCQUFrQix5QkFBUztRQUQzQixjQUFjO2FBQ2QsY0FBd0MsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzthQUNqRSxVQUE0QixNQUFjO1lBQTFDLGlCQVNDO1lBUkcsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLE1BQU0sRUFBRTtnQkFDNUIsT0FBTzthQUNWO1lBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQUMsU0FBb0IsRUFBRSxJQUFrQjtnQkFDMUQsRUFBRSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxLQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMvRSxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUM7OztPQVZnRTtJQWNqRSxzQkFBa0IseUJBQVM7UUFEM0IsY0FBYzthQUNkLGNBQXdDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDakUsVUFBNEIsTUFBYztZQUExQyxpQkFnQkM7WUFmRyxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssTUFBTSxFQUFFO2dCQUM1QixPQUFPO2FBQ1Y7WUFFRCxJ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b0JBQU8sR0FBWSxLQUFLLENBQUM7SUF5QnpCLHNCQUFTLEdBQVksS0FBSyxDQUFDO0lBb0IzQixzQkFBUyxHQUFZLEtBQUssQ0FBQztJQTBTOUMsbUJBQUM7Q0FuWkQsQUFtWkMsSUFBQTtrQkFuWm9CLFlBQVkiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUd2VlbiB9IGZyb20gXCIuL1R3ZWVuXCI7XHJcblxyXG4vKipcclxuICog6Z+z5pWI57G75Z6LXHJcbiAqL1xyXG5leHBvcnQgZW51bSBTZnhUeXBlIHtcclxuICAgIE5PUk1BTCxcclxuICAgIFVJXHJcbn1cclxuXHJcbi8qKlxyXG4gKiDpn7PpopHmkq3mlL7lj4LmlbBcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9QbGF5QXJncyB7XHJcbiAgICAvKiogQXVkaW9DbGlwICovXHJcbiAgICBjbGlwOiBjYy5BdWRpb0NsaXA7XHJcbiAgICAvKiog5piv5ZCm5b6q546v77yM6buY6K6kZmFsc2UgKi9cclxuICAgIGxvb3A/OiBib29sZWFuO1xyXG4gICAgLyoqIOmfs+mHj+a4kOWPmOaXtumVv++8jOWNleS9jXPjgILpu5jorqQwICovXHJcbiAgICBmYWRlRHVyYXRpb24/OiBudW1iZXI7XHJcbiAgICAvKiog5pKt5pS+57uT5p2f55qE5Zue6LCDICovXHJcbiAgICBmaW5pc2hDYWxsPzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF1ZGlv57yT5a2Y5pWw5o2uXHJcbiAqL1xyXG5pbnRlcmZhY2UgQXVkaW9EYXRhIHtcclxuICAgIC8qKiBhdWRpb0lEICovXHJcbiAgICBpZDogbnVtYmVyO1xyXG4gICAgLyoqIOeUqOS6juWNleeLrOaOp+WItueahOmfs+mHjyAqL1xyXG4gICAgdm9sdW1lOiBudW1iZXI7XHJcbiAgICAvKiog6Z+z6YeP5riQ5Y+YdHdlZW7lr7nosaEgKi9cclxuICAgIHR3ZWVuOiBUd2VlbjxBdWRpb0RhdGE+O1xyXG59XHJcblxyXG4vKipcclxuICog5Y2V5LiqQXVkaW9DbGlw5a+55bqU55qEc2Z4KOmfs+aViCnnvJPlrZjmlbDmja5cclxuICovXHJcbmludGVyZmFjZSBTZnhEYXRhIHtcclxuICAgIC8qKiDlt7LnvJPlrZjnmoTpn7PmlYjmlbDmja7mlbDnu4QgKi9cclxuICAgIGF1ZGlvTGlzdDogQXVkaW9EYXRhW107XHJcbiAgICAvKiog5q2k6Z+z5pWI5pyA5aSn5ZCM5pe25pKt5pS+55qE5pWw6YePICovXHJcbiAgICBtYXhOdW06IG51bWJlcjtcclxuICAgIC8qKiDotoXov4fmnIDlpKfmlbDph4/ml7bmmK/lkKZzdG9w5pyq5pKt5a6M55qE6Z+z5pWI5bm257yT5a2Y5paw55qE6Z+z5pWIICovXHJcbiAgICBvdmVyU3RvcDogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIOmfs+mikeeuoeeQhuexu1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9NYW5hZ2VyIHtcclxuICAgIC8qKiDnvJPlrZjnmoRiZ23mlbDmja4gKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9iZ21NYXA6IE1hcDxjYy5BdWRpb0NsaXAsIEF1ZGlvRGF0YT4gPSBuZXcgTWFwKCk7XHJcbiAgICAvKiog57yT5a2Y55qE5pmu6YCa6Z+z5pWI5pWw5o2uICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbm9ybWFsU2Z4TWFwOiBNYXA8Y2MuQXVkaW9DbGlwLCBTZnhEYXRhPiA9IG5ldyBNYXAoKTtcclxuICAgIC8qKiDnvJPlrZjnmoR1aemfs+aViOaVsOaNriAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3VpU2Z4TWFwOiBNYXA8Y2MuQXVkaW9DbGlwLCBTZnhEYXRhPiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYmdtVm9sdW1lOiBudW1iZXIgPSAxO1xyXG4gICAgLyoqIOWFqOWxgGJnbemfs+mHjyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgYmdtVm9sdW1lKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9iZ21Wb2x1bWU7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0IGJnbVZvbHVtZSh2b2x1bWU6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9iZ21Wb2x1bWUgPT09IHZvbHVtZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9iZ21Wb2x1bWUgPSBjYy5taXNjLmNsYW1wZih2b2x1bWUsIDAsIDEpO1xyXG4gICAgICAgIHRoaXMuX2JnbU1hcC5mb3JFYWNoKChhdWRpb0RhdGE6IEF1ZGlvRGF0YSwgY2xpcDogY2MuQXVkaW9DbGlwKSA9PiB7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnNldFZvbHVtZShhdWRpb0RhdGEuaWQsIHRoaXMuX2JnbVZvbHVtZSAqIGF1ZGlvRGF0YS52b2x1bWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9zZnhWb2x1bWU6IG51bWJlciA9IDE7XHJcbiAgICAvKiog5YWo5bGAc2Z46Z+z6YePICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBzZnhWb2x1bWUoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3NmeFZvbHVtZTsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgc2Z4Vm9sdW1lKHZvbHVtZTogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NmeFZvbHVtZSA9PT0gdm9sdW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NmeFZvbHVtZSA9IGNjLm1pc2MuY2xhbXBmKHZvbHVtZSwgMCwgMSk7XHJcbiAgICAgICAgdGhpcy5fbm9ybWFsU2Z4TWFwLmZvckVhY2goKGRhdGE6IFNmeERhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhLmF1ZGlvTGlzdC5mb3JFYWNoKChhdWRpb0RhdGE6IEF1ZGlvRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUuc2V0Vm9sdW1lKGF1ZGlvRGF0YS5pZCwgdGhpcy5fc2Z4Vm9sdW1lICogYXVkaW9EYXRhLnZvbHVtZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3VpU2Z4TWFwLmZvckVhY2goKGRhdGE6IFNmeERhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICBkYXRhLmF1ZGlvTGlzdC5mb3JFYWNoKChhdWRpb0RhdGE6IEF1ZGlvRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUuc2V0Vm9sdW1lKGF1ZGlvRGF0YS5pZCwgdGhpcy5fc2Z4Vm9sdW1lICogYXVkaW9EYXRhLnZvbHVtZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9iZ21PZmY6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8qKiBiZ23mmK/lkKblhbPpl60gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGJnbU9mZigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2JnbU9mZjsgfVxyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgYmdtT2ZmKGlzT2ZmOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JnbU9mZiA9PT0gaXNPZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9iZ21PZmYgPSBpc09mZjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2JnbU9mZikge1xyXG4gICAgICAgICAgICB0aGlzLl9iZ21NYXAuZm9yRWFjaCgoYXVkaW9EYXRhOiBBdWRpb0RhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKGF1ZGlvRGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9iZ21NYXAuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3NmeE9mZjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIHNmeOaYr+WQpuWFs+mXrSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgc2Z4T2ZmKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2Z4T2ZmOyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIHNldCBzZnhPZmYoaXNPZmY6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5fc2Z4T2ZmID09PSBpc09mZikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zZnhPZmYgPSBpc09mZjtcclxuICAgICAgICBpZiAodGhpcy5fc2Z4T2ZmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbFNmeE1hcC5mb3JFYWNoKChkYXRhOiBTZnhEYXRhLCBjbGlwOiBjYy5BdWRpb0NsaXApID0+IHtcclxuICAgICAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0LmZvckVhY2goKGF1ZGlvRGF0YTogQXVkaW9EYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGF1ZGlvRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl91aVNmeE1hcC5mb3JFYWNoKChkYXRhOiBTZnhEYXRhLCBjbGlwOiBjYy5BdWRpb0NsaXApID0+IHtcclxuICAgICAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0LmZvckVhY2goKGF1ZGlvRGF0YTogQXVkaW9EYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKGF1ZGlvRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfYmdtUGF1c2U6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8qKiBiZ23mmK/lkKbmmoLlgZwgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGJnbVBhdXNlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYmdtUGF1c2U7IH1cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0IGJnbVBhdXNlKGlzUGF1c2U6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5iZ21PZmYgfHwgdGhpcy5fYmdtUGF1c2UgPT09IGlzUGF1c2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9iZ21QYXVzZSA9IGlzUGF1c2U7XHJcblxyXG4gICAgICAgIHRoaXMuX2JnbU1hcC5mb3JFYWNoKChhdWRpb0RhdGE6IEF1ZGlvRGF0YSwgY2xpcDogY2MuQXVkaW9DbGlwKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9iZ21QYXVzZSkge1xyXG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhLnR3ZWVuPy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2UoYXVkaW9EYXRhLmlkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS50d2Vlbj8ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5yZXN1bWUoYXVkaW9EYXRhLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIF9zZnhQYXVzZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIHNmeOaYr+WQpuaaguWBnO+8jOaaguWBnOaXtuS4jeaaguWBnHVp6Z+z5pWIICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBzZnhQYXVzZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3NmeFBhdXNlOyB9XHJcbiAgICBwdWJsaWMgc3RhdGljIHNldCBzZnhQYXVzZShpc1BhdXNlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Z4T2ZmIHx8IHRoaXMuX3NmeFBhdXNlID09PSBpc1BhdXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2Z4UGF1c2UgPSBpc1BhdXNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fc2Z4UGF1c2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsU2Z4TWFwLmZvckVhY2goKGRhdGE6IFNmeERhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5hdWRpb0xpc3QuZm9yRWFjaCgoYXVkaW9EYXRhOiBBdWRpb0RhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhdWRpb0RhdGEudHdlZW4/LnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2UoYXVkaW9EYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxTZnhNYXAuZm9yRWFjaCgoZGF0YTogU2Z4RGF0YSwgY2xpcDogY2MuQXVkaW9DbGlwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmF1ZGlvTGlzdC5mb3JFYWNoKChhdWRpb0RhdGE6IEF1ZGlvRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvRGF0YS50d2Vlbj8ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lKGF1ZGlvRGF0YS5pZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmfs+mHj+a4kOWPmFxyXG4gICAgICogQHBhcmFtIGRhdGEgXHJcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24g6Z+z6YeP5riQ5Y+Y5pe26ZW/IOWNleS9jXNcclxuICAgICAqIEBwYXJhbSBmcm9tIOmfs+mHj+WIneWni+WAvFxyXG4gICAgICogQHBhcmFtIHRvIOmfs+mHj+ebruagh+WAvFxyXG4gICAgICogQHBhcmFtIGNhbGwg5riQ5Y+Y57uT5p2f55qE5Zue6LCDXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHZvbHVtZUZhZGUoZGF0YTogQXVkaW9EYXRhLCBkdXJhdGlvbjogbnVtYmVyLCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGNhbGw/OiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgZGF0YS50d2Vlbj8uc3RvcCgpO1xyXG4gICAgICAgIGRhdGEudm9sdW1lID0gZnJvbTtcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5zZXRWb2x1bWUoZGF0YS5pZCwgZGF0YS52b2x1bWUgKiB0aGlzLmJnbVZvbHVtZSk7XHJcbiAgICAgICAgZGF0YS50d2VlbiA9IG5ldyBUd2VlbihkYXRhKVxyXG4gICAgICAgICAgICAudG8oeyB2b2x1bWU6IHRvIH0sIGR1cmF0aW9uICogMTAwMClcclxuICAgICAgICAgICAgLm9uVXBkYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnNldFZvbHVtZShkYXRhLmlkLCBkYXRhLnZvbHVtZSAqIHRoaXMuYmdtVm9sdW1lKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uQ29tcGxldGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YS50d2VlbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraLpn7PpopFcclxuICAgICAqIEBwYXJhbSBhdWRpb0RhdGEgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHN0b3AoYXVkaW9EYXRhOiBBdWRpb0RhdGEpOiB2b2lkIHtcclxuICAgICAgICBpZiAoYXVkaW9EYXRhLnR3ZWVuKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YS50d2Vlbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YS50d2VlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLmF1ZGlvRW5naW5lLnN0b3AoYXVkaW9EYXRhLmlkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvumfs+mikeW5tui/lOWbnkF1ZGlvRGF0YVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwbGF5KGFyZ3M6IGNjLkF1ZGlvQ2xpcCB8IEF1ZGlvUGxheUFyZ3MsIHZvbHVtZTogbnVtYmVyLCBhdWRpb0RhdGE6IEF1ZGlvRGF0YSA9IG51bGwpOiBBdWRpb0RhdGEge1xyXG4gICAgICAgIGxldCBkYXRhOiBBdWRpb1BsYXlBcmdzID0gYXJncyBpbnN0YW5jZW9mIGNjLkF1ZGlvQ2xpcCA/IHsgY2xpcDogYXJncyB9IDogYXJncztcclxuICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJsb29wXCIpKSB7XHJcbiAgICAgICAgICAgIGRhdGEubG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJmYWRlRHVyYXRpb25cIikpIHtcclxuICAgICAgICAgICAgZGF0YS5mYWRlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJmaW5pc2hDYWxsXCIpKSB7XHJcbiAgICAgICAgICAgIGRhdGEuZmluaXNoQ2FsbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YS5pZCA9IGNjLmF1ZGlvRW5naW5lLnBsYXkoZGF0YS5jbGlwLCBkYXRhLmxvb3AsIHZvbHVtZSk7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YS52b2x1bWUgPSAxO1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhLnR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBhdWRpb0RhdGEudHdlZW4uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhLnR3ZWVuID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBjYy5hdWRpb0VuZ2luZS5wbGF5KGRhdGEuY2xpcCwgZGF0YS5sb29wLCB2b2x1bWUpLFxyXG4gICAgICAgICAgICAgICAgdm9sdW1lOiAxLFxyXG4gICAgICAgICAgICAgICAgdHdlZW46IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRhLmZpbmlzaENhbGwpIHtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUuc2V0RmluaXNoQ2FsbGJhY2soYXVkaW9EYXRhLmlkLCBkYXRhLmZpbmlzaENhbGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YS5mYWRlRHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudm9sdW1lRmFkZShhdWRpb0RhdGEsIGRhdGEuZmFkZUR1cmF0aW9uLCAwLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF1ZGlvRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvmJnbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBsYXlCZ20oYXJnczogY2MuQXVkaW9DbGlwIHwgQXVkaW9QbGF5QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjbGlwID0gYXJncyBpbnN0YW5jZW9mIGNjLkF1ZGlvQ2xpcCA/IGFyZ3MgOiBhcmdzLmNsaXA7XHJcbiAgICAgICAgaWYgKHRoaXMuYmdtT2ZmIHx8ICFjbGlwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhdWRpb0RhdGE6IEF1ZGlvRGF0YSA9IHRoaXMuX2JnbU1hcC5nZXQoY2xpcCk7XHJcbiAgICAgICAgaWYgKGF1ZGlvRGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHRoaXMucGxheShhcmdzLCB0aGlzLmJnbVZvbHVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JnbU1hcC5zZXQoY2xpcCwgYXVkaW9EYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KGFyZ3MsIHRoaXMuYmdtVm9sdW1lLCBhdWRpb0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvnNmeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBsYXlTZngoYXJnczogY2MuQXVkaW9DbGlwIHwgQXVkaW9QbGF5QXJncywgdHlwZTogU2Z4VHlwZSA9IFNmeFR5cGUuTk9STUFMKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGNsaXAgPSBhcmdzIGluc3RhbmNlb2YgY2MuQXVkaW9DbGlwID8gYXJncyA6IGFyZ3MuY2xpcDtcclxuICAgICAgICBpZiAodGhpcy5zZnhPZmYgfHwgIWNsaXApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNmeERhdGE6IFNmeERhdGEgPSB0eXBlID09PSBTZnhUeXBlLk5PUk1BTCA/IHRoaXMuX25vcm1hbFNmeE1hcC5nZXQoY2xpcCkgOiB0aGlzLl91aVNmeE1hcC5nZXQoY2xpcCk7XHJcbiAgICAgICAgbGV0IGF1ZGlvRGF0YTogQXVkaW9EYXRhID0gbnVsbDtcclxuICAgICAgICBpZiAoc2Z4RGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNmeERhdGEgPSB0aGlzLnNldFNmeERhdGEoY2xpcCwgdHlwZSk7XHJcbiAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHRoaXMucGxheShhcmdzLCB0aGlzLnNmeFZvbHVtZSk7XHJcbiAgICAgICAgICAgIHNmeERhdGEuYXVkaW9MaXN0LnB1c2goYXVkaW9EYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDliZTpmaTkuI3lpITkuo7mkq3mlL7nirbmgIHnmoTpn7PpopFcclxuICAgICAgICAgICAgd2hpbGUgKHNmeERhdGEuYXVkaW9MaXN0Lmxlbmd0aCA+IDAgJiYgY2MuYXVkaW9FbmdpbmUuZ2V0U3RhdGUoc2Z4RGF0YS5hdWRpb0xpc3RbMF0uaWQpICE9PSBjYy5hdWRpb0VuZ2luZS5BdWRpb1N0YXRlLlBMQVlJTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChzZnhEYXRhLmF1ZGlvTGlzdC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8g5bey6L6+5Yiw5pyA5aSn5pWw6YeP5YiZ5YmU6Zmk5pyA5YWIKOesrOS4gOS4qinnvJPlrZjnmoTpn7PpopFcclxuICAgICAgICAgICAgd2hpbGUgKHNmeERhdGEub3ZlclN0b3AgJiYgc2Z4RGF0YS5hdWRpb0xpc3QubGVuZ3RoID49IHNmeERhdGEubWF4TnVtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3Aoc2Z4RGF0YS5hdWRpb0xpc3Quc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIOe8k+WtmOaWsOeahOmfs+mikVxyXG4gICAgICAgICAgICBpZiAoc2Z4RGF0YS5hdWRpb0xpc3QubGVuZ3RoIDwgc2Z4RGF0YS5tYXhOdW0pIHtcclxuICAgICAgICAgICAgICAgIGF1ZGlvRGF0YSA9IHRoaXMucGxheShhcmdzLCB0aGlzLnNmeFZvbHVtZSk7XHJcbiAgICAgICAgICAgICAgICBzZnhEYXRhLmF1ZGlvTGlzdC5wdXNoKGF1ZGlvRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7pn7PmlYjmlbDmja7vvIjnlKjkuo7pmZDliLbmn5Dkupvnn63ml7bpl7TlhoXlkIzml7blpKfph4/mkq3mlL7nmoTpn7PmlYjvvIlcclxuICAgICAqIEBwYXJhbSBjbGlwIFxyXG4gICAgICogQHBhcmFtIHR5cGUg6Z+z5pWI57G75Z6LXHJcbiAgICAgKiBAcGFyYW0gbWF4TnVtIOatpOmfs+aViOacgOWkp+WQjOaXtuaSreaUvueahOaVsOmHj1xyXG4gICAgICogQHBhcmFtIG92ZXJTdG9wIOi2hei/h+acgOWkp+aVsOmHj+aXtuaYr+WQpnN0b3DmnKrmkq3lroznmoTpn7PmlYjlubbnvJPlrZjmlrDnmoTpn7PmlYhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRTZnhEYXRhKGNsaXA6IGNjLkF1ZGlvQ2xpcCwgdHlwZTogU2Z4VHlwZSA9IFNmeFR5cGUuTk9STUFMLCBtYXhOdW06IG51bWJlciA9IDgsIG92ZXJTdG9wOiBib29sZWFuID0gZmFsc2UpOiBTZnhEYXRhIHtcclxuICAgICAgICBpZiAoIWNsaXApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF4TnVtID0gTWF0aC5tYXgobWF4TnVtLCAxKTtcclxuICAgICAgICBsZXQgbWFwID0gdHlwZSA9PT0gU2Z4VHlwZS5OT1JNQUwgPyB0aGlzLl9ub3JtYWxTZnhNYXAgOiB0aGlzLl91aVNmeE1hcDtcclxuICAgICAgICBsZXQgc2Z4RGF0YTogU2Z4RGF0YSA9IG1hcC5nZXQoY2xpcCk7XHJcbiAgICAgICAgaWYgKHNmeERhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzZnhEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgYXVkaW9MaXN0OiBbXSxcclxuICAgICAgICAgICAgICAgIG1heE51bTogbWF4TnVtLFxyXG4gICAgICAgICAgICAgICAgb3ZlclN0b3A6IG92ZXJTdG9wXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1hcC5zZXQoY2xpcCwgc2Z4RGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2Z4RGF0YS5tYXhOdW0gPSBtYXhOdW07XHJcbiAgICAgICAgICAgIHNmeERhdGEub3ZlclN0b3AgPSBvdmVyU3RvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNmeERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraJiZ21cclxuICAgICAqIEBwYXJhbSBjbGlwIOmcgOWBnOatoueahOmfs+mike+8jGNsaXDov5Tlm57lgLzkuLpmYWxzZeWImeWBnOatouaJgOaciVxyXG4gICAgICogQHBhcmFtIGZhZGVEdXJhdGlvbiDpn7Pph4/muJDlj5jml7bplb8g5Y2V5L2Nc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0b3BCZ20oY2xpcDogY2MuQXVkaW9DbGlwID0gbnVsbCwgZmFkZUR1cmF0aW9uOiBudW1iZXIgPSAwKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmdtT2ZmKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjbGlwKSB7XHJcbiAgICAgICAgICAgIGxldCBhdWRpb0RhdGE6IEF1ZGlvRGF0YSA9IHRoaXMuX2JnbU1hcC5nZXQoY2xpcCk7XHJcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZmFkZUR1cmF0aW9uIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChhdWRpb0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmdtTWFwLmRlbGV0ZShjbGlwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lRmFkZShhdWRpb0RhdGEsIGZhZGVEdXJhdGlvbiwgMSwgMCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChhdWRpb0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JnbU1hcC5kZWxldGUoY2xpcCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmYWRlRHVyYXRpb24gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmdtTWFwLmZvckVhY2goKGF1ZGlvRGF0YTogQXVkaW9EYXRhLCBjbGlwOiBjYy5BdWRpb0NsaXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmdtTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZ21NYXAuZm9yRWFjaCgoYXVkaW9EYXRhOiBBdWRpb0RhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lRmFkZShhdWRpb0RhdGEsIGZhZGVEdXJhdGlvbiwgMSwgMCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmdtTWFwLmRlbGV0ZShjbGlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YGc5q2ic2Z4XHJcbiAgICAgKiBAcGFyYW0gY2xpcCDpnIDlgZzmraLnmoTpn7PpopHvvIxjbGlw6L+U5Zue5YC85Li6ZmFsc2XliJnlgZzmraLmiYDmnIlcclxuICAgICAqIEBwYXJhbSB0eXBlIOmfs+aViOexu+Wei1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0b3BTZngoY2xpcDogY2MuQXVkaW9DbGlwID0gbnVsbCwgdHlwZTogU2Z4VHlwZSA9IFNmeFR5cGUuTk9STUFMKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Z4T2ZmKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjbGlwKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhOiBTZnhEYXRhID0gdHlwZSA9PT0gU2Z4VHlwZS5OT1JNQUwgPyB0aGlzLl9ub3JtYWxTZnhNYXAuZ2V0KGNsaXApIDogdGhpcy5fdWlTZnhNYXAuZ2V0KGNsaXApO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEuYXVkaW9MaXN0Lmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0LmZvckVhY2goKGF1ZGlvRGF0YTogQXVkaW9EYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRhdGEuYXVkaW9MaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsU2Z4TWFwLmZvckVhY2goKGRhdGE6IFNmeERhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5hdWRpb0xpc3QuZm9yRWFjaCgoYXVkaW9EYXRhOiBBdWRpb0RhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5hdWRpb0xpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VpU2Z4TWFwLmZvckVhY2goKGRhdGE6IFNmeERhdGEsIGNsaXA6IGNjLkF1ZGlvQ2xpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5hdWRpb0xpc3QuZm9yRWFjaCgoYXVkaW9EYXRhOiBBdWRpb0RhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoYXVkaW9EYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5hdWRpb0xpc3QubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5YGc5q2i5omA5pyJ6Z+z6aKRXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcEFsbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnN0b3BCZ20oKTtcclxuICAgICAgICB0aGlzLnN0b3BTZngoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOaaguWBnOaJgOaciemfs+mikVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBhdXNlQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYmdtUGF1c2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2Z4UGF1c2UgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5oGi5aSN5omA5pyJ6Z+z6aKRXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVzdW1lQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYmdtUGF1c2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNmeFBhdXNlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraLmiYDmnInpn7PpopHvvIzmuIXpmaTmiYDmnInpn7PpopHnvJPlrZhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB1bmNhY2hlQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RvcEFsbCgpO1xyXG4gICAgICAgIHRoaXMuX2JnbU1hcC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX25vcm1hbFNmeE1hcC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX3VpU2Z4TWFwLmNsZWFyKCk7XHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUudW5jYWNoZUFsbCgpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/dialog/DlgLevel.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '30e60gY31BNFpQWA4Yd11XL', 'DlgLevel');
// scripts/showcase/dialog/DlgLevel.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var DialogBase_1 = require("../../common/cmpt/base/DialogBase");
var Url_1 = require("../../common/const/Url");
var Events_1 = require("../../common/util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
var DlgLevel = /** @class */ (function (_super) {
    __extends(DlgLevel, _super);
    function DlgLevel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DlgLevel.prototype.onLoad = function () {
        _super.prototype.onLoad.call(this);
        Events_1.default.targetOn(this);
    };
    DlgLevel.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    DlgLevel.prototype.update = function () { };
    /**
     * @override
     */
    DlgLevel.prototype.onOpen = function () { };
    DlgLevel.pUrl = Url_1.DirUrl.PREFAB_DIALOG + "DlgLevel";
    DlgLevel = __decorate([
        ccclass
    ], DlgLevel);
    return DlgLevel;
}(DialogBase_1.default));
exports.default = DlgLevel;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGRpYWxvZ1xcRGxnTGV2ZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0VBQTJEO0FBRTNELDhDQUF3RDtBQUd4RCxtREFBOEM7QUFFeEMsSUFBQSxLQUE4QixFQUFFLENBQUMsVUFBVSxFQUF6QyxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFHbEQ7SUFBc0MsNEJBQVU7SUFBaEQ7O0lBbUJBLENBQUM7SUFoQmEseUJBQU0sR0FBaEI7UUFDSSxpQkFBTSxNQUFNLFdBQUUsQ0FBQztRQUNmLGdCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFUyw0QkFBUyxHQUFuQjtRQUNJLGdCQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFUyx5QkFBTSxHQUFoQixjQUFxQixDQUFDO0lBRXRCOztPQUVHO0lBQ0kseUJBQU0sR0FBYixjQUFrQixDQUFDO0lBaEJMLGFBQUksR0FBVyxZQUFNLENBQUMsYUFBYSxHQUFHLFVBQVUsQ0FBQztJQUQ5QyxRQUFRO1FBRDVCLE9BQU87T0FDYSxRQUFRLENBbUI1QjtJQUFELGVBQUM7Q0FuQkQsQUFtQkMsQ0FuQnFDLG9CQUFVLEdBbUIvQztrQkFuQm9CLFFBQVEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGlhbG9nQmFzZSBmcm9tIFwiLi4vLi4vY29tbW9uL2NtcHQvYmFzZS9EaWFsb2dCYXNlXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vY29tbW9uL2NtcHQvYmFzZS9MYXllclwiO1xyXG5pbXBvcnQgeyBEaXJVcmwsIFJlc1VybCB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvVXJsXCI7XHJcbmltcG9ydCBHbG9iYWxJbmZvIGZyb20gXCIuLi8uLi9jb21tb24vcnVudGltZS9HbG9iYWxJbmZvXCI7XHJcbmltcG9ydCBVc2VySW5mbyBmcm9tIFwiLi4vLi4vY29tbW9uL3J1bnRpbWUvVXNlckluZm9cIjtcclxuaW1wb3J0IEV2ZW50cyBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWwvRXZlbnRzXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGxnTGV2ZWwgZXh0ZW5kcyBEaWFsb2dCYXNlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcFVybDogc3RyaW5nID0gRGlyVXJsLlBSRUZBQl9ESUFMT0cgKyBcIkRsZ0xldmVsXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpIHtcclxuICAgICAgICBzdXBlci5vbkxvYWQoKTtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T2ZmKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB1cGRhdGUoKSB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25PcGVuKCkgeyB9XHJcblxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/dialog/DlgRole.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '31c8afnQq1Lq702NAstz5ei', 'DlgRole');
// scripts/showcase/dialog/DlgRole.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var DialogBase_1 = require("../../common/cmpt/base/DialogBase");
var Url_1 = require("../../common/const/Url");
var Events_1 = require("../../common/util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
var DlgRole = /** @class */ (function (_super) {
    __extends(DlgRole, _super);
    function DlgRole() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DlgRole.prototype.onLoad = function () {
        _super.prototype.onLoad.call(this);
        Events_1.default.targetOn(this);
    };
    DlgRole.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    DlgRole.prototype.update = function () { };
    /**
     * @override
     */
    DlgRole.prototype.onOpen = function () { };
    DlgRole.pUrl = Url_1.DirUrl.PREFAB_DIALOG + "DlgRole";
    DlgRole = __decorate([
        ccclass
    ], DlgRole);
    return DlgRole;
}(DialogBase_1.default));
exports.default = DlgRole;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGRpYWxvZ1xcRGxnUm9sZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnRUFBMkQ7QUFDM0QsOENBQWdEO0FBQ2hELG1EQUE4QztBQUV4QyxJQUFBLEtBQThCLEVBQUUsQ0FBQyxVQUFVLEVBQXpDLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUdsRDtJQUFxQywyQkFBVTtJQUEvQzs7SUFrQkEsQ0FBQztJQWZhLHdCQUFNLEdBQWhCO1FBQ0ksaUJBQU0sTUFBTSxXQUFFLENBQUM7UUFDZixnQkFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRVMsMkJBQVMsR0FBbkI7UUFDSSxnQkFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRVMsd0JBQU0sR0FBaEIsY0FBcUIsQ0FBQztJQUV0Qjs7T0FFRztJQUNJLHdCQUFNLEdBQWIsY0FBa0IsQ0FBQztJQWhCTCxZQUFJLEdBQVcsWUFBTSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7SUFEN0MsT0FBTztRQUQzQixPQUFPO09BQ2EsT0FBTyxDQWtCM0I7SUFBRCxjQUFDO0NBbEJELEFBa0JDLENBbEJvQyxvQkFBVSxHQWtCOUM7a0JBbEJvQixPQUFPIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERpYWxvZ0Jhc2UgZnJvbSBcIi4uLy4uL2NvbW1vbi9jbXB0L2Jhc2UvRGlhbG9nQmFzZVwiO1xyXG5pbXBvcnQgeyBEaXJVcmwgfSBmcm9tIFwiLi4vLi4vY29tbW9uL2NvbnN0L1VybFwiO1xyXG5pbXBvcnQgRXZlbnRzIGZyb20gXCIuLi8uLi9jb21tb24vdXRpbC9FdmVudHNcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG5AY2NjbGFzc1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEbGdSb2xlIGV4dGVuZHMgRGlhbG9nQmFzZSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHBVcmw6IHN0cmluZyA9IERpclVybC5QUkVGQUJfRElBTE9HICsgXCJEbGdSb2xlXCI7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpIHtcclxuICAgICAgICBzdXBlci5vbkxvYWQoKTtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T2ZmKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB1cGRhdGUoKSB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25PcGVuKCkgeyB9XHJcbn1cclxuXHJcblxyXG5cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/dialog/DlgSign.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'f1944gf/AFFOaTBYctN8omX', 'DlgSign');
// scripts/showcase/dialog/DlgSign.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var DialogBase_1 = require("../../common/cmpt/base/DialogBase");
var Url_1 = require("../../common/const/Url");
var Events_1 = require("../../common/util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
var DlgSign = /** @class */ (function (_super) {
    __extends(DlgSign, _super);
    function DlgSign() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DlgSign.prototype.onLoad = function () {
        _super.prototype.onLoad.call(this);
        Events_1.default.targetOn(this);
    };
    DlgSign.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    DlgSign.prototype.update = function () { };
    DlgSign.pUrl = Url_1.DirUrl.PREFAB_DIALOG + "DlgSign";
    DlgSign = __decorate([
        ccclass
    ], DlgSign);
    return DlgSign;
}(DialogBase_1.default));
exports.default = DlgSign;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGRpYWxvZ1xcRGxnU2lnbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnRUFBMkQ7QUFDM0QsOENBQWdEO0FBQ2hELG1EQUE4QztBQUV4QyxJQUFBLEtBQThCLEVBQUUsQ0FBQyxVQUFVLEVBQXpDLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBQSxFQUFFLElBQUksVUFBa0IsQ0FBQztBQUdsRDtJQUFxQywyQkFBVTtJQUEvQzs7SUFjQSxDQUFDO0lBWGEsd0JBQU0sR0FBaEI7UUFDSSxpQkFBTSxNQUFNLFdBQUUsQ0FBQztRQUNmLGdCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFUywyQkFBUyxHQUFuQjtRQUNJLGdCQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFUyx3QkFBTSxHQUFoQixjQUFxQixDQUFDO0lBWFIsWUFBSSxHQUFXLFlBQU0sQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO0lBRDdDLE9BQU87UUFEM0IsT0FBTztPQUNhLE9BQU8sQ0FjM0I7SUFBRCxjQUFDO0NBZEQsQUFjQyxDQWRvQyxvQkFBVSxHQWM5QztrQkFkb0IsT0FBTyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWFsb2dCYXNlIGZyb20gXCIuLi8uLi9jb21tb24vY21wdC9iYXNlL0RpYWxvZ0Jhc2VcIjtcclxuaW1wb3J0IHsgRGlyVXJsIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb25zdC9VcmxcIjtcclxuaW1wb3J0IEV2ZW50cyBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWwvRXZlbnRzXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5LCBtZW51IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGxnU2lnbiBleHRlbmRzIERpYWxvZ0Jhc2Uge1xyXG4gICAgcHVibGljIHN0YXRpYyBwVXJsOiBzdHJpbmcgPSBEaXJVcmwuUFJFRkFCX0RJQUxPRyArIFwiRGxnU2lnblwiO1xyXG5cclxuICAgIHByb3RlY3RlZCBvbkxvYWQoKSB7XHJcbiAgICAgICAgc3VwZXIub25Mb2FkKCk7XHJcbiAgICAgICAgRXZlbnRzLnRhcmdldE9uKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgRXZlbnRzLnRhcmdldE9mZih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlKCkgeyB9XHJcblxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/dialog/DlgStore.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'bdc4fUopChJ+rPzHAjnTbeE', 'DlgStore');
// scripts/showcase/dialog/DlgStore.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var DialogBase_1 = require("../../common/cmpt/base/DialogBase");
var Url_1 = require("../../common/const/Url");
var Events_1 = require("../../common/util/Events");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
var DlgStore = /** @class */ (function (_super) {
    __extends(DlgStore, _super);
    function DlgStore() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DlgStore.prototype.onLoad = function () {
        _super.prototype.onLoad.call(this);
        Events_1.default.targetOn(this);
    };
    DlgStore.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    /**
     * @override
     */
    DlgStore.prototype.onOpen = function () { };
    DlgStore.pUrl = Url_1.DirUrl.PREFAB_DIALOG + "DlgStore";
    DlgStore = __decorate([
        ccclass
    ], DlgStore);
    return DlgStore;
}(DialogBase_1.default));
exports.default = DlgStore;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGRpYWxvZ1xcRGxnU3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0VBQTJEO0FBRzNELDhDQUFnRDtBQUVoRCxtREFBOEM7QUFHeEMsSUFBQSxLQUE4QixFQUFFLENBQUMsVUFBVSxFQUF6QyxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQUEsRUFBRSxJQUFJLFVBQWtCLENBQUM7QUFHbEQ7SUFBc0MsNEJBQVU7SUFBaEQ7O0lBaUJBLENBQUM7SUFkYSx5QkFBTSxHQUFoQjtRQUNJLGlCQUFNLE1BQU0sV0FBRSxDQUFDO1FBQ2YsZ0JBQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVTLDRCQUFTLEdBQW5CO1FBQ0ksZ0JBQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0kseUJBQU0sR0FBYixjQUFrQixDQUFDO0lBZEwsYUFBSSxHQUFXLFlBQU0sQ0FBQyxhQUFhLEdBQUcsVUFBVSxDQUFDO0lBRDlDLFFBQVE7UUFENUIsT0FBTztPQUNhLFFBQVEsQ0FpQjVCO0lBQUQsZUFBQztDQWpCRCxBQWlCQyxDQWpCcUMsb0JBQVUsR0FpQi9DO2tCQWpCb0IsUUFBUSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWFsb2dCYXNlIGZyb20gXCIuLi8uLi9jb21tb24vY21wdC9iYXNlL0RpYWxvZ0Jhc2VcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9jb21tb24vY21wdC9iYXNlL0xheWVyXCI7XHJcbmltcG9ydCB7IEV2ZW50TmFtZSB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCB7IERpclVybCB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvVXJsXCI7XHJcbmltcG9ydCBVc2VySW5mbywgeyBVc2VySW5mb1N0b3JnZSB9IGZyb20gXCIuLi8uLi9jb21tb24vcnVudGltZS9Vc2VySW5mb1wiO1xyXG5pbXBvcnQgRXZlbnRzIGZyb20gXCIuLi8uLi9jb21tb24vdXRpbC9FdmVudHNcIjtcclxuaW1wb3J0IFRvb2wgZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsL1Rvb2xcIjtcclxuXHJcbmNvbnN0IHsgY2NjbGFzcywgcHJvcGVydHksIG1lbnUgfSA9IGNjLl9kZWNvcmF0b3I7XHJcblxyXG5AY2NjbGFzc1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEbGdTdG9yZSBleHRlbmRzIERpYWxvZ0Jhc2Uge1xyXG4gICAgcHVibGljIHN0YXRpYyBwVXJsOiBzdHJpbmcgPSBEaXJVcmwuUFJFRkFCX0RJQUxPRyArIFwiRGxnU3RvcmVcIjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgb25Mb2FkKCkge1xyXG4gICAgICAgIHN1cGVyLm9uTG9hZCgpO1xyXG4gICAgICAgIEV2ZW50cy50YXJnZXRPbih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25EZXN0cm95KCkge1xyXG4gICAgICAgIEV2ZW50cy50YXJnZXRPZmYodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uT3BlbigpIHsgfVxyXG5cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/Home.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '1d227cGCflICZGjBQkLC7vS', 'Home');
// scripts/showcase/home/Home.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Layer_1 = require("../../common/cmpt/base/Layer");
var EventName_1 = require("../../common/const/EventName");
var Url_1 = require("../../common/const/Url");
var Events_1 = require("../../common/util/Events");
var DlgLevel_1 = require("../dialog/DlgLevel");
var DlgRole_1 = require("../dialog/DlgRole");
var DlgSign_1 = require("../dialog/DlgSign");
var DlgStore_1 = require("../dialog/DlgStore");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var Home = /** @class */ (function (_super) {
    __extends(Home, _super);
    function Home() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Home.prototype.onLoad = function () {
        Events_1.default.targetOn(this);
    };
    Home.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    Home.prototype.start = function () {
        Events_1.default.emit(EventName_1.EventName.EXCUTE_GUIDE_TASK, "guideTask1");
    };
    Home.prototype.addCoin = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    Home.prototype.onClickGame = function () {
        Layer_1.default.inst.enterMain(Url_1.ResUrl.PREFAB.GAME);
    };
    Home.prototype.onClickLevel = function () {
        Layer_1.default.inst.openUniDialogAsync(DlgLevel_1.default.pUrl);
    };
    Home.prototype.onClickSign = function () {
        Layer_1.default.inst.openUniDialogAsync(DlgSign_1.default.pUrl);
    };
    Home.prototype.onClickRole = function () {
        Layer_1.default.inst.openUniDialogAsync(DlgRole_1.default.pUrl);
    };
    Home.prototype.onClickStore = function () {
        Layer_1.default.inst.openUniDialogAsync(DlgStore_1.default.pUrl);
    };
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.ADD_COIN)
    ], Home.prototype, "addCoin", null);
    Home = __decorate([
        ccclass
    ], Home);
    return Home;
}(cc.Component));
exports.default = Home;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXEhvbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0RBQWlEO0FBQ2pELDBEQUF5RDtBQUN6RCw4Q0FBZ0Q7QUFDaEQsbURBQWdFO0FBQ2hFLCtDQUEwQztBQUMxQyw2Q0FBd0M7QUFDeEMsNkNBQXdDO0FBQ3hDLCtDQUEwQztBQUVwQyxJQUFBLEtBQXdCLEVBQUUsQ0FBQyxVQUFVLEVBQW5DLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBa0IsQ0FBQztBQUc1QztJQUFrQyx3QkFBWTtJQUE5Qzs7SUF1Q0EsQ0FBQztJQXJDYSxxQkFBTSxHQUFoQjtRQUNJLGdCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFUyx3QkFBUyxHQUFuQjtRQUNJLGdCQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFUyxvQkFBSyxHQUFmO1FBQ0ksZ0JBQU0sQ0FBQyxJQUFJLENBQUMscUJBQVMsQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQTtJQUMxRCxDQUFDO0lBR0ssc0JBQU8sR0FBYjs7Ozs7O0tBRUM7SUFFTywwQkFBVyxHQUFuQjtRQUNJLGVBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLDJCQUFZLEdBQXBCO1FBQ0ksZUFBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTywwQkFBVyxHQUFuQjtRQUNJLGVBQUssQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsaUJBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRU8sMEJBQVcsR0FBbkI7UUFDSSxlQUFLLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGlCQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVPLDJCQUFZLEdBQXBCO1FBQ0ksZUFBSyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUF0QkQ7UUFEQyxxQkFBWSxDQUFDLHFCQUFTLENBQUMsUUFBUSxDQUFDO3VDQUdoQztJQWpCZ0IsSUFBSTtRQUR4QixPQUFPO09BQ2EsSUFBSSxDQXVDeEI7SUFBRCxXQUFDO0NBdkNELEFBdUNDLENBdkNpQyxFQUFFLENBQUMsU0FBUyxHQXVDN0M7a0JBdkNvQixJQUFJIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9jb21tb24vY21wdC9iYXNlL0xheWVyXCI7XHJcbmltcG9ydCB7IEV2ZW50TmFtZSB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCB7IFJlc1VybCB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvVXJsXCI7XHJcbmltcG9ydCBFdmVudHMsIHsgcHJlbG9hZEV2ZW50IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgRGxnTGV2ZWwgZnJvbSBcIi4uL2RpYWxvZy9EbGdMZXZlbFwiO1xyXG5pbXBvcnQgRGxnUm9sZSBmcm9tIFwiLi4vZGlhbG9nL0RsZ1JvbGVcIjtcclxuaW1wb3J0IERsZ1NpZ24gZnJvbSBcIi4uL2RpYWxvZy9EbGdTaWduXCI7XHJcbmltcG9ydCBEbGdTdG9yZSBmcm9tIFwiLi4vZGlhbG9nL0RsZ1N0b3JlXCI7XHJcblxyXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5IH0gPSBjYy5fZGVjb3JhdG9yO1xyXG5cclxuQGNjY2xhc3NcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9tZSBleHRlbmRzIGNjLkNvbXBvbmVudCB7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T24odGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T2ZmKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICBFdmVudHMuZW1pdChFdmVudE5hbWUuRVhDVVRFX0dVSURFX1RBU0ssIFwiZ3VpZGVUYXNrMVwiKVxyXG4gICAgfVxyXG5cclxuICAgIEBwcmVsb2FkRXZlbnQoRXZlbnROYW1lLkFERF9DT0lOKVxyXG4gICAgYXN5bmMgYWRkQ29pbigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNsaWNrR2FtZSgpIHtcclxuICAgICAgICBMYXllci5pbnN0LmVudGVyTWFpbihSZXNVcmwuUFJFRkFCLkdBTUUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25DbGlja0xldmVsKCkge1xyXG4gICAgICAgIExheWVyLmluc3Qub3BlblVuaURpYWxvZ0FzeW5jKERsZ0xldmVsLnBVcmwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25DbGlja1NpZ24oKSB7XHJcbiAgICAgICAgTGF5ZXIuaW5zdC5vcGVuVW5pRGlhbG9nQXN5bmMoRGxnU2lnbi5wVXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQ2xpY2tSb2xlKCkge1xyXG4gICAgICAgIExheWVyLmluc3Qub3BlblVuaURpYWxvZ0FzeW5jKERsZ1JvbGUucFVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNsaWNrU3RvcmUoKSB7XHJcbiAgICAgICAgTGF5ZXIuaW5zdC5vcGVuVW5pRGlhbG9nQXN5bmMoRGxnU3RvcmUucFVybCk7XHJcbiAgICB9XHJcblxyXG59XHJcbiJdfQ==
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/scenes/Loading.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b2c36x3CPpApKUXS2CnhQU6', 'Loading');
// scripts/showcase/scenes/Loading.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Layer_1 = require("../../common/cmpt/base/Layer");
var Url_1 = require("../../common/const/Url");
var UserInfo_1 = require("../../common/runtime/UserInfo");
var Res_1 = require("../../common/util/Res");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var Loading = /** @class */ (function (_super) {
    __extends(Loading, _super);
    function Loading() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Loading.prototype.onLoad = function () {
        UserInfo_1.default.instance.initUserInfo();
        // console.log = () => { } //置空log 不显示打印
        var userInfo = UserInfo_1.UserInfoStorge.getUserInfo();
        console.log(">>> 本地的UserInfo___> ", userInfo);
        if (!userInfo) //如果本地没有数据则储存数据在本地
            UserInfo_1.UserInfoStorge.setUserInfo();
        else //若本地已有数据则将UserInfo更新为已有的数据
            UserInfo_1.default.instance.setUserInfo(userInfo);
    };
    Loading.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.initData()];
                    case 1:
                        _a.sent();
                        this.preloadScene();
                        return [2 /*return*/];
                }
            });
        });
    };
    Loading.prototype.enterMain = function () {
        Layer_1.default.inst.enterScene("Main");
    };
    Loading.prototype.preloadScene = function () {
        return new Promise(function (reslove, reject) {
            cc.director.preloadScene('Main', function (completedCount, totalCount, item) {
                var progress = completedCount / totalCount;
                console.log('预加载进度：', progress);
            }, function (error) {
                if (error) {
                    console.error('预加载Main场景资源失败：', error);
                }
                else {
                    console.log('预加载Main场景资源成功！');
                }
            });
        });
    };
    Loading.prototype.initData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log(">>> initData__> 开始加载资源");
                        promises = [];
                        // 添加各个资源加载函数返回的Promise对象到数组
                        promises.push(Res_1.default.loadDir(Url_1.DirUrl.TEXTURE, cc.SpriteFrame));
                        promises.push(Res_1.default.loadDir(Url_1.DirUrl.PREFAB, cc.Prefab));
                        promises.push(Res_1.default.loadDir(Url_1.DirUrl.AUDIO, cc.AudioClip));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        console.log(">>> 资源加载完成");
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        console.error(">>> 资源加载失败：", error_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Loading = __decorate([
        ccclass
    ], Loading);
    return Loading;
}(cc.Component));
exports.default = Loading;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXHNjZW5lc1xcTG9hZGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBaUQ7QUFDakQsOENBQWdEO0FBQ2hELDBEQUF5RTtBQUN6RSw2Q0FBd0M7QUFFbEMsSUFBQSxLQUF3QixFQUFFLENBQUMsVUFBVSxFQUFuQyxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQWtCLENBQUM7QUFHNUM7SUFBcUMsMkJBQVk7SUFBakQ7O0lBNERBLENBQUM7SUExREcsd0JBQU0sR0FBTjtRQUNJLGtCQUFRLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFBO1FBQ2hDLHdDQUF3QztRQUV4QyxJQUFJLFFBQVEsR0FBRyx5QkFBYyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQzNDLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLEVBQUUsUUFBUSxDQUFDLENBQUE7UUFFN0MsSUFBSSxDQUFDLFFBQVEsRUFBRSxrQkFBa0I7WUFDN0IseUJBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQTthQUMzQiwyQkFBMkI7WUFDNUIsa0JBQVEsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQy9DLENBQUM7SUFFSyx1QkFBSyxHQUFYOzs7OzRCQUNJLHFCQUFNLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBQTs7d0JBQXJCLFNBQXFCLENBQUE7d0JBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQTs7Ozs7S0FDdEI7SUFFRCwyQkFBUyxHQUFUO1FBQ0ksZUFBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUE7SUFDakMsQ0FBQztJQUVELDhCQUFZLEdBQVo7UUFDSSxPQUFPLElBQUksT0FBTyxDQUFPLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDckMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLFVBQUMsY0FBYyxFQUFFLFVBQVUsRUFBRSxJQUFJO2dCQUM5RCxJQUFNLFFBQVEsR0FBRyxjQUFjLEdBQUcsVUFBVSxDQUFDO2dCQUM3QyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNwQyxDQUFDLEVBQUUsVUFBQyxLQUFLO2dCQUNMLElBQUksS0FBSyxFQUFFO29CQUNQLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQzFDO3FCQUFNO29CQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztpQkFDakM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFBO0lBQ04sQ0FBQztJQUVhLDBCQUFRLEdBQXRCOzs7Ozs7d0JBQ0ksT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO3dCQUVoQyxRQUFRLEdBQUcsRUFBRSxDQUFDO3dCQUVwQiw0QkFBNEI7d0JBQzVCLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBRyxDQUFDLE9BQU8sQ0FBQyxZQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO3dCQUMzRCxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQUcsQ0FBQyxPQUFPLENBQUMsWUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzt3QkFDckQsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFHLENBQUMsT0FBTyxDQUFDLFlBQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7Ozs7d0JBS25ELHFCQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUE7O3dCQUEzQixTQUEyQixDQUFDO3dCQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7O3dCQUUxQixPQUFPLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxPQUFLLENBQUMsQ0FBQzs7Ozs7O0tBRTNDO0lBekRnQixPQUFPO1FBRDNCLE9BQU87T0FDYSxPQUFPLENBNEQzQjtJQUFELGNBQUM7Q0E1REQsQUE0REMsQ0E1RG9DLEVBQUUsQ0FBQyxTQUFTLEdBNERoRDtrQkE1RG9CLE9BQU8iLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uLy4uL2NvbW1vbi9jbXB0L2Jhc2UvTGF5ZXJcIjtcbmltcG9ydCB7IERpclVybCB9IGZyb20gXCIuLi8uLi9jb21tb24vY29uc3QvVXJsXCI7XG5pbXBvcnQgVXNlckluZm8sIHsgVXNlckluZm9TdG9yZ2UgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3J1bnRpbWUvVXNlckluZm9cIjtcbmltcG9ydCBSZXMgZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsL1Jlc1wiO1xuXG5jb25zdCB7IGNjY2xhc3MsIHByb3BlcnR5IH0gPSBjYy5fZGVjb3JhdG9yO1xuXG5AY2NjbGFzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGluZyBleHRlbmRzIGNjLkNvbXBvbmVudCB7XG5cbiAgICBvbkxvYWQoKSB7XG4gICAgICAgIFVzZXJJbmZvLmluc3RhbmNlLmluaXRVc2VySW5mbygpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nID0gKCkgPT4geyB9IC8v572u56m6bG9nIOS4jeaYvuekuuaJk+WNsFxuXG4gICAgICAgIGxldCB1c2VySW5mbyA9IFVzZXJJbmZvU3RvcmdlLmdldFVzZXJJbmZvKClcbiAgICAgICAgY29uc29sZS5sb2coXCI+Pj4g5pys5Zyw55qEVXNlckluZm9fX18+IFwiLCB1c2VySW5mbylcblxuICAgICAgICBpZiAoIXVzZXJJbmZvKSAvL+WmguaenOacrOWcsOayoeacieaVsOaNruWImeWCqOWtmOaVsOaNruWcqOacrOWcsFxuICAgICAgICAgICAgVXNlckluZm9TdG9yZ2Uuc2V0VXNlckluZm8oKVxuICAgICAgICBlbHNlIC8v6Iul5pys5Zyw5bey5pyJ5pWw5o2u5YiZ5bCGVXNlckluZm/mm7TmlrDkuLrlt7LmnInnmoTmlbDmja5cbiAgICAgICAgICAgIFVzZXJJbmZvLmluc3RhbmNlLnNldFVzZXJJbmZvKHVzZXJJbmZvKVxuICAgIH1cblxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXREYXRhKClcbiAgICAgICAgdGhpcy5wcmVsb2FkU2NlbmUoKVxuICAgIH1cblxuICAgIGVudGVyTWFpbigpIHtcbiAgICAgICAgTGF5ZXIuaW5zdC5lbnRlclNjZW5lKFwiTWFpblwiKVxuICAgIH1cblxuICAgIHByZWxvYWRTY2VuZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNsb3ZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLnByZWxvYWRTY2VuZSgnTWFpbicsIChjb21wbGV0ZWRDb3VudCwgdG90YWxDb3VudCwgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gY29tcGxldGVkQ291bnQgLyB0b3RhbENvdW50O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfpooTliqDovb3ov5vluqbvvJonLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign6aKE5Yqg6L29TWFpbuWcuuaZr+i1hOa6kOWksei0pe+8micsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn6aKE5Yqg6L29TWFpbuWcuuaZr+i1hOa6kOaIkOWKn++8gScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW5pdERhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiPj4+IGluaXREYXRhX18+IOW8gOWni+WKoOi9vei1hOa6kFwiKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIC8vIOa3u+WKoOWQhOS4qui1hOa6kOWKoOi9veWHveaVsOi/lOWbnueahFByb21pc2Xlr7nosaHliLDmlbDnu4RcbiAgICAgICAgcHJvbWlzZXMucHVzaChSZXMubG9hZERpcihEaXJVcmwuVEVYVFVSRSwgY2MuU3ByaXRlRnJhbWUpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChSZXMubG9hZERpcihEaXJVcmwuUFJFRkFCLCBjYy5QcmVmYWIpKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChSZXMubG9hZERpcihEaXJVcmwuQVVESU8sIGNjLkF1ZGlvQ2xpcCkpO1xuICAgICAgICAvLyBwcm9taXNlcy5wdXNoKFJlcy5sb2FkRGlyKERpclVybC5KU09OLCBjYy5Kc29uQXNzZXQpKTtcbiAgICAgICAgLy8gcHJvbWlzZXMucHVzaChSZXMubG9hZERpcihEaXJVcmwuQU5JTUFUSU9OLCBjYy5BbmltYXRpb25DbGlwKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiPj4+IOi1hOa6kOWKoOi9veWujOaIkFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCI+Pj4g6LWE5rqQ5Yqg6L295aSx6LSl77yaXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/main/BarrierManager.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '40a34aKlNNLnoevtbXnJA/q', 'BarrierManager');
// scripts/showcase/home/Card/BarrierManager.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Barrier_1 = require("./Barrier");
/**掉落物管理类 */
var BarrierManager = /** @class */ (function () {
    function BarrierManager(barrierArea) {
        this.barrierArea = null;
        this.barrierArea = barrierArea;
    }
    BarrierManager.prototype.createBarrier = function () {
        var barrier = new cc.Node();
        barrier.setParent(this.barrierArea);
        var barrierCmpt = barrier.addComponent(Barrier_1.default);
        barrierCmpt.init(); //记录此cmpt的唯一标识
        barrierCmpt.move();
    };
    return BarrierManager;
}());
exports.default = BarrierManager;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXENhcmRcXEJhcnJpZXJNYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUNBQStCO0FBRS9CLFlBQVk7QUFDWjtJQUdJLHdCQUFZLFdBQW9CO1FBRnhCLGdCQUFXLEdBQVksSUFBSSxDQUFBO1FBRy9CLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFBO0lBQ2xDLENBQUM7SUFFRCxzQ0FBYSxHQUFiO1FBQ0ksSUFBTSxPQUFPLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUE7UUFDN0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUE7UUFFbkMsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxpQkFBTyxDQUFDLENBQUE7UUFDakQsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFBLENBQUMsY0FBYztRQUNqQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUE7SUFDdEIsQ0FBQztJQUVMLHFCQUFDO0FBQUQsQ0FoQkEsQUFnQkMsSUFBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXJyaWVyIGZyb20gXCIuL0JhcnJpZXJcIlxyXG5cclxuLyoq5o6J6JC954mp566h55CG57G7ICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhcnJpZXJNYW5hZ2VyIHtcclxuICAgIHByaXZhdGUgYmFycmllckFyZWE6IGNjLk5vZGUgPSBudWxsXHJcblxyXG4gICAgY29uc3RydWN0b3IoYmFycmllckFyZWE6IGNjLk5vZGUpIHtcclxuICAgICAgICB0aGlzLmJhcnJpZXJBcmVhID0gYmFycmllckFyZWFcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVCYXJyaWVyKCkge1xyXG4gICAgICAgIGNvbnN0IGJhcnJpZXIgPSBuZXcgY2MuTm9kZSgpXHJcbiAgICAgICAgYmFycmllci5zZXRQYXJlbnQodGhpcy5iYXJyaWVyQXJlYSlcclxuXHJcbiAgICAgICAgY29uc3QgYmFycmllckNtcHQgPSBiYXJyaWVyLmFkZENvbXBvbmVudChCYXJyaWVyKVxyXG4gICAgICAgIGJhcnJpZXJDbXB0LmluaXQoKSAvL+iusOW9leatpGNtcHTnmoTllK/kuIDmoIfor4ZcclxuICAgICAgICBiYXJyaWVyQ21wdC5tb3ZlKClcclxuICAgIH1cclxuXHJcbn0iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/main/GameController.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'a485dwPWwRG2JkV3PtgayiE', 'GameController');
// scripts/showcase/home/main/GameController.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Layer_1 = require("../../../common/cmpt/base/Layer");
var EventName_1 = require("../../../common/const/EventName");
var EnumIndex_1 = require("../../../common/runtime/EnumIndex");
var Events_1 = require("../../../common/util/Events");
var Tool_1 = require("../../../common/util/Tool");
var BarrierManager_1 = require("./BarrierManager");
var MoveCtr_1 = require("./MoveCtr");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var GameController = /** @class */ (function (_super) {
    __extends(GameController, _super);
    function GameController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.touchArea = null;
        _this.targetMove = null;
        _this.targetShow = null;
        _this.moveCtrCmpt = null;
        _this.barrierArea = null;
        _this.barrierManagerCmpt = null;
        _this.gameStatus = EnumIndex_1.EGameStatus.END;
        _this.dlgOver = null;
        _this.isOver = false; //控制开始游戏的速度
        return _this;
    }
    GameController.prototype.onLoad = function () {
        Events_1.default.targetOn(this);
        this.moveCtrCmpt = new MoveCtr_1.default(this.targetMove, this.targetShow);
        this.barrierManagerCmpt = new BarrierManager_1.default(this.barrierArea);
    };
    GameController.prototype.startGame = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isOver)
                            return [2 /*return*/];
                        this.isOver = true;
                        this.gameStatus = EnumIndex_1.EGameStatus.START;
                        this.toggleDlgOver();
                        this.moveCtrCmpt.startMoving();
                        _a.label = 1;
                    case 1:
                        if (!(this.gameStatus === EnumIndex_1.EGameStatus.START)) return [3 /*break*/, 3];
                        this.barrierManagerCmpt.createBarrier();
                        return [4 /*yield*/, Tool_1.default.waitCmpt(this, 1)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 3:
                        this.isOver = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**改变移动方向 */
    GameController.prototype.changeMoveDirection = function () {
        if (this.gameStatus !== EnumIndex_1.EGameStatus.START)
            return;
        this.moveCtrCmpt.changeMoveDirection();
    };
    GameController.prototype.judgResult = function (barrierID) {
        var tip = {
            text: "",
            unique: false,
            end: cc.v2(0, 100)
        };
        if (barrierID === 7) {
            console.log("加道具数量");
            tip.text = "获得道具：";
            Layer_1.default.inst.showTip(tip);
            return;
        }
        var targetID = this.moveCtrCmpt.targetID;
        if (barrierID === targetID) {
            console.log("加点金币");
            tip.text = "获得金币：";
            Layer_1.default.inst.showTip(tip);
        }
        else {
            console.log("gameOver");
            tip.text = "结束获取";
            Layer_1.default.inst.showTip(tip);
            this.gameOver();
        }
    };
    GameController.prototype.gameOver = function () {
        this.gameStatus = EnumIndex_1.EGameStatus.END;
        this.moveCtrCmpt.randomID();
        this.moveCtrCmpt.gameOver();
        this.barrierArea.destroyAllChildren();
        this.toggleDlgOver();
    };
    GameController.prototype.toggleDlgOver = function () {
        this.dlgOver.active = this.gameStatus === EnumIndex_1.EGameStatus.END;
    };
    GameController.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
        // this.moveCtrCmpt.onDestroy()
    };
    __decorate([
        property(cc.Node)
    ], GameController.prototype, "touchArea", void 0);
    __decorate([
        property(cc.Node)
    ], GameController.prototype, "targetMove", void 0);
    __decorate([
        property(cc.Node)
    ], GameController.prototype, "targetShow", void 0);
    __decorate([
        property(cc.Node)
    ], GameController.prototype, "barrierArea", void 0);
    __decorate([
        property(cc.Node)
    ], GameController.prototype, "dlgOver", void 0);
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.JUDG_RESULT)
    ], GameController.prototype, "judgResult", null);
    GameController = __decorate([
        ccclass
    ], GameController);
    return GameController;
}(cc.Component));
exports.default = GameController;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXG1haW5cXEdhbWVDb250cm9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlEQUFvRDtBQUNwRCw2REFBNEQ7QUFDNUQsK0RBQWdFO0FBQ2hFLHNEQUFtRTtBQUNuRSxrREFBNkM7QUFDN0MsbURBQThDO0FBQzlDLHFDQUFnQztBQUUxQixJQUFBLEtBQXdCLEVBQUUsQ0FBQyxVQUFVLEVBQW5DLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBa0IsQ0FBQztBQUc1QztJQUE0QyxrQ0FBWTtJQUF4RDtRQUFBLHFFQTRGQztRQTNGc0IsZUFBUyxHQUFZLElBQUksQ0FBQTtRQUN6QixnQkFBVSxHQUFZLElBQUksQ0FBQTtRQUMxQixnQkFBVSxHQUFZLElBQUksQ0FBQTtRQUNyQyxpQkFBVyxHQUFZLElBQUksQ0FBQTtRQUVoQixpQkFBVyxHQUFZLElBQUksQ0FBQTtRQUN0Qyx3QkFBa0IsR0FBbUIsSUFBSSxDQUFBO1FBRXpDLGdCQUFVLEdBQWdCLHVCQUFXLENBQUMsR0FBRyxDQUFBO1FBQzlCLGFBQU8sR0FBWSxJQUFJLENBQUE7UUFDbEMsWUFBTSxHQUFZLEtBQUssQ0FBQSxDQUFDLFdBQVc7O0lBaUYvQyxDQUFDO0lBL0VhLCtCQUFNLEdBQWhCO1FBQ0ksZ0JBQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUE7UUFFckIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGlCQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDaEUsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksd0JBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUE7SUFDbEUsQ0FBQztJQUVLLGtDQUFTLEdBQWY7Ozs7O3dC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QUFsQixRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQztzREFBMkI7SUFHMUI7UUFBbEIsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7dURBQTRCO0lBSTNCO1FBQWxCLFFBQVEsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO21EQUF3QjtJQWlDMUM7UUFEQyxxQkFBWSxDQUFDLHFCQUFTLENBQUMsV0FBVyxDQUFDO29EQStCbkM7SUF6RWdCLGNBQWM7UUFEbEMsT0FBTztPQUNhLGNBQWMsQ0E0RmxDO0lBQUQscUJBQUM7Q0E1RkQsQUE0RkMsQ0E1RjJDLEVBQUUsQ0FBQyxTQUFTLEdBNEZ2RDtrQkE1Rm9CLGNBQWMiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9jbXB0L2Jhc2UvTGF5ZXJcIjtcclxuaW1wb3J0IHsgRXZlbnROYW1lIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9jb25zdC9FdmVudE5hbWVcIjtcclxuaW1wb3J0IHsgRUdhbWVTdGF0dXMgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3J1bnRpbWUvRW51bUluZGV4XCI7XHJcbmltcG9ydCBFdmVudHMsIHsgcHJlbG9hZEV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWwvVG9vbFwiO1xyXG5pbXBvcnQgQmFycmllck1hbmFnZXIgZnJvbSBcIi4vQmFycmllck1hbmFnZXJcIjtcclxuaW1wb3J0IE1vdmVDdHIgZnJvbSBcIi4vTW92ZUN0clwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVDb250cm9sbGVyIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIEBwcm9wZXJ0eShjYy5Ob2RlKSB0b3VjaEFyZWE6IGNjLk5vZGUgPSBudWxsXHJcbiAgICBAcHJvcGVydHkoY2MuTm9kZSkgdGFyZ2V0TW92ZTogY2MuTm9kZSA9IG51bGxcclxuICAgIEBwcm9wZXJ0eShjYy5Ob2RlKSB0YXJnZXRTaG93OiBjYy5Ob2RlID0gbnVsbFxyXG4gICAgcHJpdmF0ZSBtb3ZlQ3RyQ21wdDogTW92ZUN0ciA9IG51bGxcclxuXHJcbiAgICBAcHJvcGVydHkoY2MuTm9kZSkgYmFycmllckFyZWE6IGNjLk5vZGUgPSBudWxsXHJcbiAgICBwcml2YXRlIGJhcnJpZXJNYW5hZ2VyQ21wdDogQmFycmllck1hbmFnZXIgPSBudWxsXHJcblxyXG4gICAgcHJpdmF0ZSBnYW1lU3RhdHVzOiBFR2FtZVN0YXR1cyA9IEVHYW1lU3RhdHVzLkVORFxyXG4gICAgQHByb3BlcnR5KGNjLk5vZGUpIGRsZ092ZXI6IGNjLk5vZGUgPSBudWxsXHJcbiAgICBwcml2YXRlIGlzT3ZlcjogYm9vbGVhbiA9IGZhbHNlIC8v5o6n5Yi25byA5aeL5ri45oiP55qE6YCf5bqmXHJcblxyXG4gICAgcHJvdGVjdGVkIG9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T24odGhpcylcclxuXHJcbiAgICAgICAgdGhpcy5tb3ZlQ3RyQ21wdCA9IG5ldyBNb3ZlQ3RyKHRoaXMudGFyZ2V0TW92ZSwgdGhpcy50YXJnZXRTaG93KVxyXG4gICAgICAgIHRoaXMuYmFycmllck1hbmFnZXJDbXB0ID0gbmV3IEJhcnJpZXJNYW5hZ2VyKHRoaXMuYmFycmllckFyZWEpXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc3RhcnRHYW1lKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3ZlcikgcmV0dXJuXHJcbiAgICAgICAgdGhpcy5pc092ZXIgPSB0cnVlXHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXR1cyA9IEVHYW1lU3RhdHVzLlNUQVJUXHJcbiAgICAgICAgdGhpcy50b2dnbGVEbGdPdmVyKClcclxuXHJcbiAgICAgICAgdGhpcy5tb3ZlQ3RyQ21wdC5zdGFydE1vdmluZygpXHJcbiAgICAgICAgd2hpbGUgKHRoaXMuZ2FtZVN0YXR1cyA9PT0gRUdhbWVTdGF0dXMuU1RBUlQpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXJyaWVyTWFuYWdlckNtcHQuY3JlYXRlQmFycmllcigpXHJcbiAgICAgICAgICAgIGF3YWl0IFRvb2wud2FpdENtcHQodGhpcywgMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaXNPdmVyID0gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICAvKirmlLnlj5jnp7vliqjmlrnlkJEgKi9cclxuICAgIGNoYW5nZU1vdmVEaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXR1cyAhPT0gRUdhbWVTdGF0dXMuU1RBUlQpIHJldHVyblxyXG4gICAgICAgIHRoaXMubW92ZUN0ckNtcHQuY2hhbmdlTW92ZURpcmVjdGlvbigpXHJcbiAgICB9XHJcblxyXG4gICAgQHByZWxvYWRFdmVudChFdmVudE5hbWUuSlVER19SRVNVTFQpXHJcbiAgICBqdWRnUmVzdWx0KGJhcnJpZXJJRDogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgdGlwID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxyXG4gICAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxyXG4gICAgICAgICAgICBlbmQ6IGNjLnYyKDAsIDEwMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXJyaWVySUQgPT09IDcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLliqDpgZPlhbfmlbDph49cIik7XHJcblxyXG4gICAgICAgICAgICB0aXAudGV4dCA9IFwi6I635b6X6YGT5YW377yaXCJcclxuICAgICAgICAgICAgTGF5ZXIuaW5zdC5zaG93VGlwKHRpcClcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXRJRCA9IHRoaXMubW92ZUN0ckNtcHQudGFyZ2V0SURcclxuICAgICAgICBpZiAoYmFycmllcklEID09PSB0YXJnZXRJRCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWKoOeCuemHkeW4gVwiKTtcclxuXHJcbiAgICAgICAgICAgIHRpcC50ZXh0ID0gXCLojrflvpfph5HluIHvvJpcIlxyXG4gICAgICAgICAgICBMYXllci5pbnN0LnNob3dUaXAodGlwKVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImdhbWVPdmVyXCIpO1xyXG5cclxuICAgICAgICAgICAgdGlwLnRleHQgPSBcIue7k+adn+iOt+WPllwiXHJcbiAgICAgICAgICAgIExheWVyLmluc3Quc2hvd1RpcCh0aXApXHJcblxyXG4gICAgICAgICAgICB0aGlzLmdhbWVPdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdhbWVPdmVyKCkge1xyXG4gICAgICAgIHRoaXMuZ2FtZVN0YXR1cyA9IEVHYW1lU3RhdHVzLkVORFxyXG4gICAgICAgIHRoaXMubW92ZUN0ckNtcHQucmFuZG9tSUQoKVxyXG4gICAgICAgIHRoaXMubW92ZUN0ckNtcHQuZ2FtZU92ZXIoKVxyXG4gICAgICAgIHRoaXMuYmFycmllckFyZWEuZGVzdHJveUFsbENoaWxkcmVuKClcclxuICAgICAgICB0aGlzLnRvZ2dsZURsZ092ZXIoKVxyXG4gICAgfVxyXG5cclxuICAgIHRvZ2dsZURsZ092ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5kbGdPdmVyLmFjdGl2ZSA9IHRoaXMuZ2FtZVN0YXR1cyA9PT0gRUdhbWVTdGF0dXMuRU5EXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG9uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T2ZmKHRoaXMpXHJcbiAgICAgICAgLy8gdGhpcy5tb3ZlQ3RyQ21wdC5vbkRlc3Ryb3koKVxyXG4gICAgfVxyXG5cclxufVxyXG4iXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/main/Barrier.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'f8b28+GcydKlrxxzBuziF5P', 'Barrier');
// scripts/showcase/home/Card/Barrier.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ResSprite_1 = require("../../../common/cmpt/ui/res/ResSprite");
var EventName_1 = require("../../../common/const/EventName");
var Url_1 = require("../../../common/const/Url");
var Events_1 = require("../../../common/util/Events");
var Tool_1 = require("../../../common/util/Tool");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var Barrier = /** @class */ (function (_super) {
    __extends(Barrier, _super);
    function Barrier() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._randomID = null;
        return _this;
    }
    Barrier.prototype.init = function () {
        var randomID = Tool_1.default.randInt(1, 8);
        this._randomID = randomID;
        console.log("randomID:", randomID);
        var x = Tool_1.default.randInt(-650, 650);
        var y = 200;
        this.node.setPosition(x, y); //设置随机位置
        var spBarrier = this.addComponent(cc.Sprite);
        var resSpriteBarrier = this.addComponent(ResSprite_1.default);
        resSpriteBarrier.setSpriteFrame(Url_1.DirUrl.TEXTURE + "home/barrier/" + randomID);
        this.node.group = "barrier";
        var collider = this.addComponent(cc.CircleCollider);
        collider.radius = 60;
    };
    Barrier.prototype.move = function () {
        var _this = this;
        var targetPosition = cc.v3(this.node.position.x, this.node.position.y - 400);
        var time = 1.5;
        cc.tween(this.node)
            .to(time, { position: targetPosition })
            .call(function () { _this.node.destroy(); })
            .start();
    };
    Barrier.prototype.onCollisionEnter = function (other, self) {
        Events_1.default.emit(EventName_1.EventName.JUDG_RESULT, this._randomID);
        this.node.destroy();
    };
    Barrier = __decorate([
        ccclass
    ], Barrier);
    return Barrier;
}(cc.Component));
exports.default = Barrier;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXENhcmRcXEJhcnJpZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQThEO0FBQzlELDZEQUE0RDtBQUM1RCxpREFBbUQ7QUFDbkQsc0RBQWlEO0FBQ2pELGtEQUE2QztBQUV2QyxJQUFBLEtBQXdCLEVBQUUsQ0FBQyxVQUFVLEVBQW5DLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBa0IsQ0FBQztBQUc1QztJQUFxQywyQkFBWTtJQUFqRDtRQUFBLHFFQXFDQztRQXBDVyxlQUFTLEdBQVcsSUFBSSxDQUFBOztJQW9DcEMsQ0FBQztJQWxDVSxzQkFBSSxHQUFYO1FBQ0ksSUFBTSxRQUFRLEdBQUcsY0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDbkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUE7UUFDekIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFHbkMsSUFBTSxDQUFDLEdBQUcsY0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQTtRQUNqQyxJQUFNLENBQUMsR0FBRyxHQUFHLENBQUE7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUEsQ0FBQyxRQUFRO1FBRXBDLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQzlDLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBUyxDQUFDLENBQUE7UUFDckQsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLFlBQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxHQUFHLFFBQVEsQ0FBQyxDQUFBO1FBRTVFLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQTtRQUMzQixJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQTtRQUNyRCxRQUFRLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRU0sc0JBQUksR0FBWDtRQUFBLGlCQVFDO1FBUEcsSUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQy9FLElBQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUVqQixFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDZCxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxDQUFDO2FBQ3RDLElBQUksQ0FBQyxjQUFRLEtBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUEsQ0FBQyxDQUFDLENBQUM7YUFDbkMsS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUVELGtDQUFnQixHQUFoQixVQUFpQixLQUFLLEVBQUUsSUFBSTtRQUN4QixnQkFBTSxDQUFDLElBQUksQ0FBQyxxQkFBUyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUE7UUFFbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUN2QixDQUFDO0lBcENnQixPQUFPO1FBRDNCLE9BQU87T0FDYSxPQUFPLENBcUMzQjtJQUFELGNBQUM7Q0FyQ0QsQUFxQ0MsQ0FyQ29DLEVBQUUsQ0FBQyxTQUFTLEdBcUNoRDtrQkFyQ29CLE9BQU8iLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVzU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9jb21tb24vY21wdC91aS9yZXMvUmVzU3ByaXRlXCI7XHJcbmltcG9ydCB7IEV2ZW50TmFtZSB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCB7IERpclVybCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vY29uc3QvVXJsXCI7XHJcbmltcG9ydCBFdmVudHMgZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWwvVG9vbFwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhcnJpZXIgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG4gICAgcHJpdmF0ZSBfcmFuZG9tSUQ6IG51bWJlciA9IG51bGxcclxuXHJcbiAgICBwdWJsaWMgaW5pdCgpIHtcclxuICAgICAgICBjb25zdCByYW5kb21JRCA9IFRvb2wucmFuZEludCgxLCA4KVxyXG4gICAgICAgIHRoaXMuX3JhbmRvbUlEID0gcmFuZG9tSURcclxuICAgICAgICBjb25zb2xlLmxvZyhcInJhbmRvbUlEOlwiLCByYW5kb21JRCk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB4ID0gVG9vbC5yYW5kSW50KC02NTAsIDY1MClcclxuICAgICAgICBjb25zdCB5ID0gMjAwXHJcbiAgICAgICAgdGhpcy5ub2RlLnNldFBvc2l0aW9uKHgsIHkpIC8v6K6+572u6ZqP5py65L2N572uXHJcblxyXG4gICAgICAgIGNvbnN0IHNwQmFycmllciA9IHRoaXMuYWRkQ29tcG9uZW50KGNjLlNwcml0ZSlcclxuICAgICAgICBjb25zdCByZXNTcHJpdGVCYXJyaWVyID0gdGhpcy5hZGRDb21wb25lbnQoUmVzU3ByaXRlKVxyXG4gICAgICAgIHJlc1Nwcml0ZUJhcnJpZXIuc2V0U3ByaXRlRnJhbWUoRGlyVXJsLlRFWFRVUkUgKyBcImhvbWUvYmFycmllci9cIiArIHJhbmRvbUlEKVxyXG5cclxuICAgICAgICB0aGlzLm5vZGUuZ3JvdXAgPSBcImJhcnJpZXJcIlxyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5hZGRDb21wb25lbnQoY2MuQ2lyY2xlQ29sbGlkZXIpXHJcbiAgICAgICAgY29sbGlkZXIucmFkaXVzID0gNjBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbW92ZSgpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGNjLnYzKHRoaXMubm9kZS5wb3NpdGlvbi54LCB0aGlzLm5vZGUucG9zaXRpb24ueSAtIDQwMCk7XHJcbiAgICAgICAgY29uc3QgdGltZSA9IDEuNTtcclxuXHJcbiAgICAgICAgY2MudHdlZW4odGhpcy5ub2RlKVxyXG4gICAgICAgICAgICAudG8odGltZSwgeyBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24gfSlcclxuICAgICAgICAgICAgLmNhbGwoKCkgPT4geyB0aGlzLm5vZGUuZGVzdHJveSgpIH0pXHJcbiAgICAgICAgICAgIC5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ29sbGlzaW9uRW50ZXIob3RoZXIsIHNlbGYpIHtcclxuICAgICAgICBFdmVudHMuZW1pdChFdmVudE5hbWUuSlVER19SRVNVTFQsIHRoaXMuX3JhbmRvbUlEKVxyXG5cclxuICAgICAgICB0aGlzLm5vZGUuZGVzdHJveSgpXHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/main/MoveCtr.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '85314W/qlpJdrs34pUNKN2i', 'MoveCtr');
// scripts/showcase/home/Card/MoveCtr.ts

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResSprite_1 = require("../../../common/cmpt/ui/res/ResSprite");
var Url_1 = require("../../../common/const/Url");
var Tool_1 = require("../../../common/util/Tool");
/**移动控制 */
var MoveCtr = /** @class */ (function () {
    function MoveCtr(targetNode, targetShow) {
        this.targetNode = null;
        this.targetShow = null;
        this._moveSpeed = 1500; // 运动速度
        this._maxWidth = 1300;
        this._maxHeight = 0;
        this._minWidth = -1300;
        this._minHeight = 0;
        this.moveDirection = cc.v2(1, 0); // 初始运动方向向右
        this._targetID = null;
        this.targetNode = targetNode;
        this.targetShow = targetShow;
        this.randomID();
    }
    Object.defineProperty(MoveCtr.prototype, "targetID", {
        get: function () { return this._targetID; },
        enumerable: false,
        configurable: true
    });
    MoveCtr.prototype.randomID = function () {
        var _a, _b;
        this._targetID = Tool_1.default.randInt(1, 6);
        var resSprite = (_a = this.targetNode.getComponent(ResSprite_1.default)) !== null && _a !== void 0 ? _a : this.targetNode.addComponent(ResSprite_1.default);
        resSprite.setSpriteFrame(Url_1.DirUrl.TEXTURE + "home/barrier/" + this._targetID);
        var resSpriteShow = (_b = this.targetShow.getComponent(ResSprite_1.default)) !== null && _b !== void 0 ? _b : this.targetShow.addComponent(ResSprite_1.default);
        resSpriteShow.setSpriteFrame(Url_1.DirUrl.TEXTURE + "home/barrier/" + this._targetID);
    };
    MoveCtr.prototype.startMoving = function () {
        var schedule = cc.director.getScheduler();
        schedule.enableForTarget(this);
        schedule.schedule(this.updateMove, this, 0);
    };
    MoveCtr.prototype.stopMoving = function () {
        var schedule = cc.director.getScheduler();
        schedule.unschedule(this.updateMove, this);
    };
    MoveCtr.prototype.updateMove = function (dt) {
        this.targetNode.x += dt * this._moveSpeed * this.moveDirection.x;
        this.targetNode.y += dt * this._moveSpeed * this.moveDirection.y;
        var targetx = this.targetNode.x;
        var targety = this.targetNode.y;
        if (targetx >= this._maxWidth && targety >= this._maxHeight)
            this.moveDirection = cc.v2(-1, 0);
        if (targetx <= this._minWidth && targety <= this._minHeight)
            this.moveDirection = cc.v2(1, 0);
    };
    MoveCtr.prototype.changeMoveDirection = function () {
        this.moveDirection = (this.moveDirection.equals(cc.v2(1, 0))) ? cc.v2(-1, 0) : cc.v2(1, 0);
    };
    // onDestroy() {
    //     this.stopMoving();
    // }
    MoveCtr.prototype.gameOver = function () {
        this.stopMoving();
        this.targetNode.setPosition(0, 0);
    };
    return MoveCtr;
}());
exports.default = MoveCtr;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXENhcmRcXE1vdmVDdHIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtRUFBOEQ7QUFDOUQsaURBQW1EO0FBQ25ELGtEQUE2QztBQUU3QyxVQUFVO0FBQ1Y7SUFlSSxpQkFBWSxVQUFtQixFQUFFLFVBQW1CO1FBZDVDLGVBQVUsR0FBWSxJQUFJLENBQUM7UUFDM0IsZUFBVSxHQUFZLElBQUksQ0FBQztRQUUzQixlQUFVLEdBQVcsSUFBSSxDQUFDLENBQUMsT0FBTztRQUNsQyxjQUFTLEdBQVcsSUFBSSxDQUFDO1FBQ3pCLGVBQVUsR0FBVyxDQUFDLENBQUM7UUFDdkIsY0FBUyxHQUFXLENBQUMsSUFBSSxDQUFDO1FBQzFCLGVBQVUsR0FBVyxDQUFDLENBQUM7UUFFdkIsa0JBQWEsR0FBWSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVc7UUFFakQsY0FBUyxHQUFXLElBQUksQ0FBQTtRQUk1QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQU5ELHNCQUFXLDZCQUFRO2FBQW5CLGNBQXdCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQSxDQUFDLENBQUM7OztPQUFBO0lBUS9DLDBCQUFRLEdBQVI7O1FBQ0ksSUFBSSxDQUFDLFNBQVMsR0FBRyxjQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUNuQyxJQUFNLFNBQVMsU0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxtQkFBUyxDQUFDLG1DQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLG1CQUFTLENBQUMsQ0FBQTtRQUNwRyxTQUFTLENBQUMsY0FBYyxDQUFDLFlBQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUUzRSxJQUFNLGFBQWEsU0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxtQkFBUyxDQUFDLG1DQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLG1CQUFTLENBQUMsQ0FBQTtRQUN4RyxhQUFhLENBQUMsY0FBYyxDQUFDLFlBQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUNuRixDQUFDO0lBRUQsNkJBQVcsR0FBWDtRQUNJLElBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDNUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQixRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCw0QkFBVSxHQUFWO1FBQ0ksSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUM1QyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVPLDRCQUFVLEdBQWxCLFVBQW1CLEVBQVU7UUFDekIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUE7UUFDaEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUE7UUFFaEUsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUE7UUFDakMsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUE7UUFDakMsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVU7WUFBRSxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7UUFDOUYsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLFVBQVU7WUFBRSxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0lBQ2pHLENBQUM7SUFFRCxxQ0FBbUIsR0FBbkI7UUFDSSxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMvRixDQUFDO0lBRUQsZ0JBQWdCO0lBQ2hCLHlCQUF5QjtJQUN6QixJQUFJO0lBRUosMEJBQVEsR0FBUjtRQUNJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDckMsQ0FBQztJQUNMLGNBQUM7QUFBRCxDQS9EQSxBQStEQyxJQUFBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlc1Nwcml0ZSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2NtcHQvdWkvcmVzL1Jlc1Nwcml0ZVwiO1xyXG5pbXBvcnQgeyBEaXJVcmwgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2NvbnN0L1VybFwiO1xyXG5pbXBvcnQgVG9vbCBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWwvVG9vbFwiO1xyXG5cclxuLyoq56e75Yqo5o6n5Yi2ICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmVDdHIge1xyXG4gICAgcHJpdmF0ZSB0YXJnZXROb2RlOiBjYy5Ob2RlID0gbnVsbDtcclxuICAgIHByaXZhdGUgdGFyZ2V0U2hvdzogY2MuTm9kZSA9IG51bGw7XHJcblxyXG4gICAgcHJpdmF0ZSBfbW92ZVNwZWVkOiBudW1iZXIgPSAxNTAwOyAvLyDov5DliqjpgJ/luqZcclxuICAgIHByaXZhdGUgX21heFdpZHRoOiBudW1iZXIgPSAxMzAwO1xyXG4gICAgcHJpdmF0ZSBfbWF4SGVpZ2h0OiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBfbWluV2lkdGg6IG51bWJlciA9IC0xMzAwO1xyXG4gICAgcHJpdmF0ZSBfbWluSGVpZ2h0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgbW92ZURpcmVjdGlvbjogY2MuVmVjMiA9IGNjLnYyKDEsIDApOyAvLyDliJ3lp4vov5DliqjmlrnlkJHlkJHlj7NcclxuXHJcbiAgICBwcml2YXRlIF90YXJnZXRJRDogbnVtYmVyID0gbnVsbFxyXG4gICAgcHVibGljIGdldCB0YXJnZXRJRCgpIHsgcmV0dXJuIHRoaXMuX3RhcmdldElEIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXROb2RlOiBjYy5Ob2RlLCB0YXJnZXRTaG93OiBjYy5Ob2RlKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXROb2RlID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICB0aGlzLnRhcmdldFNob3cgPSB0YXJnZXRTaG93O1xyXG4gICAgICAgIHRoaXMucmFuZG9tSUQoKTtcclxuICAgIH1cclxuXHJcbiAgICByYW5kb21JRCgpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXRJRCA9IFRvb2wucmFuZEludCgxLCA2KVxyXG4gICAgICAgIGNvbnN0IHJlc1Nwcml0ZSA9IHRoaXMudGFyZ2V0Tm9kZS5nZXRDb21wb25lbnQoUmVzU3ByaXRlKSA/PyB0aGlzLnRhcmdldE5vZGUuYWRkQ29tcG9uZW50KFJlc1Nwcml0ZSlcclxuICAgICAgICByZXNTcHJpdGUuc2V0U3ByaXRlRnJhbWUoRGlyVXJsLlRFWFRVUkUgKyBcImhvbWUvYmFycmllci9cIiArIHRoaXMuX3RhcmdldElEKVxyXG5cclxuICAgICAgICBjb25zdCByZXNTcHJpdGVTaG93ID0gdGhpcy50YXJnZXRTaG93LmdldENvbXBvbmVudChSZXNTcHJpdGUpID8/IHRoaXMudGFyZ2V0U2hvdy5hZGRDb21wb25lbnQoUmVzU3ByaXRlKVxyXG4gICAgICAgIHJlc1Nwcml0ZVNob3cuc2V0U3ByaXRlRnJhbWUoRGlyVXJsLlRFWFRVUkUgKyBcImhvbWUvYmFycmllci9cIiArIHRoaXMuX3RhcmdldElEKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0TW92aW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHNjaGVkdWxlID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcbiAgICAgICAgc2NoZWR1bGUuZW5hYmxlRm9yVGFyZ2V0KHRoaXMpO1xyXG4gICAgICAgIHNjaGVkdWxlLnNjaGVkdWxlKHRoaXMudXBkYXRlTW92ZSwgdGhpcywgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcE1vdmluZygpIHtcclxuICAgICAgICBjb25zdCBzY2hlZHVsZSA9IGNjLmRpcmVjdG9yLmdldFNjaGVkdWxlcigpO1xyXG4gICAgICAgIHNjaGVkdWxlLnVuc2NoZWR1bGUodGhpcy51cGRhdGVNb3ZlLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZU1vdmUoZHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Tm9kZS54ICs9IGR0ICogdGhpcy5fbW92ZVNwZWVkICogdGhpcy5tb3ZlRGlyZWN0aW9uLnhcclxuICAgICAgICB0aGlzLnRhcmdldE5vZGUueSArPSBkdCAqIHRoaXMuX21vdmVTcGVlZCAqIHRoaXMubW92ZURpcmVjdGlvbi55XHJcblxyXG4gICAgICAgIGNvbnN0IHRhcmdldHggPSB0aGlzLnRhcmdldE5vZGUueFxyXG4gICAgICAgIGNvbnN0IHRhcmdldHkgPSB0aGlzLnRhcmdldE5vZGUueVxyXG4gICAgICAgIGlmICh0YXJnZXR4ID49IHRoaXMuX21heFdpZHRoICYmIHRhcmdldHkgPj0gdGhpcy5fbWF4SGVpZ2h0KSB0aGlzLm1vdmVEaXJlY3Rpb24gPSBjYy52MigtMSwgMClcclxuICAgICAgICBpZiAodGFyZ2V0eCA8PSB0aGlzLl9taW5XaWR0aCAmJiB0YXJnZXR5IDw9IHRoaXMuX21pbkhlaWdodCkgdGhpcy5tb3ZlRGlyZWN0aW9uID0gY2MudjIoMSwgMClcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2VNb3ZlRGlyZWN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMubW92ZURpcmVjdGlvbiA9ICh0aGlzLm1vdmVEaXJlY3Rpb24uZXF1YWxzKGNjLnYyKDEsIDApKSkgPyBjYy52MigtMSwgMCkgOiBjYy52MigxLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvbkRlc3Ryb3koKSB7XHJcbiAgICAvLyAgICAgdGhpcy5zdG9wTW92aW5nKCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgZ2FtZU92ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTW92aW5nKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXROb2RlLnNldFBvc2l0aW9uKDAsIDApXHJcbiAgICB9XHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/guide/GodGuide.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'ef198yB6J9HNLLc2uAV3Rwx', 'GodGuide');
// scripts/showcase/home/guide/GodGuide.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GodGuide = void 0;
var EventName_1 = require("../../../common/const/EventName");
var Events_1 = require("../../../common/util/Events");
var GuideTaskIndex_1 = require("./task/GuideTaskIndex");
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
// declare let require: (string) => any;
// let async = require('async');
var async = require("async");
var GodGuide = /** @class */ (function (_super) {
    __extends(GodGuide, _super);
    function GodGuide() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**手指预制件 */
        _this.fingerPrefab = null;
        _this._finger = null;
        _this._mask = null;
        _this._targetNode = null; //引导的目标（也就是要引导玩家操作的目标）
        return _this;
    }
    GodGuide_1 = GodGuide;
    GodGuide.prototype.onLoad = function () {
        Events_1.default.targetOn(this);
        if (this.fingerPrefab) {
            /**若要进行资源引用计数管理 应使用Res中的instantiate进行加载 */
            this._finger = cc.instantiate(this.fingerPrefab);
            this._finger.parent = this.node;
            this._finger.active = false;
            //this._finger.getComponent("GuideFinger").stopAnim() //手指可以挂一些动画脚本
        }
        this.node.setContentSize(cc.winSize);
        this.node.on(cc.Node.EventType.TOUCH_START, this.addSetSwallowTouchesEventListener, this);
        this._mask = this.node.getComponentInChildren(cc.Mask);
        this._mask.node.active = false; //mask遮挡面板默认不开启，只有在引导时在开启
    };
    GodGuide.prototype.onDestroy = function () {
        Events_1.default.targetOff(this);
    };
    /**
     * 由事件进行派发的引导处理
     * @param data
     */
    GodGuide.prototype.excuteGuideTask = function (data) {
        var _this = this;
        console.log("接收的引导数据", data);
        this._mask.node.active = true; //引导前开启遮挡面板
        var flie = GuideTaskIndex_1.default["" + data];
        var task = flie.task;
        this._targetNode = null; //每次引导执行前，都将之前的引导目标清空
        async.eachSeries(task.steps, function (step, cb) {
            _this._processStep(step, cb);
        }, function () {
            _this._mask._graphics.clear();
            _this._mask.node.active = false; //关闭遮挡面板
            _this._finger.active = false;
        });
    };
    /**执行引导步骤 */
    GodGuide.prototype._processStep = function (step, callback) {
        var _this = this;
        //调用async.series来执行引导的步骤
        async.series({
            stepStart: function (markonCb) {
                if (step.onStart) {
                    step.onStart(function () {
                        markonCb();
                    });
                }
                else {
                    markonCb();
                }
            },
            stepExcute: function (markonCb) {
                if (step.onExcute) {
                    step.onExcute(function () {
                        _this.scheduleOnce(function () {
                            var cmd = GodGuide_1[step.command.cmd];
                            if (cmd) {
                                cmd(_this, step, function (error) {
                                    markonCb(error);
                                });
                            }
                        }, step.delayTime || 0);
                    });
                }
                else {
                    markonCb();
                }
            },
            stepEnd: function (markonCb) {
                if (step.onEnd) {
                    step.onEnd(function () {
                        markonCb();
                    });
                }
                else {
                    markonCb();
                }
            },
        }, function (error, result) {
            if (error) {
                //如果存在意外终止 doSomething。。。。
                return;
            }
            //引导执行完毕
            callback();
        });
    };
    /**
     * 事件的吞没处理机制
     */
    GodGuide.prototype.addSetSwallowTouchesEventListener = function (event) {
        if (!this._mask.node.active) {
            this.node._touchListener.setSwallowTouches(false);
            return;
        }
        if (!this._targetNode) {
            this.node._touchListener.setSwallowTouches(true);
            return;
        }
        if (!cc.isValid(this._targetNode)) {
            return;
        }
        var rect = this._targetNode.getBoundingBoxToWorld();
        if (rect.contains(event.getLocation())) {
            //如果玩家点击了规定的区域，则让事件往下派发
            this.node._touchListener.setSwallowTouches(false);
        }
        else {
            this.node._touchListener.setSwallowTouches(true);
        }
    };
    GodGuide.movefinger = function (guideTaskMgr, step, callback) {
        var params = step.command;
        guideTaskMgr._targetNode = null; //先置空之前查找的目标节点
        //开始查找新的目标节点
        guideTaskMgr.find(params.args, function (node, rect) {
            //查找到之后并且聚焦过去
            guideTaskMgr.fingerToNode(node, function () {
                guideTaskMgr._targetNode = node; //赋值新的查找到的目标节点
                node.once(cc.Node.EventType.TOUCH_END, function () {
                    callback();
                    console.log("点击目标节点成功");
                });
            });
        });
    };
    //******************工具集函数********************* */
    /**
     * 查找节点
     * @param value
     * @param cb
     */
    GodGuide.prototype.find = function (value, cb) {
        var _this = this;
        var root = cc.find('Canvas');
        // let root = this.node.parent
        this.locateNode(root, value, function (error, node) {
            if (error) {
                console.log("查找节点失败", value);
                return;
            }
            var rect = _this._focusToNode(node);
            if (cb) {
                console.log("查找节点成功", value);
                cb(node, rect);
            }
        });
    };
    /**
    * 路径特殊字符使用正则表达式进行拆分
    * @param locator 查询的路径配置，形如：'bottom/bag/bagContent/casting',
    */
    GodGuide.prototype.parse = function (locator) {
        var names = locator.split(/[.,//,>,#]/g);
        var segments = names.map(function (name) {
            var index = locator.indexOf(name);
            var symbol = locator[index - 1] || '/';
            return { symbol: symbol, name: name.trim() };
        });
        return segments;
    };
    /**
    * 根据查找路径和根节点定位要查找的目标节点
    * @param root
    * @param locator
    * @param cb
    */
    GodGuide.prototype.locateNode = function (root, locator, cb) {
        var segments = this.parse(locator);
        var child = null, node = root;
        for (var i = 0; i < segments.length; i++) {
            var item = segments[i];
            switch (item.symbol) {
                case '/':
                    child = node.getChildByName(item.name);
                    break;
            }
            if (!child) {
                node = null;
                break;
            }
            node = child;
        }
        if (node && node.active && cb) {
            cb(null, node);
        }
        else {
            cb(locator);
        }
        return node;
    };
    /**
     * 聚焦到目标节点并绘制图形
     * @param node 查找的节点
     */
    GodGuide.prototype._focusToNode = function (node) {
        this._mask._graphics.clear();
        var rect = node.getBoundingBoxToWorld();
        var p = this.node.convertToNodeSpaceAR(rect.origin);
        rect.x = p.x;
        rect.y = p.y;
        this._mask._graphics.fillRect(rect.x, rect.y, rect.width, rect.height);
        return rect;
    };
    /**
     * 移动手指到目标节点
     * @param node
     * @param markonCb
     */
    GodGuide.prototype.fingerToNode = function (node, markonCb) {
        if (!this._finger) {
            markonCb();
        }
        this._finger.active = true;
        this._finger.stopAllActions();
        var p = this.node.convertToNodeSpaceAR(node.parent.convertToWorldSpaceAR(node.position));
        this._finger.setPosition(cc.v3(p.x + 100, p.y));
        //this._finger.getComponent("GuideFinger").playAnim(); //手指可以挂一些动画脚本，用来控制动画播放
        markonCb();
    };
    var GodGuide_1;
    __decorate([
        property(cc.Prefab)
    ], GodGuide.prototype, "fingerPrefab", void 0);
    __decorate([
        Events_1.preloadEvent(EventName_1.EventName.EXCUTE_GUIDE_TASK)
    ], GodGuide.prototype, "excuteGuideTask", null);
    GodGuide = GodGuide_1 = __decorate([
        ccclass
    ], GodGuide);
    return GodGuide;
}(cc.Component));
exports.GodGuide = GodGuide;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXGd1aWRlXFxHb2RHdWlkZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBQTREO0FBQzVELHNEQUFtRTtBQUVuRSx3REFBK0M7QUFFekMsSUFBQSxLQUF3QixFQUFFLENBQUMsVUFBVSxFQUFuQyxPQUFPLGFBQUEsRUFBRSxRQUFRLGNBQWtCLENBQUM7QUFDNUMsd0NBQXdDO0FBQ3hDLGdDQUFnQztBQUVoQyw2QkFBOEI7QUFHOUI7SUFBOEIsNEJBQVk7SUFBMUM7UUFBQSxxRUFrUUM7UUFoUUcsV0FBVztRQUNVLGtCQUFZLEdBQWMsSUFBSSxDQUFBO1FBRTNDLGFBQU8sR0FBWSxJQUFJLENBQUE7UUFDdkIsV0FBSyxHQUFZLElBQUksQ0FBQTtRQUNyQixpQkFBVyxHQUFRLElBQUksQ0FBQSxDQUFBLHNCQUFzQjs7SUEyUHpELENBQUM7aUJBbFFZLFFBQVE7SUFTakIseUJBQU0sR0FBTjtRQUNJLGdCQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBRXJCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQiwwQ0FBMEM7WUFFMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtZQUNoRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFBO1lBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQTtZQUMzQixtRUFBbUU7U0FDdEU7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxF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LElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEQsNkVBQTZFO1FBQzdFLFFBQVEsRUFBRSxDQUFDO0lBQ2YsQ0FBQzs7SUE1UG9CO1FBQXBCLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDO2tEQUErQjtJQWtDbkQ7UUFEQyxxQkFBWSxDQUFDLHFCQUFTLENBQUMsaUJBQWlCLENBQUM7bURBa0J6QztJQXREUSxRQUFRO1FBRHBCLE9BQU87T0FDSyxRQUFRLENBa1FwQjtJQUFELGVBQUM7Q0FsUUQsQUFrUUMsQ0FsUTZCLEVBQUUsQ0FBQyxTQUFTLEdBa1F6QztBQWxRWSw0QkFBUSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50TmFtZSB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vY29uc3QvRXZlbnROYW1lXCI7XHJcbmltcG9ydCBFdmVudHMsIHsgcHJlbG9hZEV2ZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi91dGlsL0V2ZW50c1wiO1xyXG5pbXBvcnQgUmVzIGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbC9SZXNcIjtcclxuaW1wb3J0IGd1aWRlVGFza3MgZnJvbSBcIi4vdGFzay9HdWlkZVRhc2tJbmRleFwiO1xyXG5cclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9ID0gY2MuX2RlY29yYXRvcjtcclxuLy8gZGVjbGFyZSBsZXQgcmVxdWlyZTogKHN0cmluZykgPT4gYW55O1xyXG4vLyBsZXQgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xyXG5cclxuaW1wb3J0ICogYXMgYXN5bmMgZnJvbSAnYXN5bmMnXHJcblxyXG5AY2NjbGFzc1xyXG5leHBvcnQgY2xhc3MgR29kR3VpZGUgZXh0ZW5kcyBjYy5Db21wb25lbnQge1xyXG5cclxuICAgIC8qKuaJi+aMh+mihOWItuS7tiAqL1xyXG4gICAgQHByb3BlcnR5KGNjLlByZWZhYikgZmluZ2VyUHJlZmFiOiBjYy5QcmVmYWIgPSBudWxsXHJcblxyXG4gICAgcHJpdmF0ZSBfZmluZ2VyOiBjYy5Ob2RlID0gbnVsbFxyXG4gICAgcHJpdmF0ZSBfbWFzazogY2MuTWFzayA9IG51bGxcclxuICAgIHByaXZhdGUgX3RhcmdldE5vZGU6IGFueSA9IG51bGwvL+W8leWvvOeahOebruagh++8iOS5n+WwseaYr+imgeW8leWvvOeOqeWutuaTjeS9nOeahOebruagh++8iVxyXG5cclxuICAgIG9uTG9hZCgpIHtcclxuICAgICAgICBFdmVudHMudGFyZ2V0T24odGhpcylcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZmluZ2VyUHJlZmFiKSB7XHJcbiAgICAgICAgICAgIC8qKuiLpeimgei/m+ihjOi1hOa6kOW8leeUqOiuoeaVsOeuoeeQhiDlupTkvb/nlKhSZXPkuK3nmoRpbnN0YW50aWF0Zei/m+ihjOWKoOi9vSAqL1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZmluZ2VyID0gY2MuaW5zdGFudGlhdGUodGhpcy5maW5nZXJQcmVmYWIpXHJcbiAgICAgICAgICAgIHRoaXMuX2Zpbmdlci5wYXJlbnQgPSB0aGlzLm5vZGVcclxuICAgICAgICAgICAgdGhpcy5fZmluZ2VyLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIC8vdGhpcy5fZmluZ2VyLmdldENvbXBvbmVudChcIkd1aWRlRmluZ2VyXCIpLnN0b3BBbmltKCkgLy/miYvmjIflj6/ku6XmjILkuIDkupvliqjnlLvohJrmnKxcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5zZXRDb250ZW50U2l6ZShjYy53aW5TaXplKVxyXG4gICAgICAgIHRoaXMubm9kZS5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9TVEFSVCwgdGhpcy5hZGRTZXRTd2FsbG93VG91Y2hlc0V2ZW50TGlzdGVuZXIsIHRoaXMpXHJcblxyXG4gICAgICAgIHRoaXMuX21hc2sgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50SW5DaGlsZHJlbihjYy5NYXNrKVxyXG4gICAgICAgIHRoaXMuX21hc2subm9kZS5hY3RpdmUgPSBmYWxzZSAvL21hc2vpga7mjKHpnaLmnb/pu5jorqTkuI3lvIDlkK/vvIzlj6rmnInlnKjlvJXlr7zml7blnKjlvIDlkK9cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIEV2ZW50cy50YXJnZXRPZmYodGhpcylcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseS6i+S7tui/m+ihjOa0vuWPkeeahOW8leWvvOWkhOeQhlxyXG4gICAgICogQHBhcmFtIGRhdGEgXHJcbiAgICAgKi9cclxuICAgIEBwcmVsb2FkRXZlbnQoRXZlbnROYW1lLkVYQ1VURV9HVUlERV9UQVNLKVxyXG4gICAgZXhjdXRlR3VpZGVUYXNrKGRhdGEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIuaOpeaUtueahOW8leWvvOaVsOaNrlwiLCBkYXRhKTtcclxuICAgICAgICB0aGlzLl9tYXNrLm5vZGUuYWN0aXZlID0gdHJ1ZTsgIC8v5byV5a+85YmN5byA5ZCv6YGu5oyh6Z2i5p2/XHJcblxyXG4gICAgICAgIGxldCBmbGllID0gZ3VpZGVUYXNrc1tgJHtkYXRhfWBdXHJcbiAgICAgICAgbGV0IHRhc2sgPSBmbGllLnRhc2tcclxuXHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0Tm9kZSA9IG51bGw7IC8v5q+P5qyh5byV5a+85omn6KGM5YmN77yM6YO95bCG5LmL5YmN55qE5byV5a+855uu5qCH5riF56m6XHJcblxyXG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXModGFzay5zdGVwcywgKHN0ZXAsIGNiKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NTdGVwKHN0ZXAsIGNiKVxyXG4gICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5fZ3JhcGhpY3MuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5ub2RlLmFjdGl2ZSA9IGZhbHNlOy8v5YWz6Zet6YGu5oyh6Z2i5p2/XHJcbiAgICAgICAgICAgIHRoaXMuX2Zpbmdlci5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKirmiafooYzlvJXlr7zmraXpqqQgKi9cclxuICAgIF9wcm9jZXNzU3RlcChzdGVwLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8v6LCD55SoYXN5bmMuc2VyaWVz5p2l5omn6KGM5byV5a+855qE5q2l6aqkXHJcbiAgICAgICAgYXN5bmMuc2VyaWVzKHtcclxuICAgICAgICAgICAgc3RlcFN0YXJ0KG1hcmtvbkNiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcC5vblN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcC5vblN0YXJ0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya29uQ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya29uQ2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3RlcEV4Y3V0ZTogKG1hcmtvbkNiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcC5vbkV4Y3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAub25FeGN1dGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlT25jZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY21kID0gR29kR3VpZGVbc3RlcC5jb21tYW5kLmNtZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kKHRoaXMsIHN0ZXAsIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrb25DYihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN0ZXAuZGVsYXlUaW1lIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrb25DYigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGVwRW5kOiAobWFya29uQ2IpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGVwLm9uRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcC5vbkVuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtvbkNiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtvbkNiKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAgICAgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5aaC5p6c5a2Y5Zyo5oSP5aSW57uI5q2iIGRvU29tZXRoaW5n44CC44CC44CC44CCXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL+W8leWvvOaJp+ihjOWujOavlVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOS6i+S7tueahOWQnuayoeWkhOeQhuacuuWItlxyXG4gICAgICovXHJcbiAgICBhZGRTZXRTd2FsbG93VG91Y2hlc0V2ZW50TGlzdGVuZXIoZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21hc2subm9kZS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLl90b3VjaExpc3RlbmVyLnNldFN3YWxsb3dUb3VjaGVzKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3RhcmdldE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLl90b3VjaExpc3RlbmVyLnNldFN3YWxsb3dUb3VjaGVzKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2MuaXNWYWxpZCh0aGlzLl90YXJnZXROb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5fdGFyZ2V0Tm9kZS5nZXRCb3VuZGluZ0JveFRvV29ybGQoKTtcclxuICAgICAgICBpZiAocmVjdC5jb250YWlucyhldmVudC5nZXRMb2NhdGlvbigpKSkge1xyXG4gICAgICAgICAgICAvL+WmguaenOeOqeWutueCueWHu+S6huinhOWumueahOWMuuWfn++8jOWImeiuqeS6i+S7tuW+gOS4i+a0vuWPkVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuX3RvdWNoTGlzdGVuZXIuc2V0U3dhbGxvd1RvdWNoZXMoZmFsc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5fdG91Y2hMaXN0ZW5lci5zZXRTd2FsbG93VG91Y2hlcyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIG1vdmVmaW5nZXIoZ3VpZGVUYXNrTWdyOiBHb2RHdWlkZSwgc3RlcCwgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgcGFyYW1zID0gc3RlcC5jb21tYW5kO1xyXG4gICAgICAgIGd1aWRlVGFza01nci5fdGFyZ2V0Tm9kZSA9IG51bGw7IC8v5YWI572u56m65LmL5YmN5p+l5om+55qE55uu5qCH6IqC54K5XHJcblxyXG4gICAgICAgIC8v5byA5aeL5p+l5om+5paw55qE55uu5qCH6IqC54K5XHJcbiAgICAgICAgZ3VpZGVUYXNrTWdyLmZpbmQocGFyYW1zLmFyZ3MsIChub2RlLCByZWN0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvL+afpeaJvuWIsOS5i+WQjuW5tuS4lOiBmueEpui/h+WOu1xyXG4gICAgICAgICAgICBndWlkZVRhc2tNZ3IuZmluZ2VyVG9Ob2RlKG5vZGUsICgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBndWlkZVRhc2tNZ3IuX3RhcmdldE5vZGUgPSBub2RlOyAvL+i1i+WAvOaWsOeahOafpeaJvuWIsOeahOebruagh+iKgueCuVxyXG5cclxuICAgICAgICAgICAgICAgIG5vZGUub25jZShjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9FTkQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi54K55Ye755uu5qCH6IqC54K55oiQ5YqfXCIpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyoqKioqKioqKioqKioqKioqKuW3peWFt+mbhuWHveaVsCoqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5p+l5om+6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgXHJcbiAgICAgKiBAcGFyYW0gY2IgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluZCh2YWx1ZSwgY2I/KSB7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBjYy5maW5kKCdDYW52YXMnKTtcclxuICAgICAgICAvLyBsZXQgcm9vdCA9IHRoaXMubm9kZS5wYXJlbnRcclxuXHJcbiAgICAgICAgdGhpcy5sb2NhdGVOb2RlKHJvb3QsIHZhbHVlLCAoZXJyb3IsIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuafpeaJvuiKgueCueWksei0pVwiLCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMuX2ZvY3VzVG9Ob2RlKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5p+l5om+6IqC54K55oiQ5YqfXCIsIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgY2Iobm9kZSwgcmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIOi3r+W+hOeJueauiuWtl+espuS9v+eUqOato+WImeihqOi+vuW8j+i/m+ihjOaLhuWIhlxyXG4gICAgKiBAcGFyYW0gbG9jYXRvciDmn6Xor6LnmoTot6/lvoTphY3nva7vvIzlvaLlpoLvvJonYm90dG9tL2JhZy9iYWdDb250ZW50L2Nhc3RpbmcnLFxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgcGFyc2UobG9jYXRvcikge1xyXG4gICAgICAgIGxldCBuYW1lcyA9IGxvY2F0b3Iuc3BsaXQoL1suLC8vLD4sI10vZyk7XHJcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gbmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGxvY2F0b3IuaW5kZXhPZihuYW1lKTtcclxuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGxvY2F0b3JbaW5kZXggLSAxXSB8fCAnLyc7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN5bWJvbDogc3ltYm9sLCBuYW1lOiBuYW1lLnRyaW0oKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdtZW50cztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIOagueaNruafpeaJvui3r+W+hOWSjOagueiKgueCueWumuS9jeimgeafpeaJvueahOebruagh+iKgueCuVxyXG4gICAgKiBAcGFyYW0gcm9vdCBcclxuICAgICogQHBhcmFtIGxvY2F0b3IgXHJcbiAgICAqIEBwYXJhbSBjYiBcclxuICAgICovXHJcbiAgICBwcml2YXRlIGxvY2F0ZU5vZGUocm9vdCwgbG9jYXRvciwgY2I/KSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnRzID0gdGhpcy5wYXJzZShsb2NhdG9yKTtcclxuICAgICAgICBsZXQgY2hpbGQgPSBudWxsLCBub2RlID0gcm9vdDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0uc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcvJzpcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoaXRlbS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5hY3RpdmUgJiYgY2IpIHtcclxuICAgICAgICAgICAgY2IobnVsbCwgbm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2IobG9jYXRvcilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6IGa54Sm5Yiw55uu5qCH6IqC54K55bm257uY5Yi25Zu+5b2iXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDmn6Xmib7nmoToioLngrlcclxuICAgICAqL1xyXG4gICAgX2ZvY3VzVG9Ob2RlKG5vZGU6IGNjLk5vZGUpIHtcclxuICAgICAgICB0aGlzLl9tYXNrLl9ncmFwaGljcy5jbGVhcigpO1xyXG5cclxuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdCb3hUb1dvcmxkKCk7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLm5vZGUuY29udmVydFRvTm9kZVNwYWNlQVIocmVjdC5vcmlnaW4pO1xyXG4gICAgICAgIHJlY3QueCA9IHAueDtcclxuICAgICAgICByZWN0LnkgPSBwLnk7XHJcbiAgICAgICAgdGhpcy5fbWFzay5fZ3JhcGhpY3MuZmlsbFJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vliqjmiYvmjIfliLDnm67moIfoioLngrlcclxuICAgICAqIEBwYXJhbSBub2RlIFxyXG4gICAgICogQHBhcmFtIG1hcmtvbkNiIFxyXG4gICAgICovXHJcbiAgICBmaW5nZXJUb05vZGUobm9kZSwgbWFya29uQ2IpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Zpbmdlcikge1xyXG4gICAgICAgICAgICBtYXJrb25DYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9maW5nZXIuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9maW5nZXIuc3RvcEFsbEFjdGlvbnMoKTtcclxuICAgICAgICBsZXQgcCA9IHRoaXMubm9kZS5jb252ZXJ0VG9Ob2RlU3BhY2VBUihub2RlLnBhcmVudC5jb252ZXJ0VG9Xb3JsZFNwYWNlQVIobm9kZS5wb3NpdGlvbikpO1xyXG4gICAgICAgIHRoaXMuX2Zpbmdlci5zZXRQb3NpdGlvbihjYy52MyhwLnggKyAxMDAsIHAueSkpO1xyXG4gICAgICAgIC8vdGhpcy5fZmluZ2VyLmdldENvbXBvbmVudChcIkd1aWRlRmluZ2VyXCIpLnBsYXlBbmltKCk7IC8v5omL5oyH5Y+v5Lul5oyC5LiA5Lqb5Yqo55S76ISa5pys77yM55So5p2l5o6n5Yi25Yqo55S75pKt5pS+XHJcbiAgICAgICAgbWFya29uQ2IoKTtcclxuICAgIH1cclxuXHJcblxyXG59Il19
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/async/dist/async.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.async = {})));
}(this, (function (exports) { 'use strict';

    /**
     * Creates a continuation function with some arguments already applied.
     *
     * Useful as a shorthand when combined with other control flow functions. Any
     * arguments passed to the returned function are added to the arguments
     * originally passed to apply.
     *
     * @name apply
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {Function} fn - The function you want to eventually apply all
     * arguments to. Invokes with (arguments...).
     * @param {...*} arguments... - Any number of arguments to automatically apply
     * when the continuation is called.
     * @returns {Function} the partially-applied function
     * @example
     *
     * // using apply
     * async.parallel([
     *     async.apply(fs.writeFile, 'testfile1', 'test1'),
     *     async.apply(fs.writeFile, 'testfile2', 'test2')
     * ]);
     *
     *
     * // the same process without using apply
     * async.parallel([
     *     function(callback) {
     *         fs.writeFile('testfile1', 'test1', callback);
     *     },
     *     function(callback) {
     *         fs.writeFile('testfile2', 'test2', callback);
     *     }
     * ]);
     *
     * // It's possible to pass any number of additional arguments when calling the
     * // continuation:
     *
     * node> var fn = async.apply(sys.puts, 'one');
     * node> fn('two', 'three');
     * one
     * two
     * three
     */
    function apply(fn, ...args) {
        return (...callArgs) => fn(...args,...callArgs);
    }

    function initialParams (fn) {
        return function (...args/*, callback*/) {
            var callback = args.pop();
            return fn.call(this, args, callback);
        };
    }

    /* istanbul ignore file */

    var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
    var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

    function fallback(fn) {
        setTimeout(fn, 0);
    }

    function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
    }

    var _defer;

    if (hasSetImmediate) {
        _defer = setImmediate;
    } else if (hasNextTick) {
        _defer = process.nextTick;
    } else {
        _defer = fallback;
    }

    var setImmediate$1 = wrap(_defer);

    /**
     * Take a sync function and make it async, passing its return value to a
     * callback. This is useful for plugging sync functions into a waterfall,
     * series, or other async functions. Any arguments passed to the generated
     * function will be passed to the wrapped function (except for the final
     * callback argument). Errors thrown will be passed to the callback.
     *
     * If the function passed to `asyncify` returns a Promise, that promises's
     * resolved/rejected state will be used to call the callback, rather than simply
     * the synchronous return value.
     *
     * This also means you can asyncify ES2017 `async` functions.
     *
     * @name asyncify
     * @static
     * @memberOf module:Utils
     * @method
     * @alias wrapSync
     * @category Util
     * @param {Function} func - The synchronous function, or Promise-returning
     * function to convert to an {@link AsyncFunction}.
     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
     * invoked with `(args..., callback)`.
     * @example
     *
     * // passing a regular synchronous function
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(JSON.parse),
     *     function (data, next) {
     *         // data is the result of parsing the text.
     *         // If there was a parsing error, it would have been caught.
     *     }
     * ], callback);
     *
     * // passing a function returning a promise
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(function (contents) {
     *         return db.model.create(contents);
     *     }),
     *     function (model, next) {
     *         // `model` is the instantiated model object.
     *         // If there was an error, this function would be skipped.
     *     }
     * ], callback);
     *
     * // es2017 example, though `asyncify` is not needed if your JS environment
     * // supports async functions out of the box
     * var q = async.queue(async.asyncify(async function(file) {
     *     var intermediateStep = await processFile(file);
     *     return await somePromise(intermediateStep)
     * }));
     *
     * q.push(files);
     */
    function asyncify(func) {
        if (isAsync(func)) {
            return function (...args/*, callback*/) {
                const callback = args.pop();
                const promise = func.apply(this, args);
                return handlePromise(promise, callback)
            }
        }

        return initialParams(function (args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (result && typeof result.then === 'function') {
                return handlePromise(result, callback)
            } else {
                callback(null, result);
            }
        });
    }

    function handlePromise(promise, callback) {
        return promise.then(value => {
            invokeCallback(callback, null, value);
        }, err => {
            invokeCallback(callback, err && err.message ? err : new Error(err));
        });
    }

    function invokeCallback(callback, error, value) {
        try {
            callback(error, value);
        } catch (err) {
            setImmediate$1(e => { throw e }, err);
        }
    }

    function isAsync(fn) {
        return fn[Symbol.toStringTag] === 'AsyncFunction';
    }

    function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === 'AsyncGenerator';
    }

    function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === 'function';
    }

    function wrapAsync(asyncFn) {
        if (typeof asyncFn !== 'function') throw new Error('expected a function')
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }

    // conditionally promisify a function.
    // only return a promise if a callback is omitted
    function awaitify (asyncFn, arity = asyncFn.length) {
        if (!arity) throw new Error('arity is undefined')
        function awaitable (...args) {
            if (typeof args[arity - 1] === 'function') {
                return asyncFn.apply(this, args)
            }

            return new Promise((resolve, reject) => {
                args[arity - 1] = (err, ...cbArgs) => {
                    if (err) return reject(err)
                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
                };
                asyncFn.apply(this, args);
            })
        }

        Object.defineProperty(awaitable, 'name', {
            value: `awaitable(${asyncFn.name})`
        });

        return awaitable
    }

    function applyEach (eachfn) {
        return function applyEach(fns, ...callArgs) {
            const go = awaitify(function (callback) {
                var that = this;
                return eachfn(fns, (fn, cb) => {
                    wrapAsync(fn).apply(that, callArgs.concat(cb));
                }, callback);
            });
            return go;
        };
    }

    function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);

        return eachfn(arr, (value, _, iterCb) => {
            var index = counter++;
            _iteratee(value, (err, v) => {
                results[index] = v;
                iterCb(err);
            });
        }, err => {
            callback(err, results);
        });
    }

    function isArrayLike(value) {
        return value &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            value.length % 1 === 0;
    }

    // A temporary value used to identify if the loop should be broken.
    // See #1064, #1293
    const breakLoop = {};

    function once(fn) {
        function wrapper (...args) {
            if (fn === null) return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper
    }

    function getIterator (coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }

    function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
            return ++i < len ? {value: coll[i], key: i} : null;
        }
    }

    function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
            var item = iterator.next();
            if (item.done)
                return null;
            i++;
            return {value: item.value, key: i};
        }
    }

    function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
            var key = okeys[++i];
            return i < len ? {value: obj[key], key} : null;
        };
    }

    function createIterator(coll) {
        if (isArrayLike(coll)) {
            return createArrayIterator(coll);
        }

        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }

    function onlyOnce(fn) {
        return function (...args) {
            if (fn === null) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        };
    }

    // for async generators
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;

        function replenish() {
            //console.log('replenish')
            if (running >= limit || awaiting || done) return
            //console.log('replenish awaiting')
            awaiting = true;
            generator.next().then(({value, done: iterDone}) => {
                //console.log('got value', value)
                if (canceled || done) return
                awaiting = false;
                if (iterDone) {
                    done = true;
                    if (running <= 0) {
                        //console.log('done nextCb')
                        callback(null);
                    }
                    return;
                }
                running++;
                iteratee(value, idx, iterateeCallback);
                idx++;
                replenish();
            }).catch(handleError);
        }

        function iterateeCallback(err, result) {
            //console.log('iterateeCallback')
            running -= 1;
            if (canceled) return
            if (err) return handleError(err)

            if (err === false) {
                done = true;
                canceled = true;
                return
            }

            if (result === breakLoop || (done && running <= 0)) {
                done = true;
                //console.log('done iterCb')
                return callback(null);
            }
            replenish();
        }

        function handleError(err) {
            if (canceled) return
            awaiting = false;
            done = true;
            callback(err);
        }

        replenish();
    }

    var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
            callback = once(callback);
            if (limit <= 0) {
                throw new RangeError('concurrency limit cannot be less than 1')
            }
            if (!obj) {
                return callback(null);
            }
            if (isAsyncGenerator(obj)) {
                return asyncEachOfLimit(obj, limit, iteratee, callback)
            }
            if (isAsyncIterable(obj)) {
                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
            }
            var nextElem = createIterator(obj);
            var done = false;
            var canceled = false;
            var running = 0;
            var looping = false;

            function iterateeCallback(err, value) {
                if (canceled) return
                running -= 1;
                if (err) {
                    done = true;
                    callback(err);
                }
                else if (err === false) {
                    done = true;
                    canceled = true;
                }
                else if (value === breakLoop || (done && running <= 0)) {
                    done = true;
                    return callback(null);
                }
                else if (!looping) {
                    replenish();
                }
            }

            function replenish () {
                looping = true;
                while (running < limit && !done) {
                    var elem = nextElem();
                    if (elem === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
                looping = false;
            }

            replenish();
        };
    };

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name eachOfLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`. The `key` is the item's key, or index in the case of an
     * array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }

    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);

    // eachOf implementation optimized for array-likes
    function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index = 0,
            completed = 0,
            {length} = coll,
            canceled = false;
        if (length === 0) {
            callback(null);
        }

        function iteratorCallback(err, value) {
            if (err === false) {
                canceled = true;
            }
            if (canceled === true) return
            if (err) {
                callback(err);
            } else if ((++completed === length) || value === breakLoop) {
                callback(null);
            }
        }

        for (; index < length; index++) {
            iteratee(coll[index], index, onlyOnce(iteratorCallback));
        }
    }

    // a generic version of eachOf which can handle array, object, and iterator cases.
    function eachOfGeneric (coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
    }

    /**
     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
     * to the iteratee.
     *
     * @name eachOf
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEachOf
     * @category Collection
     * @see [async.each]{@link module:Collections.each}
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each
     * item in `coll`.
     * The `key` is the item's key, or index in the case of an array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
     * var configs = {};
     *
     * async.forEachOf(obj, function (value, key, callback) {
     *     fs.readFile(__dirname + value, "utf8", function (err, data) {
     *         if (err) return callback(err);
     *         try {
     *             configs[key] = JSON.parse(data);
     *         } catch (e) {
     *             return callback(e);
     *         }
     *         callback();
     *     });
     * }, function (err) {
     *     if (err) console.error(err.message);
     *     // configs is now a map of JSON data
     *     doSomethingWith(configs);
     * });
     */
    function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }

    var eachOf$1 = awaitify(eachOf, 3);

    /**
     * Produces a new collection of values by mapping each value in `coll` through
     * the `iteratee` function. The `iteratee` is called with an item from `coll`
     * and a callback for when it has finished processing. Each of these callback
     * takes 2 arguments: an `error`, and the transformed item from `coll`. If
     * `iteratee` passes an error to its callback, the main `callback` (for the
     * `map` function) is immediately called with the error.
     *
     * Note, that since this function applies the `iteratee` to each item in
     * parallel, there is no guarantee that the `iteratee` functions will complete
     * in order. However, the results array will be in the same order as the
     * original `coll`.
     *
     * If `map` is passed an Object, the results will be an Array.  The results
     * will roughly be in the order of the original Objects' keys (but this can
     * vary across JavaScript engines).
     *
     * @name map
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an Array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
     *     // results is now an array of stats for each file
     * });
     */
    function map (coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback)
    }
    var map$1 = awaitify(map, 3);

    /**
     * Applies the provided arguments to each function in the array, calling
     * `callback` after all functions have completed. If you only provide the first
     * argument, `fns`, then it will return a function which lets you pass in the
     * arguments as if it were a single function call. If more arguments are
     * provided, `callback` is required while `args` is still optional. The results
     * for each of the applied async functions are passed to the final callback
     * as an array.
     *
     * @name applyEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
     * to all call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - Returns a function that takes no args other than
     * an optional callback, that is the result of applying the `args` to each
     * of the functions.
     * @example
     *
     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
     *
     * appliedFn((err, results) => {
     *     // results[0] is the results for `enableSearch`
     *     // results[1] is the results for `updateSchema`
     * });
     *
     * // partial application example:
     * async.each(
     *     buckets,
     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
     *     callback
     * );
     */
    var applyEach$1 = applyEach(map$1);

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
     *
     * @name eachOfSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback)
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);

    /**
     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
     *
     * @name mapSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapSeries (coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
    }
    var mapSeries$1 = awaitify(mapSeries, 3);

    /**
     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
     *
     * @name applyEachSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.applyEach]{@link module:ControlFlow.applyEach}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
     * call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - A function, that when called, is the result of
     * appling the `args` to the list of functions.  It takes no args, other than
     * a callback.
     */
    var applyEachSeries = applyEach(mapSeries$1);

    const PROMISE_SYMBOL = Symbol('promiseCallback');

    function promiseCallback () {
        let resolve, reject;
        function callback (err, ...args) {
            if (err) return reject(err)
            resolve(args.length > 1 ? args : args[0]);
        }

        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
            resolve = res,
            reject = rej;
        });

        return callback
    }

    /**
     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
     * their requirements. Each function can optionally depend on other functions
     * being completed first, and each function is run as soon as its requirements
     * are satisfied.
     *
     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
     * will stop. Further tasks will not execute (so any other functions depending
     * on it will not run), and the main `callback` is immediately called with the
     * error.
     *
     * {@link AsyncFunction}s also receive an object containing the results of functions which
     * have completed so far as the first argument, if they have dependencies. If a
     * task function has no dependencies, it will only be passed a callback.
     *
     * @name auto
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Object} tasks - An object. Each of its properties is either a
     * function or an array of requirements, with the {@link AsyncFunction} itself the last item
     * in the array. The object's key of a property serves as the name of the task
     * defined by that property, i.e. can be used when specifying requirements for
     * other tasks. The function receives one or two arguments:
     * * a `results` object, containing the results of the previously executed
     *   functions, only passed if the task has any dependencies,
     * * a `callback(err, result)` function, which must be called when finished,
     *   passing an `error` (which can be `null`) and the result of the function's
     *   execution.
     * @param {number} [concurrency=Infinity] - An optional `integer` for
     * determining the maximum number of tasks that can be run in parallel. By
     * default, as many as possible.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback. Results are always returned; however, if an
     * error occurs, no further `tasks` will be performed, and the results object
     * will only contain partial results. Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     * @example
     *
     * async.auto({
     *     // this function will just be passed a callback
     *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
     *     showData: ['readData', function(results, cb) {
     *         // results.readData is the file's contents
     *         // ...
     *     }]
     * }, callback);
     *
     * async.auto({
     *     get_data: function(callback) {
     *         console.log('in get_data');
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         console.log('in make_folder');
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         console.log('in write_file', JSON.stringify(results));
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         console.log('in email_link', JSON.stringify(results));
     *         // once the file is written let's email a link to it...
     *         // results.write_file contains the filename returned by write_file.
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('results = ', results);
     * });
     */
    function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== 'number') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = numTasks;
        }

        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;

        var listeners = Object.create(null);

        var readyTasks = [];

        // for cycle detection:
        var readyToCheck = []; // tasks that have been identified as reachable
        // without the possibility of returning to an ancestor task
        var uncheckedDependencies = {};

        Object.keys(tasks).forEach(key => {
            var task = tasks[key];
            if (!Array.isArray(task)) {
                // no dependencies
                enqueueTask(key, [task]);
                readyToCheck.push(key);
                return;
            }

            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
                enqueueTask(key, task);
                readyToCheck.push(key);
                return;
            }
            uncheckedDependencies[key] = remainingDependencies;

            dependencies.forEach(dependencyName => {
                if (!tasks[dependencyName]) {
                    throw new Error('async.auto task `' + key +
                        '` has a non-existent dependency `' +
                        dependencyName + '` in ' +
                        dependencies.join(', '));
                }
                addListener(dependencyName, () => {
                    remainingDependencies--;
                    if (remainingDependencies === 0) {
                        enqueueTask(key, task);
                    }
                });
            });
        });

        checkForDeadlocks();
        processQueue();

        function enqueueTask(key, task) {
            readyTasks.push(() => runTask(key, task));
        }

        function processQueue() {
            if (canceled) return
            if (readyTasks.length === 0 && runningTasks === 0) {
                return callback(null, results);
            }
            while(readyTasks.length && runningTasks < concurrency) {
                var run = readyTasks.shift();
                run();
            }

        }

        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
                taskListeners = listeners[taskName] = [];
            }

            taskListeners.push(fn);
        }

        function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            taskListeners.forEach(fn => fn());
            processQueue();
        }


        function runTask(key, task) {
            if (hasError) return;

            var taskCallback = onlyOnce((err, ...result) => {
                runningTasks--;
                if (err === false) {
                    canceled = true;
                    return
                }
                if (result.length < 2) {
                    [result] = result;
                }
                if (err) {
                    var safeResults = {};
                    Object.keys(results).forEach(rkey => {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[key] = result;
                    hasError = true;
                    listeners = Object.create(null);
                    if (canceled) return
                    callback(err, safeResults);
                } else {
                    results[key] = result;
                    taskComplete(key);
                }
            });

            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
                taskFn(results, taskCallback);
            } else {
                taskFn(taskCallback);
            }
        }

        function checkForDeadlocks() {
            // Kahn's algorithm
            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
                currentTask = readyToCheck.pop();
                counter++;
                getDependents(currentTask).forEach(dependent => {
                    if (--uncheckedDependencies[dependent] === 0) {
                        readyToCheck.push(dependent);
                    }
                });
            }

            if (counter !== numTasks) {
                throw new Error(
                    'async.auto cannot execute tasks due to a recursive dependency'
                );
            }
        }

        function getDependents(taskName) {
            var result = [];
            Object.keys(tasks).forEach(key => {
                const task = tasks[key];
                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                    result.push(key);
                }
            });
            return result;
        }

        return callback[PROMISE_SYMBOL]
    }

    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

    function parseParams(func) {
        const src = func.toString().replace(STRIP_COMMENTS, '');
        let match = src.match(FN_ARGS);
        if (!match) {
            match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
        let [, args] = match;
        return args
            .replace(/\s/g, '')
            .split(FN_ARG_SPLIT)
            .map((arg) => arg.replace(FN_ARG, '').trim());
    }

    /**
     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
     * tasks are specified as parameters to the function, after the usual callback
     * parameter, with the parameter names matching the names of the tasks it
     * depends on. This can provide even more readable task graphs which can be
     * easier to maintain.
     *
     * If a final callback is specified, the task results are similarly injected,
     * specified as named parameters after the initial error parameter.
     *
     * The autoInject function is purely syntactic sugar and its semantics are
     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
     *
     * @name autoInject
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.auto]{@link module:ControlFlow.auto}
     * @category Control Flow
     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
     * the form 'func([dependencies...], callback). The object's key of a property
     * serves as the name of the task defined by that property, i.e. can be used
     * when specifying requirements for other tasks.
     * * The `callback` parameter is a `callback(err, result)` which must be called
     *   when finished, passing an `error` (which can be `null`) and the result of
     *   the function's execution. The remaining parameters name other tasks on
     *   which the task is dependent, and the results from those tasks are the
     *   arguments of those parameters.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback, and a `results` object with any completed
     * task results, similar to `auto`.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * //  The example from `auto` can be rewritten as follows:
     * async.autoInject({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: function(get_data, make_folder, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     },
     *     email_link: function(write_file, callback) {
     *         // once the file is written let's email a link to it...
     *         // write_file contains the filename returned by write_file.
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     *
     * // If you are using a JS minifier that mangles parameter names, `autoInject`
     * // will not work with plain functions, since the parameter names will be
     * // collapsed to a single letter identifier.  To work around this, you can
     * // explicitly specify the names of the parameters your task function needs
     * // in an array, similar to Angular.js dependency injection.
     *
     * // This still has an advantage over plain `auto`, since the results a task
     * // depends on are still spread into arguments.
     * async.autoInject({
     *     //...
     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(write_file, callback) {
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }]
     *     //...
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     */
    function autoInject(tasks, callback) {
        var newTasks = {};

        Object.keys(tasks).forEach(key => {
            var taskFn = tasks[key];
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps =
                (!fnIsAsync && taskFn.length === 1) ||
                (fnIsAsync && taskFn.length === 0);

            if (Array.isArray(taskFn)) {
                params = [...taskFn];
                taskFn = params.pop();

                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
                // no dependencies, use the function as-is
                newTasks[key] = taskFn;
            } else {
                params = parseParams(taskFn);
                if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                    throw new Error("autoInject task functions require explicit parameters.");
                }

                // remove callback param
                if (!fnIsAsync) params.pop();

                newTasks[key] = params.concat(newTask);
            }

            function newTask(results, taskCb) {
                var newArgs = params.map(name => results[name]);
                newArgs.push(taskCb);
                wrapAsync(taskFn)(...newArgs);
            }
        });

        return auto(newTasks, callback);
    }

    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
    // used for queues. This implementation assumes that the node provided by the user can be modified
    // to adjust the next and last properties. We implement only the minimal functionality
    // for queue support.
    class DLL {
        constructor() {
            this.head = this.tail = null;
            this.length = 0;
        }

        removeLink(node) {
            if (node.prev) node.prev.next = node.next;
            else this.head = node.next;
            if (node.next) node.next.prev = node.prev;
            else this.tail = node.prev;

            node.prev = node.next = null;
            this.length -= 1;
            return node;
        }

        empty () {
            while(this.head) this.shift();
            return this;
        }

        insertAfter(node, newNode) {
            newNode.prev = node;
            newNode.next = node.next;
            if (node.next) node.next.prev = newNode;
            else this.tail = newNode;
            node.next = newNode;
            this.length += 1;
        }

        insertBefore(node, newNode) {
            newNode.prev = node.prev;
            newNode.next = node;
            if (node.prev) node.prev.next = newNode;
            else this.head = newNode;
            node.prev = newNode;
            this.length += 1;
        }

        unshift(node) {
            if (this.head) this.insertBefore(this.head, node);
            else setInitial(this, node);
        }

        push(node) {
            if (this.tail) this.insertAfter(this.tail, node);
            else setInitial(this, node);
        }

        shift() {
            return this.head && this.removeLink(this.head);
        }

        pop() {
            return this.tail && this.removeLink(this.tail);
        }

        toArray() {
            return [...this]
        }

        *[Symbol.iterator] () {
            var cur = this.head;
            while (cur) {
                yield cur.data;
                cur = cur.next;
            }
        }

        remove (testFn) {
            var curr = this.head;
            while(curr) {
                var {next} = curr;
                if (testFn(curr)) {
                    this.removeLink(curr);
                }
                curr = next;
            }
            return this;
        }
    }

    function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
    }

    function queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new RangeError('Concurrency must not be zero');
        }

        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
            error: [],
            drain: [],
            saturated: [],
            unsaturated: [],
            empty: []
        };

        function on (event, handler) {
            events[event].push(handler);
        }

        function once (event, handler) {
            const handleAndRemove = (...args) => {
                off(event, handleAndRemove);
                handler(...args);
            };
            events[event].push(handleAndRemove);
        }

        function off (event, handler) {
            if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
            if (!handler) return events[event] = []
            events[event] = events[event].filter(ev => ev !== handler);
        }

        function trigger (event, ...args) {
            events[event].forEach(handler => handler(...args));
        }

        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
            if (callback != null && typeof callback !== 'function') {
                throw new Error('task callback must be a function');
            }
            q.started = true;

            var res, rej;
            function promiseCallback (err, ...args) {
                // we don't care about the error, let the global error handler
                // deal with it
                if (err) return rejectOnError ? rej(err) : res()
                if (args.length <= 1) return res(args[0])
                res(args);
            }

            var item = {
                data,
                callback: rejectOnError ?
                    promiseCallback :
                    (callback || promiseCallback)
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }

            if (!processingScheduled) {
                processingScheduled = true;
                setImmediate$1(() => {
                    processingScheduled = false;
                    q.process();
                });
            }

            if (rejectOnError || !callback) {
                return new Promise((resolve, reject) => {
                    res = resolve;
                    rej = reject;
                })
            }
        }

        function _createCB(tasks) {
            return function (err, ...args) {
                numRunning -= 1;

                for (var i = 0, l = tasks.length; i < l; i++) {
                    var task = tasks[i];

                    var index = workersList.indexOf(task);
                    if (index === 0) {
                        workersList.shift();
                    } else if (index > 0) {
                        workersList.splice(index, 1);
                    }

                    task.callback(err, ...args);

                    if (err != null) {
                        trigger('error', err, task.data);
                    }
                }

                if (numRunning <= (q.concurrency - q.buffer) ) {
                    trigger('unsaturated');
                }

                if (q.idle()) {
                    trigger('drain');
                }
                q.process();
            };
        }

        function _maybeDrain(data) {
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                setImmediate$1(() => trigger('drain'));
                return true
            }
            return false
        }

        const eventMethod = (name) => (handler) => {
            if (!handler) {
                return new Promise((resolve, reject) => {
                    once(name, (err, data) => {
                        if (err) return reject(err)
                        resolve(data);
                    });
                })
            }
            off(name);
            on(name, handler);

        };

        var isProcessing = false;
        var q = {
            _tasks: new DLL(),
            *[Symbol.iterator] () {
                yield* q._tasks[Symbol.iterator]();
            },
            concurrency,
            payload,
            buffer: concurrency / 4,
            started: false,
            paused: false,
            push (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, false, callback))
                }
                return _insert(data, false, false, callback);
            },
            pushAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, true, callback))
                }
                return _insert(data, false, true, callback);
            },
            kill () {
                off();
                q._tasks.empty();
            },
            unshift (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, false, callback))
                }
                return _insert(data, true, false, callback);
            },
            unshiftAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, true, callback))
                }
                return _insert(data, true, true, callback);
            },
            remove (testFn) {
                q._tasks.remove(testFn);
            },
            process () {
                // Avoid trying to start too many processing operations. This can occur
                // when callbacks resolve synchronously (#1267).
                if (isProcessing) {
                    return;
                }
                isProcessing = true;
                while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                    var tasks = [], data = [];
                    var l = q._tasks.length;
                    if (q.payload) l = Math.min(l, q.payload);
                    for (var i = 0; i < l; i++) {
                        var node = q._tasks.shift();
                        tasks.push(node);
                        workersList.push(node);
                        data.push(node.data);
                    }

                    numRunning += 1;

                    if (q._tasks.length === 0) {
                        trigger('empty');
                    }

                    if (numRunning === q.concurrency) {
                        trigger('saturated');
                    }

                    var cb = onlyOnce(_createCB(tasks));
                    _worker(data, cb);
                }
                isProcessing = false;
            },
            length () {
                return q._tasks.length;
            },
            running () {
                return numRunning;
            },
            workersList () {
                return workersList;
            },
            idle() {
                return q._tasks.length + numRunning === 0;
            },
            pause () {
                q.paused = true;
            },
            resume () {
                if (q.paused === false) { return; }
                q.paused = false;
                setImmediate$1(q.process);
            }
        };
        // define these as fixed properties, so people get useful errors when updating
        Object.defineProperties(q, {
            saturated: {
                writable: false,
                value: eventMethod('saturated')
            },
            unsaturated: {
                writable: false,
                value: eventMethod('unsaturated')
            },
            empty: {
                writable: false,
                value: eventMethod('empty')
            },
            drain: {
                writable: false,
                value: eventMethod('drain')
            },
            error: {
                writable: false,
                value: eventMethod('error')
            },
        });
        return q;
    }

    /**
     * Creates a `cargo` object with the specified payload. Tasks added to the
     * cargo will be processed altogether (up to the `payload` limit). If the
     * `worker` is in progress, the task is queued until it becomes available. Once
     * the `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, cargo passes an array of tasks to a single worker, repeating
     * when the worker is finished.
     *
     * @name cargo
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargo and inner queue.
     * @example
     *
     * // create a cargo object with payload 2
     * var cargo = async.cargo(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2);
     *
     * // add some items
     * cargo.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargo.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * await cargo.push({name: 'baz'});
     * console.log('finished processing baz');
     */
    function cargo(worker, payload) {
        return queue(worker, 1, payload);
    }

    /**
     * Creates a `cargoQueue` object with the specified payload. Tasks added to the
     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
     * If the all `workers` are in progress, the task is queued until one becomes available. Once
     * a `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
     * the cargoQueue passes an array of tasks to multiple parallel workers.
     *
     * @name cargoQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @see [async.cargo]{@link module:ControlFLow.cargo}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.CargoObject} A cargoQueue object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargoQueue and inner queue.
     * @example
     *
     * // create a cargoQueue object with payload 2 and concurrency 2
     * var cargoQueue = async.cargoQueue(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2, 2);
     *
     * // add some items
     * cargoQueue.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargoQueue.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * cargoQueue.push({name: 'baz'}, function(err) {
     *     console.log('finished processing baz');
     * });
     * cargoQueue.push({name: 'boo'}, function(err) {
     *     console.log('finished processing boo');
     * });
     */
    function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
    }

    /**
     * Reduces `coll` into a single value using an async `iteratee` to return each
     * successive step. `memo` is the initial state of the reduction. This function
     * only operates in series.
     *
     * For performance reasons, it may make sense to split a call to this function
     * into a parallel map, and then use the normal `Array.prototype.reduce` on the
     * results. This function is for situations where each step in the reduction
     * needs to be async; if you can get the data before reducing it, then it's
     * probably a good idea to do so.
     *
     * @name reduce
     * @static
     * @memberOf module:Collections
     * @method
     * @alias inject
     * @alias foldl
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee complete with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * async.reduce([1,2,3], 0, function(memo, item, callback) {
     *     // pointless async:
     *     process.nextTick(function() {
     *         callback(null, memo + item)
     *     });
     * }, function(err, result) {
     *     // result is now equal to the last value of memo, which is 6
     * });
     */
    function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
            _iteratee(memo, x, (err, v) => {
                memo = v;
                iterCb(err);
            });
        }, err => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);

    /**
     * Version of the compose function that is more natural to read. Each function
     * consumes the return value of the previous function. It is the equivalent of
     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name seq
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.compose]{@link module:ControlFlow.compose}
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} a function that composes the `functions` in order
     * @example
     *
     * // Requires lodash (or underscore), express3 and dresende's orm2.
     * // Part of an app, that fetches cats of the logged user.
     * // This example uses `seq` function to avoid overnesting and error
     * // handling clutter.
     * app.get('/cats', function(request, response) {
     *     var User = request.models.User;
     *     async.seq(
     *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
     *         function(user, fn) {
     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
     *         }
     *     )(req.session.user_id, function (err, cats) {
     *         if (err) {
     *             console.error(err);
     *             response.json({ status: 'error', message: err.message });
     *         } else {
     *             response.json({ status: 'ok', message: 'Cats found', data: cats });
     *         }
     *     });
     * });
     */
    function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function (...args) {
            var that = this;

            var cb = args[args.length - 1];
            if (typeof cb == 'function') {
                args.pop();
            } else {
                cb = promiseCallback();
            }

            reduce$1(_functions, args, (newargs, fn, iterCb) => {
                fn.apply(that, newargs.concat((err, ...nextargs) => {
                    iterCb(err, nextargs);
                }));
            },
            (err, results) => cb(err, ...results));

            return cb[PROMISE_SYMBOL]
        };
    }

    /**
     * Creates a function which is a composition of the passed asynchronous
     * functions. Each function consumes the return value of the function that
     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
     *
     * If the last argument to the composed function is not a function, a promise
     * is returned when you call it.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name compose
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} an asynchronous function that is the composed
     * asynchronous `functions`
     * @example
     *
     * function add1(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n + 1);
     *     }, 10);
     * }
     *
     * function mul3(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n * 3);
     *     }, 10);
     * }
     *
     * var add1mul3 = async.compose(mul3, add1);
     * add1mul3(4, function (err, result) {
     *     // result now equals 15
     * });
     */
    function compose(...args) {
        return seq(...args.reverse());
    }

    /**
     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
     *
     * @name mapLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapLimit (coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)
    }
    var mapLimit$1 = awaitify(mapLimit, 4);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
     *
     * @name concatLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapLimit
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, ...args) => {
                if (err) return iterCb(err);
                return iterCb(err, args);
            });
        }, (err, mapResults) => {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    result = result.concat(...mapResults[i]);
                }
            }

            return callback(err, result);
        });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);

    /**
     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
     * the concatenated list. The `iteratee`s are called in parallel, and the
     * results are concatenated as they return. The results array will be returned in
     * the original order of `coll` passed to the `iteratee` function.
     *
     * @name concat
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @alias flatMap
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
     *     // files is now a list of filenames that exist in the 3 directories
     * });
     */
    function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback)
    }
    var concat$1 = awaitify(concat, 3);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
     *
     * @name concatSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapSeries
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
     * The iteratee should complete with an array an array of results.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback)
    }
    var concatSeries$1 = awaitify(concatSeries, 3);

    /**
     * Returns a function that when called, calls-back with the values provided.
     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
     * [`auto`]{@link module:ControlFlow.auto}.
     *
     * @name constant
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {...*} arguments... - Any number of arguments to automatically invoke
     * callback with.
     * @returns {AsyncFunction} Returns a function that when invoked, automatically
     * invokes the callback with the previous given arguments.
     * @example
     *
     * async.waterfall([
     *     async.constant(42),
     *     function (value, next) {
     *         // value === 42
     *     },
     *     //...
     * ], callback);
     *
     * async.waterfall([
     *     async.constant(filename, "utf8"),
     *     fs.readFile,
     *     function (fileData, next) {
     *         //...
     *     }
     *     //...
     * ], callback);
     *
     * async.auto({
     *     hostname: async.constant("https://server.net/"),
     *     port: findFreePort,
     *     launchServer: ["hostname", "port", function (options, cb) {
     *         startServer(options, cb);
     *     }],
     *     //...
     * }, callback);
     */
    function constant(...args) {
        return function (...ignoredArgs/*, callback*/) {
            var callback = ignoredArgs.pop();
            return callback(null, ...args);
        };
    }

    function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
            var testPassed = false;
            var testResult;
            const iteratee = wrapAsync(_iteratee);
            eachfn(arr, (value, _, callback) => {
                iteratee(value, (err, result) => {
                    if (err || err === false) return callback(err);

                    if (check(result) && !testResult) {
                        testPassed = true;
                        testResult = getResult(true, value);
                        return callback(null, breakLoop);
                    }
                    callback();
                });
            }, err => {
                if (err) return cb(err);
                cb(null, testPassed ? testResult : getResult(false));
            });
        };
    }

    /**
     * Returns the first value in `coll` that passes an async truth test. The
     * `iteratee` is applied in parallel, meaning the first iteratee to return
     * `true` will fire the detect `callback` with that result. That means the
     * result might not be the first item in the original `coll` (in terms of order)
     * that passes the test.

     * If order within the original `coll` is important, then look at
     * [`detectSeries`]{@link module:Collections.detectSeries}.
     *
     * @name detect
     * @static
     * @memberOf module:Collections
     * @method
     * @alias find
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * async.detect(['file1','file2','file3'], function(filePath, callback) {
     *     fs.access(filePath, function(err) {
     *         callback(null, !err)
     *     });
     * }, function(err, result) {
     *     // result now equals the first file in the list that exists
     * });
     */
    function detect(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
    }
    var detect$1 = awaitify(detect, 3);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name detectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findLimit
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns a Promise if no callback is passed
     */
    function detectLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var detectLimit$1 = awaitify(detectLimit, 4);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
     *
     * @name detectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findSeries
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns a Promise if no callback is passed
     */
    function detectSeries(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)
    }

    var detectSeries$1 = awaitify(detectSeries, 3);

    function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    resultArgs.forEach(x => console[name](x));
                }
            }
        })
    }

    /**
     * Logs the result of an [`async` function]{@link AsyncFunction} to the
     * `console` using `console.dir` to display the properties of the resulting object.
     * Only works in Node.js or in browsers that support `console.dir` and
     * `console.error` (such as FF and Chrome).
     * If multiple arguments are returned from the async function,
     * `console.dir` is called on each argument in order.
     *
     * @name dir
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, {hello: name});
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.dir(hello, 'world');
     * {hello: 'world'}
     */
    var dir = consoleFunc('dir');

    /**
     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
     * the order of operations, the arguments `test` and `iteratee` are switched.
     *
     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
     *
     * @name doWhilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - A function which is called each time `test`
     * passes. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`.
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped.
     * `callback` will be passed an error and any arguments passed to the final
     * `iteratee`'s callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;

        function next(err, ...args) {
            if (err) return callback(err);
            if (err === false) return;
            results = args;
            _test(...args, check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return check(null, true);
    }

    var doWhilst$1 = awaitify(doWhilst, 3);

    /**
     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
     * argument ordering differs from `until`.
     *
     * @name doUntil
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
            const cb = args.pop();
            _test(...args, (err, truth) => cb (err, !truth));
        }, callback);
    }

    function _withoutIndex(iteratee) {
        return (value, index, callback) => iteratee(value, callback);
    }

    /**
     * Applies the function `iteratee` to each item in `coll`, in parallel.
     * The `iteratee` is called with an item from the list, and a callback for when
     * it has finished. If the `iteratee` passes an error to its `callback`, the
     * main `callback` (for the `each` function) is immediately called with the
     * error.
     *
     * Note, that since this function applies `iteratee` to each item in parallel,
     * there is no guarantee that the iteratee functions will complete in order.
     *
     * @name each
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEach
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to
     * each item in `coll`. Invoked with (item, callback).
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOf`.
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // assuming openFiles is an array of file names and saveFile is a function
     * // to save the modified contents of that file:
     *
     * async.each(openFiles, saveFile, function(err){
     *   // if any of the saves produced an error, err would equal that error
     * });
     *
     * // assuming openFiles is an array of file names
     * async.each(openFiles, function(file, callback) {
     *
     *     // Perform operation on file here.
     *     console.log('Processing file ' + file);
     *
     *     if( file.length > 32 ) {
     *       console.log('This file name is too long');
     *       callback('File name too long');
     *     } else {
     *       // Do work to process file here
     *       console.log('File processed');
     *       callback();
     *     }
     * }, function(err) {
     *     // if any of the file processing produced an error, err would equal that error
     *     if( err ) {
     *       // One of the iterations produced an error.
     *       // All processing will now stop.
     *       console.log('A file failed to process');
     *     } else {
     *       console.log('All files have been processed successfully');
     *     }
     * });
     */
    function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }

    var each = awaitify(eachLimit, 3);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
     *
     * @name eachLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfLimit`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$2 = awaitify(eachLimit$1, 4);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
     *
     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
     * in series and therefore the iteratee functions will complete in order.

     * @name eachSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfSeries`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback)
    }
    var eachSeries$1 = awaitify(eachSeries, 3);

    /**
     * Wrap an async function and ensure it calls its callback on a later tick of
     * the event loop.  If the function already calls its callback on a next tick,
     * no extra deferral is added. This is useful for preventing stack overflows
     * (`RangeError: Maximum call stack size exceeded`) and generally keeping
     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
     * contained. ES2017 `async` functions are returned as-is -- they are immune
     * to Zalgo's corrupting influences, as they always resolve on a later tick.
     *
     * @name ensureAsync
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - an async function, one that expects a node-style
     * callback as its last argument.
     * @returns {AsyncFunction} Returns a wrapped function with the exact same call
     * signature as the function passed in.
     * @example
     *
     * function sometimesAsync(arg, callback) {
     *     if (cache[arg]) {
     *         return callback(null, cache[arg]); // this would be synchronous!!
     *     } else {
     *         doSomeIO(arg, callback); // this IO would be asynchronous
     *     }
     * }
     *
     * // this has a risk of stack overflows if many results are cached in a row
     * async.mapSeries(args, sometimesAsync, done);
     *
     * // this will defer sometimesAsync's callback if necessary,
     * // preventing stack overflows
     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
     */
    function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function (...args/*, callback*/) {
            var callback = args.pop();
            var sync = true;
            args.push((...innerArgs) => {
                if (sync) {
                    setImmediate$1(() => callback(...innerArgs));
                } else {
                    callback(...innerArgs);
                }
            });
            fn.apply(this, args);
            sync = false;
        };
    }

    /**
     * Returns `true` if every element in `coll` satisfies an async test. If any
     * iteratee call returns `false`, the main `callback` is immediately called.
     *
     * @name every
     * @static
     * @memberOf module:Collections
     * @method
     * @alias all
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * async.every(['file1','file2','file3'], function(filePath, callback) {
     *     fs.access(filePath, function(err) {
     *         callback(null, !err)
     *     });
     * }, function(err, result) {
     *     // if result is true then every file exists
     * });
     */
    function every(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
    }
    var every$1 = awaitify(every, 3);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
     *
     * @name everyLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everyLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var everyLimit$1 = awaitify(everyLimit, 4);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
     *
     * @name everySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in series.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everySeries(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var everySeries$1 = awaitify(everySeries, 3);

    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                truthValues[index] = !!v;
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
                if (truthValues[i]) results.push(arr[i]);
            }
            callback(null, results);
        });
    }

    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                if (err) return iterCb(err);
                if (v) {
                    results.push({index, value: x});
                }
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            callback(null, results
                .sort((a, b) => a.index - b.index)
                .map(v => v.value));
        });
    }

    function _filter(eachfn, coll, iteratee, callback) {
        var filter = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter(eachfn, coll, wrapAsync(iteratee), callback);
    }

    /**
     * Returns a new array of all the values in `coll` which pass an async truth
     * test. This operation is performed in parallel, but the results array will be
     * in the same order as the original.
     *
     * @name filter
     * @static
     * @memberOf module:Collections
     * @method
     * @alias select
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * async.filter(['file1','file2','file3'], function(filePath, callback) {
     *     fs.access(filePath, function(err) {
     *         callback(null, !err)
     *     });
     * }, function(err, results) {
     *     // results now equals an array of the existing files
     * });
     */
    function filter (coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback)
    }
    var filter$1 = awaitify(filter, 3);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name filterLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     */
    function filterLimit (coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback)
    }
    var filterLimit$1 = awaitify(filterLimit, 4);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
     *
     * @name filterSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results)
     * @returns {Promise} a promise, if no callback provided
     */
    function filterSeries (coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback)
    }
    var filterSeries$1 = awaitify(filterSeries, 3);

    /**
     * Calls the asynchronous function `fn` with a callback parameter that allows it
     * to call itself again, in series, indefinitely.

     * If an error is passed to the callback then `errback` is called with the
     * error, and execution stops, otherwise it will never be called.
     *
     * @name forever
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} fn - an async function to call repeatedly.
     * Invoked with (next).
     * @param {Function} [errback] - when `fn` passes an error to it's callback,
     * this function will be called, and execution stops. Invoked with (err).
     * @returns {Promise} a promise that rejects if an error occurs and an errback
     * is not passed
     * @example
     *
     * async.forever(
     *     function(next) {
     *         // next is suitable for passing to things that need a callback(err [, whatever]);
     *         // it will result in this function being called again.
     *     },
     *     function(err) {
     *         // if next is called with a value in its first parameter, it will appear
     *         // in here as 'err', and execution will stop.
     *     }
     * );
     */
    function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));

        function next(err) {
            if (err) return done(err);
            if (err === false) return;
            task(next);
        }
        return next();
    }
    var forever$1 = awaitify(forever, 2);

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
     *
     * @name groupByLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, key) => {
                if (err) return iterCb(err);
                return iterCb(err, {key, val});
            });
        }, (err, mapResults) => {
            var result = {};
            // from MDN, handle object having an `hasOwnProperty` prop
            var {hasOwnProperty} = Object.prototype;

            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    var {key} = mapResults[i];
                    var {val} = mapResults[i];

                    if (hasOwnProperty.call(result, key)) {
                        result[key].push(val);
                    } else {
                        result[key] = [val];
                    }
                }
            }

            return callback(err, result);
        });
    }

    var groupByLimit$1 = awaitify(groupByLimit, 4);

    /**
     * Returns a new object, where each value corresponds to an array of items, from
     * `coll`, that returned the corresponding key. That is, the keys of the object
     * correspond to the values passed to the `iteratee` callback.
     *
     * Note: Since this function applies the `iteratee` to each item in parallel,
     * there is no guarantee that the `iteratee` functions will complete in order.
     * However, the values for each key in the `result` will be in the same order as
     * the original `coll`. For Objects, the values will roughly be in the order of
     * the original Objects' keys (but this can vary across JavaScript engines).
     *
     * @name groupBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
     *     db.findById(userId, function(err, user) {
     *         if (err) return callback(err);
     *         return callback(null, user.age);
     *     });
     * }, function(err, result) {
     *     // result is object containing the userIds grouped by age
     *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
     * });
     */
    function groupBy (coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback)
    }

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
     *
     * @name groupBySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupBySeries (coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback)
    }

    /**
     * Logs the result of an `async` function to the `console`. Only works in
     * Node.js or in browsers that support `console.log` and `console.error` (such
     * as FF and Chrome). If multiple arguments are returned from the async
     * function, `console.log` is called on each argument in order.
     *
     * @name log
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, 'hello ' + name);
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.log(hello, 'world');
     * 'hello world'
     */
    var log = consoleFunc('log');

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name mapValuesLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
            _iteratee(val, key, (err, result) => {
                if (err) return next(err);
                newObj[key] = result;
                next(err);
            });
        }, err => callback(err, newObj));
    }

    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);

    /**
     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
     *
     * Produces a new Object by mapping each value of `obj` through the `iteratee`
     * function. The `iteratee` is called each `value` and `key` from `obj` and a
     * callback for when it has finished processing. Each of these callbacks takes
     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
     * passes an error to its callback, the main `callback` (for the `mapValues`
     * function) is immediately called with the error.
     *
     * Note, the order of the keys in the result is not guaranteed.  The keys will
     * be roughly in the order they complete, (but this is very engine-specific)
     *
     * @name mapValues
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * async.mapValues({
     *     f1: 'file1',
     *     f2: 'file2',
     *     f3: 'file3'
     * }, function (file, key, callback) {
     *   fs.stat(file, callback);
     * }, function(err, result) {
     *     // result is now a map of stats for each file, e.g.
     *     // {
     *     //     f1: [stats for file1],
     *     //     f2: [stats for file2],
     *     //     f3: [stats for file3]
     *     // }
     * });
     */
    function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback)
    }

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
     *
     * @name mapValuesSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback)
    }

    /**
     * Caches the results of an async function. When creating a hash to store
     * function results against, the callback is omitted from the hash and an
     * optional hash function can be used.
     *
     * **Note: if the async function errs, the result will not be cached and
     * subsequent calls will call the wrapped function.**
     *
     * If no hash function is specified, the first argument is used as a hash key,
     * which may work reasonably if it is a string or a data type that converts to a
     * distinct string. Note that objects and arrays will not behave reasonably.
     * Neither will cases where the other arguments are significant. In such cases,
     * specify your own hash function.
     *
     * The cache of results is exposed as the `memo` property of the function
     * returned by `memoize`.
     *
     * @name memoize
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function to proxy and cache results from.
     * @param {Function} hasher - An optional function for generating a custom hash
     * for storing results. It has all the arguments applied to it apart from the
     * callback, and must be synchronous.
     * @returns {AsyncFunction} a memoized version of `fn`
     * @example
     *
     * var slow_fn = function(name, callback) {
     *     // do something
     *     callback(null, result);
     * };
     * var fn = async.memoize(slow_fn);
     *
     * // fn can now be used as if it were slow_fn
     * fn('some name', function() {
     *     // callback
     * });
     */
    function memoize(fn, hasher = v => v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
            var key = hasher(...args);
            if (key in memo) {
                setImmediate$1(() => callback(null, ...memo[key]));
            } else if (key in queues) {
                queues[key].push(callback);
            } else {
                queues[key] = [callback];
                _fn(...args, (err, ...resultArgs) => {
                    // #1465 don't memoize if an error occurred
                    if (!err) {
                        memo[key] = resultArgs;
                    }
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i](err, ...resultArgs);
                    }
                });
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    }

    /**
     * Calls `callback` on a later loop around the event loop. In Node.js this just
     * calls `process.nextTick`.  In the browser it will use `setImmediate` if
     * available, otherwise `setTimeout(callback, 0)`, which means other higher
     * priority events may precede the execution of `callback`.
     *
     * This is used internally for browser-compatibility purposes.
     *
     * @name nextTick
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.setImmediate]{@link module:Utils.setImmediate}
     * @category Util
     * @param {Function} callback - The function to call on a later loop around
     * the event loop. Invoked with (args...).
     * @param {...*} args... - any number of additional arguments to pass to the
     * callback on the next tick.
     * @example
     *
     * var call_order = [];
     * async.nextTick(function() {
     *     call_order.push('two');
     *     // call_order now equals ['one','two']
     * });
     * call_order.push('one');
     *
     * async.setImmediate(function (a, b, c) {
     *     // a, b, and c equal 1, 2, and 3
     * }, 1, 2, 3);
     */
    var _defer$1;

    if (hasNextTick) {
        _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
    } else {
        _defer$1 = fallback;
    }

    var nextTick = wrap(_defer$1);

    var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};

        eachfn(tasks, (task, key, taskCb) => {
            wrapAsync(task)((err, ...result) => {
                if (result.length < 2) {
                    [result] = result;
                }
                results[key] = result;
                taskCb(err);
            });
        }, err => callback(err, results));
    }, 3);

    /**
     * Run the `tasks` collection of functions in parallel, without waiting until
     * the previous function has completed. If any of the functions pass an error to
     * its callback, the main `callback` is immediately called with the value of the
     * error. Once the `tasks` have completed, the results are passed to the final
     * `callback` as an array.
     *
     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
     * parallel execution of code.  If your tasks do not use any timers or perform
     * any I/O, they will actually be executed in series.  Any synchronous setup
     * sections for each task will happen one after the other.  JavaScript remains
     * single-threaded.
     *
     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
     * execution of other tasks when a task fails.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     * results from {@link async.parallel}.
     *
     * @name parallel
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     // the results array will equal ['one','two'] even though
     *     // the second function had a shorter timeout.
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     // results is now equals to: {one: 1, two: 2}
     * });
     */
    function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
    }

    /**
     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name parallelLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.parallel]{@link module:ControlFlow.parallel}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     */
    function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
    }

    /**
     * A queue of tasks for the worker function to complete.
     * @typedef {Iterable} QueueObject
     * @memberOf module:ControlFlow
     * @property {Function} length - a function returning the number of items
     * waiting to be processed. Invoke with `queue.length()`.
     * @property {boolean} started - a boolean indicating whether or not any
     * items have been pushed and processed by the queue.
     * @property {Function} running - a function returning the number of items
     * currently being processed. Invoke with `queue.running()`.
     * @property {Function} workersList - a function returning the array of items
     * currently being processed. Invoke with `queue.workersList()`.
     * @property {Function} idle - a function returning false if there are items
     * waiting or being processed, or true if not. Invoke with `queue.idle()`.
     * @property {number} concurrency - an integer for determining how many `worker`
     * functions should be run in parallel. This property can be changed after a
     * `queue` is created to alter the concurrency on-the-fly.
     * @property {number} payload - an integer that specifies how many items are
     * passed to the worker function at a time. only applies if this is a
     * [cargo]{@link module:ControlFlow.cargo} object
     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
     * once the `worker` has finished processing the task. Instead of a single task,
     * a `tasks` array can be submitted. The respective callback is used for every
     * task in the list. Invoke with `queue.push(task, [callback])`,
     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
     * Invoke with `queue.unshift(task, [callback])`.
     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
     * a promise that rejects if an error occurs.
     * @property {AsyncFunction} unshirtAsync - the same as `q.unshift`, except this returns
     * a promise that rejects if an error occurs.
     * @property {Function} remove - remove items from the queue that match a test
     * function.  The test function will be passed an object with a `data` property,
     * and a `priority` property, if this is a
     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
     * `function ({data, priority}) {}` and returns a Boolean.
     * @property {Function} saturated - a function that sets a callback that is
     * called when the number of running workers hits the `concurrency` limit, and
     * further tasks will be queued.  If the callback is omitted, `q.saturated()`
     * returns a promise for the next occurrence.
     * @property {Function} unsaturated - a function that sets a callback that is
     * called when the number of running workers is less than the `concurrency` &
     * `buffer` limits, and further tasks will not be queued. If the callback is
     * omitted, `q.unsaturated()` returns a promise for the next occurrence.
     * @property {number} buffer - A minimum threshold buffer in order to say that
     * the `queue` is `unsaturated`.
     * @property {Function} empty - a function that sets a callback that is called
     * when the last item from the `queue` is given to a `worker`. If the callback
     * is omitted, `q.empty()` returns a promise for the next occurrence.
     * @property {Function} drain - a function that sets a callback that is called
     * when the last item from the `queue` has returned from the `worker`. If the
     * callback is omitted, `q.drain()` returns a promise for the next occurrence.
     * @property {Function} error - a function that sets a callback that is called
     * when a task errors. Has the signature `function(error, task)`. If the
     * callback is omitted, `error()` returns a promise that rejects on the next
     * error.
     * @property {boolean} paused - a boolean for determining whether the queue is
     * in a paused state.
     * @property {Function} pause - a function that pauses the processing of tasks
     * until `resume()` is called. Invoke with `queue.pause()`.
     * @property {Function} resume - a function that resumes the processing of
     * queued tasks when the queue is paused. Invoke with `queue.resume()`.
     * @property {Function} kill - a function that removes the `drain` callback and
     * empties remaining tasks from the queue forcing it to go idle. No more tasks
     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
     *
     * @example
     * const q = aync.queue(worker, 2)
     * q.push(item1)
     * q.push(item2)
     * q.push(item3)
     * // queues are iterable, spread into an array to inspect
     * const items = [...q] // [item1, item2, item3]
     * // or use for of
     * for (let item of q) {
     *     console.log(item)
     * }
     *
     * q.drain(() => {
     *     console.log('all done')
     * })
     * // or
     * await q.drain()
     */

    /**
     * Creates a `queue` object with the specified `concurrency`. Tasks added to the
     * `queue` are processed in parallel (up to the `concurrency` limit). If all
     * `worker`s are in progress, the task is queued until one becomes available.
     * Once a `worker` completes a `task`, that `task`'s callback is called.
     *
     * @name queue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`. Invoked with (task, callback).
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
     * attached as certain properties to listen for specific events during the
     * lifecycle of the queue.
     * @example
     *
     * // create a queue object with concurrency 2
     * var q = async.queue(function(task, callback) {
     *     console.log('hello ' + task.name);
     *     callback();
     * }, 2);
     *
     * // assign a callback
     * q.drain(function() {
     *     console.log('all items have been processed');
     * });
     * // or await the end
     * await q.drain()
     *
     * // assign an error callback
     * q.error(function(err, task) {
     *     console.error('task experienced an error');
     * });
     *
     * // add some items to the queue
     * q.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * // callback is optional
     * q.push({name: 'bar'});
     *
     * // add some items to the queue (batch-wise)
     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
     *     console.log('finished processing item');
     * });
     *
     * // add some items to the front of the queue
     * q.unshift({name: 'bar'}, function (err) {
     *     console.log('finished processing bar');
     * });
     */
    function queue$1 (worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
            _worker(items[0], cb);
        }, concurrency, 1);
    }

    // Binary min-heap implementation used for priority queue.
    // Implementation is stable, i.e. push time is considered for equal priorities
    class Heap {
        constructor() {
            this.heap = [];
            this.pushCount = Number.MIN_SAFE_INTEGER;
        }

        get length() {
            return this.heap.length;
        }

        empty () {
            this.heap = [];
            return this;
        }

        percUp(index) {
            let p;

            while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
                let t = this.heap[index];
                this.heap[index] = this.heap[p];
                this.heap[p] = t;

                index = p;
            }
        }

        percDown(index) {
            let l;

            while ((l=leftChi(index)) < this.heap.length) {
                if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                    l = l+1;
                }

                if (smaller(this.heap[index], this.heap[l])) {
                    break;
                }

                let t = this.heap[index];
                this.heap[index] = this.heap[l];
                this.heap[l] = t;

                index = l;
            }
        }

        push(node) {
            node.pushCount = ++this.pushCount;
            this.heap.push(node);
            this.percUp(this.heap.length-1);
        }

        unshift(node) {
            return this.heap.push(node);
        }

        shift() {
            let [top] = this.heap;

            this.heap[0] = this.heap[this.heap.length-1];
            this.heap.pop();
            this.percDown(0);

            return top;
        }

        toArray() {
            return [...this];
        }

        *[Symbol.iterator] () {
            for (let i = 0; i < this.heap.length; i++) {
                yield this.heap[i].data;
            }
        }

        remove (testFn) {
            let j = 0;
            for (let i = 0; i < this.heap.length; i++) {
                if (!testFn(this.heap[i])) {
                    this.heap[j] = this.heap[i];
                    j++;
                }
            }

            this.heap.splice(j);

            for (let i = parent(this.heap.length-1); i >= 0; i--) {
                this.percDown(i);
            }

            return this;
        }
    }

    function leftChi(i) {
        return (i<<1)+1;
    }

    function parent(i) {
        return ((i+1)>>1)-1;
    }

    function smaller(x, y) {
        if (x.priority !== y.priority) {
            return x.priority < y.priority;
        }
        else {
            return x.pushCount < y.pushCount;
        }
    }

    /**
     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
     * completed in ascending priority order.
     *
     * @name priorityQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`.
     * Invoked with (task, callback).
     * @param {number} concurrency - An `integer` for determining how many `worker`
     * functions should be run in parallel.  If omitted, the concurrency defaults to
     * `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
     * differences between `queue` and `priorityQueue` objects:
     * * `push(task, priority, [callback])` - `priority` should be a number. If an
     *   array of `tasks` is given, all tasks will be assigned the same priority.
     * * The `unshift` method was removed.
     */
    function priorityQueue(worker, concurrency) {
        // Start with a normal queue
        var q = queue$1(worker, concurrency);

        q._tasks = new Heap();

        // Override push to accept second parameter representing priority
        q.push = function(data, priority = 0, callback = () => {}) {
            if (typeof callback !== 'function') {
                throw new Error('task callback must be a function');
            }
            q.started = true;
            if (!Array.isArray(data)) {
                data = [data];
            }
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return setImmediate$1(() => q.drain());
            }

            for (var i = 0, l = data.length; i < l; i++) {
                var item = {
                    data: data[i],
                    priority,
                    callback
                };

                q._tasks.push(item);
            }

            setImmediate$1(q.process);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    }

    /**
     * Runs the `tasks` array of functions in parallel, without waiting until the
     * previous function has completed. Once any of the `tasks` complete or pass an
     * error to its callback, the main `callback` is immediately called. It's
     * equivalent to `Promise.race()`.
     *
     * @name race
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
     * to run. Each function can complete with an optional `result` value.
     * @param {Function} callback - A callback to run once any of the functions have
     * completed. This function gets an error or result from the first function that
     * completed. Invoked with (err, result).
     * @returns undefined
     * @example
     *
     * async.race([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ],
     * // main callback
     * function(err, result) {
     *     // the result will be equal to 'two' as it finishes earlier
     * });
     */
    function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
        }
    }

    var race$1 = awaitify(race, 2);

    /**
     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
     *
     * @name reduceRight
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reduce]{@link module:Collections.reduce}
     * @alias foldr
     * @category Collection
     * @param {Array} array - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee complete with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function reduceRight (array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
    }

    /**
     * Wraps the async function in another function that always completes with a
     * result object, even when it errors.
     *
     * The result object has either the property `error` or `value`.
     *
     * @name reflect
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function you want to wrap
     * @returns {Function} - A function that always passes null to it's callback as
     * the error. The second argument to the callback will be an `object` with
     * either an `error` or a `value` property.
     * @example
     *
     * async.parallel([
     *     async.reflect(function(callback) {
     *         // do some stuff ...
     *         callback(null, 'one');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff but error ...
     *         callback('bad stuff happened');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff ...
     *         callback(null, 'two');
     *     })
     * ],
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = 'bad stuff happened'
     *     // results[2].value = 'two'
     * });
     */
    function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
            args.push((error, ...cbArgs) => {
                let retVal = {};
                if (error) {
                    retVal.error = error;
                }
                if (cbArgs.length > 0){
                    var value = cbArgs;
                    if (cbArgs.length <= 1) {
                        [value] = cbArgs;
                    }
                    retVal.value = value;
                }
                reflectCallback(null, retVal);
            });

            return _fn.apply(this, args);
        });
    }

    /**
     * A helper function that wraps an array or an object of functions with `reflect`.
     *
     * @name reflectAll
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.reflect]{@link module:Utils.reflect}
     * @category Util
     * @param {Array|Object|Iterable} tasks - The collection of
     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
     * @returns {Array} Returns an array of async functions, each wrapped in
     * `async.reflect`
     * @example
     *
     * let tasks = [
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         // do some more stuff but error ...
     *         callback(new Error('bad stuff happened'));
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ];
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = Error('bad stuff happened')
     *     // results[2].value = 'two'
     * });
     *
     * // an example using an object instead of an array
     * let tasks = {
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         callback('two');
     *     },
     *     three: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'three');
     *         }, 100);
     *     }
     * };
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results.one.value = 'one'
     *     // results.two.error = 'two'
     *     // results.three.value = 'three'
     * });
     */
    function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
            results = tasks.map(reflect);
        } else {
            results = {};
            Object.keys(tasks).forEach(key => {
                results[key] = reflect.call(this, tasks[key]);
            });
        }
        return results;
    }

    function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
            iteratee(value, (err, v) => {
                cb(err, !v);
            });
        }, callback);
    }

    /**
     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
     *
     * @name reject
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * async.reject(['file1','file2','file3'], function(filePath, callback) {
     *     fs.access(filePath, function(err) {
     *         callback(null, !err)
     *     });
     * }, function(err, results) {
     *     // results now equals an array of missing files
     *     createFiles(results);
     * });
     */
    function reject$1 (coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback)
    }
    var reject$2 = awaitify(reject$1, 3);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name rejectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectLimit (coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback)
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
     *
     * @name rejectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectSeries (coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback)
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);

    function constant$1(value) {
        return function () {
            return value;
        }
    }

    /**
     * Attempts to get a successful response from `task` no more than `times` times
     * before returning an error. If the task is successful, the `callback` will be
     * passed the result of the successful task. If all attempts fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name retry
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @see [async.retryable]{@link module:ControlFlow.retryable}
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
     * object with `times` and `interval` or a number.
     * * `times` - The number of attempts to make before giving up.  The default
     *   is `5`.
     * * `interval` - The time to wait between retries, in milliseconds.  The
     *   default is `0`. The interval may also be specified as a function of the
     *   retry count (see example).
     * * `errorFilter` - An optional synchronous function that is invoked on
     *   erroneous result. If it returns `true` the retry attempts will continue;
     *   if the function returns `false` the retry flow is aborted with the current
     *   attempt's error and result being returned to the final callback.
     *   Invoked with (err).
     * * If `opts` is a number, the number specifies the number of times to retry,
     *   with the default interval of `0`.
     * @param {AsyncFunction} task - An async function to retry.
     * Invoked with (callback).
     * @param {Function} [callback] - An optional callback which is called when the
     * task has succeeded, or after the final failed attempt. It receives the `err`
     * and `result` arguments of the last attempt at completing the `task`. Invoked
     * with (err, results).
     * @returns {Promise} a promise if no callback provided
     *
     * @example
     *
     * // The `retry` function can be used as a stand-alone control flow by passing
     * // a callback, as shown below:
     *
     * // try calling apiMethod 3 times
     * async.retry(3, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 3 times, waiting 200 ms between each retry
     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 10 times with exponential backoff
     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
     * async.retry({
     *   times: 10,
     *   interval: function(retryCount) {
     *     return 50 * Math.pow(2, retryCount);
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod the default 5 times no delay between each retry
     * async.retry(apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod only when error condition satisfies, all other
     * // errors will abort the retry control flow and return to final callback
     * async.retry({
     *   errorFilter: function(err) {
     *     return err.message === 'Temporary error'; // only retry on a specific error
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // to retry individual methods that are not as reliable within other
     * // control flow functions, use the `retryable` wrapper:
     * async.auto({
     *     users: api.getUsers.bind(api),
     *     payments: async.retryable(3, api.getPayments.bind(api))
     * }, function(err, results) {
     *     // do something with the results
     * });
     *
     */
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;

    function retry(opts, task, callback) {
        var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
        };

        if (arguments.length < 3 && typeof opts === 'function') {
            callback = task || promiseCallback();
            task = opts;
        } else {
            parseTimes(options, opts);
            callback = callback || promiseCallback();
        }

        if (typeof task !== 'function') {
            throw new Error("Invalid arguments for async.retry");
        }

        var _task = wrapAsync(task);

        var attempt = 1;
        function retryAttempt() {
            _task((err, ...args) => {
                if (err === false) return
                if (err && attempt++ < options.times &&
                    (typeof options.errorFilter != 'function' ||
                        options.errorFilter(err))) {
                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
                } else {
                    callback(err, ...args);
                }
            });
        }

        retryAttempt();
        return callback[PROMISE_SYMBOL]
    }

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    /**
     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
     * wraps a task and makes it retryable, rather than immediately calling it
     * with retries.
     *
     * @name retryable
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.retry]{@link module:ControlFlow.retry}
     * @category Control Flow
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
     * options, exactly the same as from `retry`, except for a `opts.arity` that
     * is the arity of the `task` function, defaulting to `task.length`
     * @param {AsyncFunction} task - the asynchronous function to wrap.
     * This function will be passed any arguments passed to the returned wrapper.
     * Invoked with (...args, callback).
     * @returns {AsyncFunction} The wrapped function, which when invoked, will
     * retry on an error, based on the parameters specified in `opts`.
     * This function will accept the same parameters as `task`.
     * @example
     *
     * async.auto({
     *     dep1: async.retryable(3, getFromFlakyService),
     *     process: ["dep1", async.retryable(3, function (results, cb) {
     *         maybeProcessData(results.dep1, cb);
     *     })]
     * }, callback);
     */
    function retryable (opts, task) {
        if (!task) {
            task = opts;
            opts = null;
        }
        let arity = (opts && opts.arity) || task.length;
        if (isAsync(task)) {
            arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
            if (args.length < arity - 1 || callback == null) {
                args.push(callback);
                callback = promiseCallback();
            }
            function taskFn(cb) {
                _task(...args, cb);
            }

            if (opts) retry(opts, taskFn, callback);
            else retry(taskFn, callback);

            return callback[PROMISE_SYMBOL]
        });
    }

    /**
     * Run the functions in the `tasks` collection in series, each one running once
     * the previous function has completed. If any functions in the series pass an
     * error to its callback, no more functions are run, and `callback` is
     * immediately called with the value of the error. Otherwise, `callback`
     * receives an array of results when `tasks` have completed.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function, and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     *  results from {@link async.series}.
     *
     * **Note** that while many implementations preserve the order of object
     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
     * explicitly states that
     *
     * > The mechanics and order of enumerating the properties is not specified.
     *
     * So if you rely on the order in which your series of functions are executed,
     * and want this to work on all platforms, consider using an array.
     *
     * @name series
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
     * [async functions]{@link AsyncFunction} to run in series.
     * Each function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This function gets a results array (or object)
     * containing all the result arguments passed to the `task` callbacks. Invoked
     * with (err, result).
     * @return {Promise} a promise, if no callback is passed
     * @example
     * async.series([
     *     function(callback) {
     *         // do some stuff ...
     *         callback(null, 'one');
     *     },
     *     function(callback) {
     *         // do some more stuff ...
     *         callback(null, 'two');
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     // results is now equal to ['one', 'two']
     * });
     *
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback){
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     // results is now equal to: {one: 1, two: 2}
     * });
     */
    function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
    }

    /**
     * Returns `true` if at least one element in the `coll` satisfies an async test.
     * If any iteratee call returns `true`, the main `callback` is immediately
     * called.
     *
     * @name some
     * @static
     * @memberOf module:Collections
     * @method
     * @alias any
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * async.some(['file1','file2','file3'], function(filePath, callback) {
     *     fs.access(filePath, function(err) {
     *         callback(null, !err)
     *     });
     * }, function(err, result) {
     *     // if result is true then at least one of the files exists
     * });
     */
    function some(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
    }
    var some$1 = awaitify(some, 3);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
     *
     * @name someLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anyLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var someLimit$1 = awaitify(someLimit, 4);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
     *
     * @name someSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anySeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in series.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var someSeries$1 = awaitify(someSeries, 3);

    /**
     * Sorts a list by the results of running each `coll` value through an async
     * `iteratee`.
     *
     * @name sortBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a value to use as the sort criteria as
     * its `result`.
     * Invoked with (item, callback).
     * @param {Function} callback - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is the items
     * from the original `coll` sorted by the values returned by the `iteratee`
     * calls. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback passed
     * @example
     *
     * async.sortBy(['file1','file2','file3'], function(file, callback) {
     *     fs.stat(file, function(err, stats) {
     *         callback(err, stats.mtime);
     *     });
     * }, function(err, results) {
     *     // results is now the original array of files sorted by
     *     // modified date
     * });
     *
     * // By modifying the callback parameter the
     * // sorting order can be influenced:
     *
     * // ascending order
     * async.sortBy([1,9,3,5], function(x, callback) {
     *     callback(null, x);
     * }, function(err,result) {
     *     // result callback
     * });
     *
     * // descending order
     * async.sortBy([1,9,3,5], function(x, callback) {
     *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
     * }, function(err,result) {
     *     // result callback
     * });
     */
    function sortBy (coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
            _iteratee(x, (err, criteria) => {
                if (err) return iterCb(err);
                iterCb(err, {value: x, criteria});
            });
        }, (err, results) => {
            if (err) return callback(err);
            callback(null, results.sort(comparator).map(v => v.value));
        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    }
    var sortBy$1 = awaitify(sortBy, 3);

    /**
     * Sets a time limit on an asynchronous function. If the function does not call
     * its callback within the specified milliseconds, it will be called with a
     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
     *
     * @name timeout
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} asyncFn - The async function to limit in time.
     * @param {number} milliseconds - The specified time limit.
     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
     * to timeout Error for more information..
     * @returns {AsyncFunction} Returns a wrapped function that can be used with any
     * of the control flow functions.
     * Invoke this function with the same parameters as you would `asyncFunc`.
     * @example
     *
     * function myFunction(foo, callback) {
     *     doAsyncTask(foo, function(err, data) {
     *         // handle errors
     *         if (err) return callback(err);
     *
     *         // do some stuff ...
     *
     *         // return processed data
     *         return callback(null, data);
     *     });
     * }
     *
     * var wrapped = async.timeout(myFunction, 1000);
     *
     * // call `wrapped` as you would `myFunction`
     * wrapped({ bar: 'bar' }, function(err, data) {
     *     // if `myFunction` takes < 1000 ms to execute, `err`
     *     // and `data` will have their expected values
     *
     *     // else `err` will be an Error with the code 'ETIMEDOUT'
     * });
     */
    function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);

        return initialParams((args, callback) => {
            var timedOut = false;
            var timer;

            function timeoutCallback() {
                var name = asyncFn.name || 'anonymous';
                var error  = new Error('Callback function "' + name + '" timed out.');
                error.code = 'ETIMEDOUT';
                if (info) {
                    error.info = info;
                }
                timedOut = true;
                callback(error);
            }

            args.push((...cbArgs) => {
                if (!timedOut) {
                    callback(...cbArgs);
                    clearTimeout(timer);
                }
            });

            // setup timer and call original function
            timer = setTimeout(timeoutCallback, milliseconds);
            fn(...args);
        });
    }

    function range(size) {
        var result = Array(size);
        while (size--) {
            result[size] = size;
        }
        return result;
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name timesLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} count - The number of times to run the function.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see [async.map]{@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
    }

    /**
     * Calls the `iteratee` function `n` times, and accumulates results in the same
     * manner you would use with [map]{@link module:Collections.map}.
     *
     * @name times
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     * @example
     *
     * // Pretend this is some complicated async factory
     * var createUser = function(id, callback) {
     *     callback(null, {
     *         id: 'user' + id
     *     });
     * };
     *
     * // generate 5 users
     * async.times(5, function(n, next) {
     *     createUser(n, function(err, user) {
     *         next(err, user);
     *     });
     * }, function(err, users) {
     *     // we should now have 5 users
     * });
     */
    function times (n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback)
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
     *
     * @name timesSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesSeries (n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback)
    }

    /**
     * A relative of `reduce`.  Takes an Object or Array, and iterates over each
     * element in parallel, each step potentially mutating an `accumulator` value.
     * The type of the accumulator defaults to the type of collection passed in.
     *
     * @name transform
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} [accumulator] - The initial state of the transform.  If omitted,
     * it will default to an empty Object or Array, depending on the type of `coll`
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * collection that potentially modifies the accumulator.
     * Invoked with (accumulator, item, key, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the transformed accumulator.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * async.transform([1,2,3], function(acc, item, index, callback) {
     *     // pointless async:
     *     process.nextTick(function() {
     *         acc[index] = item * 2
     *         callback(null)
     *     });
     * }, function(err, result) {
     *     // result is now equal to [2, 4, 6]
     * });
     *
     * @example
     *
     * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
     *     setImmediate(function () {
     *         obj[key] = val * 2;
     *         callback();
     *     })
     * }, function (err, result) {
     *     // result is equal to {a: 2, b: 4, c: 6}
     * })
     */
    function transform (coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === 'function') {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);

        eachOf$1(coll, (v, k, cb) => {
            _iteratee(accumulator, v, k, cb);
        }, err => callback(err, accumulator));
        return callback[PROMISE_SYMBOL]
    }

    /**
     * It runs each task in series but stops whenever any of the functions were
     * successful. If one of the tasks were successful, the `callback` will be
     * passed the result of the successful task. If all tasks fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name tryEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
     * run, each function is passed a `callback(err, result)` it must call on
     * completion with an error `err` (which can be `null`) and an optional `result`
     * value.
     * @param {Function} [callback] - An optional callback which is called when one
     * of the tasks has succeeded, or all have failed. It receives the `err` and
     * `result` arguments of the last attempt at completing the `task`. Invoked with
     * (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     * async.tryEach([
     *     function getDataFromFirstWebsite(callback) {
     *         // Try getting the data from the first website
     *         callback(err, data);
     *     },
     *     function getDataFromSecondWebsite(callback) {
     *         // First website failed,
     *         // Try getting the data from the backup website
     *         callback(err, data);
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     Now do something with the data.
     * });
     *
     */
    function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
            wrapAsync(task)((err, ...args) => {
                if (err === false) return taskCb(err);

                if (args.length < 2) {
                    [result] = args;
                } else {
                    result = args;
                }
                error = err;
                taskCb(err ? null : {});
            });
        }, () => callback(error, result));
    }

    var tryEach$1 = awaitify(tryEach);

    /**
     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
     * unmemoized form. Handy for testing.
     *
     * @name unmemoize
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.memoize]{@link module:Utils.memoize}
     * @category Util
     * @param {AsyncFunction} fn - the memoized function
     * @returns {AsyncFunction} a function that calls the original unmemoized function
     */
    function unmemoize(fn) {
        return (...args) => {
            return (fn.unmemoized || fn)(...args);
        };
    }

    /**
     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs.
     *
     * @name whilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with ().
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` passes. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * var count = 0;
     * async.whilst(
     *     function test(cb) { cb(null, count < 5;) },
     *     function iter(callback) {
     *         count++;
     *         setTimeout(function() {
     *             callback(null, count);
     *         }, 1000);
     *     },
     *     function (err, n) {
     *         // 5 seconds have passed, n = 5
     *     }
     * );
     */
    function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];

        function next(err, ...rest) {
            if (err) return callback(err);
            results = rest;
            if (err === false) return;
            _test(check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);

    /**
     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs. `callback` will be passed an error and any
     * arguments passed to the final `iteratee`'s callback.
     *
     * The inverse of [whilst]{@link module:ControlFlow.whilst}.
     *
     * @name until
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with (callback).
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     * const results = []
     * async.until(function test(page, cb) {
     *     cb(null, page.next == null)
     * }, function iter(next) {
     *     fetchPage(url, (err, body) => {
     *         if (err) return next(err)
     *         results = results.concat(body.objects)
     *         next(err, body)
     *     })
     * }, function done (err) {
     *     // all pages have been fetched
     * })
     */
    function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
    }

    /**
     * Runs the `tasks` array of functions in series, each passing their results to
     * the next in the array. However, if any of the `tasks` pass an error to their
     * own callback, the next function is not executed, and the main `callback` is
     * immediately called with the error.
     *
     * @name waterfall
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
     * to run.
     * Each function should complete with any number of `result` values.
     * The `result` values will be passed as arguments, in order, to the next task.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This will be passed the results of the last task's
     * callback. Invoked with (err, [results]).
     * @returns undefined
     * @example
     *
     * async.waterfall([
     *     function(callback) {
     *         callback(null, 'one', 'two');
     *     },
     *     function(arg1, arg2, callback) {
     *         // arg1 now equals 'one' and arg2 now equals 'two'
     *         callback(null, 'three');
     *     },
     *     function(arg1, callback) {
     *         // arg1 now equals 'three'
     *         callback(null, 'done');
     *     }
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     *
     * // Or, with named functions:
     * async.waterfall([
     *     myFirstFunction,
     *     mySecondFunction,
     *     myLastFunction,
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     * function myFirstFunction(callback) {
     *     callback(null, 'one', 'two');
     * }
     * function mySecondFunction(arg1, arg2, callback) {
     *     // arg1 now equals 'one' and arg2 now equals 'two'
     *     callback(null, 'three');
     * }
     * function myLastFunction(arg1, callback) {
     *     // arg1 now equals 'three'
     *     callback(null, 'done');
     * }
     */
    function waterfall (tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
        if (!tasks.length) return callback();
        var taskIndex = 0;

        function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            task(...args, onlyOnce(next));
        }

        function next(err, ...args) {
            if (err === false) return
            if (err || taskIndex === tasks.length) {
                return callback(err, ...args);
            }
            nextTask(args);
        }

        nextTask([]);
    }

    var waterfall$1 = awaitify(waterfall);

    /**
     * An "async function" in the context of Async is an asynchronous function with
     * a variable number of parameters, with the final parameter being a callback.
     * (`function (arg1, arg2, ..., callback) {}`)
     * The final callback is of the form `callback(err, results...)`, which must be
     * called once the function is completed.  The callback should be called with a
     * Error as its first argument to signal that an error occurred.
     * Otherwise, if no error occurred, it should be called with `null` as the first
     * argument, and any additional `result` arguments that may apply, to signal
     * successful completion.
     * The callback must be called exactly once, ideally on a later tick of the
     * JavaScript event loop.
     *
     * This type of function is also referred to as a "Node-style async function",
     * or a "continuation passing-style function" (CPS). Most of the methods of this
     * library are themselves CPS/Node-style async functions, or functions that
     * return CPS/Node-style async functions.
     *
     * Wherever we accept a Node-style async function, we also directly accept an
     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
     * In this case, the `async` function will not be passed a final callback
     * argument, and any thrown error will be used as the `err` argument of the
     * implicit callback, and the return value will be used as the `result` value.
     * (i.e. a `rejected` of the returned Promise becomes the `err` callback
     * argument, and a `resolved` value becomes the `result`.)
     *
     * Note, due to JavaScript limitations, we can only detect native `async`
     * functions and not transpilied implementations.
     * Your environment must have `async`/`await` support for this to work.
     * (e.g. Node > v7.6, or a recent version of a modern browser).
     * If you are using `async` functions through a transpiler (e.g. Babel), you
     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
     * because the `async function` will be compiled to an ordinary function that
     * returns a promise.
     *
     * @typedef {Function} AsyncFunction
     * @static
     */

    var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,

        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
    };

    exports.default = index;
    exports.apply = apply;
    exports.applyEach = applyEach$1;
    exports.applyEachSeries = applyEachSeries;
    exports.asyncify = asyncify;
    exports.auto = auto;
    exports.autoInject = autoInject;
    exports.cargo = cargo;
    exports.cargoQueue = cargo$1;
    exports.compose = compose;
    exports.concat = concat$1;
    exports.concatLimit = concatLimit$1;
    exports.concatSeries = concatSeries$1;
    exports.constant = constant;
    exports.detect = detect$1;
    exports.detectLimit = detectLimit$1;
    exports.detectSeries = detectSeries$1;
    exports.dir = dir;
    exports.doUntil = doUntil;
    exports.doWhilst = doWhilst$1;
    exports.each = each;
    exports.eachLimit = eachLimit$2;
    exports.eachOf = eachOf$1;
    exports.eachOfLimit = eachOfLimit$2;
    exports.eachOfSeries = eachOfSeries$1;
    exports.eachSeries = eachSeries$1;
    exports.ensureAsync = ensureAsync;
    exports.every = every$1;
    exports.everyLimit = everyLimit$1;
    exports.everySeries = everySeries$1;
    exports.filter = filter$1;
    exports.filterLimit = filterLimit$1;
    exports.filterSeries = filterSeries$1;
    exports.forever = forever$1;
    exports.groupBy = groupBy;
    exports.groupByLimit = groupByLimit$1;
    exports.groupBySeries = groupBySeries;
    exports.log = log;
    exports.map = map$1;
    exports.mapLimit = mapLimit$1;
    exports.mapSeries = mapSeries$1;
    exports.mapValues = mapValues;
    exports.mapValuesLimit = mapValuesLimit$1;
    exports.mapValuesSeries = mapValuesSeries;
    exports.memoize = memoize;
    exports.nextTick = nextTick;
    exports.parallel = parallel;
    exports.parallelLimit = parallelLimit;
    exports.priorityQueue = priorityQueue;
    exports.queue = queue$1;
    exports.race = race$1;
    exports.reduce = reduce$1;
    exports.reduceRight = reduceRight;
    exports.reflect = reflect;
    exports.reflectAll = reflectAll;
    exports.reject = reject$2;
    exports.rejectLimit = rejectLimit$1;
    exports.rejectSeries = rejectSeries$1;
    exports.retry = retry;
    exports.retryable = retryable;
    exports.seq = seq;
    exports.series = series;
    exports.setImmediate = setImmediate$1;
    exports.some = some$1;
    exports.someLimit = someLimit$1;
    exports.someSeries = someSeries$1;
    exports.sortBy = sortBy$1;
    exports.timeout = timeout;
    exports.times = times;
    exports.timesLimit = timesLimit;
    exports.timesSeries = timesSeries;
    exports.transform = transform;
    exports.tryEach = tryEach$1;
    exports.unmemoize = unmemoize;
    exports.until = until;
    exports.waterfall = waterfall$1;
    exports.whilst = whilst$1;
    exports.all = every$1;
    exports.allLimit = everyLimit$1;
    exports.allSeries = everySeries$1;
    exports.any = some$1;
    exports.anyLimit = someLimit$1;
    exports.anySeries = someSeries$1;
    exports.find = detect$1;
    exports.findLimit = detectLimit$1;
    exports.findSeries = detectSeries$1;
    exports.flatMap = concat$1;
    exports.flatMapLimit = concatLimit$1;
    exports.flatMapSeries = concatSeries$1;
    exports.forEach = each;
    exports.forEachSeries = eachSeries$1;
    exports.forEachLimit = eachLimit$2;
    exports.forEachOf = eachOf$1;
    exports.forEachOfSeries = eachOfSeries$1;
    exports.forEachOfLimit = eachOfLimit$2;
    exports.inject = reduce$1;
    exports.foldl = reduce$1;
    exports.foldr = reduceRight;
    exports.select = filter$1;
    exports.selectLimit = filterLimit$1;
    exports.selectSeries = filterSeries$1;
    exports.wrapSync = asyncify;
    exports.during = whilst$1;
    exports.doDuring = doWhilst$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require("../../process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/process/browser.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/guide/task/GuideTask1.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '388a8dJ3CZNBI9gxOj8fQio', 'GuideTask1');
// scripts/showcase/home/guide/task/GuideTask1.ts

"use strict";
/**主界面任务引导 */
Object.defineProperty(exports, "__esModule", { value: true });
var task = {
    name: 'home',
    debug: false,
    steps: [
        {
            order: 0,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '点击冒险按钮',
                args: 'MainLayer/Home/bottom/btns/btn1',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 1,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '冒险关闭按钮',
                args: 'DialogLayer/DlgLevel/bg/closeButton',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 2,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '点击签到按钮',
                args: 'MainLayer/Home/bottom/btns/btn2',
            },
            delayTime: 0,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 3,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '签到关闭按钮',
                args: 'DialogLayer/DlgSign/bg/closeButton',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 4,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '点击角色按钮',
                args: 'MainLayer/Home/bottom/btns/btn3',
            },
            delayTime: 0,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 5,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '角色关闭按钮',
                args: 'DialogLayer/DlgRole/bg/closeButton',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 6,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '点击商店按钮',
                args: 'MainLayer/Home/bottom/btns/btn4',
            },
            delayTime: 0,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
        {
            order: 7,
            name: 'GuideTask1',
            command: {
                cmd: 'movefinger',
                text: '商店关闭按钮',
                args: 'DialogLayer/DlgStore/bg/closeButton',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        },
    ]
};
var guideTask = {
    task: task
};
exports.default = guideTask;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXGd1aWRlXFx0YXNrXFxHdWlkZVRhc2sxLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxhQUFhOztBQUViLElBQU0sSUFBSSxHQUFHO0lBQ1QsSUFBSSxFQUFFLE1BQU07SUFDWixLQUFLLEVBQUUsS0FBSztJQUNaLEtBQUssRUFBRTtRQUNIO1lBQ0ksS0FBSyxFQUFFLENBQUM7WUFDUixJQUFJLEVBQUUsWUFBWTtZQUNsQixPQUFPLEVBQUU7Z0JBQ0wsR0FBRyxFQUFFLFlBQVk7Z0JBQ2pCLElBQUksRUFBRSxRQUFRO2dCQUNkLElBQUksRUFBRSxpQ0FBaUM7YUFDMUM7WUFDRCxTQUFTLEVBQUUsR0FBRztZQUNkLE9BQU8sWUFBQyxRQUFRO2dCQUNaLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztZQUNELFFBQVEsWUFBQyxRQUFRO2dCQUNiLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztZQUNELEtBQUssWUFBQyxRQUFRO2dCQUNWLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztTQUNKO1FBQ0Q7WUFDSSxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksRUFBRSxZQUFZO1lBQ2xCLE9BQU8sRUFBRTtnQkFDTCxHQUFHLEVBQUUsWUFBWTtnQkFDakIsSUFBSSxFQUFFLFFBQVE7Z0JBQ2QsSUFBSSxFQUFFLHFDQUFxQzthQUM5QztZQUNELFNBQVMsRUFBRSxHQUFHO1lBQ2QsT0FBTyxZQUFDLFFBQVE7Z0JBQ1osUUFBUSxFQUFFLENBQUM7WUFDZixDQUFDO1lBQ0QsUUFBUSxZQUFDLFFBQVE7Z0JBQ2IsUUFBUSxFQUFFLENBQUM7WUFDZixDQUFDO1lBQ0QsS0FBSyxZQUFDLFFBQVE7Z0JBQ1YsUUFBUSxFQUFFLENBQUM7WUFDZixDQUFDO1NBQ0o7UUFDRDtZQUNJLEtBQUssRUFBRSxDQUFDO1lBQ1IsSUFBSSxFQUFFLFlBQVk7WUFDbEIsT0FBTyxFQUFFO2dCQUNM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S0FDSjtDQUNKLENBQUE7QUFFRCxJQUFNLFNBQVMsR0FBRztJQUNkLElBQUksRUFBRSxJQUFJO0NBQ2IsQ0FBQTtBQUVELGtCQUFlLFNBQVMsQ0FBQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKirkuLvnlYzpnaLku7vliqHlvJXlr7wgKi9cclxuXHJcbmNvbnN0IHRhc2sgPSB7XHJcbiAgICBuYW1lOiAnaG9tZScsXHJcbiAgICBkZWJ1ZzogZmFsc2UsXHJcbiAgICBzdGVwczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JkZXI6IDAsICAvL+aVsOe7hOe0ouW8leS4ujBcclxuICAgICAgICAgICAgbmFtZTogJ0d1aWRlVGFzazEnLFxyXG4gICAgICAgICAgICBjb21tYW5kOiB7XHJcbiAgICAgICAgICAgICAgICBjbWQ6ICdtb3ZlZmluZ2VyJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICfngrnlh7vlhpLpmanmjInpkq4nLFxyXG4gICAgICAgICAgICAgICAgYXJnczogJ01haW5MYXllci9Ib21lL2JvdHRvbS9idG5zL2J0bjEnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAuNSxcclxuICAgICAgICAgICAgb25TdGFydChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FeGN1dGUoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRW5kKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9yZGVyOiAxLCAgLy/mlbDnu4TntKLlvJXkuLowXHJcbiAgICAgICAgICAgIG5hbWU6ICdHdWlkZVRhc2sxJyxcclxuICAgICAgICAgICAgY29tbWFuZDoge1xyXG4gICAgICAgICAgICAgICAgY21kOiAnbW92ZWZpbmdlcicsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiAn5YaS6Zmp5YWz6Zet5oyJ6ZKuJyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6ICdEaWFsb2dMYXllci9EbGdMZXZlbC9iZy9jbG9zZUJ1dHRvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGF5VGltZTogMC41LFxyXG4gICAgICAgICAgICBvblN0YXJ0KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkV4Y3V0ZShjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FbmQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JkZXI6IDIsICAvL+aVsOe7hOe0ouW8leS4ujBcclxuICAgICAgICAgICAgbmFtZTogJ0d1aWRlVGFzazEnLFxyXG4gICAgICAgICAgICBjb21tYW5kOiB7XHJcbiAgICAgICAgICAgICAgICBjbWQ6ICdtb3ZlZmluZ2VyJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICfngrnlh7vnrb7liLDmjInpkq4nLFxyXG4gICAgICAgICAgICAgICAgYXJnczogJ01haW5MYXllci9Ib21lL2JvdHRvbS9idG5zL2J0bjInLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAsXHJcbiAgICAgICAgICAgIG9uU3RhcnQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXhjdXRlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVuZChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvcmRlcjogMywgIC8v5pWw57uE57Si5byV5Li6MFxyXG4gICAgICAgICAgICBuYW1lOiAnR3VpZGVUYXNrMScsXHJcbiAgICAgICAgICAgIGNvbW1hbmQ6IHtcclxuICAgICAgICAgICAgICAgIGNtZDogJ21vdmVmaW5nZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ+etvuWIsOWFs+mXreaMiemSricsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiAnRGlhbG9nTGF5ZXIvRGxnU2lnbi9iZy9jbG9zZUJ1dHRvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGF5VGltZTogMC41LFxyXG4gICAgICAgICAgICBvblN0YXJ0KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkV4Y3V0ZShjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FbmQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JkZXI6IDQsICAvL+aVsOe7hOe0ouW8leS4ujBcclxuICAgICAgICAgICAgbmFtZTogJ0d1aWRlVGFzazEnLFxyXG4gICAgICAgICAgICBjb21tYW5kOiB7XHJcbiAgICAgICAgICAgICAgICBjbWQ6ICdtb3ZlZmluZ2VyJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICfngrnlh7vop5LoibLmjInpkq4nLFxyXG4gICAgICAgICAgICAgICAgYXJnczogJ01haW5MYXllci9Ib21lL2JvdHRvbS9idG5zL2J0bjMnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAsXHJcbiAgICAgICAgICAgIG9uU3RhcnQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXhjdXRlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVuZChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvcmRlcjogNSwgIC8v5pWw57uE57Si5byV5Li6MFxyXG4gICAgICAgICAgICBuYW1lOiAnR3VpZGVUYXNrMScsXHJcbiAgICAgICAgICAgIGNvbW1hbmQ6IHtcclxuICAgICAgICAgICAgICAgIGNtZDogJ21vdmVmaW5nZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ+inkuiJsuWFs+mXreaMiemSricsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiAnRGlhbG9nTGF5ZXIvRGxnUm9sZS9iZy9jbG9zZUJ1dHRvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGF5VGltZTogMC41LFxyXG4gICAgICAgICAgICBvblN0YXJ0KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkV4Y3V0ZShjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FbmQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgb3JkZXI6IDYsICAvL+aVsOe7hOe0ouW8leS4ujBcclxuICAgICAgICAgICAgbmFtZTogJ0d1aWRlVGFzazEnLFxyXG4gICAgICAgICAgICBjb21tYW5kOiB7XHJcbiAgICAgICAgICAgICAgICBjbWQ6ICdtb3ZlZmluZ2VyJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6ICfngrnlh7vllYblupfmjInpkq4nLFxyXG4gICAgICAgICAgICAgICAgYXJnczogJ01haW5MYXllci9Ib21lL2JvdHRvbS9idG5zL2J0bjQnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAsXHJcbiAgICAgICAgICAgIG9uU3RhcnQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXhjdXRlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVuZChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvcmRlcjogNywgIC8v5pWw57uE57Si5byV5Li6MFxyXG4gICAgICAgICAgICBuYW1lOiAnR3VpZGVUYXNrMScsXHJcbiAgICAgICAgICAgIGNvbW1hbmQ6IHtcclxuICAgICAgICAgICAgICAgIGNtZDogJ21vdmVmaW5nZXInLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogJ+WVhuW6l+WFs+mXreaMiemSricsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiAnRGlhbG9nTGF5ZXIvRGxnU3RvcmUvYmcvY2xvc2VCdXR0b24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWxheVRpbWU6IDAuNSxcclxuICAgICAgICAgICAgb25TdGFydChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FeGN1dGUoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRW5kKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIF1cclxufVxyXG5cclxuY29uc3QgZ3VpZGVUYXNrID0ge1xyXG4gICAgdGFzazogdGFza1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBndWlkZVRhc2siXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/guide/task/GuideTaskIndex.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, 'b38c71bDMtBXL06617ZK9CT', 'GuideTaskIndex');
// scripts/showcase/home/guide/task/GuideTaskIndex.ts

"use strict";
/**获取任务入口文件 */
Object.defineProperty(exports, "__esModule", { value: true });
var GuideTask1_1 = require("./GuideTask1");
var GuideTask2_1 = require("./GuideTask2");
var guideTasks = {
    guideTask1: GuideTask1_1.default,
    guideTask2: GuideTask2_1.default,
};
exports.default = guideTasks;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXGd1aWRlXFx0YXNrXFxHdWlkZVRhc2tJbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsY0FBYzs7QUFFZCwyQ0FBcUM7QUFDckMsMkNBQXFDO0FBTXJDLElBQU0sVUFBVSxHQUErQjtJQUMzQyxVQUFVLHNCQUFBO0lBQ1YsVUFBVSxzQkFBQTtDQUNiLENBQUE7QUFFRCxrQkFBZSxVQUFVLENBQUEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoq6I635Y+W5Lu75Yqh5YWl5Y+j5paH5Lu2ICovXHJcblxyXG5pbXBvcnQgZ3VpZGVUYXNrMSBmcm9tIFwiLi9HdWlkZVRhc2sxXCJcclxuaW1wb3J0IGd1aWRlVGFzazIgZnJvbSBcIi4vR3VpZGVUYXNrMlwiXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElHdWlkZVRhc2sge1xyXG4gICAgdGFzazogYW55XHJcbn1cclxuXHJcbmNvbnN0IGd1aWRlVGFza3M6IFJlY29yZDxzdHJpbmcsIElHdWlkZVRhc2s+ID0ge1xyXG4gICAgZ3VpZGVUYXNrMSxcclxuICAgIGd1aWRlVGFzazIsXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGd1aWRlVGFza3MiXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/guide/task/GuideTask2.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '5a815umzYdGdLKiGAjSSWzs', 'GuideTask2');
// scripts/showcase/home/guide/task/GuideTask2.ts

"use strict";
/**xx任务引导 */
Object.defineProperty(exports, "__esModule", { value: true });
var task = {
    name: 'xx',
    debug: false,
    steps: [
        {
            order: 0,
            name: 'GuideTask2',
            command: {
                cmd: 'movefinger',
                text: '点击冒险按钮',
                args: 'bottom/btns/btn1',
            },
            delayTime: 0.5,
            onStart: function (callback) {
                callback();
            },
            onExcute: function (callback) {
                callback();
            },
            onEnd: function (callback) {
                callback();
            }
        }
    ]
};
var guideTask = {
    task: task
};
exports.default = guideTask;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXGd1aWRlXFx0YXNrXFxHdWlkZVRhc2syLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxZQUFZOztBQUVaLElBQU0sSUFBSSxHQUFHO0lBQ1QsSUFBSSxFQUFFLElBQUk7SUFDVixLQUFLLEVBQUUsS0FBSztJQUNaLEtBQUssRUFBRTtRQUNIO1lBQ0ksS0FBSyxFQUFFLENBQUM7WUFDUixJQUFJLEVBQUUsWUFBWTtZQUNsQixPQUFPLEVBQUU7Z0JBQ0wsR0FBRyxFQUFFLFlBQVk7Z0JBQ2pCLElBQUksRUFBRSxRQUFRO2dCQUNkLElBQUksRUFBRSxrQkFBa0I7YUFDM0I7WUFDRCxTQUFTLEVBQUUsR0FBRztZQUNkLE9BQU8sWUFBQyxRQUFRO2dCQUNaLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztZQUNELFFBQVEsWUFBQyxRQUFRO2dCQUNiLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztZQUNELEtBQUssWUFBQyxRQUFRO2dCQUNWLFFBQVEsRUFBRSxDQUFDO1lBQ2YsQ0FBQztTQUNKO0tBQ0o7Q0FDSixDQUFBO0FBRUQsSUFBTSxTQUFTLEdBQUc7SUFDZCxJQUFJLEVBQUUsSUFBSTtDQUNiLENBQUE7QUFFRCxrQkFBZSxTQUFTLENBQUEiLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqeHjku7vliqHlvJXlr7wgKi9cclxuXHJcbmNvbnN0IHRhc2sgPSB7XHJcbiAgICBuYW1lOiAneHgnLFxyXG4gICAgZGVidWc6IGZhbHNlLFxyXG4gICAgc3RlcHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9yZGVyOiAwLCAgLy/mlbDnu4TntKLlvJXkuLowXHJcbiAgICAgICAgICAgIG5hbWU6ICdHdWlkZVRhc2syJyxcclxuICAgICAgICAgICAgY29tbWFuZDoge1xyXG4gICAgICAgICAgICAgICAgY21kOiAnbW92ZWZpbmdlcicsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiAn54K55Ye75YaS6Zmp5oyJ6ZKuJyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6ICdib3R0b20vYnRucy9idG4xJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVsYXlUaW1lOiAwLjUsXHJcbiAgICAgICAgICAgIG9uU3RhcnQoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uRXhjdXRlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkVuZChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF1cclxufVxyXG5cclxuY29uc3QgZ3VpZGVUYXNrID0ge1xyXG4gICAgdGFzazogdGFza1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBndWlkZVRhc2siXX0=
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/__node_modules/async/dist/async.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}(function (process){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.async = {})));
}(this, (function (exports) { 'use strict';

    /**
     * Creates a continuation function with some arguments already applied.
     *
     * Useful as a shorthand when combined with other control flow functions. Any
     * arguments passed to the returned function are added to the arguments
     * originally passed to apply.
     *
     * @name apply
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {Function} fn - The function you want to eventually apply all
     * arguments to. Invokes with (arguments...).
     * @param {...*} arguments... - Any number of arguments to automatically apply
     * when the continuation is called.
     * @returns {Function} the partially-applied function
     * @example
     *
     * // using apply
     * async.parallel([
     *     async.apply(fs.writeFile, 'testfile1', 'test1'),
     *     async.apply(fs.writeFile, 'testfile2', 'test2')
     * ]);
     *
     *
     * // the same process without using apply
     * async.parallel([
     *     function(callback) {
     *         fs.writeFile('testfile1', 'test1', callback);
     *     },
     *     function(callback) {
     *         fs.writeFile('testfile2', 'test2', callback);
     *     }
     * ]);
     *
     * // It's possible to pass any number of additional arguments when calling the
     * // continuation:
     *
     * node> var fn = async.apply(sys.puts, 'one');
     * node> fn('two', 'three');
     * one
     * two
     * three
     */
    function apply(fn, ...args) {
        return (...callArgs) => fn(...args,...callArgs);
    }

    function initialParams (fn) {
        return function (...args/*, callback*/) {
            var callback = args.pop();
            return fn.call(this, args, callback);
        };
    }

    /* istanbul ignore file */

    var hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
    var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

    function fallback(fn) {
        setTimeout(fn, 0);
    }

    function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
    }

    var _defer;

    if (hasQueueMicrotask) {
        _defer = queueMicrotask;
    } else if (hasSetImmediate) {
        _defer = setImmediate;
    } else if (hasNextTick) {
        _defer = process.nextTick;
    } else {
        _defer = fallback;
    }

    var setImmediate$1 = wrap(_defer);

    /**
     * Take a sync function and make it async, passing its return value to a
     * callback. This is useful for plugging sync functions into a waterfall,
     * series, or other async functions. Any arguments passed to the generated
     * function will be passed to the wrapped function (except for the final
     * callback argument). Errors thrown will be passed to the callback.
     *
     * If the function passed to `asyncify` returns a Promise, that promises's
     * resolved/rejected state will be used to call the callback, rather than simply
     * the synchronous return value.
     *
     * This also means you can asyncify ES2017 `async` functions.
     *
     * @name asyncify
     * @static
     * @memberOf module:Utils
     * @method
     * @alias wrapSync
     * @category Util
     * @param {Function} func - The synchronous function, or Promise-returning
     * function to convert to an {@link AsyncFunction}.
     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
     * invoked with `(args..., callback)`.
     * @example
     *
     * // passing a regular synchronous function
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(JSON.parse),
     *     function (data, next) {
     *         // data is the result of parsing the text.
     *         // If there was a parsing error, it would have been caught.
     *     }
     * ], callback);
     *
     * // passing a function returning a promise
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(function (contents) {
     *         return db.model.create(contents);
     *     }),
     *     function (model, next) {
     *         // `model` is the instantiated model object.
     *         // If there was an error, this function would be skipped.
     *     }
     * ], callback);
     *
     * // es2017 example, though `asyncify` is not needed if your JS environment
     * // supports async functions out of the box
     * var q = async.queue(async.asyncify(async function(file) {
     *     var intermediateStep = await processFile(file);
     *     return await somePromise(intermediateStep)
     * }));
     *
     * q.push(files);
     */
    function asyncify(func) {
        if (isAsync(func)) {
            return function (...args/*, callback*/) {
                const callback = args.pop();
                const promise = func.apply(this, args);
                return handlePromise(promise, callback)
            }
        }

        return initialParams(function (args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (result && typeof result.then === 'function') {
                return handlePromise(result, callback)
            } else {
                callback(null, result);
            }
        });
    }

    function handlePromise(promise, callback) {
        return promise.then(value => {
            invokeCallback(callback, null, value);
        }, err => {
            invokeCallback(callback, err && err.message ? err : new Error(err));
        });
    }

    function invokeCallback(callback, error, value) {
        try {
            callback(error, value);
        } catch (err) {
            setImmediate$1(e => { throw e }, err);
        }
    }

    function isAsync(fn) {
        return fn[Symbol.toStringTag] === 'AsyncFunction';
    }

    function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === 'AsyncGenerator';
    }

    function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === 'function';
    }

    function wrapAsync(asyncFn) {
        if (typeof asyncFn !== 'function') throw new Error('expected a function')
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }

    // conditionally promisify a function.
    // only return a promise if a callback is omitted
    function awaitify (asyncFn, arity = asyncFn.length) {
        if (!arity) throw new Error('arity is undefined')
        function awaitable (...args) {
            if (typeof args[arity - 1] === 'function') {
                return asyncFn.apply(this, args)
            }

            return new Promise((resolve, reject) => {
                args[arity - 1] = (err, ...cbArgs) => {
                    if (err) return reject(err)
                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
                };
                asyncFn.apply(this, args);
            })
        }

        return awaitable
    }

    function applyEach (eachfn) {
        return function applyEach(fns, ...callArgs) {
            const go = awaitify(function (callback) {
                var that = this;
                return eachfn(fns, (fn, cb) => {
                    wrapAsync(fn).apply(that, callArgs.concat(cb));
                }, callback);
            });
            return go;
        };
    }

    function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);

        return eachfn(arr, (value, _, iterCb) => {
            var index = counter++;
            _iteratee(value, (err, v) => {
                results[index] = v;
                iterCb(err);
            });
        }, err => {
            callback(err, results);
        });
    }

    function isArrayLike(value) {
        return value &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            value.length % 1 === 0;
    }

    // A temporary value used to identify if the loop should be broken.
    // See #1064, #1293
    const breakLoop = {};

    function once(fn) {
        function wrapper (...args) {
            if (fn === null) return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper
    }

    function getIterator (coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }

    function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
            return ++i < len ? {value: coll[i], key: i} : null;
        }
    }

    function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
            var item = iterator.next();
            if (item.done)
                return null;
            i++;
            return {value: item.value, key: i};
        }
    }

    function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
            var key = okeys[++i];
            if (key === '__proto__') {
                return next();
            }
            return i < len ? {value: obj[key], key} : null;
        };
    }

    function createIterator(coll) {
        if (isArrayLike(coll)) {
            return createArrayIterator(coll);
        }

        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }

    function onlyOnce(fn) {
        return function (...args) {
            if (fn === null) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        };
    }

    // for async generators
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;

        function replenish() {
            //console.log('replenish')
            if (running >= limit || awaiting || done) return
            //console.log('replenish awaiting')
            awaiting = true;
            generator.next().then(({value, done: iterDone}) => {
                //console.log('got value', value)
                if (canceled || done) return
                awaiting = false;
                if (iterDone) {
                    done = true;
                    if (running <= 0) {
                        //console.log('done nextCb')
                        callback(null);
                    }
                    return;
                }
                running++;
                iteratee(value, idx, iterateeCallback);
                idx++;
                replenish();
            }).catch(handleError);
        }

        function iterateeCallback(err, result) {
            //console.log('iterateeCallback')
            running -= 1;
            if (canceled) return
            if (err) return handleError(err)

            if (err === false) {
                done = true;
                canceled = true;
                return
            }

            if (result === breakLoop || (done && running <= 0)) {
                done = true;
                //console.log('done iterCb')
                return callback(null);
            }
            replenish();
        }

        function handleError(err) {
            if (canceled) return
            awaiting = false;
            done = true;
            callback(err);
        }

        replenish();
    }

    var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
            callback = once(callback);
            if (limit <= 0) {
                throw new RangeError('concurrency limit cannot be less than 1')
            }
            if (!obj) {
                return callback(null);
            }
            if (isAsyncGenerator(obj)) {
                return asyncEachOfLimit(obj, limit, iteratee, callback)
            }
            if (isAsyncIterable(obj)) {
                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)
            }
            var nextElem = createIterator(obj);
            var done = false;
            var canceled = false;
            var running = 0;
            var looping = false;

            function iterateeCallback(err, value) {
                if (canceled) return
                running -= 1;
                if (err) {
                    done = true;
                    callback(err);
                }
                else if (err === false) {
                    done = true;
                    canceled = true;
                }
                else if (value === breakLoop || (done && running <= 0)) {
                    done = true;
                    return callback(null);
                }
                else if (!looping) {
                    replenish();
                }
            }

            function replenish () {
                looping = true;
                while (running < limit && !done) {
                    var elem = nextElem();
                    if (elem === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
                looping = false;
            }

            replenish();
        };
    };

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name eachOfLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`. The `key` is the item's key, or index in the case of an
     * array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
    }

    var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);

    // eachOf implementation optimized for array-likes
    function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index = 0,
            completed = 0,
            {length} = coll,
            canceled = false;
        if (length === 0) {
            callback(null);
        }

        function iteratorCallback(err, value) {
            if (err === false) {
                canceled = true;
            }
            if (canceled === true) return
            if (err) {
                callback(err);
            } else if ((++completed === length) || value === breakLoop) {
                callback(null);
            }
        }

        for (; index < length; index++) {
            iteratee(coll[index], index, onlyOnce(iteratorCallback));
        }
    }

    // a generic version of eachOf which can handle array, object, and iterator cases.
    function eachOfGeneric (coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
    }

    /**
     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
     * to the iteratee.
     *
     * @name eachOf
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEachOf
     * @category Collection
     * @see [async.each]{@link module:Collections.each}
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each
     * item in `coll`.
     * The `key` is the item's key, or index in the case of an array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dev.json is a file containing a valid json object config for dev environment
     * // dev.json is a file containing a valid json object config for test environment
     * // prod.json is a file containing a valid json object config for prod environment
     * // invalid.json is a file with a malformed json object
     *
     * let configs = {}; //global variable
     * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
     * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
     *
     * // asynchronous function that reads a json file and parses the contents as json object
     * function parseFile(file, key, callback) {
     *     fs.readFile(file, "utf8", function(err, data) {
     *         if (err) return calback(err);
     *         try {
     *             configs[key] = JSON.parse(data);
     *         } catch (e) {
     *             return callback(e);
     *         }
     *         callback();
     *     });
     * }
     *
     * // Using callbacks
     * async.forEachOf(validConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *         // JSON parse error exception
     *     } else {
     *         console.log(configs);
     *     }
     * });
     *
     * // Using Promises
     * async.forEachOf(validConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     *     // configs is now a map of JSON data, e.g.
     *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     * }).catch( err => {
     *     console.error(err);
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     * }).catch( err => {
     *     console.error(err);
     *     // JSON parse error exception
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.forEachOf(validConfigFileMap, parseFile);
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * //Error handing
     * async () => {
     *     try {
     *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
     *         console.log(configs);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // JSON parse error exception
     *     }
     * }
     *
     */
    function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }

    var eachOf$1 = awaitify(eachOf, 3);

    /**
     * Produces a new collection of values by mapping each value in `coll` through
     * the `iteratee` function. The `iteratee` is called with an item from `coll`
     * and a callback for when it has finished processing. Each of these callbacks
     * takes 2 arguments: an `error`, and the transformed item from `coll`. If
     * `iteratee` passes an error to its callback, the main `callback` (for the
     * `map` function) is immediately called with the error.
     *
     * Note, that since this function applies the `iteratee` to each item in
     * parallel, there is no guarantee that the `iteratee` functions will complete
     * in order. However, the results array will be in the same order as the
     * original `coll`.
     *
     * If `map` is passed an Object, the results will be an Array.  The results
     * will roughly be in the order of the original Objects' keys (but this can
     * vary across JavaScript engines).
     *
     * @name map
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an Array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.map(fileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(results);
     *     }
     * });
     *
     * // Using Promises
     * async.map(fileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now an array of the file size in bytes for each file, e.g.
     *     // [ 1000, 2000, 3000]
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.map(fileList, getFileSizeInBytes);
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.map(withMissingFileList, getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function map (coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback)
    }
    var map$1 = awaitify(map, 3);

    /**
     * Applies the provided arguments to each function in the array, calling
     * `callback` after all functions have completed. If you only provide the first
     * argument, `fns`, then it will return a function which lets you pass in the
     * arguments as if it were a single function call. If more arguments are
     * provided, `callback` is required while `args` is still optional. The results
     * for each of the applied async functions are passed to the final callback
     * as an array.
     *
     * @name applyEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
     * to all call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - Returns a function that takes no args other than
     * an optional callback, that is the result of applying the `args` to each
     * of the functions.
     * @example
     *
     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
     *
     * appliedFn((err, results) => {
     *     // results[0] is the results for `enableSearch`
     *     // results[1] is the results for `updateSchema`
     * });
     *
     * // partial application example:
     * async.each(
     *     buckets,
     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
     *     callback
     * );
     */
    var applyEach$1 = applyEach(map$1);

    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
     *
     * @name eachOfSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback)
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);

    /**
     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
     *
     * @name mapSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapSeries (coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback)
    }
    var mapSeries$1 = awaitify(mapSeries, 3);

    /**
     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
     *
     * @name applyEachSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.applyEach]{@link module:ControlFlow.applyEach}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
     * call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - A function, that when called, is the result of
     * appling the `args` to the list of functions.  It takes no args, other than
     * a callback.
     */
    var applyEachSeries = applyEach(mapSeries$1);

    const PROMISE_SYMBOL = Symbol('promiseCallback');

    function promiseCallback () {
        let resolve, reject;
        function callback (err, ...args) {
            if (err) return reject(err)
            resolve(args.length > 1 ? args : args[0]);
        }

        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
            resolve = res,
            reject = rej;
        });

        return callback
    }

    /**
     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
     * their requirements. Each function can optionally depend on other functions
     * being completed first, and each function is run as soon as its requirements
     * are satisfied.
     *
     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
     * will stop. Further tasks will not execute (so any other functions depending
     * on it will not run), and the main `callback` is immediately called with the
     * error.
     *
     * {@link AsyncFunction}s also receive an object containing the results of functions which
     * have completed so far as the first argument, if they have dependencies. If a
     * task function has no dependencies, it will only be passed a callback.
     *
     * @name auto
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Object} tasks - An object. Each of its properties is either a
     * function or an array of requirements, with the {@link AsyncFunction} itself the last item
     * in the array. The object's key of a property serves as the name of the task
     * defined by that property, i.e. can be used when specifying requirements for
     * other tasks. The function receives one or two arguments:
     * * a `results` object, containing the results of the previously executed
     *   functions, only passed if the task has any dependencies,
     * * a `callback(err, result)` function, which must be called when finished,
     *   passing an `error` (which can be `null`) and the result of the function's
     *   execution.
     * @param {number} [concurrency=Infinity] - An optional `integer` for
     * determining the maximum number of tasks that can be run in parallel. By
     * default, as many as possible.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback. Results are always returned; however, if an
     * error occurs, no further `tasks` will be performed, and the results object
     * will only contain partial results. Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     * @example
     *
     * //Using Callbacks
     * async.auto({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }, function(err, results) {
     *     if (err) {
     *         console.log('err = ', err);
     *     }
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * });
     *
     * //Using Promises
     * async.auto({
     *     get_data: function(callback) {
     *         console.log('in get_data');
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         console.log('in make_folder');
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }).then(results => {
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * }).catch(err => {
     *     console.log('err = ', err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.auto({
     *             get_data: function(callback) {
     *                 // async code to get some data
     *                 callback(null, 'data', 'converted to array');
     *             },
     *             make_folder: function(callback) {
     *                 // async code to create a directory to store a file in
     *                 // this is run at the same time as getting the data
     *                 callback(null, 'folder');
     *             },
     *             write_file: ['get_data', 'make_folder', function(results, callback) {
     *                 // once there is some data and the directory exists,
     *                 // write the data to a file in the directory
     *                 callback(null, 'filename');
     *             }],
     *             email_link: ['write_file', function(results, callback) {
     *                 // once the file is written let's email a link to it...
     *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *             }]
     *         });
     *         console.log('results = ', results);
     *         // results = {
     *         //     get_data: ['data', 'converted to array']
     *         //     make_folder; 'folder',
     *         //     write_file: 'filename'
     *         //     email_link: { file: 'filename', email: 'user@example.com' }
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== 'number') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = numTasks;
        }

        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;

        var listeners = Object.create(null);

        var readyTasks = [];

        // for cycle detection:
        var readyToCheck = []; // tasks that have been identified as reachable
        // without the possibility of returning to an ancestor task
        var uncheckedDependencies = {};

        Object.keys(tasks).forEach(key => {
            var task = tasks[key];
            if (!Array.isArray(task)) {
                // no dependencies
                enqueueTask(key, [task]);
                readyToCheck.push(key);
                return;
            }

            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
                enqueueTask(key, task);
                readyToCheck.push(key);
                return;
            }
            uncheckedDependencies[key] = remainingDependencies;

            dependencies.forEach(dependencyName => {
                if (!tasks[dependencyName]) {
                    throw new Error('async.auto task `' + key +
                        '` has a non-existent dependency `' +
                        dependencyName + '` in ' +
                        dependencies.join(', '));
                }
                addListener(dependencyName, () => {
                    remainingDependencies--;
                    if (remainingDependencies === 0) {
                        enqueueTask(key, task);
                    }
                });
            });
        });

        checkForDeadlocks();
        processQueue();

        function enqueueTask(key, task) {
            readyTasks.push(() => runTask(key, task));
        }

        function processQueue() {
            if (canceled) return
            if (readyTasks.length === 0 && runningTasks === 0) {
                return callback(null, results);
            }
            while(readyTasks.length && runningTasks < concurrency) {
                var run = readyTasks.shift();
                run();
            }

        }

        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
                taskListeners = listeners[taskName] = [];
            }

            taskListeners.push(fn);
        }

        function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            taskListeners.forEach(fn => fn());
            processQueue();
        }


        function runTask(key, task) {
            if (hasError) return;

            var taskCallback = onlyOnce((err, ...result) => {
                runningTasks--;
                if (err === false) {
                    canceled = true;
                    return
                }
                if (result.length < 2) {
                    [result] = result;
                }
                if (err) {
                    var safeResults = {};
                    Object.keys(results).forEach(rkey => {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[key] = result;
                    hasError = true;
                    listeners = Object.create(null);
                    if (canceled) return
                    callback(err, safeResults);
                } else {
                    results[key] = result;
                    taskComplete(key);
                }
            });

            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
                taskFn(results, taskCallback);
            } else {
                taskFn(taskCallback);
            }
        }

        function checkForDeadlocks() {
            // Kahn's algorithm
            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
                currentTask = readyToCheck.pop();
                counter++;
                getDependents(currentTask).forEach(dependent => {
                    if (--uncheckedDependencies[dependent] === 0) {
                        readyToCheck.push(dependent);
                    }
                });
            }

            if (counter !== numTasks) {
                throw new Error(
                    'async.auto cannot execute tasks due to a recursive dependency'
                );
            }
        }

        function getDependents(taskName) {
            var result = [];
            Object.keys(tasks).forEach(key => {
                const task = tasks[key];
                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                    result.push(key);
                }
            });
            return result;
        }

        return callback[PROMISE_SYMBOL]
    }

    var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;

    function stripComments(string) {
        let stripped = '';
        let index = 0;
        let endBlockComment = string.indexOf('*/');
        while (index < string.length) {
            if (string[index] === '/' && string[index+1] === '/') {
                // inline comment
                let endIndex = string.indexOf('\n', index);
                index = (endIndex === -1) ? string.length : endIndex;
            } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {
                // block comment
                let endIndex = string.indexOf('*/', index);
                if (endIndex !== -1) {
                    index = endIndex + 2;
                    endBlockComment = string.indexOf('*/', index);
                } else {
                    stripped += string[index];
                    index++;
                }
            } else {
                stripped += string[index];
                index++;
            }
        }
        return stripped;
    }

    function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
            match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error('could not parse args in autoInject\nSource:\n' + src)
        let [, args] = match;
        return args
            .replace(/\s/g, '')
            .split(FN_ARG_SPLIT)
            .map((arg) => arg.replace(FN_ARG, '').trim());
    }

    /**
     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
     * tasks are specified as parameters to the function, after the usual callback
     * parameter, with the parameter names matching the names of the tasks it
     * depends on. This can provide even more readable task graphs which can be
     * easier to maintain.
     *
     * If a final callback is specified, the task results are similarly injected,
     * specified as named parameters after the initial error parameter.
     *
     * The autoInject function is purely syntactic sugar and its semantics are
     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
     *
     * @name autoInject
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.auto]{@link module:ControlFlow.auto}
     * @category Control Flow
     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
     * the form 'func([dependencies...], callback). The object's key of a property
     * serves as the name of the task defined by that property, i.e. can be used
     * when specifying requirements for other tasks.
     * * The `callback` parameter is a `callback(err, result)` which must be called
     *   when finished, passing an `error` (which can be `null`) and the result of
     *   the function's execution. The remaining parameters name other tasks on
     *   which the task is dependent, and the results from those tasks are the
     *   arguments of those parameters.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback, and a `results` object with any completed
     * task results, similar to `auto`.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * //  The example from `auto` can be rewritten as follows:
     * async.autoInject({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: function(get_data, make_folder, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     },
     *     email_link: function(write_file, callback) {
     *         // once the file is written let's email a link to it...
     *         // write_file contains the filename returned by write_file.
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     *
     * // If you are using a JS minifier that mangles parameter names, `autoInject`
     * // will not work with plain functions, since the parameter names will be
     * // collapsed to a single letter identifier.  To work around this, you can
     * // explicitly specify the names of the parameters your task function needs
     * // in an array, similar to Angular.js dependency injection.
     *
     * // This still has an advantage over plain `auto`, since the results a task
     * // depends on are still spread into arguments.
     * async.autoInject({
     *     //...
     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(write_file, callback) {
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }]
     *     //...
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     */
    function autoInject(tasks, callback) {
        var newTasks = {};

        Object.keys(tasks).forEach(key => {
            var taskFn = tasks[key];
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps =
                (!fnIsAsync && taskFn.length === 1) ||
                (fnIsAsync && taskFn.length === 0);

            if (Array.isArray(taskFn)) {
                params = [...taskFn];
                taskFn = params.pop();

                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
                // no dependencies, use the function as-is
                newTasks[key] = taskFn;
            } else {
                params = parseParams(taskFn);
                if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {
                    throw new Error("autoInject task functions require explicit parameters.");
                }

                // remove callback param
                if (!fnIsAsync) params.pop();

                newTasks[key] = params.concat(newTask);
            }

            function newTask(results, taskCb) {
                var newArgs = params.map(name => results[name]);
                newArgs.push(taskCb);
                wrapAsync(taskFn)(...newArgs);
            }
        });

        return auto(newTasks, callback);
    }

    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
    // used for queues. This implementation assumes that the node provided by the user can be modified
    // to adjust the next and last properties. We implement only the minimal functionality
    // for queue support.
    class DLL {
        constructor() {
            this.head = this.tail = null;
            this.length = 0;
        }

        removeLink(node) {
            if (node.prev) node.prev.next = node.next;
            else this.head = node.next;
            if (node.next) node.next.prev = node.prev;
            else this.tail = node.prev;

            node.prev = node.next = null;
            this.length -= 1;
            return node;
        }

        empty () {
            while(this.head) this.shift();
            return this;
        }

        insertAfter(node, newNode) {
            newNode.prev = node;
            newNode.next = node.next;
            if (node.next) node.next.prev = newNode;
            else this.tail = newNode;
            node.next = newNode;
            this.length += 1;
        }

        insertBefore(node, newNode) {
            newNode.prev = node.prev;
            newNode.next = node;
            if (node.prev) node.prev.next = newNode;
            else this.head = newNode;
            node.prev = newNode;
            this.length += 1;
        }

        unshift(node) {
            if (this.head) this.insertBefore(this.head, node);
            else setInitial(this, node);
        }

        push(node) {
            if (this.tail) this.insertAfter(this.tail, node);
            else setInitial(this, node);
        }

        shift() {
            return this.head && this.removeLink(this.head);
        }

        pop() {
            return this.tail && this.removeLink(this.tail);
        }

        toArray() {
            return [...this]
        }

        *[Symbol.iterator] () {
            var cur = this.head;
            while (cur) {
                yield cur.data;
                cur = cur.next;
            }
        }

        remove (testFn) {
            var curr = this.head;
            while(curr) {
                var {next} = curr;
                if (testFn(curr)) {
                    this.removeLink(curr);
                }
                curr = next;
            }
            return this;
        }
    }

    function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
    }

    function queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new RangeError('Concurrency must not be zero');
        }

        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
            error: [],
            drain: [],
            saturated: [],
            unsaturated: [],
            empty: []
        };

        function on (event, handler) {
            events[event].push(handler);
        }

        function once (event, handler) {
            const handleAndRemove = (...args) => {
                off(event, handleAndRemove);
                handler(...args);
            };
            events[event].push(handleAndRemove);
        }

        function off (event, handler) {
            if (!event) return Object.keys(events).forEach(ev => events[ev] = [])
            if (!handler) return events[event] = []
            events[event] = events[event].filter(ev => ev !== handler);
        }

        function trigger (event, ...args) {
            events[event].forEach(handler => handler(...args));
        }

        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
            if (callback != null && typeof callback !== 'function') {
                throw new Error('task callback must be a function');
            }
            q.started = true;

            var res, rej;
            function promiseCallback (err, ...args) {
                // we don't care about the error, let the global error handler
                // deal with it
                if (err) return rejectOnError ? rej(err) : res()
                if (args.length <= 1) return res(args[0])
                res(args);
            }

            var item = q._createTaskItem(
                data,
                rejectOnError ? promiseCallback :
                    (callback || promiseCallback)
            );

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }

            if (!processingScheduled) {
                processingScheduled = true;
                setImmediate$1(() => {
                    processingScheduled = false;
                    q.process();
                });
            }

            if (rejectOnError || !callback) {
                return new Promise((resolve, reject) => {
                    res = resolve;
                    rej = reject;
                })
            }
        }

        function _createCB(tasks) {
            return function (err, ...args) {
                numRunning -= 1;

                for (var i = 0, l = tasks.length; i < l; i++) {
                    var task = tasks[i];

                    var index = workersList.indexOf(task);
                    if (index === 0) {
                        workersList.shift();
                    } else if (index > 0) {
                        workersList.splice(index, 1);
                    }

                    task.callback(err, ...args);

                    if (err != null) {
                        trigger('error', err, task.data);
                    }
                }

                if (numRunning <= (q.concurrency - q.buffer) ) {
                    trigger('unsaturated');
                }

                if (q.idle()) {
                    trigger('drain');
                }
                q.process();
            };
        }

        function _maybeDrain(data) {
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                setImmediate$1(() => trigger('drain'));
                return true
            }
            return false
        }

        const eventMethod = (name) => (handler) => {
            if (!handler) {
                return new Promise((resolve, reject) => {
                    once(name, (err, data) => {
                        if (err) return reject(err)
                        resolve(data);
                    });
                })
            }
            off(name);
            on(name, handler);

        };

        var isProcessing = false;
        var q = {
            _tasks: new DLL(),
            _createTaskItem (data, callback) {
                return {
                    data,
                    callback
                };
            },
            *[Symbol.iterator] () {
                yield* q._tasks[Symbol.iterator]();
            },
            concurrency,
            payload,
            buffer: concurrency / 4,
            started: false,
            paused: false,
            push (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, false, callback))
                }
                return _insert(data, false, false, callback);
            },
            pushAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, false, true, callback))
                }
                return _insert(data, false, true, callback);
            },
            kill () {
                off();
                q._tasks.empty();
            },
            unshift (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, false, callback))
                }
                return _insert(data, true, false, callback);
            },
            unshiftAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return
                    return data.map(datum => _insert(datum, true, true, callback))
                }
                return _insert(data, true, true, callback);
            },
            remove (testFn) {
                q._tasks.remove(testFn);
            },
            process () {
                // Avoid trying to start too many processing operations. This can occur
                // when callbacks resolve synchronously (#1267).
                if (isProcessing) {
                    return;
                }
                isProcessing = true;
                while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                    var tasks = [], data = [];
                    var l = q._tasks.length;
                    if (q.payload) l = Math.min(l, q.payload);
                    for (var i = 0; i < l; i++) {
                        var node = q._tasks.shift();
                        tasks.push(node);
                        workersList.push(node);
                        data.push(node.data);
                    }

                    numRunning += 1;

                    if (q._tasks.length === 0) {
                        trigger('empty');
                    }

                    if (numRunning === q.concurrency) {
                        trigger('saturated');
                    }

                    var cb = onlyOnce(_createCB(tasks));
                    _worker(data, cb);
                }
                isProcessing = false;
            },
            length () {
                return q._tasks.length;
            },
            running () {
                return numRunning;
            },
            workersList () {
                return workersList;
            },
            idle() {
                return q._tasks.length + numRunning === 0;
            },
            pause () {
                q.paused = true;
            },
            resume () {
                if (q.paused === false) { return; }
                q.paused = false;
                setImmediate$1(q.process);
            }
        };
        // define these as fixed properties, so people get useful errors when updating
        Object.defineProperties(q, {
            saturated: {
                writable: false,
                value: eventMethod('saturated')
            },
            unsaturated: {
                writable: false,
                value: eventMethod('unsaturated')
            },
            empty: {
                writable: false,
                value: eventMethod('empty')
            },
            drain: {
                writable: false,
                value: eventMethod('drain')
            },
            error: {
                writable: false,
                value: eventMethod('error')
            },
        });
        return q;
    }

    /**
     * Creates a `cargo` object with the specified payload. Tasks added to the
     * cargo will be processed altogether (up to the `payload` limit). If the
     * `worker` is in progress, the task is queued until it becomes available. Once
     * the `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, cargo passes an array of tasks to a single worker, repeating
     * when the worker is finished.
     *
     * @name cargo
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargo and inner queue.
     * @example
     *
     * // create a cargo object with payload 2
     * var cargo = async.cargo(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2);
     *
     * // add some items
     * cargo.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargo.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * await cargo.push({name: 'baz'});
     * console.log('finished processing baz');
     */
    function cargo(worker, payload) {
        return queue(worker, 1, payload);
    }

    /**
     * Creates a `cargoQueue` object with the specified payload. Tasks added to the
     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
     * If the all `workers` are in progress, the task is queued until one becomes available. Once
     * a `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
     * the cargoQueue passes an array of tasks to multiple parallel workers.
     *
     * @name cargoQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @see [async.cargo]{@link module:ControlFLow.cargo}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargoQueue and inner queue.
     * @example
     *
     * // create a cargoQueue object with payload 2 and concurrency 2
     * var cargoQueue = async.cargoQueue(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2, 2);
     *
     * // add some items
     * cargoQueue.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargoQueue.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * cargoQueue.push({name: 'baz'}, function(err) {
     *     console.log('finished processing baz');
     * });
     * cargoQueue.push({name: 'boo'}, function(err) {
     *     console.log('finished processing boo');
     * });
     */
    function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
    }

    /**
     * Reduces `coll` into a single value using an async `iteratee` to return each
     * successive step. `memo` is the initial state of the reduction. This function
     * only operates in series.
     *
     * For performance reasons, it may make sense to split a call to this function
     * into a parallel map, and then use the normal `Array.prototype.reduce` on the
     * results. This function is for situations where each step in the reduction
     * needs to be async; if you can get the data before reducing it, then it's
     * probably a good idea to do so.
     *
     * @name reduce
     * @static
     * @memberOf module:Collections
     * @method
     * @alias inject
     * @alias foldl
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];
     *
     * // asynchronous function that computes the file size in bytes
     * // file size is added to the memoized value, then returned
     * function getFileSizeInBytes(memo, file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, memo + stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.reduce(fileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // 6000
     *     // which is the sum of the file sizes of the three files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
            _iteratee(memo, x, (err, v) => {
                memo = v;
                iterCb(err);
            });
        }, err => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);

    /**
     * Version of the compose function that is more natural to read. Each function
     * consumes the return value of the previous function. It is the equivalent of
     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name seq
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.compose]{@link module:ControlFlow.compose}
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} a function that composes the `functions` in order
     * @example
     *
     * // Requires lodash (or underscore), express3 and dresende's orm2.
     * // Part of an app, that fetches cats of the logged user.
     * // This example uses `seq` function to avoid overnesting and error
     * // handling clutter.
     * app.get('/cats', function(request, response) {
     *     var User = request.models.User;
     *     async.seq(
     *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))
     *         function(user, fn) {
     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
     *         }
     *     )(req.session.user_id, function (err, cats) {
     *         if (err) {
     *             console.error(err);
     *             response.json({ status: 'error', message: err.message });
     *         } else {
     *             response.json({ status: 'ok', message: 'Cats found', data: cats });
     *         }
     *     });
     * });
     */
    function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function (...args) {
            var that = this;

            var cb = args[args.length - 1];
            if (typeof cb == 'function') {
                args.pop();
            } else {
                cb = promiseCallback();
            }

            reduce$1(_functions, args, (newargs, fn, iterCb) => {
                fn.apply(that, newargs.concat((err, ...nextargs) => {
                    iterCb(err, nextargs);
                }));
            },
            (err, results) => cb(err, ...results));

            return cb[PROMISE_SYMBOL]
        };
    }

    /**
     * Creates a function which is a composition of the passed asynchronous
     * functions. Each function consumes the return value of the function that
     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
     *
     * If the last argument to the composed function is not a function, a promise
     * is returned when you call it.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name compose
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} an asynchronous function that is the composed
     * asynchronous `functions`
     * @example
     *
     * function add1(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n + 1);
     *     }, 10);
     * }
     *
     * function mul3(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n * 3);
     *     }, 10);
     * }
     *
     * var add1mul3 = async.compose(mul3, add1);
     * add1mul3(4, function (err, result) {
     *     // result now equals 15
     * });
     */
    function compose(...args) {
        return seq(...args.reverse());
    }

    /**
     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
     *
     * @name mapLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapLimit (coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)
    }
    var mapLimit$1 = awaitify(mapLimit, 4);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
     *
     * @name concatLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapLimit
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, ...args) => {
                if (err) return iterCb(err);
                return iterCb(err, args);
            });
        }, (err, mapResults) => {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    result = result.concat(...mapResults[i]);
                }
            }

            return callback(err, result);
        });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);

    /**
     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
     * the concatenated list. The `iteratee`s are called in parallel, and the
     * results are concatenated as they return. The results array will be returned in
     * the original order of `coll` passed to the `iteratee` function.
     *
     * @name concat
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @alias flatMap
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * let directoryList = ['dir1','dir2','dir3'];
     * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];
     *
     * // Using callbacks
     * async.concat(directoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *    }
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *        // [ Error: ENOENT: no such file or directory ]
     *        // since dir4 does not exist
     *    } else {
     *        console.log(results);
     *    }
     * });
     *
     * // Using Promises
     * async.concat(directoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     * }).catch(err => {
     *      console.log(err);
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     * }).catch(err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4 does not exist
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.concat(directoryList, fs.readdir);
     *         console.log(results);
     *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *     } catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.concat(withMissingDirectoryList, fs.readdir);
     *         console.log(results);
     *     } catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4 does not exist
     *     }
     * }
     *
     */
    function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback)
    }
    var concat$1 = awaitify(concat, 3);

    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
     *
     * @name concatSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapSeries
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
     * The iteratee should complete with an array an array of results.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */
    function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback)
    }
    var concatSeries$1 = awaitify(concatSeries, 3);

    /**
     * Returns a function that when called, calls-back with the values provided.
     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
     * [`auto`]{@link module:ControlFlow.auto}.
     *
     * @name constant
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {...*} arguments... - Any number of arguments to automatically invoke
     * callback with.
     * @returns {AsyncFunction} Returns a function that when invoked, automatically
     * invokes the callback with the previous given arguments.
     * @example
     *
     * async.waterfall([
     *     async.constant(42),
     *     function (value, next) {
     *         // value === 42
     *     },
     *     //...
     * ], callback);
     *
     * async.waterfall([
     *     async.constant(filename, "utf8"),
     *     fs.readFile,
     *     function (fileData, next) {
     *         //...
     *     }
     *     //...
     * ], callback);
     *
     * async.auto({
     *     hostname: async.constant("https://server.net/"),
     *     port: findFreePort,
     *     launchServer: ["hostname", "port", function (options, cb) {
     *         startServer(options, cb);
     *     }],
     *     //...
     * }, callback);
     */
    function constant(...args) {
        return function (...ignoredArgs/*, callback*/) {
            var callback = ignoredArgs.pop();
            return callback(null, ...args);
        };
    }

    function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
            var testPassed = false;
            var testResult;
            const iteratee = wrapAsync(_iteratee);
            eachfn(arr, (value, _, callback) => {
                iteratee(value, (err, result) => {
                    if (err || err === false) return callback(err);

                    if (check(result) && !testResult) {
                        testPassed = true;
                        testResult = getResult(true, value);
                        return callback(null, breakLoop);
                    }
                    callback();
                });
            }, err => {
                if (err) return cb(err);
                cb(null, testPassed ? testResult : getResult(false));
            });
        };
    }

    /**
     * Returns the first value in `coll` that passes an async truth test. The
     * `iteratee` is applied in parallel, meaning the first iteratee to return
     * `true` will fire the detect `callback` with that result. That means the
     * result might not be the first item in the original `coll` (in terms of order)
     * that passes the test.

     * If order within the original `coll` is important, then look at
     * [`detectSeries`]{@link module:Collections.detectSeries}.
     *
     * @name detect
     * @static
     * @memberOf module:Collections
     * @method
     * @alias find
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // dir1/file1.txt
     *        // result now equals the first file in the list that exists
     *    }
     *);
     *
     * // Using Promises
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)
     * .then(result => {
     *     console.log(result);
     *     // dir1/file1.txt
     *     // result now equals the first file in the list that exists
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);
     *         console.log(result);
     *         // dir1/file1.txt
     *         // result now equals the file in the list that exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function detect(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)
    }
    var detect$1 = awaitify(detect, 3);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name detectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findLimit
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function detectLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var detectLimit$1 = awaitify(detectLimit, 4);

    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
     *
     * @name detectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findSeries
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function detectSeries(coll, iteratee, callback) {
        return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)
    }

    var detectSeries$1 = awaitify(detectSeries, 3);

    function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
            /* istanbul ignore else */
            if (typeof console === 'object') {
                /* istanbul ignore else */
                if (err) {
                    /* istanbul ignore else */
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) { /* istanbul ignore else */
                    resultArgs.forEach(x => console[name](x));
                }
            }
        })
    }

    /**
     * Logs the result of an [`async` function]{@link AsyncFunction} to the
     * `console` using `console.dir` to display the properties of the resulting object.
     * Only works in Node.js or in browsers that support `console.dir` and
     * `console.error` (such as FF and Chrome).
     * If multiple arguments are returned from the async function,
     * `console.dir` is called on each argument in order.
     *
     * @name dir
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, {hello: name});
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.dir(hello, 'world');
     * {hello: 'world'}
     */
    var dir = consoleFunc('dir');

    /**
     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
     * the order of operations, the arguments `test` and `iteratee` are switched.
     *
     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
     *
     * @name doWhilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - A function which is called each time `test`
     * passes. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`.
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped.
     * `callback` will be passed an error and any arguments passed to the final
     * `iteratee`'s callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;

        function next(err, ...args) {
            if (err) return callback(err);
            if (err === false) return;
            results = args;
            _test(...args, check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return check(null, true);
    }

    var doWhilst$1 = awaitify(doWhilst, 3);

    /**
     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
     * argument ordering differs from `until`.
     *
     * @name doUntil
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */
    function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
            const cb = args.pop();
            _test(...args, (err, truth) => cb (err, !truth));
        }, callback);
    }

    function _withoutIndex(iteratee) {
        return (value, index, callback) => iteratee(value, callback);
    }

    /**
     * Applies the function `iteratee` to each item in `coll`, in parallel.
     * The `iteratee` is called with an item from the list, and a callback for when
     * it has finished. If the `iteratee` passes an error to its `callback`, the
     * main `callback` (for the `each` function) is immediately called with the
     * error.
     *
     * Note, that since this function applies `iteratee` to each item in parallel,
     * there is no guarantee that the iteratee functions will complete in order.
     *
     * @name each
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEach
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to
     * each item in `coll`. Invoked with (item, callback).
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOf`.
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
     * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
     *
     * // asynchronous function that deletes a file
     * const deleteFile = function(file, callback) {
     *     fs.unlink(file, callback);
     * };
     *
     * // Using callbacks
     * async.each(fileList, deleteFile, function(err) {
     *     if( err ) {
     *         console.log(err);
     *     } else {
     *         console.log('All files have been deleted successfully');
     *     }
     * });
     *
     * // Error Handling
     * async.each(withMissingFileList, deleteFile, function(err){
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using Promises
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         await async.each(files, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         await async.each(withMissingFileList, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4/file2.txt does not exist
     *         // dir1/file1.txt could have been deleted
     *     }
     * }
     *
     */
    function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }

    var each = awaitify(eachLimit, 3);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
     *
     * @name eachLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfLimit`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$2 = awaitify(eachLimit$1, 4);

    /**
     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
     *
     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
     * in series and therefore the iteratee functions will complete in order.

     * @name eachSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfSeries`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */
    function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback)
    }
    var eachSeries$1 = awaitify(eachSeries, 3);

    /**
     * Wrap an async function and ensure it calls its callback on a later tick of
     * the event loop.  If the function already calls its callback on a next tick,
     * no extra deferral is added. This is useful for preventing stack overflows
     * (`RangeError: Maximum call stack size exceeded`) and generally keeping
     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
     * contained. ES2017 `async` functions are returned as-is -- they are immune
     * to Zalgo's corrupting influences, as they always resolve on a later tick.
     *
     * @name ensureAsync
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - an async function, one that expects a node-style
     * callback as its last argument.
     * @returns {AsyncFunction} Returns a wrapped function with the exact same call
     * signature as the function passed in.
     * @example
     *
     * function sometimesAsync(arg, callback) {
     *     if (cache[arg]) {
     *         return callback(null, cache[arg]); // this would be synchronous!!
     *     } else {
     *         doSomeIO(arg, callback); // this IO would be asynchronous
     *     }
     * }
     *
     * // this has a risk of stack overflows if many results are cached in a row
     * async.mapSeries(args, sometimesAsync, done);
     *
     * // this will defer sometimesAsync's callback if necessary,
     * // preventing stack overflows
     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
     */
    function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function (...args/*, callback*/) {
            var callback = args.pop();
            var sync = true;
            args.push((...innerArgs) => {
                if (sync) {
                    setImmediate$1(() => callback(...innerArgs));
                } else {
                    callback(...innerArgs);
                }
            });
            fn.apply(this, args);
            sync = false;
        };
    }

    /**
     * Returns `true` if every element in `coll` satisfies an async test. If any
     * iteratee call returns `false`, the main `callback` is immediately called.
     *
     * @name every
     * @static
     * @memberOf module:Collections
     * @method
     * @alias all
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.every(fileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * });
     *
     * async.every(withMissingFileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * });
     *
     * // Using Promises
     * async.every(fileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.every(withMissingFileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.every(fileList, fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.every(withMissingFileList, fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since NOT every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function every(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)
    }
    var every$1 = awaitify(every, 3);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
     *
     * @name everyLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everyLimit(coll, limit, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var everyLimit$1 = awaitify(everyLimit, 4);

    /**
     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
     *
     * @name everySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in series.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function everySeries(coll, iteratee, callback) {
        return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var everySeries$1 = awaitify(everySeries, 3);

    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                truthValues[index] = !!v;
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
                if (truthValues[i]) results.push(arr[i]);
            }
            callback(null, results);
        });
    }

    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index, iterCb) => {
            iteratee(x, (err, v) => {
                if (err) return iterCb(err);
                if (v) {
                    results.push({index, value: x});
                }
                iterCb(err);
            });
        }, err => {
            if (err) return callback(err);
            callback(null, results
                .sort((a, b) => a.index - b.index)
                .map(v => v.value));
        });
    }

    function _filter(eachfn, coll, iteratee, callback) {
        var filter = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter(eachfn, coll, wrapAsync(iteratee), callback);
    }

    /**
     * Returns a new array of all the values in `coll` which pass an async truth
     * test. This operation is performed in parallel, but the results array will be
     * in the same order as the original.
     *
     * @name filter
     * @static
     * @memberOf module:Collections
     * @method
     * @alias select
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.filter(files, fileExists, function(err, results) {
     *    if(err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *        // results is now an array of the existing files
     *    }
     * });
     *
     * // Using Promises
     * async.filter(files, fileExists)
     * .then(results => {
     *     console.log(results);
     *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *     // results is now an array of the existing files
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.filter(files, fileExists);
     *         console.log(results);
     *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *         // results is now an array of the existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function filter (coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback)
    }
    var filter$1 = awaitify(filter, 3);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name filterLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     */
    function filterLimit (coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback)
    }
    var filterLimit$1 = awaitify(filterLimit, 4);

    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
     *
     * @name filterSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results)
     * @returns {Promise} a promise, if no callback provided
     */
    function filterSeries (coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback)
    }
    var filterSeries$1 = awaitify(filterSeries, 3);

    /**
     * Calls the asynchronous function `fn` with a callback parameter that allows it
     * to call itself again, in series, indefinitely.

     * If an error is passed to the callback then `errback` is called with the
     * error, and execution stops, otherwise it will never be called.
     *
     * @name forever
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} fn - an async function to call repeatedly.
     * Invoked with (next).
     * @param {Function} [errback] - when `fn` passes an error to it's callback,
     * this function will be called, and execution stops. Invoked with (err).
     * @returns {Promise} a promise that rejects if an error occurs and an errback
     * is not passed
     * @example
     *
     * async.forever(
     *     function(next) {
     *         // next is suitable for passing to things that need a callback(err [, whatever]);
     *         // it will result in this function being called again.
     *     },
     *     function(err) {
     *         // if next is called with a value in its first parameter, it will appear
     *         // in here as 'err', and execution will stop.
     *     }
     * );
     */
    function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));

        function next(err) {
            if (err) return done(err);
            if (err === false) return;
            task(next);
        }
        return next();
    }
    var forever$1 = awaitify(forever, 2);

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
     *
     * @name groupByLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
            _iteratee(val, (err, key) => {
                if (err) return iterCb(err);
                return iterCb(err, {key, val});
            });
        }, (err, mapResults) => {
            var result = {};
            // from MDN, handle object having an `hasOwnProperty` prop
            var {hasOwnProperty} = Object.prototype;

            for (var i = 0; i < mapResults.length; i++) {
                if (mapResults[i]) {
                    var {key} = mapResults[i];
                    var {val} = mapResults[i];

                    if (hasOwnProperty.call(result, key)) {
                        result[key].push(val);
                    } else {
                        result[key] = [val];
                    }
                }
            }

            return callback(err, result);
        });
    }

    var groupByLimit$1 = awaitify(groupByLimit, 4);

    /**
     * Returns a new object, where each value corresponds to an array of items, from
     * `coll`, that returned the corresponding key. That is, the keys of the object
     * correspond to the values passed to the `iteratee` callback.
     *
     * Note: Since this function applies the `iteratee` to each item in parallel,
     * there is no guarantee that the `iteratee` functions will complete in order.
     * However, the values for each key in the `result` will be in the same order as
     * the original `coll`. For Objects, the values will roughly be in the order of
     * the original Objects' keys (but this can vary across JavaScript engines).
     *
     * @name groupBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const files = ['dir1/file1.txt','dir2','dir4']
     *
     * // asynchronous function that detects file type as none, file, or directory
     * function detectFile(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(null, 'none');
     *         }
     *         callback(null, stat.isDirectory() ? 'directory' : 'file');
     *     });
     * }
     *
     * //Using callbacks
     * async.groupBy(files, detectFile, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *	       console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     * });
     *
     * // Using Promises
     * async.groupBy(files, detectFile)
     * .then( result => {
     *     console.log(result);
     *     // {
     *     //     file: [ 'dir1/file1.txt' ],
     *     //     none: [ 'dir4' ],
     *     //     directory: [ 'dir2']
     *     // }
     *     // result is object containing the files grouped by type
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.groupBy(files, detectFile);
     *         console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function groupBy (coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback)
    }

    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
     *
     * @name groupBySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whose
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */
    function groupBySeries (coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback)
    }

    /**
     * Logs the result of an `async` function to the `console`. Only works in
     * Node.js or in browsers that support `console.log` and `console.error` (such
     * as FF and Chrome). If multiple arguments are returned from the async
     * function, `console.log` is called on each argument in order.
     *
     * @name log
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, 'hello ' + name);
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.log(hello, 'world');
     * 'hello world'
     */
    var log = consoleFunc('log');

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name mapValuesLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
            _iteratee(val, key, (err, result) => {
                if (err) return next(err);
                newObj[key] = result;
                next(err);
            });
        }, err => callback(err, newObj));
    }

    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);

    /**
     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
     *
     * Produces a new Object by mapping each value of `obj` through the `iteratee`
     * function. The `iteratee` is called each `value` and `key` from `obj` and a
     * callback for when it has finished processing. Each of these callbacks takes
     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
     * passes an error to its callback, the main `callback` (for the `mapValues`
     * function) is immediately called with the error.
     *
     * Note, the order of the keys in the result is not guaranteed.  The keys will
     * be roughly in the order they complete, (but this is very engine-specific)
     *
     * @name mapValues
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file3.txt'
     * };
     *
     * const withMissingFileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file4.txt'
     * };
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, key, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     * });
     *
     * // Error handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.mapValues(fileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // result is now a map of file size in bytes for each file, e.g.
     *     // {
     *     //     f1: 1000,
     *     //     f2: 2000,
     *     //     f3: 3000
     *     // }
     * }).catch (err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch (err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.mapValues(fileMap, getFileSizeInBytes);
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback)
    }

    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
     *
     * @name mapValuesSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback)
    }

    /**
     * Caches the results of an async function. When creating a hash to store
     * function results against, the callback is omitted from the hash and an
     * optional hash function can be used.
     *
     * **Note: if the async function errs, the result will not be cached and
     * subsequent calls will call the wrapped function.**
     *
     * If no hash function is specified, the first argument is used as a hash key,
     * which may work reasonably if it is a string or a data type that converts to a
     * distinct string. Note that objects and arrays will not behave reasonably.
     * Neither will cases where the other arguments are significant. In such cases,
     * specify your own hash function.
     *
     * The cache of results is exposed as the `memo` property of the function
     * returned by `memoize`.
     *
     * @name memoize
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function to proxy and cache results from.
     * @param {Function} hasher - An optional function for generating a custom hash
     * for storing results. It has all the arguments applied to it apart from the
     * callback, and must be synchronous.
     * @returns {AsyncFunction} a memoized version of `fn`
     * @example
     *
     * var slow_fn = function(name, callback) {
     *     // do something
     *     callback(null, result);
     * };
     * var fn = async.memoize(slow_fn);
     *
     * // fn can now be used as if it were slow_fn
     * fn('some name', function() {
     *     // callback
     * });
     */
    function memoize(fn, hasher = v => v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
            var key = hasher(...args);
            if (key in memo) {
                setImmediate$1(() => callback(null, ...memo[key]));
            } else if (key in queues) {
                queues[key].push(callback);
            } else {
                queues[key] = [callback];
                _fn(...args, (err, ...resultArgs) => {
                    // #1465 don't memoize if an error occurred
                    if (!err) {
                        memo[key] = resultArgs;
                    }
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i](err, ...resultArgs);
                    }
                });
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    }

    /* istanbul ignore file */

    /**
     * Calls `callback` on a later loop around the event loop. In Node.js this just
     * calls `process.nextTick`.  In the browser it will use `setImmediate` if
     * available, otherwise `setTimeout(callback, 0)`, which means other higher
     * priority events may precede the execution of `callback`.
     *
     * This is used internally for browser-compatibility purposes.
     *
     * @name nextTick
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.setImmediate]{@link module:Utils.setImmediate}
     * @category Util
     * @param {Function} callback - The function to call on a later loop around
     * the event loop. Invoked with (args...).
     * @param {...*} args... - any number of additional arguments to pass to the
     * callback on the next tick.
     * @example
     *
     * var call_order = [];
     * async.nextTick(function() {
     *     call_order.push('two');
     *     // call_order now equals ['one','two']
     * });
     * call_order.push('one');
     *
     * async.setImmediate(function (a, b, c) {
     *     // a, b, and c equal 1, 2, and 3
     * }, 1, 2, 3);
     */
    var _defer$1;

    if (hasNextTick) {
        _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
    } else {
        _defer$1 = fallback;
    }

    var nextTick = wrap(_defer$1);

    var parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};

        eachfn(tasks, (task, key, taskCb) => {
            wrapAsync(task)((err, ...result) => {
                if (result.length < 2) {
                    [result] = result;
                }
                results[key] = result;
                taskCb(err);
            });
        }, err => callback(err, results));
    }, 3);

    /**
     * Run the `tasks` collection of functions in parallel, without waiting until
     * the previous function has completed. If any of the functions pass an error to
     * its callback, the main `callback` is immediately called with the value of the
     * error. Once the `tasks` have completed, the results are passed to the final
     * `callback` as an array.
     *
     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
     * parallel execution of code.  If your tasks do not use any timers or perform
     * any I/O, they will actually be executed in series.  Any synchronous setup
     * sections for each task will happen one after the other.  JavaScript remains
     * single-threaded.
     *
     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
     * execution of other tasks when a task fails.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     * results from {@link async.parallel}.
     *
     * @name parallel
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     *
     * //Using Callbacks
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.parallel([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two'] even though
     *         // the second function had a shorter timeout.
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function parallel$1(tasks, callback) {
        return parallel(eachOf$1, tasks, callback);
    }

    /**
     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name parallelLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.parallel]{@link module:ControlFlow.parallel}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     */
    function parallelLimit(tasks, limit, callback) {
        return parallel(eachOfLimit(limit), tasks, callback);
    }

    /**
     * A queue of tasks for the worker function to complete.
     * @typedef {Iterable} QueueObject
     * @memberOf module:ControlFlow
     * @property {Function} length - a function returning the number of items
     * waiting to be processed. Invoke with `queue.length()`.
     * @property {boolean} started - a boolean indicating whether or not any
     * items have been pushed and processed by the queue.
     * @property {Function} running - a function returning the number of items
     * currently being processed. Invoke with `queue.running()`.
     * @property {Function} workersList - a function returning the array of items
     * currently being processed. Invoke with `queue.workersList()`.
     * @property {Function} idle - a function returning false if there are items
     * waiting or being processed, or true if not. Invoke with `queue.idle()`.
     * @property {number} concurrency - an integer for determining how many `worker`
     * functions should be run in parallel. This property can be changed after a
     * `queue` is created to alter the concurrency on-the-fly.
     * @property {number} payload - an integer that specifies how many items are
     * passed to the worker function at a time. only applies if this is a
     * [cargo]{@link module:ControlFlow.cargo} object
     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
     * once the `worker` has finished processing the task. Instead of a single task,
     * a `tasks` array can be submitted. The respective callback is used for every
     * task in the list. Invoke with `queue.push(task, [callback])`,
     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
     * Invoke with `queue.unshift(task, [callback])`.
     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
     * a promise that rejects if an error occurs.
     * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
     * a promise that rejects if an error occurs.
     * @property {Function} remove - remove items from the queue that match a test
     * function.  The test function will be passed an object with a `data` property,
     * and a `priority` property, if this is a
     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
     * `function ({data, priority}) {}` and returns a Boolean.
     * @property {Function} saturated - a function that sets a callback that is
     * called when the number of running workers hits the `concurrency` limit, and
     * further tasks will be queued.  If the callback is omitted, `q.saturated()`
     * returns a promise for the next occurrence.
     * @property {Function} unsaturated - a function that sets a callback that is
     * called when the number of running workers is less than the `concurrency` &
     * `buffer` limits, and further tasks will not be queued. If the callback is
     * omitted, `q.unsaturated()` returns a promise for the next occurrence.
     * @property {number} buffer - A minimum threshold buffer in order to say that
     * the `queue` is `unsaturated`.
     * @property {Function} empty - a function that sets a callback that is called
     * when the last item from the `queue` is given to a `worker`. If the callback
     * is omitted, `q.empty()` returns a promise for the next occurrence.
     * @property {Function} drain - a function that sets a callback that is called
     * when the last item from the `queue` has returned from the `worker`. If the
     * callback is omitted, `q.drain()` returns a promise for the next occurrence.
     * @property {Function} error - a function that sets a callback that is called
     * when a task errors. Has the signature `function(error, task)`. If the
     * callback is omitted, `error()` returns a promise that rejects on the next
     * error.
     * @property {boolean} paused - a boolean for determining whether the queue is
     * in a paused state.
     * @property {Function} pause - a function that pauses the processing of tasks
     * until `resume()` is called. Invoke with `queue.pause()`.
     * @property {Function} resume - a function that resumes the processing of
     * queued tasks when the queue is paused. Invoke with `queue.resume()`.
     * @property {Function} kill - a function that removes the `drain` callback and
     * empties remaining tasks from the queue forcing it to go idle. No more tasks
     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
     *
     * @example
     * const q = async.queue(worker, 2)
     * q.push(item1)
     * q.push(item2)
     * q.push(item3)
     * // queues are iterable, spread into an array to inspect
     * const items = [...q] // [item1, item2, item3]
     * // or use for of
     * for (let item of q) {
     *     console.log(item)
     * }
     *
     * q.drain(() => {
     *     console.log('all done')
     * })
     * // or
     * await q.drain()
     */

    /**
     * Creates a `queue` object with the specified `concurrency`. Tasks added to the
     * `queue` are processed in parallel (up to the `concurrency` limit). If all
     * `worker`s are in progress, the task is queued until one becomes available.
     * Once a `worker` completes a `task`, that `task`'s callback is called.
     *
     * @name queue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`. Invoked with (task, callback).
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
     * attached as certain properties to listen for specific events during the
     * lifecycle of the queue.
     * @example
     *
     * // create a queue object with concurrency 2
     * var q = async.queue(function(task, callback) {
     *     console.log('hello ' + task.name);
     *     callback();
     * }, 2);
     *
     * // assign a callback
     * q.drain(function() {
     *     console.log('all items have been processed');
     * });
     * // or await the end
     * await q.drain()
     *
     * // assign an error callback
     * q.error(function(err, task) {
     *     console.error('task experienced an error');
     * });
     *
     * // add some items to the queue
     * q.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * // callback is optional
     * q.push({name: 'bar'});
     *
     * // add some items to the queue (batch-wise)
     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
     *     console.log('finished processing item');
     * });
     *
     * // add some items to the front of the queue
     * q.unshift({name: 'bar'}, function (err) {
     *     console.log('finished processing bar');
     * });
     */
    function queue$1 (worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
            _worker(items[0], cb);
        }, concurrency, 1);
    }

    // Binary min-heap implementation used for priority queue.
    // Implementation is stable, i.e. push time is considered for equal priorities
    class Heap {
        constructor() {
            this.heap = [];
            this.pushCount = Number.MIN_SAFE_INTEGER;
        }

        get length() {
            return this.heap.length;
        }

        empty () {
            this.heap = [];
            return this;
        }

        percUp(index) {
            let p;

            while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {
                let t = this.heap[index];
                this.heap[index] = this.heap[p];
                this.heap[p] = t;

                index = p;
            }
        }

        percDown(index) {
            let l;

            while ((l=leftChi(index)) < this.heap.length) {
                if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {
                    l = l+1;
                }

                if (smaller(this.heap[index], this.heap[l])) {
                    break;
                }

                let t = this.heap[index];
                this.heap[index] = this.heap[l];
                this.heap[l] = t;

                index = l;
            }
        }

        push(node) {
            node.pushCount = ++this.pushCount;
            this.heap.push(node);
            this.percUp(this.heap.length-1);
        }

        unshift(node) {
            return this.heap.push(node);
        }

        shift() {
            let [top] = this.heap;

            this.heap[0] = this.heap[this.heap.length-1];
            this.heap.pop();
            this.percDown(0);

            return top;
        }

        toArray() {
            return [...this];
        }

        *[Symbol.iterator] () {
            for (let i = 0; i < this.heap.length; i++) {
                yield this.heap[i].data;
            }
        }

        remove (testFn) {
            let j = 0;
            for (let i = 0; i < this.heap.length; i++) {
                if (!testFn(this.heap[i])) {
                    this.heap[j] = this.heap[i];
                    j++;
                }
            }

            this.heap.splice(j);

            for (let i = parent(this.heap.length-1); i >= 0; i--) {
                this.percDown(i);
            }

            return this;
        }
    }

    function leftChi(i) {
        return (i<<1)+1;
    }

    function parent(i) {
        return ((i+1)>>1)-1;
    }

    function smaller(x, y) {
        if (x.priority !== y.priority) {
            return x.priority < y.priority;
        }
        else {
            return x.pushCount < y.pushCount;
        }
    }

    /**
     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
     * completed in ascending priority order.
     *
     * @name priorityQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`.
     * Invoked with (task, callback).
     * @param {number} concurrency - An `integer` for determining how many `worker`
     * functions should be run in parallel.  If omitted, the concurrency defaults to
     * `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three
     * differences between `queue` and `priorityQueue` objects:
     * * `push(task, priority, [callback])` - `priority` should be a number. If an
     *   array of `tasks` is given, all tasks will be assigned the same priority.
     * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,
     *   except this returns a promise that rejects if an error occurs.
     * * The `unshift` and `unshiftAsync` methods were removed.
     */
    function priorityQueue(worker, concurrency) {
        // Start with a normal queue
        var q = queue$1(worker, concurrency);

        var {
            push,
            pushAsync
        } = q;

        q._tasks = new Heap();
        q._createTaskItem = ({data, priority}, callback) => {
            return {
                data,
                priority,
                callback
            };
        };

        function createDataItems(tasks, priority) {
            if (!Array.isArray(tasks)) {
                return {data: tasks, priority};
            }
            return tasks.map(data => { return {data, priority}; });
        }

        // Override push to accept second parameter representing priority
        q.push = function(data, priority = 0, callback) {
            return push(createDataItems(data, priority), callback);
        };

        q.pushAsync = function(data, priority = 0, callback) {
            return pushAsync(createDataItems(data, priority), callback);
        };

        // Remove unshift functions
        delete q.unshift;
        delete q.unshiftAsync;

        return q;
    }

    /**
     * Runs the `tasks` array of functions in parallel, without waiting until the
     * previous function has completed. Once any of the `tasks` complete or pass an
     * error to its callback, the main `callback` is immediately called. It's
     * equivalent to `Promise.race()`.
     *
     * @name race
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
     * to run. Each function can complete with an optional `result` value.
     * @param {Function} callback - A callback to run once any of the functions have
     * completed. This function gets an error or result from the first function that
     * completed. Invoked with (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * async.race([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ],
     * // main callback
     * function(err, result) {
     *     // the result will be equal to 'two' as it finishes earlier
     * });
     */
    function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
        if (!tasks.length) return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
        }
    }

    var race$1 = awaitify(race, 2);

    /**
     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
     *
     * @name reduceRight
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reduce]{@link module:Collections.reduce}
     * @alias foldr
     * @category Collection
     * @param {Array} array - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */
    function reduceRight (array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
    }

    /**
     * Wraps the async function in another function that always completes with a
     * result object, even when it errors.
     *
     * The result object has either the property `error` or `value`.
     *
     * @name reflect
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function you want to wrap
     * @returns {Function} - A function that always passes null to it's callback as
     * the error. The second argument to the callback will be an `object` with
     * either an `error` or a `value` property.
     * @example
     *
     * async.parallel([
     *     async.reflect(function(callback) {
     *         // do some stuff ...
     *         callback(null, 'one');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff but error ...
     *         callback('bad stuff happened');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff ...
     *         callback(null, 'two');
     *     })
     * ],
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = 'bad stuff happened'
     *     // results[2].value = 'two'
     * });
     */
    function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
            args.push((error, ...cbArgs) => {
                let retVal = {};
                if (error) {
                    retVal.error = error;
                }
                if (cbArgs.length > 0){
                    var value = cbArgs;
                    if (cbArgs.length <= 1) {
                        [value] = cbArgs;
                    }
                    retVal.value = value;
                }
                reflectCallback(null, retVal);
            });

            return _fn.apply(this, args);
        });
    }

    /**
     * A helper function that wraps an array or an object of functions with `reflect`.
     *
     * @name reflectAll
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.reflect]{@link module:Utils.reflect}
     * @category Util
     * @param {Array|Object|Iterable} tasks - The collection of
     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
     * @returns {Array} Returns an array of async functions, each wrapped in
     * `async.reflect`
     * @example
     *
     * let tasks = [
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         // do some more stuff but error ...
     *         callback(new Error('bad stuff happened'));
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ];
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = Error('bad stuff happened')
     *     // results[2].value = 'two'
     * });
     *
     * // an example using an object instead of an array
     * let tasks = {
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         callback('two');
     *     },
     *     three: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'three');
     *         }, 100);
     *     }
     * };
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results.one.value = 'one'
     *     // results.two.error = 'two'
     *     // results.three.value = 'three'
     * });
     */
    function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
            results = tasks.map(reflect);
        } else {
            results = {};
            Object.keys(tasks).forEach(key => {
                results[key] = reflect.call(this, tasks[key]);
            });
        }
        return results;
    }

    function reject(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
            iteratee(value, (err, v) => {
                cb(err, !v);
            });
        }, callback);
    }

    /**
     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
     *
     * @name reject
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.reject(fileList, fileExists, function(err, results) {
     *    // [ 'dir3/file6.txt' ]
     *    // results now equals an array of the non-existing files
     * });
     *
     * // Using Promises
     * async.reject(fileList, fileExists)
     * .then( results => {
     *     console.log(results);
     *     // [ 'dir3/file6.txt' ]
     *     // results now equals an array of the non-existing files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.reject(fileList, fileExists);
     *         console.log(results);
     *         // [ 'dir3/file6.txt' ]
     *         // results now equals an array of the non-existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function reject$1 (coll, iteratee, callback) {
        return reject(eachOf$1, coll, iteratee, callback)
    }
    var reject$2 = awaitify(reject$1, 3);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name rejectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectLimit (coll, limit, iteratee, callback) {
        return reject(eachOfLimit(limit), coll, iteratee, callback)
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);

    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
     *
     * @name rejectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */
    function rejectSeries (coll, iteratee, callback) {
        return reject(eachOfSeries$1, coll, iteratee, callback)
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);

    function constant$1(value) {
        return function () {
            return value;
        }
    }

    /**
     * Attempts to get a successful response from `task` no more than `times` times
     * before returning an error. If the task is successful, the `callback` will be
     * passed the result of the successful task. If all attempts fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name retry
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @see [async.retryable]{@link module:ControlFlow.retryable}
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
     * object with `times` and `interval` or a number.
     * * `times` - The number of attempts to make before giving up.  The default
     *   is `5`.
     * * `interval` - The time to wait between retries, in milliseconds.  The
     *   default is `0`. The interval may also be specified as a function of the
     *   retry count (see example).
     * * `errorFilter` - An optional synchronous function that is invoked on
     *   erroneous result. If it returns `true` the retry attempts will continue;
     *   if the function returns `false` the retry flow is aborted with the current
     *   attempt's error and result being returned to the final callback.
     *   Invoked with (err).
     * * If `opts` is a number, the number specifies the number of times to retry,
     *   with the default interval of `0`.
     * @param {AsyncFunction} task - An async function to retry.
     * Invoked with (callback).
     * @param {Function} [callback] - An optional callback which is called when the
     * task has succeeded, or after the final failed attempt. It receives the `err`
     * and `result` arguments of the last attempt at completing the `task`. Invoked
     * with (err, results).
     * @returns {Promise} a promise if no callback provided
     *
     * @example
     *
     * // The `retry` function can be used as a stand-alone control flow by passing
     * // a callback, as shown below:
     *
     * // try calling apiMethod 3 times
     * async.retry(3, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 3 times, waiting 200 ms between each retry
     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 10 times with exponential backoff
     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
     * async.retry({
     *   times: 10,
     *   interval: function(retryCount) {
     *     return 50 * Math.pow(2, retryCount);
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod the default 5 times no delay between each retry
     * async.retry(apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod only when error condition satisfies, all other
     * // errors will abort the retry control flow and return to final callback
     * async.retry({
     *   errorFilter: function(err) {
     *     return err.message === 'Temporary error'; // only retry on a specific error
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // to retry individual methods that are not as reliable within other
     * // control flow functions, use the `retryable` wrapper:
     * async.auto({
     *     users: api.getUsers.bind(api),
     *     payments: async.retryable(3, api.getPayments.bind(api))
     * }, function(err, results) {
     *     // do something with the results
     * });
     *
     */
    const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;

    function retry(opts, task, callback) {
        var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
        };

        if (arguments.length < 3 && typeof opts === 'function') {
            callback = task || promiseCallback();
            task = opts;
        } else {
            parseTimes(options, opts);
            callback = callback || promiseCallback();
        }

        if (typeof task !== 'function') {
            throw new Error("Invalid arguments for async.retry");
        }

        var _task = wrapAsync(task);

        var attempt = 1;
        function retryAttempt() {
            _task((err, ...args) => {
                if (err === false) return
                if (err && attempt++ < options.times &&
                    (typeof options.errorFilter != 'function' ||
                        options.errorFilter(err))) {
                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
                } else {
                    callback(err, ...args);
                }
            });
        }

        retryAttempt();
        return callback[PROMISE_SYMBOL]
    }

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    /**
     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
     * wraps a task and makes it retryable, rather than immediately calling it
     * with retries.
     *
     * @name retryable
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.retry]{@link module:ControlFlow.retry}
     * @category Control Flow
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
     * options, exactly the same as from `retry`, except for a `opts.arity` that
     * is the arity of the `task` function, defaulting to `task.length`
     * @param {AsyncFunction} task - the asynchronous function to wrap.
     * This function will be passed any arguments passed to the returned wrapper.
     * Invoked with (...args, callback).
     * @returns {AsyncFunction} The wrapped function, which when invoked, will
     * retry on an error, based on the parameters specified in `opts`.
     * This function will accept the same parameters as `task`.
     * @example
     *
     * async.auto({
     *     dep1: async.retryable(3, getFromFlakyService),
     *     process: ["dep1", async.retryable(3, function (results, cb) {
     *         maybeProcessData(results.dep1, cb);
     *     })]
     * }, callback);
     */
    function retryable (opts, task) {
        if (!task) {
            task = opts;
            opts = null;
        }
        let arity = (opts && opts.arity) || task.length;
        if (isAsync(task)) {
            arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
            if (args.length < arity - 1 || callback == null) {
                args.push(callback);
                callback = promiseCallback();
            }
            function taskFn(cb) {
                _task(...args, cb);
            }

            if (opts) retry(opts, taskFn, callback);
            else retry(taskFn, callback);

            return callback[PROMISE_SYMBOL]
        });
    }

    /**
     * Run the functions in the `tasks` collection in series, each one running once
     * the previous function has completed. If any functions in the series pass an
     * error to its callback, no more functions are run, and `callback` is
     * immediately called with the value of the error. Otherwise, `callback`
     * receives an array of results when `tasks` have completed.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function, and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     *  results from {@link async.series}.
     *
     * **Note** that while many implementations preserve the order of object
     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
     * explicitly states that
     *
     * > The mechanics and order of enumerating the properties is not specified.
     *
     * So if you rely on the order in which your series of functions are executed,
     * and want this to work on all platforms, consider using an array.
     *
     * @name series
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
     * [async functions]{@link AsyncFunction} to run in series.
     * Each function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This function gets a results array (or object)
     * containing all the result arguments passed to the `task` callbacks. Invoked
     * with (err, result).
     * @return {Promise} a promise, if no callback is passed
     * @example
     *
     * //Using Callbacks
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * });
     *
     * // an example using objects instead of arrays
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.series([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function series(tasks, callback) {
        return parallel(eachOfSeries$1, tasks, callback);
    }

    /**
     * Returns `true` if at least one element in the `coll` satisfies an async test.
     * If any iteratee call returns `true`, the main `callback` is immediately
     * called.
     *
     * @name some
     * @static
     * @memberOf module:Collections
     * @method
     * @alias any
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // true
     *        // result is true since some file in the list exists
     *    }
     *);
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // false
     *        // result is false since none of the files exists
     *    }
     *);
     *
     * // Using Promises
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since some file in the list exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since none of the files exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since some file in the list exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since none of the files exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function some(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)
    }
    var some$1 = awaitify(some, 3);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
     *
     * @name someLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anyLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)
    }
    var someLimit$1 = awaitify(someLimit, 4);

    /**
     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
     *
     * @name someSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anySeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in series.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */
    function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)
    }
    var someSeries$1 = awaitify(someSeries, 3);

    /**
     * Sorts a list by the results of running each `coll` value through an async
     * `iteratee`.
     *
     * @name sortBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a value to use as the sort criteria as
     * its `result`.
     * Invoked with (item, callback).
     * @param {Function} callback - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is the items
     * from the original `coll` sorted by the values returned by the `iteratee`
     * calls. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback passed
     * @example
     *
     * // bigfile.txt is a file that is 251100 bytes in size
     * // mediumfile.txt is a file that is 11000 bytes in size
     * // smallfile.txt is a file that is 121 bytes in size
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // By modifying the callback parameter the
     * // sorting order can be influenced:
     *
     * // ascending order
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) return callback(getFileSizeErr);
     *         callback(null, fileSize);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // descending order
     * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) {
     *             return callback(getFileSizeErr);
     *         }
     *         callback(null, fileSize * -1);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']
     *         }
     *     }
     * );
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *             // [ Error: ENOENT: no such file or directory ]
     *         } else {
     *             console.log(results);
     *         }
     *     }
     * );
     *
     * // Using Promises
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now the original array of files sorted by
     *     // file size (ascending by default), e.g.
     *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *         // results is now the original array of files sorted by
     *         // file size (ascending by default), e.g.
     *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * // Error handling
     * async () => {
     *     try {
     *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */
    function sortBy (coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
            _iteratee(x, (err, criteria) => {
                if (err) return iterCb(err);
                iterCb(err, {value: x, criteria});
            });
        }, (err, results) => {
            if (err) return callback(err);
            callback(null, results.sort(comparator).map(v => v.value));
        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    }
    var sortBy$1 = awaitify(sortBy, 3);

    /**
     * Sets a time limit on an asynchronous function. If the function does not call
     * its callback within the specified milliseconds, it will be called with a
     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
     *
     * @name timeout
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} asyncFn - The async function to limit in time.
     * @param {number} milliseconds - The specified time limit.
     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
     * to timeout Error for more information..
     * @returns {AsyncFunction} Returns a wrapped function that can be used with any
     * of the control flow functions.
     * Invoke this function with the same parameters as you would `asyncFunc`.
     * @example
     *
     * function myFunction(foo, callback) {
     *     doAsyncTask(foo, function(err, data) {
     *         // handle errors
     *         if (err) return callback(err);
     *
     *         // do some stuff ...
     *
     *         // return processed data
     *         return callback(null, data);
     *     });
     * }
     *
     * var wrapped = async.timeout(myFunction, 1000);
     *
     * // call `wrapped` as you would `myFunction`
     * wrapped({ bar: 'bar' }, function(err, data) {
     *     // if `myFunction` takes < 1000 ms to execute, `err`
     *     // and `data` will have their expected values
     *
     *     // else `err` will be an Error with the code 'ETIMEDOUT'
     * });
     */
    function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);

        return initialParams((args, callback) => {
            var timedOut = false;
            var timer;

            function timeoutCallback() {
                var name = asyncFn.name || 'anonymous';
                var error  = new Error('Callback function "' + name + '" timed out.');
                error.code = 'ETIMEDOUT';
                if (info) {
                    error.info = info;
                }
                timedOut = true;
                callback(error);
            }

            args.push((...cbArgs) => {
                if (!timedOut) {
                    callback(...cbArgs);
                    clearTimeout(timer);
                }
            });

            // setup timer and call original function
            timer = setTimeout(timeoutCallback, milliseconds);
            fn(...args);
        });
    }

    function range(size) {
        var result = Array(size);
        while (size--) {
            result[size] = size;
        }
        return result;
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name timesLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} count - The number of times to run the function.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see [async.map]{@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
    }

    /**
     * Calls the `iteratee` function `n` times, and accumulates results in the same
     * manner you would use with [map]{@link module:Collections.map}.
     *
     * @name times
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     * @example
     *
     * // Pretend this is some complicated async factory
     * var createUser = function(id, callback) {
     *     callback(null, {
     *         id: 'user' + id
     *     });
     * };
     *
     * // generate 5 users
     * async.times(5, function(n, next) {
     *     createUser(n, function(err, user) {
     *         next(err, user);
     *     });
     * }, function(err, users) {
     *     // we should now have 5 users
     * });
     */
    function times (n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback)
    }

    /**
     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
     *
     * @name timesSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */
    function timesSeries (n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback)
    }

    /**
     * A relative of `reduce`.  Takes an Object or Array, and iterates over each
     * element in parallel, each step potentially mutating an `accumulator` value.
     * The type of the accumulator defaults to the type of collection passed in.
     *
     * @name transform
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} [accumulator] - The initial state of the transform.  If omitted,
     * it will default to an empty Object or Array, depending on the type of `coll`
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * collection that potentially modifies the accumulator.
     * Invoked with (accumulator, item, key, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the transformed accumulator.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileList, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileList, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let result = await async.transform(fileList, transformFileSize);
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileMap, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileMap, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.transform(fileMap, transformFileSize);
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */
    function transform (coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === 'function') {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);

        eachOf$1(coll, (v, k, cb) => {
            _iteratee(accumulator, v, k, cb);
        }, err => callback(err, accumulator));
        return callback[PROMISE_SYMBOL]
    }

    /**
     * It runs each task in series but stops whenever any of the functions were
     * successful. If one of the tasks were successful, the `callback` will be
     * passed the result of the successful task. If all tasks fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name tryEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
     * run, each function is passed a `callback(err, result)` it must call on
     * completion with an error `err` (which can be `null`) and an optional `result`
     * value.
     * @param {Function} [callback] - An optional callback which is called when one
     * of the tasks has succeeded, or all have failed. It receives the `err` and
     * `result` arguments of the last attempt at completing the `task`. Invoked with
     * (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     * async.tryEach([
     *     function getDataFromFirstWebsite(callback) {
     *         // Try getting the data from the first website
     *         callback(err, data);
     *     },
     *     function getDataFromSecondWebsite(callback) {
     *         // First website failed,
     *         // Try getting the data from the backup website
     *         callback(err, data);
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     Now do something with the data.
     * });
     *
     */
    function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
            wrapAsync(task)((err, ...args) => {
                if (err === false) return taskCb(err);

                if (args.length < 2) {
                    [result] = args;
                } else {
                    result = args;
                }
                error = err;
                taskCb(err ? null : {});
            });
        }, () => callback(error, result));
    }

    var tryEach$1 = awaitify(tryEach);

    /**
     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
     * unmemoized form. Handy for testing.
     *
     * @name unmemoize
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.memoize]{@link module:Utils.memoize}
     * @category Util
     * @param {AsyncFunction} fn - the memoized function
     * @returns {AsyncFunction} a function that calls the original unmemoized function
     */
    function unmemoize(fn) {
        return (...args) => {
            return (fn.unmemoized || fn)(...args);
        };
    }

    /**
     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs.
     *
     * @name whilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with ().
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` passes. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * var count = 0;
     * async.whilst(
     *     function test(cb) { cb(null, count < 5); },
     *     function iter(callback) {
     *         count++;
     *         setTimeout(function() {
     *             callback(null, count);
     *         }, 1000);
     *     },
     *     function (err, n) {
     *         // 5 seconds have passed, n = 5
     *     }
     * );
     */
    function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];

        function next(err, ...rest) {
            if (err) return callback(err);
            results = rest;
            if (err === false) return;
            _test(check);
        }

        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }

        return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);

    /**
     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs. `callback` will be passed an error and any
     * arguments passed to the final `iteratee`'s callback.
     *
     * The inverse of [whilst]{@link module:ControlFlow.whilst}.
     *
     * @name until
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with (callback).
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     * const results = []
     * let finished = false
     * async.until(function test(cb) {
     *     cb(null, finished)
     * }, function iter(next) {
     *     fetchPage(url, (err, body) => {
     *         if (err) return next(err)
     *         results = results.concat(body.objects)
     *         finished = !!body.next
     *         next(err)
     *     })
     * }, function done (err) {
     *     // all pages have been fetched
     * })
     */
    function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);
    }

    /**
     * Runs the `tasks` array of functions in series, each passing their results to
     * the next in the array. However, if any of the `tasks` pass an error to their
     * own callback, the next function is not executed, and the main `callback` is
     * immediately called with the error.
     *
     * @name waterfall
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
     * to run.
     * Each function should complete with any number of `result` values.
     * The `result` values will be passed as arguments, in order, to the next task.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This will be passed the results of the last task's
     * callback. Invoked with (err, [results]).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * async.waterfall([
     *     function(callback) {
     *         callback(null, 'one', 'two');
     *     },
     *     function(arg1, arg2, callback) {
     *         // arg1 now equals 'one' and arg2 now equals 'two'
     *         callback(null, 'three');
     *     },
     *     function(arg1, callback) {
     *         // arg1 now equals 'three'
     *         callback(null, 'done');
     *     }
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     *
     * // Or, with named functions:
     * async.waterfall([
     *     myFirstFunction,
     *     mySecondFunction,
     *     myLastFunction,
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     * function myFirstFunction(callback) {
     *     callback(null, 'one', 'two');
     * }
     * function mySecondFunction(arg1, arg2, callback) {
     *     // arg1 now equals 'one' and arg2 now equals 'two'
     *     callback(null, 'three');
     * }
     * function myLastFunction(arg1, callback) {
     *     // arg1 now equals 'three'
     *     callback(null, 'done');
     * }
     */
    function waterfall (tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
        if (!tasks.length) return callback();
        var taskIndex = 0;

        function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            task(...args, onlyOnce(next));
        }

        function next(err, ...args) {
            if (err === false) return
            if (err || taskIndex === tasks.length) {
                return callback(err, ...args);
            }
            nextTask(args);
        }

        nextTask([]);
    }

    var waterfall$1 = awaitify(waterfall);

    /**
     * An "async function" in the context of Async is an asynchronous function with
     * a variable number of parameters, with the final parameter being a callback.
     * (`function (arg1, arg2, ..., callback) {}`)
     * The final callback is of the form `callback(err, results...)`, which must be
     * called once the function is completed.  The callback should be called with a
     * Error as its first argument to signal that an error occurred.
     * Otherwise, if no error occurred, it should be called with `null` as the first
     * argument, and any additional `result` arguments that may apply, to signal
     * successful completion.
     * The callback must be called exactly once, ideally on a later tick of the
     * JavaScript event loop.
     *
     * This type of function is also referred to as a "Node-style async function",
     * or a "continuation passing-style function" (CPS). Most of the methods of this
     * library are themselves CPS/Node-style async functions, or functions that
     * return CPS/Node-style async functions.
     *
     * Wherever we accept a Node-style async function, we also directly accept an
     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
     * In this case, the `async` function will not be passed a final callback
     * argument, and any thrown error will be used as the `err` argument of the
     * implicit callback, and the return value will be used as the `result` value.
     * (i.e. a `rejected` of the returned Promise becomes the `err` callback
     * argument, and a `resolved` value becomes the `result`.)
     *
     * Note, due to JavaScript limitations, we can only detect native `async`
     * functions and not transpilied implementations.
     * Your environment must have `async`/`await` support for this to work.
     * (e.g. Node > v7.6, or a recent version of a modern browser).
     * If you are using `async` functions through a transpiler (e.g. Babel), you
     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
     * because the `async function` will be compiled to an ordinary function that
     * returns a promise.
     *
     * @typedef {Function} AsyncFunction
     * @static
     */

    var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel: parallel$1,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,

        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
    };

    exports.default = index;
    exports.apply = apply;
    exports.applyEach = applyEach$1;
    exports.applyEachSeries = applyEachSeries;
    exports.asyncify = asyncify;
    exports.auto = auto;
    exports.autoInject = autoInject;
    exports.cargo = cargo;
    exports.cargoQueue = cargo$1;
    exports.compose = compose;
    exports.concat = concat$1;
    exports.concatLimit = concatLimit$1;
    exports.concatSeries = concatSeries$1;
    exports.constant = constant;
    exports.detect = detect$1;
    exports.detectLimit = detectLimit$1;
    exports.detectSeries = detectSeries$1;
    exports.dir = dir;
    exports.doUntil = doUntil;
    exports.doWhilst = doWhilst$1;
    exports.each = each;
    exports.eachLimit = eachLimit$2;
    exports.eachOf = eachOf$1;
    exports.eachOfLimit = eachOfLimit$2;
    exports.eachOfSeries = eachOfSeries$1;
    exports.eachSeries = eachSeries$1;
    exports.ensureAsync = ensureAsync;
    exports.every = every$1;
    exports.everyLimit = everyLimit$1;
    exports.everySeries = everySeries$1;
    exports.filter = filter$1;
    exports.filterLimit = filterLimit$1;
    exports.filterSeries = filterSeries$1;
    exports.forever = forever$1;
    exports.groupBy = groupBy;
    exports.groupByLimit = groupByLimit$1;
    exports.groupBySeries = groupBySeries;
    exports.log = log;
    exports.map = map$1;
    exports.mapLimit = mapLimit$1;
    exports.mapSeries = mapSeries$1;
    exports.mapValues = mapValues;
    exports.mapValuesLimit = mapValuesLimit$1;
    exports.mapValuesSeries = mapValuesSeries;
    exports.memoize = memoize;
    exports.nextTick = nextTick;
    exports.parallel = parallel$1;
    exports.parallelLimit = parallelLimit;
    exports.priorityQueue = priorityQueue;
    exports.queue = queue$1;
    exports.race = race$1;
    exports.reduce = reduce$1;
    exports.reduceRight = reduceRight;
    exports.reflect = reflect;
    exports.reflectAll = reflectAll;
    exports.reject = reject$2;
    exports.rejectLimit = rejectLimit$1;
    exports.rejectSeries = rejectSeries$1;
    exports.retry = retry;
    exports.retryable = retryable;
    exports.seq = seq;
    exports.series = series;
    exports.setImmediate = setImmediate$1;
    exports.some = some$1;
    exports.someLimit = someLimit$1;
    exports.someSeries = someSeries$1;
    exports.sortBy = sortBy$1;
    exports.timeout = timeout;
    exports.times = times;
    exports.timesLimit = timesLimit;
    exports.timesSeries = timesSeries;
    exports.transform = transform;
    exports.tryEach = tryEach$1;
    exports.unmemoize = unmemoize;
    exports.until = until;
    exports.waterfall = waterfall$1;
    exports.whilst = whilst$1;
    exports.all = every$1;
    exports.allLimit = everyLimit$1;
    exports.allSeries = everySeries$1;
    exports.any = some$1;
    exports.anyLimit = someLimit$1;
    exports.anySeries = someSeries$1;
    exports.find = detect$1;
    exports.findLimit = detectLimit$1;
    exports.findSeries = detectSeries$1;
    exports.flatMap = concat$1;
    exports.flatMapLimit = concatLimit$1;
    exports.flatMapSeries = concatSeries$1;
    exports.forEach = each;
    exports.forEachSeries = eachSeries$1;
    exports.forEachLimit = eachLimit$2;
    exports.forEachOf = eachOf$1;
    exports.forEachOfSeries = eachOfSeries$1;
    exports.forEachOfLimit = eachOfLimit$2;
    exports.inject = reduce$1;
    exports.foldl = reduce$1;
    exports.foldr = reduceRight;
    exports.select = filter$1;
    exports.selectLimit = filterLimit$1;
    exports.selectSeries = filterSeries$1;
    exports.wrapSync = asyncify;
    exports.during = whilst$1;
    exports.doDuring = doWhilst$1;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require("F:/cocos-dashboard-editors/2.4.5/resources/app.asar/node_modules/process/browser.js"))
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//------QC-SOURCE-SPLIT------

                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'preview-scripts/assets/scripts/showcase/home/guide/GuideFinger.js';
                    var __require = nodeEnv ? function (request) {
                        return cc.require(request);
                    } : function (request) {
                        return __quick_compile_project__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_project__.registerModule(__filename, module);}"use strict";
cc._RF.push(module, '5e777kzBOVBr5Ukkso/Bw+7', 'GuideFinger');
// scripts/showcase/home/guide/GuideFinger.ts

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
var GuideFinger = /** @class */ (function (_super) {
    __extends(GuideFinger, _super);
    function GuideFinger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GuideFinger = __decorate([
        ccclass
    ], GuideFinger);
    return GuideFinger;
}(cc.Component));
exports.default = GuideFinger;

cc._RF.pop();
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_project__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0c1xcc2NyaXB0c1xcc2hvd2Nhc2VcXGhvbWVcXGd1aWRlXFxHdWlkZUZpbmdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDTSxJQUFBLEtBQXdCLEVBQUUsQ0FBQyxVQUFVLEVBQW5DLE9BQU8sYUFBQSxFQUFFLFFBQVEsY0FBa0IsQ0FBQztBQUc1QztJQUF5QywrQkFBWTtJQUFyRDs7SUFHQSxDQUFDO0lBSG9CLFdBQVc7UUFEL0IsT0FBTztPQUNhLFdBQVcsQ0FHL0I7SUFBRCxrQkFBQztDQUhELEFBR0MsQ0FId0MsRUFBRSxDQUFDLFNBQVMsR0FHcEQ7a0JBSG9CLFdBQVciLCJmaWxlIjoiIiwic291cmNlUm9vdCI6Ii8iLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9ID0gY2MuX2RlY29yYXRvcjtcclxuXHJcbkBjY2NsYXNzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEd1aWRlRmluZ2VyIGV4dGVuZHMgY2MuQ29tcG9uZW50IHtcclxuICAgIC8v5oq956a75omL5oyH5a+56LGhICDlj6/ku6Xlrp7njrDmiYvmjIfkuIrpnIDopoHnmoTkuIDkupvliqjnlLvnrYlcclxuXHJcbn1cclxuIl19
//------QC-SOURCE-SPLIT------
